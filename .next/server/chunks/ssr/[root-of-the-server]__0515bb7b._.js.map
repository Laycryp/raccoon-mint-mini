{"version":3,"sources":["turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/crypt/crypt.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/charenc/charenc.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/is-buffer/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/md5/md5.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/delayed-stream/lib/delayed_stream.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/combined-stream/lib/combined_stream.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/mime-db/db.json","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/mime-db/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/mime-types/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/asynckit/lib/defer.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/asynckit/lib/async.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/asynckit/lib/abort.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/asynckit/lib/iterate.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/asynckit/lib/state.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/asynckit/lib/terminator.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/asynckit/parallel.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/asynckit/serialOrdered.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/asynckit/serial.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/asynckit/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/es-object-atoms/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/es-errors/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/es-errors/eval.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/es-errors/range.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/es-errors/ref.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/es-errors/syntax.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/es-errors/type.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/es-errors/uri.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/math-intrinsics/abs.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/math-intrinsics/floor.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/math-intrinsics/max.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/math-intrinsics/min.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/math-intrinsics/pow.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/math-intrinsics/round.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/math-intrinsics/isNaN.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/math-intrinsics/sign.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/gopd/gOPD.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/gopd/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/es-define-property/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/has-symbols/shams.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/has-symbols/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/get-proto/Reflect.getPrototypeOf.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/get-proto/Object.getPrototypeOf.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/function-bind/implementation.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/function-bind/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/call-bind-apply-helpers/functionCall.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/call-bind-apply-helpers/functionApply.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/call-bind-apply-helpers/reflectApply.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/call-bind-apply-helpers/actualApply.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/call-bind-apply-helpers/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/dunder-proto/get.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/get-proto/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/hasown/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/get-intrinsic/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/has-tostringtag/shams.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/es-set-tostringtag/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/form-data/lib/populate.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/form-data/lib/form_data.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/proxy-from-env/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/debug/src/common.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/debug/src/node.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/debug/src/browser.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/debug/src/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/follow-redirects/debug.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/follow-redirects/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/is-retry-allowed/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/utils.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/zustand/esm/vanilla.mjs","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/preact/dist/preact.mjs","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/clsx/dist/clsx.m.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/zustand/esm/middleware.mjs","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/platform/node/classes/FormData.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/toFormData.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/AxiosURLSearchParams.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/buildURL.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/core/InterceptorManager.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/platform/node/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/platform/node/classes/URLSearchParams.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/platform/common/utils.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/toURLEncodedForm.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/formDataToJSON.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/defaults/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/parseHeaders.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/core/AxiosHeaders.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/core/transformData.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/cancel/CanceledError.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/core/settle.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/core/buildFullPath.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/fromDataURI.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/AxiosTransformStream.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/readBlob.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/throttle.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/core/mergeConfig.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/core/dispatchRequest.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/validator.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/core/Axios.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/cancel/CancelToken.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/isAxiosError.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/HttpStatusCode.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/axios.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios-retry/dist/esm/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/lib/crypto_key.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/lib/invalid_key_input.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/lib/is_object.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/core/AxiosError.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/env/data.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/lib/buffer_utils.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/lib/base64.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/util/errors.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/lib/check_key_length.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/lib/is_disjoint.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/lib/is_key_like.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/node_modules/zod/v3/helpers/util.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/node_modules/zod/v3/helpers/errorUtil.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/ox/core/internal/entropy.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/preact/hooks/dist/hooks.mjs","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/account-abstraction/utils/formatters/userOperation.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/preact/jsx-runtime/dist/jsxRuntime.mjs","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/lib/jwk_to_key.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/platform/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/node_modules/zod/v3/errors.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/trackStream.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/lib/subtle_dsa.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/lib/is_jwk.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/lib/validate_crit.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/jws/compact/sign.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/node_modules/zod/v3/ZodError.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/index.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/node_modules/zod/v3/locales/en.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/callbackify.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/uncrypto/dist/crypto.node.mjs","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/speedometer.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/node_modules/zod/v3/helpers/parseUtil.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/lib/get_sign_verify_key.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/util/base64url.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/parseProtocol.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/isURLSameOrigin.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/cancel/isCancel.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/defaults/transitional.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/huddle01Mainnet.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/zksyncLocalHyperchainL1.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/lib/check_key_type.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/lib/jwt_claims_set.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/store/correlation-ids/store.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/lib/sign.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/jwt/sign.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/cookies.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/zksync/errors/bytecode.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/clients/createWalletClient.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/zksync/utils/isEip712Transaction.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/util/encoding.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/sign/base-account/utils.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/accounts/evm/toEvmSmartAccount.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/account-abstraction/clients/createBundlerClient.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/account-abstraction/actions/bundler/prepareUserOperation.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/ui/assets/injectFontStyle.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/celoAlfajores.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/node_modules/abitype/src/human-readable/runtime/utils.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/actions/solana/constants.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/zksync/serializers.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/sign/base-account/Signer.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/lib/normalize_key.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/lib/asn1.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/adapters/http.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/composeSignals.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/progressEventReducer.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/hychainTestnet.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/sign/base-account/utils/handleInsufficientBalance.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/actions/evm/transfer/smartAccountTransferStrategy.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/assertions/src/crypto.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/account-abstraction/errors/userOperation.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/zksync/utils/hashBytecode.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/ox/core/Base64.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/ui/assets/BaseLogo.tsx","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/node_modules/zod/v3/types.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/key/import.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/core/error/errors.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/bitTorrentTestnet.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/bitkubTestnet.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/bitTorrent.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/weavevmAlphanet.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/account-abstraction/utils/userOperation/toPackedUserOperation.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/actions/solana/transfer.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/celo/serializers.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/account-abstraction/accounts/toSmartAccount.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/index.node.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/node_modules/abitype/src/human-readable/errors/splitParameters.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/formDataToStream.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/adapters/adapters.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/util/assertPresence.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/openapi-client/generated/evm-swaps/evm-swaps.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/actions/wallet/sendTransactionSync.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/sign/base-account/utils/createSubAccountSigner.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/ox/core/Solidity.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/openapi-client/generated/evm-accounts/evm-accounts.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/node_modules/abitype/src/human-readable/runtime/signatures.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/optimismSepolia.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/openapi-client/generated/policy-engine/policy-engine.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/programs/src/program-error.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/options/src/option.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/openapi-client/generated/evm-token-balances/evm-token-balances.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/jose/dist/webapi/jws/flattened/sign.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/redstone.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/skale/europa.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/openapi-client/generated/solana-token-balances/solana-token-balances.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/skale/exorde.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/openapi-client/generated/onchain-data/onchain-data.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/payment/subscribe.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/auth/utils/jwt.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/zksync/errors/transaction.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/ox/core/WebAuthnP256.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/isAbsoluteURL.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/estimateDataURLDecodedBytes.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/bind.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/resolveConfig.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/account-abstraction/utils/userOperation/getUserOperationHash.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/dchain.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/sign/base-account/utils/findOwnerIndex.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/util/assertSubAccount.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/util/web.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/sign/base-account/utils/handleAddSubAccountOwner.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/actions/evm/requestFaucet.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/sign/base-account/utils/routeThroughGlobalAccount.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/actions/wallet/sendCalls.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/actions/solana/rpc.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/adapters/fetch.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/combineURLs.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/avalancheFuji.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/songbird.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/accounts/src/decode-account.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/ox/node_modules/@noble/hashes/src/_u64.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/dchainTestnet.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/sign/base-account/utils/presentAddOwnerDialog.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/ui/Dialog/Dialog.tsx","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/adapters/xhr.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/statusNetworkSepolia.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/zenchainTestnet.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transaction-messages/src/blockhash.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/node_modules/abitype/src/regex.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/auth/utils/hash.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/linea/chainConfig.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/actions/evm/transfer/transfer.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/celo/fees.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/kms/crypto-key/index.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-core/src/bytes.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/iotaTestnet.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/account-abstraction/utils/errors/getUserOperationError.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/account-abstraction/clients/decorators/bundler.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/utils/signature/parseSignature.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/ox/node_modules/@noble/hashes/src/sha3.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/clients/decorators/wallet.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-types/src/blockhash.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/signers/src/deduplicate-signers.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/client/evm/evm.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/node_modules/abitype/src/errors.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/core/telemetry/events/scw-sub-account.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/ox/node_modules/@noble/hashes/src/utils.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/core/telemetry/events/subscription.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/util/validatePreferences.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/utils/bigint.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/core/type/util.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/client/solana/solana.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/util/cipher.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/auth/errors.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/metisSepolia.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-data-structures/src/utils.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/spend-permissions/constants.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/merlinErigonTestnet.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/ox/node_modules/@noble/hashes/src/sha2.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/utils/signature/serializeErc6492Signature.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/filecoinCalibration.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/defichainEvmTestnet.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/openapi-client/index.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/utils/uuidV4.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-strings/src/baseX.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/luksoTestnet.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/accounts/toAccount.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/spend-permissions/utils.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-api/src/index.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/utils/nonceManager.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/actions/evm/getUserOperation.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/zksync/utils/assertEip712Transaction.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/policies/solanaSchema.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/actions/evm/swap/getSwapPrice.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/ox/core/internal/errors.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/analytics.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/openapi-client/errors.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/actions/evm/sendTransaction.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/actions/solana/signMessage.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/actions/solana/requestFaucet.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/fast-stable-stringify/src/index.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/actions/wallet/addChain.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/accounts/evm/getBaseNodeRpcUrl.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/actions/wallet/getPermissions.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/signers/src/transaction-modifying-signer.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/openapi-client/generated/coinbaseDeveloperPlatformAPIs.schemas.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/errors/src/codes.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/ox/core/P256.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/axios/lib/helpers/spread.js","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/actions/wallet/requestPermissions.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/payment/utils/validation.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/node_modules/abitype/src/zod.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/utils/unit/parseUnits.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/payment/utils/translatePayment.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/actions/evm/listSpendPermissions.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/megaethTestnet.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/taiko.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/funkiSepolia.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/ox/core/Json.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/tac.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/chiliz.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/zkFair.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/beamTestnet.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/moonriver.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/rolluxTestnet.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/moonbeam.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/syscoin.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/moonbaseAlpha.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/beam.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/mantaSepoliaTestnet.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/flame.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/actions/wallet/getCapabilities.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transactions/src/codecs/signatures-encoder.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/opBNB.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/actions/evm/swap/createSwapQuote.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/blastSepolia.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/arbitrumSepolia.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/eduChainTestnet.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/unichain.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/forma.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/rollux.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/options/src/option-codec.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/auth/hooks/axios/withAuth.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/accounts/evm/toNetworkScopedEvmServerAccount.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@noble/curves/src/nist.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/actions/wallet/getAddresses.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/sign/base-account/utils/constants.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/ox/core/Signature.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/account-abstraction/errors/bundler.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/actions/evm/waitForUserOperation.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/actions/solana/utils.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/addresses/src/address.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/accounts/evm/networkToChainResolver.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/actions/wallet/requestAddresses.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/core/error/utils.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-strings/src/assertions.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/actions/wallet/getCallsStatus.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/utils/wait.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/account-abstraction/utils/formatters/userOperationRequest.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/node_modules/abitype/src/human-readable/errors/signature.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/accounts/evm/toEvmServerAccount.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/openapi-client/generated/solana-accounts/solana-accounts.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-numbers/src/utils.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/account-abstraction/actions/paymaster/getPaymasterData.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc/src/rpc-integer-overflow-error.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/actions/evm/spend-permissions/resolveSpendPermission.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transactions/src/codecs/transaction-codec.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/core/telemetry/events/scw-signer.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/ox/core/WebCryptoP256.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/util/provider.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-transformers/src/tree-traversal.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/account-abstraction/actions/bundler/waitForUserOperationReceipt.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/blast.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/payment/pay.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/account-abstraction/actions/bundler/getUserOperationReceipt.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/assertions/src/subtle-crypto.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/account-abstraction/actions/paymaster/getPaymasterStubData.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/actions/wallet/waitForCallsStatus.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/ox/core/internal/webauthn.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/openapi-client/generated/evm-smart-accounts/evm-smart-accounts.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/accounts/mint.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/payment/getSubscriptionStatus.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/util/checkCrossOriginOpenerPolicy.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/celo/utils.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/zksync/utils/getEip712Domain.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/auth/utils/http.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/ox/node_modules/@noble/hashes/src/legacy.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/core/telemetry/events/payment.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/actions/solana/signTransaction.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/linea/actions/estimateGas.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/core/communicator/Communicator.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/actions/wallet/writeContractSync.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/actions/wallet/sendCallsSync.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/account-abstraction/actions/bundler/estimateUserOperationGas.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/system/src/generated/accounts/nonce.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/ox/core/internal/bytes.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/accounts/evm/resolveViemClients.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/actions/evm/transfer/transferWithViem.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-data-structures/src/array.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/accounts/src/parse-account.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/zoraSepolia.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/zircuit.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/rss3Sepolia.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/rss3.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/celoSepolia.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/index.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/account-abstraction/actions/bundler/sendUserOperation.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/payment/getPaymentStatus.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/ox/node_modules/@noble/hashes/src/_md.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/account-abstraction/constants/abis.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-transport-http/src/http-transport-headers.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/sign/base-account/SCWKeyManager.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/signers/src/transaction-sending-signer.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/sign/base-account/utils/createSmartAccount.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/builder/core/createBaseAccountSDK.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/public-utilities/spend-permission/methods/getHash.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/core/telemetry/logEvent.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/ox/core/internal/hex.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/store/chain-clients/utils.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/payment/constants.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/node_modules/abitype/src/human-readable/runtime/cache.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/utils/export.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/bobSepolia.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/celo/formatters.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/public-utilities/spend-permission/utils.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/payment/utils/sdkManager.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc/src/rpc-default-config.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-spec-types/src/parse-json-with-bigints.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/utils/abi/encodePacked.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/actions/wallet/signTransaction.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/public-utilities/spend-permission/methods/getPermissionStatus.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-spec/src/rpc-api.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/signers/src/transaction-signer.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/actions/evm/sendUserOperation.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/payment/getOrCreateSubscriptionOwnerWallet.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/chains/definitions/baseSepolia.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/zksync/formatters.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-numbers/src/f32.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/accounts/evm/networkCapabilities.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/keys/src/private-key.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-transformers/src/request-transformer-bigint-downcast.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/client/cdp.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/accounts/src/fetch-account.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/accounts/evm/toNetworkScopedEvmSmartAccount.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc/src/rpc-request-coalescer.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/builder/core/BaseAccountProvider.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/node_modules/abitype/src/human-readable/errors/abiParameter.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/actions/wallet/prepareAuthorization.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/signers/src/account-signer-meta.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/ox/core/Hash.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/openapi-client/cdpApiClient.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/instructions/src/roles.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/store/store.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/payment/prepareCharge.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-core/src/codec.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/actions/evm/signAndWrapTypedDataForSmartAccount.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-spec/src/rpc-transport.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/payment/charge.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-types/src/commitment.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/actions/evm/swap/sendSwapTransaction.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/policies/evmSchema.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/actions/evm/swap/sendSwapOperation.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-transformers/src/request-transformer-default-commitment-internal.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/ox/core/PublicKey.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/signers/src/add-signers.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/core/error/constants.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/accounts/multisig.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-spec-types/src/stringify-json-with-bigints.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-transport-http/src/http-transport.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/addresses/src/vendor/noble/ed25519.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-numbers/src/f64.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/ox/core/Hex.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/account-abstraction/utils/errors/getBundlerError.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-core/src/combine-codec.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/accounts/src/maybe-account.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transactions/src/compile-transaction.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-numbers/src/i128.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-types/src/lamports.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/system/src/generated/programs/system.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-strings/src/base16.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/public-utilities/spend-permission/methods/prepareSpendCallData.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-data-structures/src/bit-array.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/keys/src/signatures.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/options/src/unwrap-option-recursively.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/ox/core/Errors.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/viem/actions/wallet/signTypedData.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/signers/src/fee-payer-signer.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-core/src/add-codec-sentinel.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transactions/src/signatures.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transaction-messages/src/codecs/address-table-lookup.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-numbers/src/i16.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-transformers/src/request-transformer-default-commitment.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/signers/src/message-partial-signer.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/node_modules/ox/core/Bytes.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc/src/rpc-request-deduplication.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/types/accountState.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-numbers/src/i32.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/signers/src/keypair-signer.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-transport-http/src/is-solana-request.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transaction-messages/src/codecs/header.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc/src/rpc-transport.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/types/authorityType.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-numbers/src/i64.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-types/src/stringified-bigint.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-transformers/src/request-transformer-integer-overflow-internal.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-strings/src/base58.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-strings/src/baseX-reslice.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/keys/src/key-pair.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/addresses/src/curve-internal.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-data-structures/src/boolean.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-transformers/src/request-transformer-integer-overflow.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/system/src/generated/errors/system.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-numbers/src/i8.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transaction-messages/src/codecs/instruction.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/accounts/token.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-data-structures/src/bytes.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc/src/rpc.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-transport-http/src/http-transport-for-solana-rpc.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@coinbase/cdp-sdk/client/policies/policies.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/signers/src/message-modifying-signer.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/addresses/src/curve.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-types/src/unix-timestamp.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-numbers/src/short-u16.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-core/src/assertions.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/signers/src/message-signer.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-transformers/src/request-transformer-options-object-position-config.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/addresses/src/program-derived-address.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-strings/src/base64.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-data-structures/src/constant.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transactions/src/wire-transaction.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/system/src/generated/shared/index.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/signers/src/noop-signer.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transactions/src/transaction-size.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/signers/src/transaction-with-single-sending-signer.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-core/src/add-codec-size-prefix.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-transformers/src/request-transformer.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transaction-messages/src/codecs/transaction-version.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-numbers/src/u128.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transactions/src/sendable-transaction.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-strings/src/null-characters.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-data-structures/src/tuple.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transactions/src/transaction-message-size.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/signers/src/sign-transaction.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/system/src/generated/instructions/advanceNonceAccount.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-transformers/src/response-transformer-bigint-upcast-internal.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-strings/src/utf8.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-numbers/src/u16.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/errors/src/context.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transaction-messages/src/codecs/message.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-core/src/fix-codec-size.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/programs/associatedToken.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-numbers/src/u32.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-transformers/src/response-transformer-bigint-upcast.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-data-structures/src/union.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-transformers/src/response-transformer-throw-solana-error.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-numbers/src/u64.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/programs/token.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-transformers/src/response-transformer.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/errors/src/messages.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-numbers/src/u8.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-core/src/offset-codec.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/system/src/generated/instructions/allocate.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/rpc-transformers/src/response-transformer-allowed-numeric-values.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/addresses/src/public-key.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/signers/src/signable-message.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-core/src/resize-codec.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-data-structures/src/discriminated-union.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transaction-messages/src/compile/accounts.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/system/src/generated/instructions/allocateWithSeed.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-data-structures/src/enum-helpers.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-core/src/pad-codec.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-core/src/reverse-codec.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/errors/associatedToken.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-data-structures/src/enum.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/system/src/generated/instructions/assign.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/errors/token.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-core/src/transform-codec.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-data-structures/src/hidden-prefix.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/system/src/generated/instructions/assignWithSeed.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-data-structures/src/hidden-suffix.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/shared/index.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-data-structures/src/literal-union.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transaction-messages/src/compile/address-table-lookups.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/errors/src/message-formatter.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/amountToUiAmount.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-data-structures/src/map.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transaction-messages/src/compile/header.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-data-structures/src/unit.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/system/src/generated/instructions/authorizeNonceAccount.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transaction-messages/src/compile/instructions.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-data-structures/src/nullable.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transaction-messages/src/compile/lifetime-token.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/approve.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transaction-messages/src/compile/static-accounts.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transaction-messages/src/compile/message.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/errors/src/error.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transaction-messages/src/compress-transaction-message.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/system/src/generated/instructions/createAccount.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-data-structures/src/set.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/codecs-data-structures/src/struct.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/errors/src/stack-trace.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/errors/src/rpc-enum-errors.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transaction-messages/src/create-transaction-message.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/approveChecked.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transaction-messages/src/durable-nonce-instruction.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/errors/src/instruction-error.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transaction-messages/src/durable-nonce.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/system/src/generated/instructions/createAccountWithSeed.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transaction-messages/src/fee-payer.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/burn.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transaction-messages/src/instructions.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/errors/src/transaction-error.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/transaction-messages/src/decompile-message.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/system/src/generated/instructions/initializeNonceAccount.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/burnChecked.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana/errors/src/json-rpc-error.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/system/src/generated/instructions/transferSol.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/closeAccount.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/system/src/generated/instructions/transferSolWithSeed.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/pdas/associatedToken.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/createAssociatedToken.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/system/src/generated/instructions/upgradeNonceAccount.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/system/src/generated/instructions/withdrawNonceAccount.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/createAssociatedTokenIdempotent.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/freezeAccount.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/getAccountDataSize.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/initializeAccount.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/initializeAccount2.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/initializeAccount3.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/initializeImmutableOwner.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/initializeMint.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/initializeMint2.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/initializeMultisig.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/initializeMultisig2.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/mintTo.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/mintToChecked.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/recoverNestedAssociatedToken.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/revoke.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/setAuthority.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/syncNative.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/thawAccount.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/transfer.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/transferChecked.ts","turbopack:///[project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@solana-program/token/src/generated/instructions/uiAmountToAmount.ts"],"sourcesContent":["(function() {\n  var base64map\n      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n\n  crypt = {\n    // Bit-wise rotation left\n    rotl: function(n, b) {\n      return (n << b) | (n >>> (32 - b));\n    },\n\n    // Bit-wise rotation right\n    rotr: function(n, b) {\n      return (n << (32 - b)) | (n >>> b);\n    },\n\n    // Swap big-endian to little-endian and vice versa\n    endian: function(n) {\n      // If number given, swap endian\n      if (n.constructor == Number) {\n        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;\n      }\n\n      // Else, assume array and swap all items\n      for (var i = 0; i < n.length; i++)\n        n[i] = crypt.endian(n[i]);\n      return n;\n    },\n\n    // Generate an array of any length of random bytes\n    randomBytes: function(n) {\n      for (var bytes = []; n > 0; n--)\n        bytes.push(Math.floor(Math.random() * 256));\n      return bytes;\n    },\n\n    // Convert a byte array to big-endian 32-bit words\n    bytesToWords: function(bytes) {\n      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)\n        words[b >>> 5] |= bytes[i] << (24 - b % 32);\n      return words;\n    },\n\n    // Convert big-endian 32-bit words to a byte array\n    wordsToBytes: function(words) {\n      for (var bytes = [], b = 0; b < words.length * 32; b += 8)\n        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);\n      return bytes;\n    },\n\n    // Convert a byte array to a hex string\n    bytesToHex: function(bytes) {\n      for (var hex = [], i = 0; i < bytes.length; i++) {\n        hex.push((bytes[i] >>> 4).toString(16));\n        hex.push((bytes[i] & 0xF).toString(16));\n      }\n      return hex.join('');\n    },\n\n    // Convert a hex string to a byte array\n    hexToBytes: function(hex) {\n      for (var bytes = [], c = 0; c < hex.length; c += 2)\n        bytes.push(parseInt(hex.substr(c, 2), 16));\n      return bytes;\n    },\n\n    // Convert a byte array to a base-64 string\n    bytesToBase64: function(bytes) {\n      for (var base64 = [], i = 0; i < bytes.length; i += 3) {\n        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\n        for (var j = 0; j < 4; j++)\n          if (i * 8 + j * 6 <= bytes.length * 8)\n            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));\n          else\n            base64.push('=');\n      }\n      return base64.join('');\n    },\n\n    // Convert a base-64 string to a byte array\n    base64ToBytes: function(base64) {\n      // Remove non-base-64 characters\n      base64 = base64.replace(/[^A-Z0-9+\\/]/ig, '');\n\n      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;\n          imod4 = ++i % 4) {\n        if (imod4 == 0) continue;\n        bytes.push(((base64map.indexOf(base64.charAt(i - 1))\n            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))\n            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));\n      }\n      return bytes;\n    }\n  };\n\n  module.exports = crypt;\n})();\n","var charenc = {\n  // UTF-8 encoding\n  utf8: {\n    // Convert a string to a byte array\n    stringToBytes: function(str) {\n      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));\n    },\n\n    // Convert a byte array to a string\n    bytesToString: function(bytes) {\n      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));\n    }\n  },\n\n  // Binary encoding\n  bin: {\n    // Convert a string to a byte array\n    stringToBytes: function(str) {\n      for (var bytes = [], i = 0; i < str.length; i++)\n        bytes.push(str.charCodeAt(i) & 0xFF);\n      return bytes;\n    },\n\n    // Convert a byte array to a string\n    bytesToString: function(bytes) {\n      for (var str = [], i = 0; i < bytes.length; i++)\n        str.push(String.fromCharCode(bytes[i]));\n      return str.join('');\n    }\n  }\n};\n\nmodule.exports = charenc;\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n","(function(){\r\n  var crypt = require('crypt'),\r\n      utf8 = require('charenc').utf8,\r\n      isBuffer = require('is-buffer'),\r\n      bin = require('charenc').bin,\r\n\r\n  // The core\r\n  md5 = function (message, options) {\r\n    // Convert to byte array\r\n    if (message.constructor == String)\r\n      if (options && options.encoding === 'binary')\r\n        message = bin.stringToBytes(message);\r\n      else\r\n        message = utf8.stringToBytes(message);\r\n    else if (isBuffer(message))\r\n      message = Array.prototype.slice.call(message, 0);\r\n    else if (!Array.isArray(message) && message.constructor !== Uint8Array)\r\n      message = message.toString();\r\n    // else, assume byte array already\r\n\r\n    var m = crypt.bytesToWords(message),\r\n        l = message.length * 8,\r\n        a =  1732584193,\r\n        b = -271733879,\r\n        c = -1732584194,\r\n        d =  271733878;\r\n\r\n    // Swap endian\r\n    for (var i = 0; i < m.length; i++) {\r\n      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |\r\n             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;\r\n    }\r\n\r\n    // Padding\r\n    m[l >>> 5] |= 0x80 << (l % 32);\r\n    m[(((l + 64) >>> 9) << 4) + 14] = l;\r\n\r\n    // Method shortcuts\r\n    var FF = md5._ff,\r\n        GG = md5._gg,\r\n        HH = md5._hh,\r\n        II = md5._ii;\r\n\r\n    for (var i = 0; i < m.length; i += 16) {\r\n\r\n      var aa = a,\r\n          bb = b,\r\n          cc = c,\r\n          dd = d;\r\n\r\n      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);\r\n      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);\r\n      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);\r\n      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);\r\n      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);\r\n      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);\r\n      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);\r\n      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);\r\n      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);\r\n      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);\r\n      c = FF(c, d, a, b, m[i+10], 17, -42063);\r\n      b = FF(b, c, d, a, m[i+11], 22, -1990404162);\r\n      a = FF(a, b, c, d, m[i+12],  7,  1804603682);\r\n      d = FF(d, a, b, c, m[i+13], 12, -40341101);\r\n      c = FF(c, d, a, b, m[i+14], 17, -1502002290);\r\n      b = FF(b, c, d, a, m[i+15], 22,  1236535329);\r\n\r\n      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);\r\n      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);\r\n      c = GG(c, d, a, b, m[i+11], 14,  643717713);\r\n      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);\r\n      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);\r\n      d = GG(d, a, b, c, m[i+10],  9,  38016083);\r\n      c = GG(c, d, a, b, m[i+15], 14, -660478335);\r\n      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);\r\n      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);\r\n      d = GG(d, a, b, c, m[i+14],  9, -1019803690);\r\n      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);\r\n      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);\r\n      a = GG(a, b, c, d, m[i+13],  5, -1444681467);\r\n      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);\r\n      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);\r\n      b = GG(b, c, d, a, m[i+12], 20, -1926607734);\r\n\r\n      a = HH(a, b, c, d, m[i+ 5],  4, -378558);\r\n      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);\r\n      c = HH(c, d, a, b, m[i+11], 16,  1839030562);\r\n      b = HH(b, c, d, a, m[i+14], 23, -35309556);\r\n      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);\r\n      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);\r\n      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);\r\n      b = HH(b, c, d, a, m[i+10], 23, -1094730640);\r\n      a = HH(a, b, c, d, m[i+13],  4,  681279174);\r\n      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);\r\n      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);\r\n      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);\r\n      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);\r\n      d = HH(d, a, b, c, m[i+12], 11, -421815835);\r\n      c = HH(c, d, a, b, m[i+15], 16,  530742520);\r\n      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);\r\n\r\n      a = II(a, b, c, d, m[i+ 0],  6, -198630844);\r\n      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);\r\n      c = II(c, d, a, b, m[i+14], 15, -1416354905);\r\n      b = II(b, c, d, a, m[i+ 5], 21, -57434055);\r\n      a = II(a, b, c, d, m[i+12],  6,  1700485571);\r\n      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);\r\n      c = II(c, d, a, b, m[i+10], 15, -1051523);\r\n      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);\r\n      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);\r\n      d = II(d, a, b, c, m[i+15], 10, -30611744);\r\n      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);\r\n      b = II(b, c, d, a, m[i+13], 21,  1309151649);\r\n      a = II(a, b, c, d, m[i+ 4],  6, -145523070);\r\n      d = II(d, a, b, c, m[i+11], 10, -1120210379);\r\n      c = II(c, d, a, b, m[i+ 2], 15,  718787259);\r\n      b = II(b, c, d, a, m[i+ 9], 21, -343485551);\r\n\r\n      a = (a + aa) >>> 0;\r\n      b = (b + bb) >>> 0;\r\n      c = (c + cc) >>> 0;\r\n      d = (d + dd) >>> 0;\r\n    }\r\n\r\n    return crypt.endian([a, b, c, d]);\r\n  };\r\n\r\n  // Auxiliary functions\r\n  md5._ff  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b & c | ~b & d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._gg  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b & d | c & ~d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._hh  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b ^ c ^ d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._ii  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n\r\n  // Package private blocksize\r\n  md5._blocksize = 16;\r\n  md5._digestsize = 16;\r\n\r\n  module.exports = function (message, options) {\r\n    if (message === undefined || message === null)\r\n      throw new Error('Illegal argument ' + message);\r\n\r\n    var digestbytes = crypt.wordsToBytes(md5(message, options));\r\n    return options && options.asBytes ? digestbytes :\r\n        options && options.asString ? bin.bytesToString(digestbytes) :\r\n        crypt.bytesToHex(digestbytes);\r\n  };\r\n\r\n})();\r\n","var Stream = require('stream').Stream;\nvar util = require('util');\n\nmodule.exports = DelayedStream;\nfunction DelayedStream() {\n  this.source = null;\n  this.dataSize = 0;\n  this.maxDataSize = 1024 * 1024;\n  this.pauseStream = true;\n\n  this._maxDataSizeExceeded = false;\n  this._released = false;\n  this._bufferedEvents = [];\n}\nutil.inherits(DelayedStream, Stream);\n\nDelayedStream.create = function(source, options) {\n  var delayedStream = new this();\n\n  options = options || {};\n  for (var option in options) {\n    delayedStream[option] = options[option];\n  }\n\n  delayedStream.source = source;\n\n  var realEmit = source.emit;\n  source.emit = function() {\n    delayedStream._handleEmit(arguments);\n    return realEmit.apply(source, arguments);\n  };\n\n  source.on('error', function() {});\n  if (delayedStream.pauseStream) {\n    source.pause();\n  }\n\n  return delayedStream;\n};\n\nObject.defineProperty(DelayedStream.prototype, 'readable', {\n  configurable: true,\n  enumerable: true,\n  get: function() {\n    return this.source.readable;\n  }\n});\n\nDelayedStream.prototype.setEncoding = function() {\n  return this.source.setEncoding.apply(this.source, arguments);\n};\n\nDelayedStream.prototype.resume = function() {\n  if (!this._released) {\n    this.release();\n  }\n\n  this.source.resume();\n};\n\nDelayedStream.prototype.pause = function() {\n  this.source.pause();\n};\n\nDelayedStream.prototype.release = function() {\n  this._released = true;\n\n  this._bufferedEvents.forEach(function(args) {\n    this.emit.apply(this, args);\n  }.bind(this));\n  this._bufferedEvents = [];\n};\n\nDelayedStream.prototype.pipe = function() {\n  var r = Stream.prototype.pipe.apply(this, arguments);\n  this.resume();\n  return r;\n};\n\nDelayedStream.prototype._handleEmit = function(args) {\n  if (this._released) {\n    this.emit.apply(this, args);\n    return;\n  }\n\n  if (args[0] === 'data') {\n    this.dataSize += args[1].length;\n    this._checkIfMaxDataSizeExceeded();\n  }\n\n  this._bufferedEvents.push(args);\n};\n\nDelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {\n  if (this._maxDataSizeExceeded) {\n    return;\n  }\n\n  if (this.dataSize <= this.maxDataSize) {\n    return;\n  }\n\n  this._maxDataSizeExceeded = true;\n  var message =\n    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'\n  this.emit('error', new Error(message));\n};\n","var util = require('util');\nvar Stream = require('stream').Stream;\nvar DelayedStream = require('delayed-stream');\n\nmodule.exports = CombinedStream;\nfunction CombinedStream() {\n  this.writable = false;\n  this.readable = true;\n  this.dataSize = 0;\n  this.maxDataSize = 2 * 1024 * 1024;\n  this.pauseStreams = true;\n\n  this._released = false;\n  this._streams = [];\n  this._currentStream = null;\n  this._insideLoop = false;\n  this._pendingNext = false;\n}\nutil.inherits(CombinedStream, Stream);\n\nCombinedStream.create = function(options) {\n  var combinedStream = new this();\n\n  options = options || {};\n  for (var option in options) {\n    combinedStream[option] = options[option];\n  }\n\n  return combinedStream;\n};\n\nCombinedStream.isStreamLike = function(stream) {\n  return (typeof stream !== 'function')\n    && (typeof stream !== 'string')\n    && (typeof stream !== 'boolean')\n    && (typeof stream !== 'number')\n    && (!Buffer.isBuffer(stream));\n};\n\nCombinedStream.prototype.append = function(stream) {\n  var isStreamLike = CombinedStream.isStreamLike(stream);\n\n  if (isStreamLike) {\n    if (!(stream instanceof DelayedStream)) {\n      var newStream = DelayedStream.create(stream, {\n        maxDataSize: Infinity,\n        pauseStream: this.pauseStreams,\n      });\n      stream.on('data', this._checkDataSize.bind(this));\n      stream = newStream;\n    }\n\n    this._handleErrors(stream);\n\n    if (this.pauseStreams) {\n      stream.pause();\n    }\n  }\n\n  this._streams.push(stream);\n  return this;\n};\n\nCombinedStream.prototype.pipe = function(dest, options) {\n  Stream.prototype.pipe.call(this, dest, options);\n  this.resume();\n  return dest;\n};\n\nCombinedStream.prototype._getNext = function() {\n  this._currentStream = null;\n\n  if (this._insideLoop) {\n    this._pendingNext = true;\n    return; // defer call\n  }\n\n  this._insideLoop = true;\n  try {\n    do {\n      this._pendingNext = false;\n      this._realGetNext();\n    } while (this._pendingNext);\n  } finally {\n    this._insideLoop = false;\n  }\n};\n\nCombinedStream.prototype._realGetNext = function() {\n  var stream = this._streams.shift();\n\n\n  if (typeof stream == 'undefined') {\n    this.end();\n    return;\n  }\n\n  if (typeof stream !== 'function') {\n    this._pipeNext(stream);\n    return;\n  }\n\n  var getStream = stream;\n  getStream(function(stream) {\n    var isStreamLike = CombinedStream.isStreamLike(stream);\n    if (isStreamLike) {\n      stream.on('data', this._checkDataSize.bind(this));\n      this._handleErrors(stream);\n    }\n\n    this._pipeNext(stream);\n  }.bind(this));\n};\n\nCombinedStream.prototype._pipeNext = function(stream) {\n  this._currentStream = stream;\n\n  var isStreamLike = CombinedStream.isStreamLike(stream);\n  if (isStreamLike) {\n    stream.on('end', this._getNext.bind(this));\n    stream.pipe(this, {end: false});\n    return;\n  }\n\n  var value = stream;\n  this.write(value);\n  this._getNext();\n};\n\nCombinedStream.prototype._handleErrors = function(stream) {\n  var self = this;\n  stream.on('error', function(err) {\n    self._emitError(err);\n  });\n};\n\nCombinedStream.prototype.write = function(data) {\n  this.emit('data', data);\n};\n\nCombinedStream.prototype.pause = function() {\n  if (!this.pauseStreams) {\n    return;\n  }\n\n  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();\n  this.emit('pause');\n};\n\nCombinedStream.prototype.resume = function() {\n  if (!this._released) {\n    this._released = true;\n    this.writable = true;\n    this._getNext();\n  }\n\n  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();\n  this.emit('resume');\n};\n\nCombinedStream.prototype.end = function() {\n  this._reset();\n  this.emit('end');\n};\n\nCombinedStream.prototype.destroy = function() {\n  this._reset();\n  this.emit('close');\n};\n\nCombinedStream.prototype._reset = function() {\n  this.writable = false;\n  this._streams = [];\n  this._currentStream = null;\n};\n\nCombinedStream.prototype._checkDataSize = function() {\n  this._updateDataSize();\n  if (this.dataSize <= this.maxDataSize) {\n    return;\n  }\n\n  var message =\n    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';\n  this._emitError(new Error(message));\n};\n\nCombinedStream.prototype._updateDataSize = function() {\n  this.dataSize = 0;\n\n  var self = this;\n  this._streams.forEach(function(stream) {\n    if (!stream.dataSize) {\n      return;\n    }\n\n    self.dataSize += stream.dataSize;\n  });\n\n  if (this._currentStream && this._currentStream.dataSize) {\n    this.dataSize += this._currentStream.dataSize;\n  }\n};\n\nCombinedStream.prototype._emitError = function(err) {\n  this._reset();\n  this.emit('error', err);\n};\n","{\"application/1d-interleaved-parityfec\":{\"source\":\"iana\"},\"application/3gpdash-qoe-report+xml\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true},\"application/3gpp-ims+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/3gpphal+json\":{\"source\":\"iana\",\"compressible\":true},\"application/3gpphalforms+json\":{\"source\":\"iana\",\"compressible\":true},\"application/a2l\":{\"source\":\"iana\"},\"application/ace+cbor\":{\"source\":\"iana\"},\"application/activemessage\":{\"source\":\"iana\"},\"application/activity+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-costmap+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-costmapfilter+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-directory+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-endpointcost+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-endpointcostparams+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-endpointprop+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-endpointpropparams+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-error+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-networkmap+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-networkmapfilter+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-updatestreamcontrol+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-updatestreamparams+json\":{\"source\":\"iana\",\"compressible\":true},\"application/aml\":{\"source\":\"iana\"},\"application/andrew-inset\":{\"source\":\"iana\",\"extensions\":[\"ez\"]},\"application/applefile\":{\"source\":\"iana\"},\"application/applixware\":{\"source\":\"apache\",\"extensions\":[\"aw\"]},\"application/at+jwt\":{\"source\":\"iana\"},\"application/atf\":{\"source\":\"iana\"},\"application/atfx\":{\"source\":\"iana\"},\"application/atom+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"atom\"]},\"application/atomcat+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"atomcat\"]},\"application/atomdeleted+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"atomdeleted\"]},\"application/atomicmail\":{\"source\":\"iana\"},\"application/atomsvc+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"atomsvc\"]},\"application/atsc-dwd+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"dwd\"]},\"application/atsc-dynamic-event-message\":{\"source\":\"iana\"},\"application/atsc-held+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"held\"]},\"application/atsc-rdt+json\":{\"source\":\"iana\",\"compressible\":true},\"application/atsc-rsat+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rsat\"]},\"application/atxml\":{\"source\":\"iana\"},\"application/auth-policy+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/bacnet-xdd+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/batch-smtp\":{\"source\":\"iana\"},\"application/bdoc\":{\"compressible\":false,\"extensions\":[\"bdoc\"]},\"application/beep+xml\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true},\"application/calendar+json\":{\"source\":\"iana\",\"compressible\":true},\"application/calendar+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xcs\"]},\"application/call-completion\":{\"source\":\"iana\"},\"application/cals-1840\":{\"source\":\"iana\"},\"application/captive+json\":{\"source\":\"iana\",\"compressible\":true},\"application/cbor\":{\"source\":\"iana\"},\"application/cbor-seq\":{\"source\":\"iana\"},\"application/cccex\":{\"source\":\"iana\"},\"application/ccmp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/ccxml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ccxml\"]},\"application/cdfx+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"cdfx\"]},\"application/cdmi-capability\":{\"source\":\"iana\",\"extensions\":[\"cdmia\"]},\"application/cdmi-container\":{\"source\":\"iana\",\"extensions\":[\"cdmic\"]},\"application/cdmi-domain\":{\"source\":\"iana\",\"extensions\":[\"cdmid\"]},\"application/cdmi-object\":{\"source\":\"iana\",\"extensions\":[\"cdmio\"]},\"application/cdmi-queue\":{\"source\":\"iana\",\"extensions\":[\"cdmiq\"]},\"application/cdni\":{\"source\":\"iana\"},\"application/cea\":{\"source\":\"iana\"},\"application/cea-2018+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/cellml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/cfw\":{\"source\":\"iana\"},\"application/city+json\":{\"source\":\"iana\",\"compressible\":true},\"application/clr\":{\"source\":\"iana\"},\"application/clue+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/clue_info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/cms\":{\"source\":\"iana\"},\"application/cnrp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/coap-group+json\":{\"source\":\"iana\",\"compressible\":true},\"application/coap-payload\":{\"source\":\"iana\"},\"application/commonground\":{\"source\":\"iana\"},\"application/conference-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/cose\":{\"source\":\"iana\"},\"application/cose-key\":{\"source\":\"iana\"},\"application/cose-key-set\":{\"source\":\"iana\"},\"application/cpl+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"cpl\"]},\"application/csrattrs\":{\"source\":\"iana\"},\"application/csta+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/cstadata+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/csvm+json\":{\"source\":\"iana\",\"compressible\":true},\"application/cu-seeme\":{\"source\":\"apache\",\"extensions\":[\"cu\"]},\"application/cwt\":{\"source\":\"iana\"},\"application/cybercash\":{\"source\":\"iana\"},\"application/dart\":{\"compressible\":true},\"application/dash+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mpd\"]},\"application/dash-patch+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mpp\"]},\"application/dashdelta\":{\"source\":\"iana\"},\"application/davmount+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"davmount\"]},\"application/dca-rft\":{\"source\":\"iana\"},\"application/dcd\":{\"source\":\"iana\"},\"application/dec-dx\":{\"source\":\"iana\"},\"application/dialog-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/dicom\":{\"source\":\"iana\"},\"application/dicom+json\":{\"source\":\"iana\",\"compressible\":true},\"application/dicom+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/dii\":{\"source\":\"iana\"},\"application/dit\":{\"source\":\"iana\"},\"application/dns\":{\"source\":\"iana\"},\"application/dns+json\":{\"source\":\"iana\",\"compressible\":true},\"application/dns-message\":{\"source\":\"iana\"},\"application/docbook+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"dbk\"]},\"application/dots+cbor\":{\"source\":\"iana\"},\"application/dskpp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/dssc+der\":{\"source\":\"iana\",\"extensions\":[\"dssc\"]},\"application/dssc+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xdssc\"]},\"application/dvcs\":{\"source\":\"iana\"},\"application/ecmascript\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"es\",\"ecma\"]},\"application/edi-consent\":{\"source\":\"iana\"},\"application/edi-x12\":{\"source\":\"iana\",\"compressible\":false},\"application/edifact\":{\"source\":\"iana\",\"compressible\":false},\"application/efi\":{\"source\":\"iana\"},\"application/elm+json\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true},\"application/elm+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.cap+xml\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true},\"application/emergencycalldata.comment+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.control+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.deviceinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.ecall.msd\":{\"source\":\"iana\"},\"application/emergencycalldata.providerinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.serviceinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.subscriberinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.veds+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emma+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"emma\"]},\"application/emotionml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"emotionml\"]},\"application/encaprtp\":{\"source\":\"iana\"},\"application/epp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/epub+zip\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"epub\"]},\"application/eshop\":{\"source\":\"iana\"},\"application/exi\":{\"source\":\"iana\",\"extensions\":[\"exi\"]},\"application/expect-ct-report+json\":{\"source\":\"iana\",\"compressible\":true},\"application/express\":{\"source\":\"iana\",\"extensions\":[\"exp\"]},\"application/fastinfoset\":{\"source\":\"iana\"},\"application/fastsoap\":{\"source\":\"iana\"},\"application/fdt+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"fdt\"]},\"application/fhir+json\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true},\"application/fhir+xml\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true},\"application/fido.trusted-apps+json\":{\"compressible\":true},\"application/fits\":{\"source\":\"iana\"},\"application/flexfec\":{\"source\":\"iana\"},\"application/font-sfnt\":{\"source\":\"iana\"},\"application/font-tdpfr\":{\"source\":\"iana\",\"extensions\":[\"pfr\"]},\"application/font-woff\":{\"source\":\"iana\",\"compressible\":false},\"application/framework-attributes+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/geo+json\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"geojson\"]},\"application/geo+json-seq\":{\"source\":\"iana\"},\"application/geopackage+sqlite3\":{\"source\":\"iana\"},\"application/geoxacml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/gltf-buffer\":{\"source\":\"iana\"},\"application/gml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"gml\"]},\"application/gpx+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"gpx\"]},\"application/gxf\":{\"source\":\"apache\",\"extensions\":[\"gxf\"]},\"application/gzip\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"gz\"]},\"application/h224\":{\"source\":\"iana\"},\"application/held+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/hjson\":{\"extensions\":[\"hjson\"]},\"application/http\":{\"source\":\"iana\"},\"application/hyperstudio\":{\"source\":\"iana\",\"extensions\":[\"stk\"]},\"application/ibe-key-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/ibe-pkg-reply+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/ibe-pp-data\":{\"source\":\"iana\"},\"application/iges\":{\"source\":\"iana\"},\"application/im-iscomposing+xml\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true},\"application/index\":{\"source\":\"iana\"},\"application/index.cmd\":{\"source\":\"iana\"},\"application/index.obj\":{\"source\":\"iana\"},\"application/index.response\":{\"source\":\"iana\"},\"application/index.vnd\":{\"source\":\"iana\"},\"application/inkml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ink\",\"inkml\"]},\"application/iotp\":{\"source\":\"iana\"},\"application/ipfix\":{\"source\":\"iana\",\"extensions\":[\"ipfix\"]},\"application/ipp\":{\"source\":\"iana\"},\"application/isup\":{\"source\":\"iana\"},\"application/its+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"its\"]},\"application/java-archive\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"jar\",\"war\",\"ear\"]},\"application/java-serialized-object\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"ser\"]},\"application/java-vm\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"class\"]},\"application/javascript\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"js\",\"mjs\"]},\"application/jf2feed+json\":{\"source\":\"iana\",\"compressible\":true},\"application/jose\":{\"source\":\"iana\"},\"application/jose+json\":{\"source\":\"iana\",\"compressible\":true},\"application/jrd+json\":{\"source\":\"iana\",\"compressible\":true},\"application/jscalendar+json\":{\"source\":\"iana\",\"compressible\":true},\"application/json\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"json\",\"map\"]},\"application/json-patch+json\":{\"source\":\"iana\",\"compressible\":true},\"application/json-seq\":{\"source\":\"iana\"},\"application/json5\":{\"extensions\":[\"json5\"]},\"application/jsonml+json\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"jsonml\"]},\"application/jwk+json\":{\"source\":\"iana\",\"compressible\":true},\"application/jwk-set+json\":{\"source\":\"iana\",\"compressible\":true},\"application/jwt\":{\"source\":\"iana\"},\"application/kpml-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/kpml-response+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/ld+json\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"jsonld\"]},\"application/lgr+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"lgr\"]},\"application/link-format\":{\"source\":\"iana\"},\"application/load-control+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/lost+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"lostxml\"]},\"application/lostsync+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/lpf+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/lxf\":{\"source\":\"iana\"},\"application/mac-binhex40\":{\"source\":\"iana\",\"extensions\":[\"hqx\"]},\"application/mac-compactpro\":{\"source\":\"apache\",\"extensions\":[\"cpt\"]},\"application/macwriteii\":{\"source\":\"iana\"},\"application/mads+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mads\"]},\"application/manifest+json\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"webmanifest\"]},\"application/marc\":{\"source\":\"iana\",\"extensions\":[\"mrc\"]},\"application/marcxml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mrcx\"]},\"application/mathematica\":{\"source\":\"iana\",\"extensions\":[\"ma\",\"nb\",\"mb\"]},\"application/mathml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mathml\"]},\"application/mathml-content+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mathml-presentation+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-associated-procedure-description+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-deregister+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-envelope+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-msk+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-msk-response+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-protection-description+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-reception-report+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-register+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-register-response+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-schedule+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-user-service-description+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbox\":{\"source\":\"iana\",\"extensions\":[\"mbox\"]},\"application/media-policy-dataset+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mpf\"]},\"application/media_control+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mediaservercontrol+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mscml\"]},\"application/merge-patch+json\":{\"source\":\"iana\",\"compressible\":true},\"application/metalink+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"metalink\"]},\"application/metalink4+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"meta4\"]},\"application/mets+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mets\"]},\"application/mf4\":{\"source\":\"iana\"},\"application/mikey\":{\"source\":\"iana\"},\"application/mipc\":{\"source\":\"iana\"},\"application/missing-blocks+cbor-seq\":{\"source\":\"iana\"},\"application/mmt-aei+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"maei\"]},\"application/mmt-usd+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"musd\"]},\"application/mods+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mods\"]},\"application/moss-keys\":{\"source\":\"iana\"},\"application/moss-signature\":{\"source\":\"iana\"},\"application/mosskey-data\":{\"source\":\"iana\"},\"application/mosskey-request\":{\"source\":\"iana\"},\"application/mp21\":{\"source\":\"iana\",\"extensions\":[\"m21\",\"mp21\"]},\"application/mp4\":{\"source\":\"iana\",\"extensions\":[\"mp4s\",\"m4p\"]},\"application/mpeg4-generic\":{\"source\":\"iana\"},\"application/mpeg4-iod\":{\"source\":\"iana\"},\"application/mpeg4-iod-xmt\":{\"source\":\"iana\"},\"application/mrb-consumer+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mrb-publish+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/msc-ivr+xml\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true},\"application/msc-mixer+xml\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true},\"application/msword\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"doc\",\"dot\"]},\"application/mud+json\":{\"source\":\"iana\",\"compressible\":true},\"application/multipart-core\":{\"source\":\"iana\"},\"application/mxf\":{\"source\":\"iana\",\"extensions\":[\"mxf\"]},\"application/n-quads\":{\"source\":\"iana\",\"extensions\":[\"nq\"]},\"application/n-triples\":{\"source\":\"iana\",\"extensions\":[\"nt\"]},\"application/nasdata\":{\"source\":\"iana\"},\"application/news-checkgroups\":{\"source\":\"iana\",\"charset\":\"US-ASCII\"},\"application/news-groupinfo\":{\"source\":\"iana\",\"charset\":\"US-ASCII\"},\"application/news-transmission\":{\"source\":\"iana\"},\"application/nlsml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/node\":{\"source\":\"iana\",\"extensions\":[\"cjs\"]},\"application/nss\":{\"source\":\"iana\"},\"application/oauth-authz-req+jwt\":{\"source\":\"iana\"},\"application/oblivious-dns-message\":{\"source\":\"iana\"},\"application/ocsp-request\":{\"source\":\"iana\"},\"application/ocsp-response\":{\"source\":\"iana\"},\"application/octet-stream\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"bin\",\"dms\",\"lrf\",\"mar\",\"so\",\"dist\",\"distz\",\"pkg\",\"bpk\",\"dump\",\"elc\",\"deploy\",\"exe\",\"dll\",\"deb\",\"dmg\",\"iso\",\"img\",\"msi\",\"msp\",\"msm\",\"buffer\"]},\"application/oda\":{\"source\":\"iana\",\"extensions\":[\"oda\"]},\"application/odm+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/odx\":{\"source\":\"iana\"},\"application/oebps-package+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"opf\"]},\"application/ogg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"ogx\"]},\"application/omdoc+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"omdoc\"]},\"application/onenote\":{\"source\":\"apache\",\"extensions\":[\"onetoc\",\"onetoc2\",\"onetmp\",\"onepkg\"]},\"application/opc-nodeset+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/oscore\":{\"source\":\"iana\"},\"application/oxps\":{\"source\":\"iana\",\"extensions\":[\"oxps\"]},\"application/p21\":{\"source\":\"iana\"},\"application/p21+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/p2p-overlay+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"relo\"]},\"application/parityfec\":{\"source\":\"iana\"},\"application/passport\":{\"source\":\"iana\"},\"application/patch-ops-error+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xer\"]},\"application/pdf\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"pdf\"]},\"application/pdx\":{\"source\":\"iana\"},\"application/pem-certificate-chain\":{\"source\":\"iana\"},\"application/pgp-encrypted\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"pgp\"]},\"application/pgp-keys\":{\"source\":\"iana\",\"extensions\":[\"asc\"]},\"application/pgp-signature\":{\"source\":\"iana\",\"extensions\":[\"asc\",\"sig\"]},\"application/pics-rules\":{\"source\":\"apache\",\"extensions\":[\"prf\"]},\"application/pidf+xml\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true},\"application/pidf-diff+xml\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true},\"application/pkcs10\":{\"source\":\"iana\",\"extensions\":[\"p10\"]},\"application/pkcs12\":{\"source\":\"iana\"},\"application/pkcs7-mime\":{\"source\":\"iana\",\"extensions\":[\"p7m\",\"p7c\"]},\"application/pkcs7-signature\":{\"source\":\"iana\",\"extensions\":[\"p7s\"]},\"application/pkcs8\":{\"source\":\"iana\",\"extensions\":[\"p8\"]},\"application/pkcs8-encrypted\":{\"source\":\"iana\"},\"application/pkix-attr-cert\":{\"source\":\"iana\",\"extensions\":[\"ac\"]},\"application/pkix-cert\":{\"source\":\"iana\",\"extensions\":[\"cer\"]},\"application/pkix-crl\":{\"source\":\"iana\",\"extensions\":[\"crl\"]},\"application/pkix-pkipath\":{\"source\":\"iana\",\"extensions\":[\"pkipath\"]},\"application/pkixcmp\":{\"source\":\"iana\",\"extensions\":[\"pki\"]},\"application/pls+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"pls\"]},\"application/poc-settings+xml\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true},\"application/postscript\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ai\",\"eps\",\"ps\"]},\"application/ppsp-tracker+json\":{\"source\":\"iana\",\"compressible\":true},\"application/problem+json\":{\"source\":\"iana\",\"compressible\":true},\"application/problem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/provenance+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"provx\"]},\"application/prs.alvestrand.titrax-sheet\":{\"source\":\"iana\"},\"application/prs.cww\":{\"source\":\"iana\",\"extensions\":[\"cww\"]},\"application/prs.cyn\":{\"source\":\"iana\",\"charset\":\"7-BIT\"},\"application/prs.hpub+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/prs.nprend\":{\"source\":\"iana\"},\"application/prs.plucker\":{\"source\":\"iana\"},\"application/prs.rdf-xml-crypt\":{\"source\":\"iana\"},\"application/prs.xsf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/pskc+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"pskcxml\"]},\"application/pvd+json\":{\"source\":\"iana\",\"compressible\":true},\"application/qsig\":{\"source\":\"iana\"},\"application/raml+yaml\":{\"compressible\":true,\"extensions\":[\"raml\"]},\"application/raptorfec\":{\"source\":\"iana\"},\"application/rdap+json\":{\"source\":\"iana\",\"compressible\":true},\"application/rdf+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rdf\",\"owl\"]},\"application/reginfo+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rif\"]},\"application/relax-ng-compact-syntax\":{\"source\":\"iana\",\"extensions\":[\"rnc\"]},\"application/remote-printing\":{\"source\":\"iana\"},\"application/reputon+json\":{\"source\":\"iana\",\"compressible\":true},\"application/resource-lists+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rl\"]},\"application/resource-lists-diff+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rld\"]},\"application/rfc+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/riscos\":{\"source\":\"iana\"},\"application/rlmi+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/rls-services+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rs\"]},\"application/route-apd+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rapd\"]},\"application/route-s-tsid+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"sls\"]},\"application/route-usd+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rusd\"]},\"application/rpki-ghostbusters\":{\"source\":\"iana\",\"extensions\":[\"gbr\"]},\"application/rpki-manifest\":{\"source\":\"iana\",\"extensions\":[\"mft\"]},\"application/rpki-publication\":{\"source\":\"iana\"},\"application/rpki-roa\":{\"source\":\"iana\",\"extensions\":[\"roa\"]},\"application/rpki-updown\":{\"source\":\"iana\"},\"application/rsd+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"rsd\"]},\"application/rss+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"rss\"]},\"application/rtf\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rtf\"]},\"application/rtploopback\":{\"source\":\"iana\"},\"application/rtx\":{\"source\":\"iana\"},\"application/samlassertion+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/samlmetadata+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/sarif+json\":{\"source\":\"iana\",\"compressible\":true},\"application/sarif-external-properties+json\":{\"source\":\"iana\",\"compressible\":true},\"application/sbe\":{\"source\":\"iana\"},\"application/sbml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"sbml\"]},\"application/scaip+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/scim+json\":{\"source\":\"iana\",\"compressible\":true},\"application/scvp-cv-request\":{\"source\":\"iana\",\"extensions\":[\"scq\"]},\"application/scvp-cv-response\":{\"source\":\"iana\",\"extensions\":[\"scs\"]},\"application/scvp-vp-request\":{\"source\":\"iana\",\"extensions\":[\"spq\"]},\"application/scvp-vp-response\":{\"source\":\"iana\",\"extensions\":[\"spp\"]},\"application/sdp\":{\"source\":\"iana\",\"extensions\":[\"sdp\"]},\"application/secevent+jwt\":{\"source\":\"iana\"},\"application/senml+cbor\":{\"source\":\"iana\"},\"application/senml+json\":{\"source\":\"iana\",\"compressible\":true},\"application/senml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"senmlx\"]},\"application/senml-etch+cbor\":{\"source\":\"iana\"},\"application/senml-etch+json\":{\"source\":\"iana\",\"compressible\":true},\"application/senml-exi\":{\"source\":\"iana\"},\"application/sensml+cbor\":{\"source\":\"iana\"},\"application/sensml+json\":{\"source\":\"iana\",\"compressible\":true},\"application/sensml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"sensmlx\"]},\"application/sensml-exi\":{\"source\":\"iana\"},\"application/sep+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/sep-exi\":{\"source\":\"iana\"},\"application/session-info\":{\"source\":\"iana\"},\"application/set-payment\":{\"source\":\"iana\"},\"application/set-payment-initiation\":{\"source\":\"iana\",\"extensions\":[\"setpay\"]},\"application/set-registration\":{\"source\":\"iana\"},\"application/set-registration-initiation\":{\"source\":\"iana\",\"extensions\":[\"setreg\"]},\"application/sgml\":{\"source\":\"iana\"},\"application/sgml-open-catalog\":{\"source\":\"iana\"},\"application/shf+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"shf\"]},\"application/sieve\":{\"source\":\"iana\",\"extensions\":[\"siv\",\"sieve\"]},\"application/simple-filter+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/simple-message-summary\":{\"source\":\"iana\"},\"application/simplesymbolcontainer\":{\"source\":\"iana\"},\"application/sipc\":{\"source\":\"iana\"},\"application/slate\":{\"source\":\"iana\"},\"application/smil\":{\"source\":\"iana\"},\"application/smil+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"smi\",\"smil\"]},\"application/smpte336m\":{\"source\":\"iana\"},\"application/soap+fastinfoset\":{\"source\":\"iana\"},\"application/soap+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/sparql-query\":{\"source\":\"iana\",\"extensions\":[\"rq\"]},\"application/sparql-results+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"srx\"]},\"application/spdx+json\":{\"source\":\"iana\",\"compressible\":true},\"application/spirits-event+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/sql\":{\"source\":\"iana\"},\"application/srgs\":{\"source\":\"iana\",\"extensions\":[\"gram\"]},\"application/srgs+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"grxml\"]},\"application/sru+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"sru\"]},\"application/ssdl+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"ssdl\"]},\"application/ssml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ssml\"]},\"application/stix+json\":{\"source\":\"iana\",\"compressible\":true},\"application/swid+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"swidtag\"]},\"application/tamp-apex-update\":{\"source\":\"iana\"},\"application/tamp-apex-update-confirm\":{\"source\":\"iana\"},\"application/tamp-community-update\":{\"source\":\"iana\"},\"application/tamp-community-update-confirm\":{\"source\":\"iana\"},\"application/tamp-error\":{\"source\":\"iana\"},\"application/tamp-sequence-adjust\":{\"source\":\"iana\"},\"application/tamp-sequence-adjust-confirm\":{\"source\":\"iana\"},\"application/tamp-status-query\":{\"source\":\"iana\"},\"application/tamp-status-response\":{\"source\":\"iana\"},\"application/tamp-update\":{\"source\":\"iana\"},\"application/tamp-update-confirm\":{\"source\":\"iana\"},\"application/tar\":{\"compressible\":true},\"application/taxii+json\":{\"source\":\"iana\",\"compressible\":true},\"application/td+json\":{\"source\":\"iana\",\"compressible\":true},\"application/tei+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"tei\",\"teicorpus\"]},\"application/tetra_isi\":{\"source\":\"iana\"},\"application/thraud+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"tfi\"]},\"application/timestamp-query\":{\"source\":\"iana\"},\"application/timestamp-reply\":{\"source\":\"iana\"},\"application/timestamped-data\":{\"source\":\"iana\",\"extensions\":[\"tsd\"]},\"application/tlsrpt+gzip\":{\"source\":\"iana\"},\"application/tlsrpt+json\":{\"source\":\"iana\",\"compressible\":true},\"application/tnauthlist\":{\"source\":\"iana\"},\"application/token-introspection+jwt\":{\"source\":\"iana\"},\"application/toml\":{\"compressible\":true,\"extensions\":[\"toml\"]},\"application/trickle-ice-sdpfrag\":{\"source\":\"iana\"},\"application/trig\":{\"source\":\"iana\",\"extensions\":[\"trig\"]},\"application/ttml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ttml\"]},\"application/tve-trigger\":{\"source\":\"iana\"},\"application/tzif\":{\"source\":\"iana\"},\"application/tzif-leap\":{\"source\":\"iana\"},\"application/ubjson\":{\"compressible\":false,\"extensions\":[\"ubj\"]},\"application/ulpfec\":{\"source\":\"iana\"},\"application/urc-grpsheet+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/urc-ressheet+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rsheet\"]},\"application/urc-targetdesc+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"td\"]},\"application/urc-uisocketdesc+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vcard+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vcard+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vemmi\":{\"source\":\"iana\"},\"application/vividence.scriptfile\":{\"source\":\"apache\"},\"application/vnd.1000minds.decision-model+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"1km\"]},\"application/vnd.3gpp-prose+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp-prose-pc3ch+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp-v2x-local-service-information\":{\"source\":\"iana\"},\"application/vnd.3gpp.5gnas\":{\"source\":\"iana\"},\"application/vnd.3gpp.access-transfer-events+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.bsf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.gmop+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.gtpc\":{\"source\":\"iana\"},\"application/vnd.3gpp.interworking-data\":{\"source\":\"iana\"},\"application/vnd.3gpp.lpp\":{\"source\":\"iana\"},\"application/vnd.3gpp.mc-signalling-ear\":{\"source\":\"iana\"},\"application/vnd.3gpp.mcdata-affiliation-command+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcdata-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcdata-payload\":{\"source\":\"iana\"},\"application/vnd.3gpp.mcdata-service-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcdata-signalling\":{\"source\":\"iana\"},\"application/vnd.3gpp.mcdata-ue-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcdata-user-profile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-affiliation-command+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-floor-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-location-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-mbms-usage-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-service-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-signed+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-ue-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-ue-init-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-user-profile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-affiliation-command+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-affiliation-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-location-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-mbms-usage-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-service-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-transmission-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-ue-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-user-profile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mid-call+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.ngap\":{\"source\":\"iana\"},\"application/vnd.3gpp.pfcp\":{\"source\":\"iana\"},\"application/vnd.3gpp.pic-bw-large\":{\"source\":\"iana\",\"extensions\":[\"plb\"]},\"application/vnd.3gpp.pic-bw-small\":{\"source\":\"iana\",\"extensions\":[\"psb\"]},\"application/vnd.3gpp.pic-bw-var\":{\"source\":\"iana\",\"extensions\":[\"pvb\"]},\"application/vnd.3gpp.s1ap\":{\"source\":\"iana\"},\"application/vnd.3gpp.sms\":{\"source\":\"iana\"},\"application/vnd.3gpp.sms+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.srvcc-ext+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.srvcc-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.state-and-event-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.ussd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp2.bcmcsinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp2.sms\":{\"source\":\"iana\"},\"application/vnd.3gpp2.tcap\":{\"source\":\"iana\",\"extensions\":[\"tcap\"]},\"application/vnd.3lightssoftware.imagescal\":{\"source\":\"iana\"},\"application/vnd.3m.post-it-notes\":{\"source\":\"iana\",\"extensions\":[\"pwn\"]},\"application/vnd.accpac.simply.aso\":{\"source\":\"iana\",\"extensions\":[\"aso\"]},\"application/vnd.accpac.simply.imp\":{\"source\":\"iana\",\"extensions\":[\"imp\"]},\"application/vnd.acucobol\":{\"source\":\"iana\",\"extensions\":[\"acu\"]},\"application/vnd.acucorp\":{\"source\":\"iana\",\"extensions\":[\"atc\",\"acutc\"]},\"application/vnd.adobe.air-application-installer-package+zip\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"air\"]},\"application/vnd.adobe.flash.movie\":{\"source\":\"iana\"},\"application/vnd.adobe.formscentral.fcdt\":{\"source\":\"iana\",\"extensions\":[\"fcdt\"]},\"application/vnd.adobe.fxp\":{\"source\":\"iana\",\"extensions\":[\"fxp\",\"fxpl\"]},\"application/vnd.adobe.partial-upload\":{\"source\":\"iana\"},\"application/vnd.adobe.xdp+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xdp\"]},\"application/vnd.adobe.xfdf\":{\"source\":\"iana\",\"extensions\":[\"xfdf\"]},\"application/vnd.aether.imp\":{\"source\":\"iana\"},\"application/vnd.afpc.afplinedata\":{\"source\":\"iana\"},\"application/vnd.afpc.afplinedata-pagedef\":{\"source\":\"iana\"},\"application/vnd.afpc.cmoca-cmresource\":{\"source\":\"iana\"},\"application/vnd.afpc.foca-charset\":{\"source\":\"iana\"},\"application/vnd.afpc.foca-codedfont\":{\"source\":\"iana\"},\"application/vnd.afpc.foca-codepage\":{\"source\":\"iana\"},\"application/vnd.afpc.modca\":{\"source\":\"iana\"},\"application/vnd.afpc.modca-cmtable\":{\"source\":\"iana\"},\"application/vnd.afpc.modca-formdef\":{\"source\":\"iana\"},\"application/vnd.afpc.modca-mediummap\":{\"source\":\"iana\"},\"application/vnd.afpc.modca-objectcontainer\":{\"source\":\"iana\"},\"application/vnd.afpc.modca-overlay\":{\"source\":\"iana\"},\"application/vnd.afpc.modca-pagesegment\":{\"source\":\"iana\"},\"application/vnd.age\":{\"source\":\"iana\",\"extensions\":[\"age\"]},\"application/vnd.ah-barcode\":{\"source\":\"iana\"},\"application/vnd.ahead.space\":{\"source\":\"iana\",\"extensions\":[\"ahead\"]},\"application/vnd.airzip.filesecure.azf\":{\"source\":\"iana\",\"extensions\":[\"azf\"]},\"application/vnd.airzip.filesecure.azs\":{\"source\":\"iana\",\"extensions\":[\"azs\"]},\"application/vnd.amadeus+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.amazon.ebook\":{\"source\":\"apache\",\"extensions\":[\"azw\"]},\"application/vnd.amazon.mobi8-ebook\":{\"source\":\"iana\"},\"application/vnd.americandynamics.acc\":{\"source\":\"iana\",\"extensions\":[\"acc\"]},\"application/vnd.amiga.ami\":{\"source\":\"iana\",\"extensions\":[\"ami\"]},\"application/vnd.amundsen.maze+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.android.ota\":{\"source\":\"iana\"},\"application/vnd.android.package-archive\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"apk\"]},\"application/vnd.anki\":{\"source\":\"iana\"},\"application/vnd.anser-web-certificate-issue-initiation\":{\"source\":\"iana\",\"extensions\":[\"cii\"]},\"application/vnd.anser-web-funds-transfer-initiation\":{\"source\":\"apache\",\"extensions\":[\"fti\"]},\"application/vnd.antix.game-component\":{\"source\":\"iana\",\"extensions\":[\"atx\"]},\"application/vnd.apache.arrow.file\":{\"source\":\"iana\"},\"application/vnd.apache.arrow.stream\":{\"source\":\"iana\"},\"application/vnd.apache.thrift.binary\":{\"source\":\"iana\"},\"application/vnd.apache.thrift.compact\":{\"source\":\"iana\"},\"application/vnd.apache.thrift.json\":{\"source\":\"iana\"},\"application/vnd.api+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.aplextor.warrp+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.apothekende.reservation+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.apple.installer+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mpkg\"]},\"application/vnd.apple.keynote\":{\"source\":\"iana\",\"extensions\":[\"key\"]},\"application/vnd.apple.mpegurl\":{\"source\":\"iana\",\"extensions\":[\"m3u8\"]},\"application/vnd.apple.numbers\":{\"source\":\"iana\",\"extensions\":[\"numbers\"]},\"application/vnd.apple.pages\":{\"source\":\"iana\",\"extensions\":[\"pages\"]},\"application/vnd.apple.pkpass\":{\"compressible\":false,\"extensions\":[\"pkpass\"]},\"application/vnd.arastra.swi\":{\"source\":\"iana\"},\"application/vnd.aristanetworks.swi\":{\"source\":\"iana\",\"extensions\":[\"swi\"]},\"application/vnd.artisan+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.artsquare\":{\"source\":\"iana\"},\"application/vnd.astraea-software.iota\":{\"source\":\"iana\",\"extensions\":[\"iota\"]},\"application/vnd.audiograph\":{\"source\":\"iana\",\"extensions\":[\"aep\"]},\"application/vnd.autopackage\":{\"source\":\"iana\"},\"application/vnd.avalon+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.avistar+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.balsamiq.bmml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"bmml\"]},\"application/vnd.balsamiq.bmpr\":{\"source\":\"iana\"},\"application/vnd.banana-accounting\":{\"source\":\"iana\"},\"application/vnd.bbf.usp.error\":{\"source\":\"iana\"},\"application/vnd.bbf.usp.msg\":{\"source\":\"iana\"},\"application/vnd.bbf.usp.msg+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.bekitzur-stech+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.bint.med-content\":{\"source\":\"iana\"},\"application/vnd.biopax.rdf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.blink-idb-value-wrapper\":{\"source\":\"iana\"},\"application/vnd.blueice.multipass\":{\"source\":\"iana\",\"extensions\":[\"mpm\"]},\"application/vnd.bluetooth.ep.oob\":{\"source\":\"iana\"},\"application/vnd.bluetooth.le.oob\":{\"source\":\"iana\"},\"application/vnd.bmi\":{\"source\":\"iana\",\"extensions\":[\"bmi\"]},\"application/vnd.bpf\":{\"source\":\"iana\"},\"application/vnd.bpf3\":{\"source\":\"iana\"},\"application/vnd.businessobjects\":{\"source\":\"iana\",\"extensions\":[\"rep\"]},\"application/vnd.byu.uapi+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.cab-jscript\":{\"source\":\"iana\"},\"application/vnd.canon-cpdl\":{\"source\":\"iana\"},\"application/vnd.canon-lips\":{\"source\":\"iana\"},\"application/vnd.capasystems-pg+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.cendio.thinlinc.clientconf\":{\"source\":\"iana\"},\"application/vnd.century-systems.tcp_stream\":{\"source\":\"iana\"},\"application/vnd.chemdraw+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"cdxml\"]},\"application/vnd.chess-pgn\":{\"source\":\"iana\"},\"application/vnd.chipnuts.karaoke-mmd\":{\"source\":\"iana\",\"extensions\":[\"mmd\"]},\"application/vnd.ciedi\":{\"source\":\"iana\"},\"application/vnd.cinderella\":{\"source\":\"iana\",\"extensions\":[\"cdy\"]},\"application/vnd.cirpack.isdn-ext\":{\"source\":\"iana\"},\"application/vnd.citationstyles.style+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"csl\"]},\"application/vnd.claymore\":{\"source\":\"iana\",\"extensions\":[\"cla\"]},\"application/vnd.cloanto.rp9\":{\"source\":\"iana\",\"extensions\":[\"rp9\"]},\"application/vnd.clonk.c4group\":{\"source\":\"iana\",\"extensions\":[\"c4g\",\"c4d\",\"c4f\",\"c4p\",\"c4u\"]},\"application/vnd.cluetrust.cartomobile-config\":{\"source\":\"iana\",\"extensions\":[\"c11amc\"]},\"application/vnd.cluetrust.cartomobile-config-pkg\":{\"source\":\"iana\",\"extensions\":[\"c11amz\"]},\"application/vnd.coffeescript\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.document\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.document-template\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.presentation\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.presentation-template\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.spreadsheet\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.spreadsheet-template\":{\"source\":\"iana\"},\"application/vnd.collection+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.collection.doc+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.collection.next+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.comicbook+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.comicbook-rar\":{\"source\":\"iana\"},\"application/vnd.commerce-battelle\":{\"source\":\"iana\"},\"application/vnd.commonspace\":{\"source\":\"iana\",\"extensions\":[\"csp\"]},\"application/vnd.contact.cmsg\":{\"source\":\"iana\",\"extensions\":[\"cdbcmsg\"]},\"application/vnd.coreos.ignition+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.cosmocaller\":{\"source\":\"iana\",\"extensions\":[\"cmc\"]},\"application/vnd.crick.clicker\":{\"source\":\"iana\",\"extensions\":[\"clkx\"]},\"application/vnd.crick.clicker.keyboard\":{\"source\":\"iana\",\"extensions\":[\"clkk\"]},\"application/vnd.crick.clicker.palette\":{\"source\":\"iana\",\"extensions\":[\"clkp\"]},\"application/vnd.crick.clicker.template\":{\"source\":\"iana\",\"extensions\":[\"clkt\"]},\"application/vnd.crick.clicker.wordbank\":{\"source\":\"iana\",\"extensions\":[\"clkw\"]},\"application/vnd.criticaltools.wbs+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"wbs\"]},\"application/vnd.cryptii.pipe+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.crypto-shade-file\":{\"source\":\"iana\"},\"application/vnd.cryptomator.encrypted\":{\"source\":\"iana\"},\"application/vnd.cryptomator.vault\":{\"source\":\"iana\"},\"application/vnd.ctc-posml\":{\"source\":\"iana\",\"extensions\":[\"pml\"]},\"application/vnd.ctct.ws+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.cups-pdf\":{\"source\":\"iana\"},\"application/vnd.cups-postscript\":{\"source\":\"iana\"},\"application/vnd.cups-ppd\":{\"source\":\"iana\",\"extensions\":[\"ppd\"]},\"application/vnd.cups-raster\":{\"source\":\"iana\"},\"application/vnd.cups-raw\":{\"source\":\"iana\"},\"application/vnd.curl\":{\"source\":\"iana\"},\"application/vnd.curl.car\":{\"source\":\"apache\",\"extensions\":[\"car\"]},\"application/vnd.curl.pcurl\":{\"source\":\"apache\",\"extensions\":[\"pcurl\"]},\"application/vnd.cyan.dean.root+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.cybank\":{\"source\":\"iana\"},\"application/vnd.cyclonedx+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.cyclonedx+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.d2l.coursepackage1p0+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.d3m-dataset\":{\"source\":\"iana\"},\"application/vnd.d3m-problem\":{\"source\":\"iana\"},\"application/vnd.dart\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"dart\"]},\"application/vnd.data-vision.rdz\":{\"source\":\"iana\",\"extensions\":[\"rdz\"]},\"application/vnd.datapackage+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dataresource+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dbf\":{\"source\":\"iana\",\"extensions\":[\"dbf\"]},\"application/vnd.debian.binary-package\":{\"source\":\"iana\"},\"application/vnd.dece.data\":{\"source\":\"iana\",\"extensions\":[\"uvf\",\"uvvf\",\"uvd\",\"uvvd\"]},\"application/vnd.dece.ttml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"uvt\",\"uvvt\"]},\"application/vnd.dece.unspecified\":{\"source\":\"iana\",\"extensions\":[\"uvx\",\"uvvx\"]},\"application/vnd.dece.zip\":{\"source\":\"iana\",\"extensions\":[\"uvz\",\"uvvz\"]},\"application/vnd.denovo.fcselayout-link\":{\"source\":\"iana\",\"extensions\":[\"fe_launch\"]},\"application/vnd.desmume.movie\":{\"source\":\"iana\"},\"application/vnd.dir-bi.plate-dl-nosuffix\":{\"source\":\"iana\"},\"application/vnd.dm.delegation+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dna\":{\"source\":\"iana\",\"extensions\":[\"dna\"]},\"application/vnd.document+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dolby.mlp\":{\"source\":\"apache\",\"extensions\":[\"mlp\"]},\"application/vnd.dolby.mobile.1\":{\"source\":\"iana\"},\"application/vnd.dolby.mobile.2\":{\"source\":\"iana\"},\"application/vnd.doremir.scorecloud-binary-document\":{\"source\":\"iana\"},\"application/vnd.dpgraph\":{\"source\":\"iana\",\"extensions\":[\"dpg\"]},\"application/vnd.dreamfactory\":{\"source\":\"iana\",\"extensions\":[\"dfac\"]},\"application/vnd.drive+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ds-keypoint\":{\"source\":\"apache\",\"extensions\":[\"kpxx\"]},\"application/vnd.dtg.local\":{\"source\":\"iana\"},\"application/vnd.dtg.local.flash\":{\"source\":\"iana\"},\"application/vnd.dtg.local.html\":{\"source\":\"iana\"},\"application/vnd.dvb.ait\":{\"source\":\"iana\",\"extensions\":[\"ait\"]},\"application/vnd.dvb.dvbisl+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.dvbj\":{\"source\":\"iana\"},\"application/vnd.dvb.esgcontainer\":{\"source\":\"iana\"},\"application/vnd.dvb.ipdcdftnotifaccess\":{\"source\":\"iana\"},\"application/vnd.dvb.ipdcesgaccess\":{\"source\":\"iana\"},\"application/vnd.dvb.ipdcesgaccess2\":{\"source\":\"iana\"},\"application/vnd.dvb.ipdcesgpdd\":{\"source\":\"iana\"},\"application/vnd.dvb.ipdcroaming\":{\"source\":\"iana\"},\"application/vnd.dvb.iptv.alfec-base\":{\"source\":\"iana\"},\"application/vnd.dvb.iptv.alfec-enhancement\":{\"source\":\"iana\"},\"application/vnd.dvb.notif-aggregate-root+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-container+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-generic+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-ia-msglist+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-ia-registration-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-ia-registration-response+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-init+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.pfr\":{\"source\":\"iana\"},\"application/vnd.dvb.service\":{\"source\":\"iana\",\"extensions\":[\"svc\"]},\"application/vnd.dxr\":{\"source\":\"iana\"},\"application/vnd.dynageo\":{\"source\":\"iana\",\"extensions\":[\"geo\"]},\"application/vnd.dzr\":{\"source\":\"iana\"},\"application/vnd.easykaraoke.cdgdownload\":{\"source\":\"iana\"},\"application/vnd.ecdis-update\":{\"source\":\"iana\"},\"application/vnd.ecip.rlp\":{\"source\":\"iana\"},\"application/vnd.eclipse.ditto+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ecowin.chart\":{\"source\":\"iana\",\"extensions\":[\"mag\"]},\"application/vnd.ecowin.filerequest\":{\"source\":\"iana\"},\"application/vnd.ecowin.fileupdate\":{\"source\":\"iana\"},\"application/vnd.ecowin.series\":{\"source\":\"iana\"},\"application/vnd.ecowin.seriesrequest\":{\"source\":\"iana\"},\"application/vnd.ecowin.seriesupdate\":{\"source\":\"iana\"},\"application/vnd.efi.img\":{\"source\":\"iana\"},\"application/vnd.efi.iso\":{\"source\":\"iana\"},\"application/vnd.emclient.accessrequest+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.enliven\":{\"source\":\"iana\",\"extensions\":[\"nml\"]},\"application/vnd.enphase.envoy\":{\"source\":\"iana\"},\"application/vnd.eprints.data+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.epson.esf\":{\"source\":\"iana\",\"extensions\":[\"esf\"]},\"application/vnd.epson.msf\":{\"source\":\"iana\",\"extensions\":[\"msf\"]},\"application/vnd.epson.quickanime\":{\"source\":\"iana\",\"extensions\":[\"qam\"]},\"application/vnd.epson.salt\":{\"source\":\"iana\",\"extensions\":[\"slt\"]},\"application/vnd.epson.ssf\":{\"source\":\"iana\",\"extensions\":[\"ssf\"]},\"application/vnd.ericsson.quickcall\":{\"source\":\"iana\"},\"application/vnd.espass-espass+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.eszigno3+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"es3\",\"et3\"]},\"application/vnd.etsi.aoc+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.asic-e+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.etsi.asic-s+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.etsi.cug+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvcommand+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvdiscovery+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvprofile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvsad-bc+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvsad-cod+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvsad-npvr+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvservice+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvsync+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvueprofile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.mcid+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.mheg5\":{\"source\":\"iana\"},\"application/vnd.etsi.overload-control-policy-dataset+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.pstn+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.sci+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.simservs+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.timestamp-token\":{\"source\":\"iana\"},\"application/vnd.etsi.tsl+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.tsl.der\":{\"source\":\"iana\"},\"application/vnd.eu.kasparian.car+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.eudora.data\":{\"source\":\"iana\"},\"application/vnd.evolv.ecig.profile\":{\"source\":\"iana\"},\"application/vnd.evolv.ecig.settings\":{\"source\":\"iana\"},\"application/vnd.evolv.ecig.theme\":{\"source\":\"iana\"},\"application/vnd.exstream-empower+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.exstream-package\":{\"source\":\"iana\"},\"application/vnd.ezpix-album\":{\"source\":\"iana\",\"extensions\":[\"ez2\"]},\"application/vnd.ezpix-package\":{\"source\":\"iana\",\"extensions\":[\"ez3\"]},\"application/vnd.f-secure.mobile\":{\"source\":\"iana\"},\"application/vnd.familysearch.gedcom+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.fastcopy-disk-image\":{\"source\":\"iana\"},\"application/vnd.fdf\":{\"source\":\"iana\",\"extensions\":[\"fdf\"]},\"application/vnd.fdsn.mseed\":{\"source\":\"iana\",\"extensions\":[\"mseed\"]},\"application/vnd.fdsn.seed\":{\"source\":\"iana\",\"extensions\":[\"seed\",\"dataless\"]},\"application/vnd.ffsns\":{\"source\":\"iana\"},\"application/vnd.ficlab.flb+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.filmit.zfc\":{\"source\":\"iana\"},\"application/vnd.fints\":{\"source\":\"iana\"},\"application/vnd.firemonkeys.cloudcell\":{\"source\":\"iana\"},\"application/vnd.flographit\":{\"source\":\"iana\",\"extensions\":[\"gph\"]},\"application/vnd.fluxtime.clip\":{\"source\":\"iana\",\"extensions\":[\"ftc\"]},\"application/vnd.font-fontforge-sfd\":{\"source\":\"iana\"},\"application/vnd.framemaker\":{\"source\":\"iana\",\"extensions\":[\"fm\",\"frame\",\"maker\",\"book\"]},\"application/vnd.frogans.fnc\":{\"source\":\"iana\",\"extensions\":[\"fnc\"]},\"application/vnd.frogans.ltf\":{\"source\":\"iana\",\"extensions\":[\"ltf\"]},\"application/vnd.fsc.weblaunch\":{\"source\":\"iana\",\"extensions\":[\"fsc\"]},\"application/vnd.fujifilm.fb.docuworks\":{\"source\":\"iana\"},\"application/vnd.fujifilm.fb.docuworks.binder\":{\"source\":\"iana\"},\"application/vnd.fujifilm.fb.docuworks.container\":{\"source\":\"iana\"},\"application/vnd.fujifilm.fb.jfi+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.fujitsu.oasys\":{\"source\":\"iana\",\"extensions\":[\"oas\"]},\"application/vnd.fujitsu.oasys2\":{\"source\":\"iana\",\"extensions\":[\"oa2\"]},\"application/vnd.fujitsu.oasys3\":{\"source\":\"iana\",\"extensions\":[\"oa3\"]},\"application/vnd.fujitsu.oasysgp\":{\"source\":\"iana\",\"extensions\":[\"fg5\"]},\"application/vnd.fujitsu.oasysprs\":{\"source\":\"iana\",\"extensions\":[\"bh2\"]},\"application/vnd.fujixerox.art-ex\":{\"source\":\"iana\"},\"application/vnd.fujixerox.art4\":{\"source\":\"iana\"},\"application/vnd.fujixerox.ddd\":{\"source\":\"iana\",\"extensions\":[\"ddd\"]},\"application/vnd.fujixerox.docuworks\":{\"source\":\"iana\",\"extensions\":[\"xdw\"]},\"application/vnd.fujixerox.docuworks.binder\":{\"source\":\"iana\",\"extensions\":[\"xbd\"]},\"application/vnd.fujixerox.docuworks.container\":{\"source\":\"iana\"},\"application/vnd.fujixerox.hbpl\":{\"source\":\"iana\"},\"application/vnd.fut-misnet\":{\"source\":\"iana\"},\"application/vnd.futoin+cbor\":{\"source\":\"iana\"},\"application/vnd.futoin+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.fuzzysheet\":{\"source\":\"iana\",\"extensions\":[\"fzs\"]},\"application/vnd.genomatix.tuxedo\":{\"source\":\"iana\",\"extensions\":[\"txd\"]},\"application/vnd.gentics.grd+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.geo+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.geocube+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.geogebra.file\":{\"source\":\"iana\",\"extensions\":[\"ggb\"]},\"application/vnd.geogebra.slides\":{\"source\":\"iana\"},\"application/vnd.geogebra.tool\":{\"source\":\"iana\",\"extensions\":[\"ggt\"]},\"application/vnd.geometry-explorer\":{\"source\":\"iana\",\"extensions\":[\"gex\",\"gre\"]},\"application/vnd.geonext\":{\"source\":\"iana\",\"extensions\":[\"gxt\"]},\"application/vnd.geoplan\":{\"source\":\"iana\",\"extensions\":[\"g2w\"]},\"application/vnd.geospace\":{\"source\":\"iana\",\"extensions\":[\"g3w\"]},\"application/vnd.gerber\":{\"source\":\"iana\"},\"application/vnd.globalplatform.card-content-mgt\":{\"source\":\"iana\"},\"application/vnd.globalplatform.card-content-mgt-response\":{\"source\":\"iana\"},\"application/vnd.gmx\":{\"source\":\"iana\",\"extensions\":[\"gmx\"]},\"application/vnd.google-apps.document\":{\"compressible\":false,\"extensions\":[\"gdoc\"]},\"application/vnd.google-apps.presentation\":{\"compressible\":false,\"extensions\":[\"gslides\"]},\"application/vnd.google-apps.spreadsheet\":{\"compressible\":false,\"extensions\":[\"gsheet\"]},\"application/vnd.google-earth.kml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"kml\"]},\"application/vnd.google-earth.kmz\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"kmz\"]},\"application/vnd.gov.sk.e-form+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.gov.sk.e-form+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.gov.sk.xmldatacontainer+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.grafeq\":{\"source\":\"iana\",\"extensions\":[\"gqf\",\"gqs\"]},\"application/vnd.gridmp\":{\"source\":\"iana\"},\"application/vnd.groove-account\":{\"source\":\"iana\",\"extensions\":[\"gac\"]},\"application/vnd.groove-help\":{\"source\":\"iana\",\"extensions\":[\"ghf\"]},\"application/vnd.groove-identity-message\":{\"source\":\"iana\",\"extensions\":[\"gim\"]},\"application/vnd.groove-injector\":{\"source\":\"iana\",\"extensions\":[\"grv\"]},\"application/vnd.groove-tool-message\":{\"source\":\"iana\",\"extensions\":[\"gtm\"]},\"application/vnd.groove-tool-template\":{\"source\":\"iana\",\"extensions\":[\"tpl\"]},\"application/vnd.groove-vcard\":{\"source\":\"iana\",\"extensions\":[\"vcg\"]},\"application/vnd.hal+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hal+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"hal\"]},\"application/vnd.handheld-entertainment+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"zmm\"]},\"application/vnd.hbci\":{\"source\":\"iana\",\"extensions\":[\"hbci\"]},\"application/vnd.hc+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hcl-bireports\":{\"source\":\"iana\"},\"application/vnd.hdt\":{\"source\":\"iana\"},\"application/vnd.heroku+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hhe.lesson-player\":{\"source\":\"iana\",\"extensions\":[\"les\"]},\"application/vnd.hl7cda+xml\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true},\"application/vnd.hl7v2+xml\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true},\"application/vnd.hp-hpgl\":{\"source\":\"iana\",\"extensions\":[\"hpgl\"]},\"application/vnd.hp-hpid\":{\"source\":\"iana\",\"extensions\":[\"hpid\"]},\"application/vnd.hp-hps\":{\"source\":\"iana\",\"extensions\":[\"hps\"]},\"application/vnd.hp-jlyt\":{\"source\":\"iana\",\"extensions\":[\"jlt\"]},\"application/vnd.hp-pcl\":{\"source\":\"iana\",\"extensions\":[\"pcl\"]},\"application/vnd.hp-pclxl\":{\"source\":\"iana\",\"extensions\":[\"pclxl\"]},\"application/vnd.httphone\":{\"source\":\"iana\"},\"application/vnd.hydrostatix.sof-data\":{\"source\":\"iana\",\"extensions\":[\"sfd-hdstx\"]},\"application/vnd.hyper+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hyper-item+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hyperdrive+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hzn-3d-crossword\":{\"source\":\"iana\"},\"application/vnd.ibm.afplinedata\":{\"source\":\"iana\"},\"application/vnd.ibm.electronic-media\":{\"source\":\"iana\"},\"application/vnd.ibm.minipay\":{\"source\":\"iana\",\"extensions\":[\"mpy\"]},\"application/vnd.ibm.modcap\":{\"source\":\"iana\",\"extensions\":[\"afp\",\"listafp\",\"list3820\"]},\"application/vnd.ibm.rights-management\":{\"source\":\"iana\",\"extensions\":[\"irm\"]},\"application/vnd.ibm.secure-container\":{\"source\":\"iana\",\"extensions\":[\"sc\"]},\"application/vnd.iccprofile\":{\"source\":\"iana\",\"extensions\":[\"icc\",\"icm\"]},\"application/vnd.ieee.1905\":{\"source\":\"iana\"},\"application/vnd.igloader\":{\"source\":\"iana\",\"extensions\":[\"igl\"]},\"application/vnd.imagemeter.folder+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.imagemeter.image+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.immervision-ivp\":{\"source\":\"iana\",\"extensions\":[\"ivp\"]},\"application/vnd.immervision-ivu\":{\"source\":\"iana\",\"extensions\":[\"ivu\"]},\"application/vnd.ims.imsccv1p1\":{\"source\":\"iana\"},\"application/vnd.ims.imsccv1p2\":{\"source\":\"iana\"},\"application/vnd.ims.imsccv1p3\":{\"source\":\"iana\"},\"application/vnd.ims.lis.v2.result+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ims.lti.v2.toolconsumerprofile+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ims.lti.v2.toolproxy+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ims.lti.v2.toolproxy.id+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ims.lti.v2.toolsettings+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ims.lti.v2.toolsettings.simple+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.informedcontrol.rms+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.informix-visionary\":{\"source\":\"iana\"},\"application/vnd.infotech.project\":{\"source\":\"iana\"},\"application/vnd.infotech.project+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.innopath.wamp.notification\":{\"source\":\"iana\"},\"application/vnd.insors.igm\":{\"source\":\"iana\",\"extensions\":[\"igm\"]},\"application/vnd.intercon.formnet\":{\"source\":\"iana\",\"extensions\":[\"xpw\",\"xpx\"]},\"application/vnd.intergeo\":{\"source\":\"iana\",\"extensions\":[\"i2g\"]},\"application/vnd.intertrust.digibox\":{\"source\":\"iana\"},\"application/vnd.intertrust.nncp\":{\"source\":\"iana\"},\"application/vnd.intu.qbo\":{\"source\":\"iana\",\"extensions\":[\"qbo\"]},\"application/vnd.intu.qfx\":{\"source\":\"iana\",\"extensions\":[\"qfx\"]},\"application/vnd.iptc.g2.catalogitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.conceptitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.knowledgeitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.newsitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.newsmessage+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.packageitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.planningitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ipunplugged.rcprofile\":{\"source\":\"iana\",\"extensions\":[\"rcprofile\"]},\"application/vnd.irepository.package+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"irp\"]},\"application/vnd.is-xpr\":{\"source\":\"iana\",\"extensions\":[\"xpr\"]},\"application/vnd.isac.fcs\":{\"source\":\"iana\",\"extensions\":[\"fcs\"]},\"application/vnd.iso11783-10+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.jam\":{\"source\":\"iana\",\"extensions\":[\"jam\"]},\"application/vnd.japannet-directory-service\":{\"source\":\"iana\"},\"application/vnd.japannet-jpnstore-wakeup\":{\"source\":\"iana\"},\"application/vnd.japannet-payment-wakeup\":{\"source\":\"iana\"},\"application/vnd.japannet-registration\":{\"source\":\"iana\"},\"application/vnd.japannet-registration-wakeup\":{\"source\":\"iana\"},\"application/vnd.japannet-setstore-wakeup\":{\"source\":\"iana\"},\"application/vnd.japannet-verification\":{\"source\":\"iana\"},\"application/vnd.japannet-verification-wakeup\":{\"source\":\"iana\"},\"application/vnd.jcp.javame.midlet-rms\":{\"source\":\"iana\",\"extensions\":[\"rms\"]},\"application/vnd.jisp\":{\"source\":\"iana\",\"extensions\":[\"jisp\"]},\"application/vnd.joost.joda-archive\":{\"source\":\"iana\",\"extensions\":[\"joda\"]},\"application/vnd.jsk.isdn-ngn\":{\"source\":\"iana\"},\"application/vnd.kahootz\":{\"source\":\"iana\",\"extensions\":[\"ktz\",\"ktr\"]},\"application/vnd.kde.karbon\":{\"source\":\"iana\",\"extensions\":[\"karbon\"]},\"application/vnd.kde.kchart\":{\"source\":\"iana\",\"extensions\":[\"chrt\"]},\"application/vnd.kde.kformula\":{\"source\":\"iana\",\"extensions\":[\"kfo\"]},\"application/vnd.kde.kivio\":{\"source\":\"iana\",\"extensions\":[\"flw\"]},\"application/vnd.kde.kontour\":{\"source\":\"iana\",\"extensions\":[\"kon\"]},\"application/vnd.kde.kpresenter\":{\"source\":\"iana\",\"extensions\":[\"kpr\",\"kpt\"]},\"application/vnd.kde.kspread\":{\"source\":\"iana\",\"extensions\":[\"ksp\"]},\"application/vnd.kde.kword\":{\"source\":\"iana\",\"extensions\":[\"kwd\",\"kwt\"]},\"application/vnd.kenameaapp\":{\"source\":\"iana\",\"extensions\":[\"htke\"]},\"application/vnd.kidspiration\":{\"source\":\"iana\",\"extensions\":[\"kia\"]},\"application/vnd.kinar\":{\"source\":\"iana\",\"extensions\":[\"kne\",\"knp\"]},\"application/vnd.koan\":{\"source\":\"iana\",\"extensions\":[\"skp\",\"skd\",\"skt\",\"skm\"]},\"application/vnd.kodak-descriptor\":{\"source\":\"iana\",\"extensions\":[\"sse\"]},\"application/vnd.las\":{\"source\":\"iana\"},\"application/vnd.las.las+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.las.las+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"lasxml\"]},\"application/vnd.laszip\":{\"source\":\"iana\"},\"application/vnd.leap+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.liberty-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.llamagraphics.life-balance.desktop\":{\"source\":\"iana\",\"extensions\":[\"lbd\"]},\"application/vnd.llamagraphics.life-balance.exchange+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"lbe\"]},\"application/vnd.logipipe.circuit+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.loom\":{\"source\":\"iana\"},\"application/vnd.lotus-1-2-3\":{\"source\":\"iana\",\"extensions\":[\"123\"]},\"application/vnd.lotus-approach\":{\"source\":\"iana\",\"extensions\":[\"apr\"]},\"application/vnd.lotus-freelance\":{\"source\":\"iana\",\"extensions\":[\"pre\"]},\"application/vnd.lotus-notes\":{\"source\":\"iana\",\"extensions\":[\"nsf\"]},\"application/vnd.lotus-organizer\":{\"source\":\"iana\",\"extensions\":[\"org\"]},\"application/vnd.lotus-screencam\":{\"source\":\"iana\",\"extensions\":[\"scm\"]},\"application/vnd.lotus-wordpro\":{\"source\":\"iana\",\"extensions\":[\"lwp\"]},\"application/vnd.macports.portpkg\":{\"source\":\"iana\",\"extensions\":[\"portpkg\"]},\"application/vnd.mapbox-vector-tile\":{\"source\":\"iana\",\"extensions\":[\"mvt\"]},\"application/vnd.marlin.drm.actiontoken+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.marlin.drm.conftoken+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.marlin.drm.license+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.marlin.drm.mdcf\":{\"source\":\"iana\"},\"application/vnd.mason+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.maxar.archive.3tz+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.maxmind.maxmind-db\":{\"source\":\"iana\"},\"application/vnd.mcd\":{\"source\":\"iana\",\"extensions\":[\"mcd\"]},\"application/vnd.medcalcdata\":{\"source\":\"iana\",\"extensions\":[\"mc1\"]},\"application/vnd.mediastation.cdkey\":{\"source\":\"iana\",\"extensions\":[\"cdkey\"]},\"application/vnd.meridian-slingshot\":{\"source\":\"iana\"},\"application/vnd.mfer\":{\"source\":\"iana\",\"extensions\":[\"mwf\"]},\"application/vnd.mfmp\":{\"source\":\"iana\",\"extensions\":[\"mfm\"]},\"application/vnd.micro+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.micrografx.flo\":{\"source\":\"iana\",\"extensions\":[\"flo\"]},\"application/vnd.micrografx.igx\":{\"source\":\"iana\",\"extensions\":[\"igx\"]},\"application/vnd.microsoft.portable-executable\":{\"source\":\"iana\"},\"application/vnd.microsoft.windows.thumbnail-cache\":{\"source\":\"iana\"},\"application/vnd.miele+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.mif\":{\"source\":\"iana\",\"extensions\":[\"mif\"]},\"application/vnd.minisoft-hp3000-save\":{\"source\":\"iana\"},\"application/vnd.mitsubishi.misty-guard.trustweb\":{\"source\":\"iana\"},\"application/vnd.mobius.daf\":{\"source\":\"iana\",\"extensions\":[\"daf\"]},\"application/vnd.mobius.dis\":{\"source\":\"iana\",\"extensions\":[\"dis\"]},\"application/vnd.mobius.mbk\":{\"source\":\"iana\",\"extensions\":[\"mbk\"]},\"application/vnd.mobius.mqy\":{\"source\":\"iana\",\"extensions\":[\"mqy\"]},\"application/vnd.mobius.msl\":{\"source\":\"iana\",\"extensions\":[\"msl\"]},\"application/vnd.mobius.plc\":{\"source\":\"iana\",\"extensions\":[\"plc\"]},\"application/vnd.mobius.txf\":{\"source\":\"iana\",\"extensions\":[\"txf\"]},\"application/vnd.mophun.application\":{\"source\":\"iana\",\"extensions\":[\"mpn\"]},\"application/vnd.mophun.certificate\":{\"source\":\"iana\",\"extensions\":[\"mpc\"]},\"application/vnd.motorola.flexsuite\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.adsi\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.fis\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.gotap\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.kmr\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.ttc\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.wem\":{\"source\":\"iana\"},\"application/vnd.motorola.iprm\":{\"source\":\"iana\"},\"application/vnd.mozilla.xul+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xul\"]},\"application/vnd.ms-3mfdocument\":{\"source\":\"iana\"},\"application/vnd.ms-artgalry\":{\"source\":\"iana\",\"extensions\":[\"cil\"]},\"application/vnd.ms-asf\":{\"source\":\"iana\"},\"application/vnd.ms-cab-compressed\":{\"source\":\"iana\",\"extensions\":[\"cab\"]},\"application/vnd.ms-color.iccprofile\":{\"source\":\"apache\"},\"application/vnd.ms-excel\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"xls\",\"xlm\",\"xla\",\"xlc\",\"xlt\",\"xlw\"]},\"application/vnd.ms-excel.addin.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"xlam\"]},\"application/vnd.ms-excel.sheet.binary.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"xlsb\"]},\"application/vnd.ms-excel.sheet.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"xlsm\"]},\"application/vnd.ms-excel.template.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"xltm\"]},\"application/vnd.ms-fontobject\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"eot\"]},\"application/vnd.ms-htmlhelp\":{\"source\":\"iana\",\"extensions\":[\"chm\"]},\"application/vnd.ms-ims\":{\"source\":\"iana\",\"extensions\":[\"ims\"]},\"application/vnd.ms-lrm\":{\"source\":\"iana\",\"extensions\":[\"lrm\"]},\"application/vnd.ms-office.activex+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ms-officetheme\":{\"source\":\"iana\",\"extensions\":[\"thmx\"]},\"application/vnd.ms-opentype\":{\"source\":\"apache\",\"compressible\":true},\"application/vnd.ms-outlook\":{\"compressible\":false,\"extensions\":[\"msg\"]},\"application/vnd.ms-package.obfuscated-opentype\":{\"source\":\"apache\"},\"application/vnd.ms-pki.seccat\":{\"source\":\"apache\",\"extensions\":[\"cat\"]},\"application/vnd.ms-pki.stl\":{\"source\":\"apache\",\"extensions\":[\"stl\"]},\"application/vnd.ms-playready.initiator+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ms-powerpoint\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"ppt\",\"pps\",\"pot\"]},\"application/vnd.ms-powerpoint.addin.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"ppam\"]},\"application/vnd.ms-powerpoint.presentation.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"pptm\"]},\"application/vnd.ms-powerpoint.slide.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"sldm\"]},\"application/vnd.ms-powerpoint.slideshow.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"ppsm\"]},\"application/vnd.ms-powerpoint.template.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"potm\"]},\"application/vnd.ms-printdevicecapabilities+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ms-printing.printticket+xml\":{\"source\":\"apache\",\"compressible\":true},\"application/vnd.ms-printschematicket+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ms-project\":{\"source\":\"iana\",\"extensions\":[\"mpp\",\"mpt\"]},\"application/vnd.ms-tnef\":{\"source\":\"iana\"},\"application/vnd.ms-windows.devicepairing\":{\"source\":\"iana\"},\"application/vnd.ms-windows.nwprinting.oob\":{\"source\":\"iana\"},\"application/vnd.ms-windows.printerpairing\":{\"source\":\"iana\"},\"application/vnd.ms-windows.wsd.oob\":{\"source\":\"iana\"},\"application/vnd.ms-wmdrm.lic-chlg-req\":{\"source\":\"iana\"},\"application/vnd.ms-wmdrm.lic-resp\":{\"source\":\"iana\"},\"application/vnd.ms-wmdrm.meter-chlg-req\":{\"source\":\"iana\"},\"application/vnd.ms-wmdrm.meter-resp\":{\"source\":\"iana\"},\"application/vnd.ms-word.document.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"docm\"]},\"application/vnd.ms-word.template.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"dotm\"]},\"application/vnd.ms-works\":{\"source\":\"iana\",\"extensions\":[\"wps\",\"wks\",\"wcm\",\"wdb\"]},\"application/vnd.ms-wpl\":{\"source\":\"iana\",\"extensions\":[\"wpl\"]},\"application/vnd.ms-xpsdocument\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"xps\"]},\"application/vnd.msa-disk-image\":{\"source\":\"iana\"},\"application/vnd.mseq\":{\"source\":\"iana\",\"extensions\":[\"mseq\"]},\"application/vnd.msign\":{\"source\":\"iana\"},\"application/vnd.multiad.creator\":{\"source\":\"iana\"},\"application/vnd.multiad.creator.cif\":{\"source\":\"iana\"},\"application/vnd.music-niff\":{\"source\":\"iana\"},\"application/vnd.musician\":{\"source\":\"iana\",\"extensions\":[\"mus\"]},\"application/vnd.muvee.style\":{\"source\":\"iana\",\"extensions\":[\"msty\"]},\"application/vnd.mynfc\":{\"source\":\"iana\",\"extensions\":[\"taglet\"]},\"application/vnd.nacamar.ybrid+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ncd.control\":{\"source\":\"iana\"},\"application/vnd.ncd.reference\":{\"source\":\"iana\"},\"application/vnd.nearst.inv+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nebumind.line\":{\"source\":\"iana\"},\"application/vnd.nervana\":{\"source\":\"iana\"},\"application/vnd.netfpx\":{\"source\":\"iana\"},\"application/vnd.neurolanguage.nlu\":{\"source\":\"iana\",\"extensions\":[\"nlu\"]},\"application/vnd.nimn\":{\"source\":\"iana\"},\"application/vnd.nintendo.nitro.rom\":{\"source\":\"iana\"},\"application/vnd.nintendo.snes.rom\":{\"source\":\"iana\"},\"application/vnd.nitf\":{\"source\":\"iana\",\"extensions\":[\"ntf\",\"nitf\"]},\"application/vnd.noblenet-directory\":{\"source\":\"iana\",\"extensions\":[\"nnd\"]},\"application/vnd.noblenet-sealer\":{\"source\":\"iana\",\"extensions\":[\"nns\"]},\"application/vnd.noblenet-web\":{\"source\":\"iana\",\"extensions\":[\"nnw\"]},\"application/vnd.nokia.catalogs\":{\"source\":\"iana\"},\"application/vnd.nokia.conml+wbxml\":{\"source\":\"iana\"},\"application/vnd.nokia.conml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nokia.iptv.config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nokia.isds-radio-presets\":{\"source\":\"iana\"},\"application/vnd.nokia.landmark+wbxml\":{\"source\":\"iana\"},\"application/vnd.nokia.landmark+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nokia.landmarkcollection+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nokia.n-gage.ac+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ac\"]},\"application/vnd.nokia.n-gage.data\":{\"source\":\"iana\",\"extensions\":[\"ngdat\"]},\"application/vnd.nokia.n-gage.symbian.install\":{\"source\":\"iana\",\"extensions\":[\"n-gage\"]},\"application/vnd.nokia.ncd\":{\"source\":\"iana\"},\"application/vnd.nokia.pcd+wbxml\":{\"source\":\"iana\"},\"application/vnd.nokia.pcd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nokia.radio-preset\":{\"source\":\"iana\",\"extensions\":[\"rpst\"]},\"application/vnd.nokia.radio-presets\":{\"source\":\"iana\",\"extensions\":[\"rpss\"]},\"application/vnd.novadigm.edm\":{\"source\":\"iana\",\"extensions\":[\"edm\"]},\"application/vnd.novadigm.edx\":{\"source\":\"iana\",\"extensions\":[\"edx\"]},\"application/vnd.novadigm.ext\":{\"source\":\"iana\",\"extensions\":[\"ext\"]},\"application/vnd.ntt-local.content-share\":{\"source\":\"iana\"},\"application/vnd.ntt-local.file-transfer\":{\"source\":\"iana\"},\"application/vnd.ntt-local.ogw_remote-access\":{\"source\":\"iana\"},\"application/vnd.ntt-local.sip-ta_remote\":{\"source\":\"iana\"},\"application/vnd.ntt-local.sip-ta_tcp_stream\":{\"source\":\"iana\"},\"application/vnd.oasis.opendocument.chart\":{\"source\":\"iana\",\"extensions\":[\"odc\"]},\"application/vnd.oasis.opendocument.chart-template\":{\"source\":\"iana\",\"extensions\":[\"otc\"]},\"application/vnd.oasis.opendocument.database\":{\"source\":\"iana\",\"extensions\":[\"odb\"]},\"application/vnd.oasis.opendocument.formula\":{\"source\":\"iana\",\"extensions\":[\"odf\"]},\"application/vnd.oasis.opendocument.formula-template\":{\"source\":\"iana\",\"extensions\":[\"odft\"]},\"application/vnd.oasis.opendocument.graphics\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"odg\"]},\"application/vnd.oasis.opendocument.graphics-template\":{\"source\":\"iana\",\"extensions\":[\"otg\"]},\"application/vnd.oasis.opendocument.image\":{\"source\":\"iana\",\"extensions\":[\"odi\"]},\"application/vnd.oasis.opendocument.image-template\":{\"source\":\"iana\",\"extensions\":[\"oti\"]},\"application/vnd.oasis.opendocument.presentation\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"odp\"]},\"application/vnd.oasis.opendocument.presentation-template\":{\"source\":\"iana\",\"extensions\":[\"otp\"]},\"application/vnd.oasis.opendocument.spreadsheet\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"ods\"]},\"application/vnd.oasis.opendocument.spreadsheet-template\":{\"source\":\"iana\",\"extensions\":[\"ots\"]},\"application/vnd.oasis.opendocument.text\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"odt\"]},\"application/vnd.oasis.opendocument.text-master\":{\"source\":\"iana\",\"extensions\":[\"odm\"]},\"application/vnd.oasis.opendocument.text-template\":{\"source\":\"iana\",\"extensions\":[\"ott\"]},\"application/vnd.oasis.opendocument.text-web\":{\"source\":\"iana\",\"extensions\":[\"oth\"]},\"application/vnd.obn\":{\"source\":\"iana\"},\"application/vnd.ocf+cbor\":{\"source\":\"iana\"},\"application/vnd.oci.image.manifest.v1+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oftn.l10n+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.contentaccessdownload+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.contentaccessstreaming+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.cspg-hexbinary\":{\"source\":\"iana\"},\"application/vnd.oipf.dae.svg+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.dae.xhtml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.mippvcontrolmessage+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.pae.gem\":{\"source\":\"iana\"},\"application/vnd.oipf.spdiscovery+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.spdlist+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.ueprofile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.userprofile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.olpc-sugar\":{\"source\":\"iana\",\"extensions\":[\"xo\"]},\"application/vnd.oma-scws-config\":{\"source\":\"iana\"},\"application/vnd.oma-scws-http-request\":{\"source\":\"iana\"},\"application/vnd.oma-scws-http-response\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.associated-procedure-parameter+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.drm-trigger+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.imd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.ltkm\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.notification+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.provisioningtrigger\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.sgboot\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.sgdd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.sgdu\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.simple-symbol-container\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.smartcard-trigger+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.sprov+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.stkm\":{\"source\":\"iana\"},\"application/vnd.oma.cab-address-book+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.cab-feature-handler+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.cab-pcc+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.cab-subs-invite+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.cab-user-prefs+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.dcd\":{\"source\":\"iana\"},\"application/vnd.oma.dcdc\":{\"source\":\"iana\"},\"application/vnd.oma.dd2+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"dd2\"]},\"application/vnd.oma.drm.risd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.group-usage-list+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.lwm2m+cbor\":{\"source\":\"iana\"},\"application/vnd.oma.lwm2m+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.lwm2m+tlv\":{\"source\":\"iana\"},\"application/vnd.oma.pal+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.poc.detailed-progress-report+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.poc.final-report+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.poc.groups+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.poc.invocation-descriptor+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.poc.optimized-progress-report+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.push\":{\"source\":\"iana\"},\"application/vnd.oma.scidm.messages+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.xcap-directory+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.omads-email+xml\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true},\"application/vnd.omads-file+xml\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true},\"application/vnd.omads-folder+xml\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true},\"application/vnd.omaloc-supl-init\":{\"source\":\"iana\"},\"application/vnd.onepager\":{\"source\":\"iana\"},\"application/vnd.onepagertamp\":{\"source\":\"iana\"},\"application/vnd.onepagertamx\":{\"source\":\"iana\"},\"application/vnd.onepagertat\":{\"source\":\"iana\"},\"application/vnd.onepagertatp\":{\"source\":\"iana\"},\"application/vnd.onepagertatx\":{\"source\":\"iana\"},\"application/vnd.openblox.game+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"obgx\"]},\"application/vnd.openblox.game-binary\":{\"source\":\"iana\"},\"application/vnd.openeye.oeb\":{\"source\":\"iana\"},\"application/vnd.openofficeorg.extension\":{\"source\":\"apache\",\"extensions\":[\"oxt\"]},\"application/vnd.openstreetmap.data+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"osm\"]},\"application/vnd.opentimestamps.ots\":{\"source\":\"iana\"},\"application/vnd.openxmlformats-officedocument.custom-properties+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.customxmlproperties+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawing+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.chart+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.extended-properties+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.comments+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.presentation\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"pptx\"]},\"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.slide\":{\"source\":\"iana\",\"extensions\":[\"sldx\"]},\"application/vnd.openxmlformats-officedocument.presentationml.slide+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.slideshow\":{\"source\":\"iana\",\"extensions\":[\"ppsx\"]},\"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.tags+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.template\":{\"source\":\"iana\",\"extensions\":[\"potx\"]},\"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"xlsx\"]},\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.template\":{\"source\":\"iana\",\"extensions\":[\"xltx\"]},\"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.theme+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.themeoverride+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.vmldrawing\":{\"source\":\"iana\"},\"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.document\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"docx\"]},\"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.template\":{\"source\":\"iana\",\"extensions\":[\"dotx\"]},\"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-package.core-properties+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-package.relationships+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oracle.resource+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.orange.indata\":{\"source\":\"iana\"},\"application/vnd.osa.netdeploy\":{\"source\":\"iana\"},\"application/vnd.osgeo.mapguide.package\":{\"source\":\"iana\",\"extensions\":[\"mgp\"]},\"application/vnd.osgi.bundle\":{\"source\":\"iana\"},\"application/vnd.osgi.dp\":{\"source\":\"iana\",\"extensions\":[\"dp\"]},\"application/vnd.osgi.subsystem\":{\"source\":\"iana\",\"extensions\":[\"esa\"]},\"application/vnd.otps.ct-kip+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oxli.countgraph\":{\"source\":\"iana\"},\"application/vnd.pagerduty+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.palm\":{\"source\":\"iana\",\"extensions\":[\"pdb\",\"pqa\",\"oprc\"]},\"application/vnd.panoply\":{\"source\":\"iana\"},\"application/vnd.paos.xml\":{\"source\":\"iana\"},\"application/vnd.patentdive\":{\"source\":\"iana\"},\"application/vnd.patientecommsdoc\":{\"source\":\"iana\"},\"application/vnd.pawaafile\":{\"source\":\"iana\",\"extensions\":[\"paw\"]},\"application/vnd.pcos\":{\"source\":\"iana\"},\"application/vnd.pg.format\":{\"source\":\"iana\",\"extensions\":[\"str\"]},\"application/vnd.pg.osasli\":{\"source\":\"iana\",\"extensions\":[\"ei6\"]},\"application/vnd.piaccess.application-licence\":{\"source\":\"iana\"},\"application/vnd.picsel\":{\"source\":\"iana\",\"extensions\":[\"efif\"]},\"application/vnd.pmi.widget\":{\"source\":\"iana\",\"extensions\":[\"wg\"]},\"application/vnd.poc.group-advertisement+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.pocketlearn\":{\"source\":\"iana\",\"extensions\":[\"plf\"]},\"application/vnd.powerbuilder6\":{\"source\":\"iana\",\"extensions\":[\"pbd\"]},\"application/vnd.powerbuilder6-s\":{\"source\":\"iana\"},\"application/vnd.powerbuilder7\":{\"source\":\"iana\"},\"application/vnd.powerbuilder7-s\":{\"source\":\"iana\"},\"application/vnd.powerbuilder75\":{\"source\":\"iana\"},\"application/vnd.powerbuilder75-s\":{\"source\":\"iana\"},\"application/vnd.preminet\":{\"source\":\"iana\"},\"application/vnd.previewsystems.box\":{\"source\":\"iana\",\"extensions\":[\"box\"]},\"application/vnd.proteus.magazine\":{\"source\":\"iana\",\"extensions\":[\"mgz\"]},\"application/vnd.psfs\":{\"source\":\"iana\"},\"application/vnd.publishare-delta-tree\":{\"source\":\"iana\",\"extensions\":[\"qps\"]},\"application/vnd.pvi.ptid1\":{\"source\":\"iana\",\"extensions\":[\"ptid\"]},\"application/vnd.pwg-multiplexed\":{\"source\":\"iana\"},\"application/vnd.pwg-xhtml-print+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.qualcomm.brew-app-res\":{\"source\":\"iana\"},\"application/vnd.quarantainenet\":{\"source\":\"iana\"},\"application/vnd.quark.quarkxpress\":{\"source\":\"iana\",\"extensions\":[\"qxd\",\"qxt\",\"qwd\",\"qwt\",\"qxl\",\"qxb\"]},\"application/vnd.quobject-quoxdocument\":{\"source\":\"iana\"},\"application/vnd.radisys.moml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-audit+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-audit-conf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-audit-conn+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-audit-dialog+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-audit-stream+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-conf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-base+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-fax-detect+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-fax-sendrecv+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-group+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-speech+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-transform+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.rainstor.data\":{\"source\":\"iana\"},\"application/vnd.rapid\":{\"source\":\"iana\"},\"application/vnd.rar\":{\"source\":\"iana\",\"extensions\":[\"rar\"]},\"application/vnd.realvnc.bed\":{\"source\":\"iana\",\"extensions\":[\"bed\"]},\"application/vnd.recordare.musicxml\":{\"source\":\"iana\",\"extensions\":[\"mxl\"]},\"application/vnd.recordare.musicxml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"musicxml\"]},\"application/vnd.renlearn.rlprint\":{\"source\":\"iana\"},\"application/vnd.resilient.logic\":{\"source\":\"iana\"},\"application/vnd.restful+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.rig.cryptonote\":{\"source\":\"iana\",\"extensions\":[\"cryptonote\"]},\"application/vnd.rim.cod\":{\"source\":\"apache\",\"extensions\":[\"cod\"]},\"application/vnd.rn-realmedia\":{\"source\":\"apache\",\"extensions\":[\"rm\"]},\"application/vnd.rn-realmedia-vbr\":{\"source\":\"apache\",\"extensions\":[\"rmvb\"]},\"application/vnd.route66.link66+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"link66\"]},\"application/vnd.rs-274x\":{\"source\":\"iana\"},\"application/vnd.ruckus.download\":{\"source\":\"iana\"},\"application/vnd.s3sms\":{\"source\":\"iana\"},\"application/vnd.sailingtracker.track\":{\"source\":\"iana\",\"extensions\":[\"st\"]},\"application/vnd.sar\":{\"source\":\"iana\"},\"application/vnd.sbm.cid\":{\"source\":\"iana\"},\"application/vnd.sbm.mid2\":{\"source\":\"iana\"},\"application/vnd.scribus\":{\"source\":\"iana\"},\"application/vnd.sealed.3df\":{\"source\":\"iana\"},\"application/vnd.sealed.csf\":{\"source\":\"iana\"},\"application/vnd.sealed.doc\":{\"source\":\"iana\"},\"application/vnd.sealed.eml\":{\"source\":\"iana\"},\"application/vnd.sealed.mht\":{\"source\":\"iana\"},\"application/vnd.sealed.net\":{\"source\":\"iana\"},\"application/vnd.sealed.ppt\":{\"source\":\"iana\"},\"application/vnd.sealed.tiff\":{\"source\":\"iana\"},\"application/vnd.sealed.xls\":{\"source\":\"iana\"},\"application/vnd.sealedmedia.softseal.html\":{\"source\":\"iana\"},\"application/vnd.sealedmedia.softseal.pdf\":{\"source\":\"iana\"},\"application/vnd.seemail\":{\"source\":\"iana\",\"extensions\":[\"see\"]},\"application/vnd.seis+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.sema\":{\"source\":\"iana\",\"extensions\":[\"sema\"]},\"application/vnd.semd\":{\"source\":\"iana\",\"extensions\":[\"semd\"]},\"application/vnd.semf\":{\"source\":\"iana\",\"extensions\":[\"semf\"]},\"application/vnd.shade-save-file\":{\"source\":\"iana\"},\"application/vnd.shana.informed.formdata\":{\"source\":\"iana\",\"extensions\":[\"ifm\"]},\"application/vnd.shana.informed.formtemplate\":{\"source\":\"iana\",\"extensions\":[\"itp\"]},\"application/vnd.shana.informed.interchange\":{\"source\":\"iana\",\"extensions\":[\"iif\"]},\"application/vnd.shana.informed.package\":{\"source\":\"iana\",\"extensions\":[\"ipk\"]},\"application/vnd.shootproof+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.shopkick+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.shp\":{\"source\":\"iana\"},\"application/vnd.shx\":{\"source\":\"iana\"},\"application/vnd.sigrok.session\":{\"source\":\"iana\"},\"application/vnd.simtech-mindmapper\":{\"source\":\"iana\",\"extensions\":[\"twd\",\"twds\"]},\"application/vnd.siren+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.smaf\":{\"source\":\"iana\",\"extensions\":[\"mmf\"]},\"application/vnd.smart.notebook\":{\"source\":\"iana\"},\"application/vnd.smart.teacher\":{\"source\":\"iana\",\"extensions\":[\"teacher\"]},\"application/vnd.snesdev-page-table\":{\"source\":\"iana\"},\"application/vnd.software602.filler.form+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"fo\"]},\"application/vnd.software602.filler.form-xml-zip\":{\"source\":\"iana\"},\"application/vnd.solent.sdkm+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"sdkm\",\"sdkd\"]},\"application/vnd.spotfire.dxp\":{\"source\":\"iana\",\"extensions\":[\"dxp\"]},\"application/vnd.spotfire.sfs\":{\"source\":\"iana\",\"extensions\":[\"sfs\"]},\"application/vnd.sqlite3\":{\"source\":\"iana\"},\"application/vnd.sss-cod\":{\"source\":\"iana\"},\"application/vnd.sss-dtf\":{\"source\":\"iana\"},\"application/vnd.sss-ntf\":{\"source\":\"iana\"},\"application/vnd.stardivision.calc\":{\"source\":\"apache\",\"extensions\":[\"sdc\"]},\"application/vnd.stardivision.draw\":{\"source\":\"apache\",\"extensions\":[\"sda\"]},\"application/vnd.stardivision.impress\":{\"source\":\"apache\",\"extensions\":[\"sdd\"]},\"application/vnd.stardivision.math\":{\"source\":\"apache\",\"extensions\":[\"smf\"]},\"application/vnd.stardivision.writer\":{\"source\":\"apache\",\"extensions\":[\"sdw\",\"vor\"]},\"application/vnd.stardivision.writer-global\":{\"source\":\"apache\",\"extensions\":[\"sgl\"]},\"application/vnd.stepmania.package\":{\"source\":\"iana\",\"extensions\":[\"smzip\"]},\"application/vnd.stepmania.stepchart\":{\"source\":\"iana\",\"extensions\":[\"sm\"]},\"application/vnd.street-stream\":{\"source\":\"iana\"},\"application/vnd.sun.wadl+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"wadl\"]},\"application/vnd.sun.xml.calc\":{\"source\":\"apache\",\"extensions\":[\"sxc\"]},\"application/vnd.sun.xml.calc.template\":{\"source\":\"apache\",\"extensions\":[\"stc\"]},\"application/vnd.sun.xml.draw\":{\"source\":\"apache\",\"extensions\":[\"sxd\"]},\"application/vnd.sun.xml.draw.template\":{\"source\":\"apache\",\"extensions\":[\"std\"]},\"application/vnd.sun.xml.impress\":{\"source\":\"apache\",\"extensions\":[\"sxi\"]},\"application/vnd.sun.xml.impress.template\":{\"source\":\"apache\",\"extensions\":[\"sti\"]},\"application/vnd.sun.xml.math\":{\"source\":\"apache\",\"extensions\":[\"sxm\"]},\"application/vnd.sun.xml.writer\":{\"source\":\"apache\",\"extensions\":[\"sxw\"]},\"application/vnd.sun.xml.writer.global\":{\"source\":\"apache\",\"extensions\":[\"sxg\"]},\"application/vnd.sun.xml.writer.template\":{\"source\":\"apache\",\"extensions\":[\"stw\"]},\"application/vnd.sus-calendar\":{\"source\":\"iana\",\"extensions\":[\"sus\",\"susp\"]},\"application/vnd.svd\":{\"source\":\"iana\",\"extensions\":[\"svd\"]},\"application/vnd.swiftview-ics\":{\"source\":\"iana\"},\"application/vnd.sycle+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.syft+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.symbian.install\":{\"source\":\"apache\",\"extensions\":[\"sis\",\"sisx\"]},\"application/vnd.syncml+xml\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"xsm\"]},\"application/vnd.syncml.dm+wbxml\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"extensions\":[\"bdm\"]},\"application/vnd.syncml.dm+xml\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"xdm\"]},\"application/vnd.syncml.dm.notification\":{\"source\":\"iana\"},\"application/vnd.syncml.dmddf+wbxml\":{\"source\":\"iana\"},\"application/vnd.syncml.dmddf+xml\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"ddf\"]},\"application/vnd.syncml.dmtnds+wbxml\":{\"source\":\"iana\"},\"application/vnd.syncml.dmtnds+xml\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true},\"application/vnd.syncml.ds.notification\":{\"source\":\"iana\"},\"application/vnd.tableschema+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.tao.intent-module-archive\":{\"source\":\"iana\",\"extensions\":[\"tao\"]},\"application/vnd.tcpdump.pcap\":{\"source\":\"iana\",\"extensions\":[\"pcap\",\"cap\",\"dmp\"]},\"application/vnd.think-cell.ppttc+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.tmd.mediaflex.api+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.tml\":{\"source\":\"iana\"},\"application/vnd.tmobile-livetv\":{\"source\":\"iana\",\"extensions\":[\"tmo\"]},\"application/vnd.tri.onesource\":{\"source\":\"iana\"},\"application/vnd.trid.tpt\":{\"source\":\"iana\",\"extensions\":[\"tpt\"]},\"application/vnd.triscape.mxs\":{\"source\":\"iana\",\"extensions\":[\"mxs\"]},\"application/vnd.trueapp\":{\"source\":\"iana\",\"extensions\":[\"tra\"]},\"application/vnd.truedoc\":{\"source\":\"iana\"},\"application/vnd.ubisoft.webplayer\":{\"source\":\"iana\"},\"application/vnd.ufdl\":{\"source\":\"iana\",\"extensions\":[\"ufd\",\"ufdl\"]},\"application/vnd.uiq.theme\":{\"source\":\"iana\",\"extensions\":[\"utz\"]},\"application/vnd.umajin\":{\"source\":\"iana\",\"extensions\":[\"umj\"]},\"application/vnd.unity\":{\"source\":\"iana\",\"extensions\":[\"unityweb\"]},\"application/vnd.uoml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"uoml\"]},\"application/vnd.uplanet.alert\":{\"source\":\"iana\"},\"application/vnd.uplanet.alert-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.bearer-choice\":{\"source\":\"iana\"},\"application/vnd.uplanet.bearer-choice-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.cacheop\":{\"source\":\"iana\"},\"application/vnd.uplanet.cacheop-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.channel\":{\"source\":\"iana\"},\"application/vnd.uplanet.channel-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.list\":{\"source\":\"iana\"},\"application/vnd.uplanet.list-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.listcmd\":{\"source\":\"iana\"},\"application/vnd.uplanet.listcmd-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.signal\":{\"source\":\"iana\"},\"application/vnd.uri-map\":{\"source\":\"iana\"},\"application/vnd.valve.source.material\":{\"source\":\"iana\"},\"application/vnd.vcx\":{\"source\":\"iana\",\"extensions\":[\"vcx\"]},\"application/vnd.vd-study\":{\"source\":\"iana\"},\"application/vnd.vectorworks\":{\"source\":\"iana\"},\"application/vnd.vel+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.verimatrix.vcas\":{\"source\":\"iana\"},\"application/vnd.veritone.aion+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.veryant.thin\":{\"source\":\"iana\"},\"application/vnd.ves.encrypted\":{\"source\":\"iana\"},\"application/vnd.vidsoft.vidconference\":{\"source\":\"iana\"},\"application/vnd.visio\":{\"source\":\"iana\",\"extensions\":[\"vsd\",\"vst\",\"vss\",\"vsw\"]},\"application/vnd.visionary\":{\"source\":\"iana\",\"extensions\":[\"vis\"]},\"application/vnd.vividence.scriptfile\":{\"source\":\"iana\"},\"application/vnd.vsf\":{\"source\":\"iana\",\"extensions\":[\"vsf\"]},\"application/vnd.wap.sic\":{\"source\":\"iana\"},\"application/vnd.wap.slc\":{\"source\":\"iana\"},\"application/vnd.wap.wbxml\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"extensions\":[\"wbxml\"]},\"application/vnd.wap.wmlc\":{\"source\":\"iana\",\"extensions\":[\"wmlc\"]},\"application/vnd.wap.wmlscriptc\":{\"source\":\"iana\",\"extensions\":[\"wmlsc\"]},\"application/vnd.webturbo\":{\"source\":\"iana\",\"extensions\":[\"wtb\"]},\"application/vnd.wfa.dpp\":{\"source\":\"iana\"},\"application/vnd.wfa.p2p\":{\"source\":\"iana\"},\"application/vnd.wfa.wsc\":{\"source\":\"iana\"},\"application/vnd.windows.devicepairing\":{\"source\":\"iana\"},\"application/vnd.wmc\":{\"source\":\"iana\"},\"application/vnd.wmf.bootstrap\":{\"source\":\"iana\"},\"application/vnd.wolfram.mathematica\":{\"source\":\"iana\"},\"application/vnd.wolfram.mathematica.package\":{\"source\":\"iana\"},\"application/vnd.wolfram.player\":{\"source\":\"iana\",\"extensions\":[\"nbp\"]},\"application/vnd.wordperfect\":{\"source\":\"iana\",\"extensions\":[\"wpd\"]},\"application/vnd.wqd\":{\"source\":\"iana\",\"extensions\":[\"wqd\"]},\"application/vnd.wrq-hp3000-labelled\":{\"source\":\"iana\"},\"application/vnd.wt.stf\":{\"source\":\"iana\",\"extensions\":[\"stf\"]},\"application/vnd.wv.csp+wbxml\":{\"source\":\"iana\"},\"application/vnd.wv.csp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.wv.ssp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.xacml+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.xara\":{\"source\":\"iana\",\"extensions\":[\"xar\"]},\"application/vnd.xfdl\":{\"source\":\"iana\",\"extensions\":[\"xfdl\"]},\"application/vnd.xfdl.webform\":{\"source\":\"iana\"},\"application/vnd.xmi+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.xmpie.cpkg\":{\"source\":\"iana\"},\"application/vnd.xmpie.dpkg\":{\"source\":\"iana\"},\"application/vnd.xmpie.plan\":{\"source\":\"iana\"},\"application/vnd.xmpie.ppkg\":{\"source\":\"iana\"},\"application/vnd.xmpie.xlim\":{\"source\":\"iana\"},\"application/vnd.yamaha.hv-dic\":{\"source\":\"iana\",\"extensions\":[\"hvd\"]},\"application/vnd.yamaha.hv-script\":{\"source\":\"iana\",\"extensions\":[\"hvs\"]},\"application/vnd.yamaha.hv-voice\":{\"source\":\"iana\",\"extensions\":[\"hvp\"]},\"application/vnd.yamaha.openscoreformat\":{\"source\":\"iana\",\"extensions\":[\"osf\"]},\"application/vnd.yamaha.openscoreformat.osfpvg+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"osfpvg\"]},\"application/vnd.yamaha.remote-setup\":{\"source\":\"iana\"},\"application/vnd.yamaha.smaf-audio\":{\"source\":\"iana\",\"extensions\":[\"saf\"]},\"application/vnd.yamaha.smaf-phrase\":{\"source\":\"iana\",\"extensions\":[\"spf\"]},\"application/vnd.yamaha.through-ngn\":{\"source\":\"iana\"},\"application/vnd.yamaha.tunnel-udpencap\":{\"source\":\"iana\"},\"application/vnd.yaoweme\":{\"source\":\"iana\"},\"application/vnd.yellowriver-custom-menu\":{\"source\":\"iana\",\"extensions\":[\"cmp\"]},\"application/vnd.youtube.yt\":{\"source\":\"iana\"},\"application/vnd.zul\":{\"source\":\"iana\",\"extensions\":[\"zir\",\"zirz\"]},\"application/vnd.zzazz.deck+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"zaz\"]},\"application/voicexml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"vxml\"]},\"application/voucher-cms+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vq-rtcpxr\":{\"source\":\"iana\"},\"application/wasm\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"wasm\"]},\"application/watcherinfo+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"wif\"]},\"application/webpush-options+json\":{\"source\":\"iana\",\"compressible\":true},\"application/whoispp-query\":{\"source\":\"iana\"},\"application/whoispp-response\":{\"source\":\"iana\"},\"application/widget\":{\"source\":\"iana\",\"extensions\":[\"wgt\"]},\"application/winhlp\":{\"source\":\"apache\",\"extensions\":[\"hlp\"]},\"application/wita\":{\"source\":\"iana\"},\"application/wordperfect5.1\":{\"source\":\"iana\"},\"application/wsdl+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"wsdl\"]},\"application/wspolicy+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"wspolicy\"]},\"application/x-7z-compressed\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"7z\"]},\"application/x-abiword\":{\"source\":\"apache\",\"extensions\":[\"abw\"]},\"application/x-ace-compressed\":{\"source\":\"apache\",\"extensions\":[\"ace\"]},\"application/x-amf\":{\"source\":\"apache\"},\"application/x-apple-diskimage\":{\"source\":\"apache\",\"extensions\":[\"dmg\"]},\"application/x-arj\":{\"compressible\":false,\"extensions\":[\"arj\"]},\"application/x-authorware-bin\":{\"source\":\"apache\",\"extensions\":[\"aab\",\"x32\",\"u32\",\"vox\"]},\"application/x-authorware-map\":{\"source\":\"apache\",\"extensions\":[\"aam\"]},\"application/x-authorware-seg\":{\"source\":\"apache\",\"extensions\":[\"aas\"]},\"application/x-bcpio\":{\"source\":\"apache\",\"extensions\":[\"bcpio\"]},\"application/x-bdoc\":{\"compressible\":false,\"extensions\":[\"bdoc\"]},\"application/x-bittorrent\":{\"source\":\"apache\",\"extensions\":[\"torrent\"]},\"application/x-blorb\":{\"source\":\"apache\",\"extensions\":[\"blb\",\"blorb\"]},\"application/x-bzip\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"bz\"]},\"application/x-bzip2\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"bz2\",\"boz\"]},\"application/x-cbr\":{\"source\":\"apache\",\"extensions\":[\"cbr\",\"cba\",\"cbt\",\"cbz\",\"cb7\"]},\"application/x-cdlink\":{\"source\":\"apache\",\"extensions\":[\"vcd\"]},\"application/x-cfs-compressed\":{\"source\":\"apache\",\"extensions\":[\"cfs\"]},\"application/x-chat\":{\"source\":\"apache\",\"extensions\":[\"chat\"]},\"application/x-chess-pgn\":{\"source\":\"apache\",\"extensions\":[\"pgn\"]},\"application/x-chrome-extension\":{\"extensions\":[\"crx\"]},\"application/x-cocoa\":{\"source\":\"nginx\",\"extensions\":[\"cco\"]},\"application/x-compress\":{\"source\":\"apache\"},\"application/x-conference\":{\"source\":\"apache\",\"extensions\":[\"nsc\"]},\"application/x-cpio\":{\"source\":\"apache\",\"extensions\":[\"cpio\"]},\"application/x-csh\":{\"source\":\"apache\",\"extensions\":[\"csh\"]},\"application/x-deb\":{\"compressible\":false},\"application/x-debian-package\":{\"source\":\"apache\",\"extensions\":[\"deb\",\"udeb\"]},\"application/x-dgc-compressed\":{\"source\":\"apache\",\"extensions\":[\"dgc\"]},\"application/x-director\":{\"source\":\"apache\",\"extensions\":[\"dir\",\"dcr\",\"dxr\",\"cst\",\"cct\",\"cxt\",\"w3d\",\"fgd\",\"swa\"]},\"application/x-doom\":{\"source\":\"apache\",\"extensions\":[\"wad\"]},\"application/x-dtbncx+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"ncx\"]},\"application/x-dtbook+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"dtb\"]},\"application/x-dtbresource+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"res\"]},\"application/x-dvi\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"dvi\"]},\"application/x-envoy\":{\"source\":\"apache\",\"extensions\":[\"evy\"]},\"application/x-eva\":{\"source\":\"apache\",\"extensions\":[\"eva\"]},\"application/x-font-bdf\":{\"source\":\"apache\",\"extensions\":[\"bdf\"]},\"application/x-font-dos\":{\"source\":\"apache\"},\"application/x-font-framemaker\":{\"source\":\"apache\"},\"application/x-font-ghostscript\":{\"source\":\"apache\",\"extensions\":[\"gsf\"]},\"application/x-font-libgrx\":{\"source\":\"apache\"},\"application/x-font-linux-psf\":{\"source\":\"apache\",\"extensions\":[\"psf\"]},\"application/x-font-pcf\":{\"source\":\"apache\",\"extensions\":[\"pcf\"]},\"application/x-font-snf\":{\"source\":\"apache\",\"extensions\":[\"snf\"]},\"application/x-font-speedo\":{\"source\":\"apache\"},\"application/x-font-sunos-news\":{\"source\":\"apache\"},\"application/x-font-type1\":{\"source\":\"apache\",\"extensions\":[\"pfa\",\"pfb\",\"pfm\",\"afm\"]},\"application/x-font-vfont\":{\"source\":\"apache\"},\"application/x-freearc\":{\"source\":\"apache\",\"extensions\":[\"arc\"]},\"application/x-futuresplash\":{\"source\":\"apache\",\"extensions\":[\"spl\"]},\"application/x-gca-compressed\":{\"source\":\"apache\",\"extensions\":[\"gca\"]},\"application/x-glulx\":{\"source\":\"apache\",\"extensions\":[\"ulx\"]},\"application/x-gnumeric\":{\"source\":\"apache\",\"extensions\":[\"gnumeric\"]},\"application/x-gramps-xml\":{\"source\":\"apache\",\"extensions\":[\"gramps\"]},\"application/x-gtar\":{\"source\":\"apache\",\"extensions\":[\"gtar\"]},\"application/x-gzip\":{\"source\":\"apache\"},\"application/x-hdf\":{\"source\":\"apache\",\"extensions\":[\"hdf\"]},\"application/x-httpd-php\":{\"compressible\":true,\"extensions\":[\"php\"]},\"application/x-install-instructions\":{\"source\":\"apache\",\"extensions\":[\"install\"]},\"application/x-iso9660-image\":{\"source\":\"apache\",\"extensions\":[\"iso\"]},\"application/x-iwork-keynote-sffkey\":{\"extensions\":[\"key\"]},\"application/x-iwork-numbers-sffnumbers\":{\"extensions\":[\"numbers\"]},\"application/x-iwork-pages-sffpages\":{\"extensions\":[\"pages\"]},\"application/x-java-archive-diff\":{\"source\":\"nginx\",\"extensions\":[\"jardiff\"]},\"application/x-java-jnlp-file\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"jnlp\"]},\"application/x-javascript\":{\"compressible\":true},\"application/x-keepass2\":{\"extensions\":[\"kdbx\"]},\"application/x-latex\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"latex\"]},\"application/x-lua-bytecode\":{\"extensions\":[\"luac\"]},\"application/x-lzh-compressed\":{\"source\":\"apache\",\"extensions\":[\"lzh\",\"lha\"]},\"application/x-makeself\":{\"source\":\"nginx\",\"extensions\":[\"run\"]},\"application/x-mie\":{\"source\":\"apache\",\"extensions\":[\"mie\"]},\"application/x-mobipocket-ebook\":{\"source\":\"apache\",\"extensions\":[\"prc\",\"mobi\"]},\"application/x-mpegurl\":{\"compressible\":false},\"application/x-ms-application\":{\"source\":\"apache\",\"extensions\":[\"application\"]},\"application/x-ms-shortcut\":{\"source\":\"apache\",\"extensions\":[\"lnk\"]},\"application/x-ms-wmd\":{\"source\":\"apache\",\"extensions\":[\"wmd\"]},\"application/x-ms-wmz\":{\"source\":\"apache\",\"extensions\":[\"wmz\"]},\"application/x-ms-xbap\":{\"source\":\"apache\",\"extensions\":[\"xbap\"]},\"application/x-msaccess\":{\"source\":\"apache\",\"extensions\":[\"mdb\"]},\"application/x-msbinder\":{\"source\":\"apache\",\"extensions\":[\"obd\"]},\"application/x-mscardfile\":{\"source\":\"apache\",\"extensions\":[\"crd\"]},\"application/x-msclip\":{\"source\":\"apache\",\"extensions\":[\"clp\"]},\"application/x-msdos-program\":{\"extensions\":[\"exe\"]},\"application/x-msdownload\":{\"source\":\"apache\",\"extensions\":[\"exe\",\"dll\",\"com\",\"bat\",\"msi\"]},\"application/x-msmediaview\":{\"source\":\"apache\",\"extensions\":[\"mvb\",\"m13\",\"m14\"]},\"application/x-msmetafile\":{\"source\":\"apache\",\"extensions\":[\"wmf\",\"wmz\",\"emf\",\"emz\"]},\"application/x-msmoney\":{\"source\":\"apache\",\"extensions\":[\"mny\"]},\"application/x-mspublisher\":{\"source\":\"apache\",\"extensions\":[\"pub\"]},\"application/x-msschedule\":{\"source\":\"apache\",\"extensions\":[\"scd\"]},\"application/x-msterminal\":{\"source\":\"apache\",\"extensions\":[\"trm\"]},\"application/x-mswrite\":{\"source\":\"apache\",\"extensions\":[\"wri\"]},\"application/x-netcdf\":{\"source\":\"apache\",\"extensions\":[\"nc\",\"cdf\"]},\"application/x-ns-proxy-autoconfig\":{\"compressible\":true,\"extensions\":[\"pac\"]},\"application/x-nzb\":{\"source\":\"apache\",\"extensions\":[\"nzb\"]},\"application/x-perl\":{\"source\":\"nginx\",\"extensions\":[\"pl\",\"pm\"]},\"application/x-pilot\":{\"source\":\"nginx\",\"extensions\":[\"prc\",\"pdb\"]},\"application/x-pkcs12\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"p12\",\"pfx\"]},\"application/x-pkcs7-certificates\":{\"source\":\"apache\",\"extensions\":[\"p7b\",\"spc\"]},\"application/x-pkcs7-certreqresp\":{\"source\":\"apache\",\"extensions\":[\"p7r\"]},\"application/x-pki-message\":{\"source\":\"iana\"},\"application/x-rar-compressed\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"rar\"]},\"application/x-redhat-package-manager\":{\"source\":\"nginx\",\"extensions\":[\"rpm\"]},\"application/x-research-info-systems\":{\"source\":\"apache\",\"extensions\":[\"ris\"]},\"application/x-sea\":{\"source\":\"nginx\",\"extensions\":[\"sea\"]},\"application/x-sh\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"sh\"]},\"application/x-shar\":{\"source\":\"apache\",\"extensions\":[\"shar\"]},\"application/x-shockwave-flash\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"swf\"]},\"application/x-silverlight-app\":{\"source\":\"apache\",\"extensions\":[\"xap\"]},\"application/x-sql\":{\"source\":\"apache\",\"extensions\":[\"sql\"]},\"application/x-stuffit\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"sit\"]},\"application/x-stuffitx\":{\"source\":\"apache\",\"extensions\":[\"sitx\"]},\"application/x-subrip\":{\"source\":\"apache\",\"extensions\":[\"srt\"]},\"application/x-sv4cpio\":{\"source\":\"apache\",\"extensions\":[\"sv4cpio\"]},\"application/x-sv4crc\":{\"source\":\"apache\",\"extensions\":[\"sv4crc\"]},\"application/x-t3vm-image\":{\"source\":\"apache\",\"extensions\":[\"t3\"]},\"application/x-tads\":{\"source\":\"apache\",\"extensions\":[\"gam\"]},\"application/x-tar\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"tar\"]},\"application/x-tcl\":{\"source\":\"apache\",\"extensions\":[\"tcl\",\"tk\"]},\"application/x-tex\":{\"source\":\"apache\",\"extensions\":[\"tex\"]},\"application/x-tex-tfm\":{\"source\":\"apache\",\"extensions\":[\"tfm\"]},\"application/x-texinfo\":{\"source\":\"apache\",\"extensions\":[\"texinfo\",\"texi\"]},\"application/x-tgif\":{\"source\":\"apache\",\"extensions\":[\"obj\"]},\"application/x-ustar\":{\"source\":\"apache\",\"extensions\":[\"ustar\"]},\"application/x-virtualbox-hdd\":{\"compressible\":true,\"extensions\":[\"hdd\"]},\"application/x-virtualbox-ova\":{\"compressible\":true,\"extensions\":[\"ova\"]},\"application/x-virtualbox-ovf\":{\"compressible\":true,\"extensions\":[\"ovf\"]},\"application/x-virtualbox-vbox\":{\"compressible\":true,\"extensions\":[\"vbox\"]},\"application/x-virtualbox-vbox-extpack\":{\"compressible\":false,\"extensions\":[\"vbox-extpack\"]},\"application/x-virtualbox-vdi\":{\"compressible\":true,\"extensions\":[\"vdi\"]},\"application/x-virtualbox-vhd\":{\"compressible\":true,\"extensions\":[\"vhd\"]},\"application/x-virtualbox-vmdk\":{\"compressible\":true,\"extensions\":[\"vmdk\"]},\"application/x-wais-source\":{\"source\":\"apache\",\"extensions\":[\"src\"]},\"application/x-web-app-manifest+json\":{\"compressible\":true,\"extensions\":[\"webapp\"]},\"application/x-www-form-urlencoded\":{\"source\":\"iana\",\"compressible\":true},\"application/x-x509-ca-cert\":{\"source\":\"iana\",\"extensions\":[\"der\",\"crt\",\"pem\"]},\"application/x-x509-ca-ra-cert\":{\"source\":\"iana\"},\"application/x-x509-next-ca-cert\":{\"source\":\"iana\"},\"application/x-xfig\":{\"source\":\"apache\",\"extensions\":[\"fig\"]},\"application/x-xliff+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"xlf\"]},\"application/x-xpinstall\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"xpi\"]},\"application/x-xz\":{\"source\":\"apache\",\"extensions\":[\"xz\"]},\"application/x-zmachine\":{\"source\":\"apache\",\"extensions\":[\"z1\",\"z2\",\"z3\",\"z4\",\"z5\",\"z6\",\"z7\",\"z8\"]},\"application/x400-bp\":{\"source\":\"iana\"},\"application/xacml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xaml+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"xaml\"]},\"application/xcap-att+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xav\"]},\"application/xcap-caps+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xca\"]},\"application/xcap-diff+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xdf\"]},\"application/xcap-el+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xel\"]},\"application/xcap-error+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xcap-ns+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xns\"]},\"application/xcon-conference-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xcon-conference-info-diff+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xenc+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xenc\"]},\"application/xhtml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xhtml\",\"xht\"]},\"application/xhtml-voice+xml\":{\"source\":\"apache\",\"compressible\":true},\"application/xliff+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xlf\"]},\"application/xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xml\",\"xsl\",\"xsd\",\"rng\"]},\"application/xml-dtd\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"dtd\"]},\"application/xml-external-parsed-entity\":{\"source\":\"iana\"},\"application/xml-patch+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xmpp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xop+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xop\"]},\"application/xproc+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"xpl\"]},\"application/xslt+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xsl\",\"xslt\"]},\"application/xspf+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"xspf\"]},\"application/xv+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mxml\",\"xhvml\",\"xvml\",\"xvm\"]},\"application/yang\":{\"source\":\"iana\",\"extensions\":[\"yang\"]},\"application/yang-data+json\":{\"source\":\"iana\",\"compressible\":true},\"application/yang-data+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/yang-patch+json\":{\"source\":\"iana\",\"compressible\":true},\"application/yang-patch+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/yin+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"yin\"]},\"application/zip\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"zip\"]},\"application/zlib\":{\"source\":\"iana\"},\"application/zstd\":{\"source\":\"iana\"},\"audio/1d-interleaved-parityfec\":{\"source\":\"iana\"},\"audio/32kadpcm\":{\"source\":\"iana\"},\"audio/3gpp\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"3gpp\"]},\"audio/3gpp2\":{\"source\":\"iana\"},\"audio/aac\":{\"source\":\"iana\"},\"audio/ac3\":{\"source\":\"iana\"},\"audio/adpcm\":{\"source\":\"apache\",\"extensions\":[\"adp\"]},\"audio/amr\":{\"source\":\"iana\",\"extensions\":[\"amr\"]},\"audio/amr-wb\":{\"source\":\"iana\"},\"audio/amr-wb+\":{\"source\":\"iana\"},\"audio/aptx\":{\"source\":\"iana\"},\"audio/asc\":{\"source\":\"iana\"},\"audio/atrac-advanced-lossless\":{\"source\":\"iana\"},\"audio/atrac-x\":{\"source\":\"iana\"},\"audio/atrac3\":{\"source\":\"iana\"},\"audio/basic\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"au\",\"snd\"]},\"audio/bv16\":{\"source\":\"iana\"},\"audio/bv32\":{\"source\":\"iana\"},\"audio/clearmode\":{\"source\":\"iana\"},\"audio/cn\":{\"source\":\"iana\"},\"audio/dat12\":{\"source\":\"iana\"},\"audio/dls\":{\"source\":\"iana\"},\"audio/dsr-es201108\":{\"source\":\"iana\"},\"audio/dsr-es202050\":{\"source\":\"iana\"},\"audio/dsr-es202211\":{\"source\":\"iana\"},\"audio/dsr-es202212\":{\"source\":\"iana\"},\"audio/dv\":{\"source\":\"iana\"},\"audio/dvi4\":{\"source\":\"iana\"},\"audio/eac3\":{\"source\":\"iana\"},\"audio/encaprtp\":{\"source\":\"iana\"},\"audio/evrc\":{\"source\":\"iana\"},\"audio/evrc-qcp\":{\"source\":\"iana\"},\"audio/evrc0\":{\"source\":\"iana\"},\"audio/evrc1\":{\"source\":\"iana\"},\"audio/evrcb\":{\"source\":\"iana\"},\"audio/evrcb0\":{\"source\":\"iana\"},\"audio/evrcb1\":{\"source\":\"iana\"},\"audio/evrcnw\":{\"source\":\"iana\"},\"audio/evrcnw0\":{\"source\":\"iana\"},\"audio/evrcnw1\":{\"source\":\"iana\"},\"audio/evrcwb\":{\"source\":\"iana\"},\"audio/evrcwb0\":{\"source\":\"iana\"},\"audio/evrcwb1\":{\"source\":\"iana\"},\"audio/evs\":{\"source\":\"iana\"},\"audio/flexfec\":{\"source\":\"iana\"},\"audio/fwdred\":{\"source\":\"iana\"},\"audio/g711-0\":{\"source\":\"iana\"},\"audio/g719\":{\"source\":\"iana\"},\"audio/g722\":{\"source\":\"iana\"},\"audio/g7221\":{\"source\":\"iana\"},\"audio/g723\":{\"source\":\"iana\"},\"audio/g726-16\":{\"source\":\"iana\"},\"audio/g726-24\":{\"source\":\"iana\"},\"audio/g726-32\":{\"source\":\"iana\"},\"audio/g726-40\":{\"source\":\"iana\"},\"audio/g728\":{\"source\":\"iana\"},\"audio/g729\":{\"source\":\"iana\"},\"audio/g7291\":{\"source\":\"iana\"},\"audio/g729d\":{\"source\":\"iana\"},\"audio/g729e\":{\"source\":\"iana\"},\"audio/gsm\":{\"source\":\"iana\"},\"audio/gsm-efr\":{\"source\":\"iana\"},\"audio/gsm-hr-08\":{\"source\":\"iana\"},\"audio/ilbc\":{\"source\":\"iana\"},\"audio/ip-mr_v2.5\":{\"source\":\"iana\"},\"audio/isac\":{\"source\":\"apache\"},\"audio/l16\":{\"source\":\"iana\"},\"audio/l20\":{\"source\":\"iana\"},\"audio/l24\":{\"source\":\"iana\",\"compressible\":false},\"audio/l8\":{\"source\":\"iana\"},\"audio/lpc\":{\"source\":\"iana\"},\"audio/melp\":{\"source\":\"iana\"},\"audio/melp1200\":{\"source\":\"iana\"},\"audio/melp2400\":{\"source\":\"iana\"},\"audio/melp600\":{\"source\":\"iana\"},\"audio/mhas\":{\"source\":\"iana\"},\"audio/midi\":{\"source\":\"apache\",\"extensions\":[\"mid\",\"midi\",\"kar\",\"rmi\"]},\"audio/mobile-xmf\":{\"source\":\"iana\",\"extensions\":[\"mxmf\"]},\"audio/mp3\":{\"compressible\":false,\"extensions\":[\"mp3\"]},\"audio/mp4\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"m4a\",\"mp4a\"]},\"audio/mp4a-latm\":{\"source\":\"iana\"},\"audio/mpa\":{\"source\":\"iana\"},\"audio/mpa-robust\":{\"source\":\"iana\"},\"audio/mpeg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"mpga\",\"mp2\",\"mp2a\",\"mp3\",\"m2a\",\"m3a\"]},\"audio/mpeg4-generic\":{\"source\":\"iana\"},\"audio/musepack\":{\"source\":\"apache\"},\"audio/ogg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"oga\",\"ogg\",\"spx\",\"opus\"]},\"audio/opus\":{\"source\":\"iana\"},\"audio/parityfec\":{\"source\":\"iana\"},\"audio/pcma\":{\"source\":\"iana\"},\"audio/pcma-wb\":{\"source\":\"iana\"},\"audio/pcmu\":{\"source\":\"iana\"},\"audio/pcmu-wb\":{\"source\":\"iana\"},\"audio/prs.sid\":{\"source\":\"iana\"},\"audio/qcelp\":{\"source\":\"iana\"},\"audio/raptorfec\":{\"source\":\"iana\"},\"audio/red\":{\"source\":\"iana\"},\"audio/rtp-enc-aescm128\":{\"source\":\"iana\"},\"audio/rtp-midi\":{\"source\":\"iana\"},\"audio/rtploopback\":{\"source\":\"iana\"},\"audio/rtx\":{\"source\":\"iana\"},\"audio/s3m\":{\"source\":\"apache\",\"extensions\":[\"s3m\"]},\"audio/scip\":{\"source\":\"iana\"},\"audio/silk\":{\"source\":\"apache\",\"extensions\":[\"sil\"]},\"audio/smv\":{\"source\":\"iana\"},\"audio/smv-qcp\":{\"source\":\"iana\"},\"audio/smv0\":{\"source\":\"iana\"},\"audio/sofa\":{\"source\":\"iana\"},\"audio/sp-midi\":{\"source\":\"iana\"},\"audio/speex\":{\"source\":\"iana\"},\"audio/t140c\":{\"source\":\"iana\"},\"audio/t38\":{\"source\":\"iana\"},\"audio/telephone-event\":{\"source\":\"iana\"},\"audio/tetra_acelp\":{\"source\":\"iana\"},\"audio/tetra_acelp_bb\":{\"source\":\"iana\"},\"audio/tone\":{\"source\":\"iana\"},\"audio/tsvcis\":{\"source\":\"iana\"},\"audio/uemclip\":{\"source\":\"iana\"},\"audio/ulpfec\":{\"source\":\"iana\"},\"audio/usac\":{\"source\":\"iana\"},\"audio/vdvi\":{\"source\":\"iana\"},\"audio/vmr-wb\":{\"source\":\"iana\"},\"audio/vnd.3gpp.iufp\":{\"source\":\"iana\"},\"audio/vnd.4sb\":{\"source\":\"iana\"},\"audio/vnd.audiokoz\":{\"source\":\"iana\"},\"audio/vnd.celp\":{\"source\":\"iana\"},\"audio/vnd.cisco.nse\":{\"source\":\"iana\"},\"audio/vnd.cmles.radio-events\":{\"source\":\"iana\"},\"audio/vnd.cns.anp1\":{\"source\":\"iana\"},\"audio/vnd.cns.inf1\":{\"source\":\"iana\"},\"audio/vnd.dece.audio\":{\"source\":\"iana\",\"extensions\":[\"uva\",\"uvva\"]},\"audio/vnd.digital-winds\":{\"source\":\"iana\",\"extensions\":[\"eol\"]},\"audio/vnd.dlna.adts\":{\"source\":\"iana\"},\"audio/vnd.dolby.heaac.1\":{\"source\":\"iana\"},\"audio/vnd.dolby.heaac.2\":{\"source\":\"iana\"},\"audio/vnd.dolby.mlp\":{\"source\":\"iana\"},\"audio/vnd.dolby.mps\":{\"source\":\"iana\"},\"audio/vnd.dolby.pl2\":{\"source\":\"iana\"},\"audio/vnd.dolby.pl2x\":{\"source\":\"iana\"},\"audio/vnd.dolby.pl2z\":{\"source\":\"iana\"},\"audio/vnd.dolby.pulse.1\":{\"source\":\"iana\"},\"audio/vnd.dra\":{\"source\":\"iana\",\"extensions\":[\"dra\"]},\"audio/vnd.dts\":{\"source\":\"iana\",\"extensions\":[\"dts\"]},\"audio/vnd.dts.hd\":{\"source\":\"iana\",\"extensions\":[\"dtshd\"]},\"audio/vnd.dts.uhd\":{\"source\":\"iana\"},\"audio/vnd.dvb.file\":{\"source\":\"iana\"},\"audio/vnd.everad.plj\":{\"source\":\"iana\"},\"audio/vnd.hns.audio\":{\"source\":\"iana\"},\"audio/vnd.lucent.voice\":{\"source\":\"iana\",\"extensions\":[\"lvp\"]},\"audio/vnd.ms-playready.media.pya\":{\"source\":\"iana\",\"extensions\":[\"pya\"]},\"audio/vnd.nokia.mobile-xmf\":{\"source\":\"iana\"},\"audio/vnd.nortel.vbk\":{\"source\":\"iana\"},\"audio/vnd.nuera.ecelp4800\":{\"source\":\"iana\",\"extensions\":[\"ecelp4800\"]},\"audio/vnd.nuera.ecelp7470\":{\"source\":\"iana\",\"extensions\":[\"ecelp7470\"]},\"audio/vnd.nuera.ecelp9600\":{\"source\":\"iana\",\"extensions\":[\"ecelp9600\"]},\"audio/vnd.octel.sbc\":{\"source\":\"iana\"},\"audio/vnd.presonus.multitrack\":{\"source\":\"iana\"},\"audio/vnd.qcelp\":{\"source\":\"iana\"},\"audio/vnd.rhetorex.32kadpcm\":{\"source\":\"iana\"},\"audio/vnd.rip\":{\"source\":\"iana\",\"extensions\":[\"rip\"]},\"audio/vnd.rn-realaudio\":{\"compressible\":false},\"audio/vnd.sealedmedia.softseal.mpeg\":{\"source\":\"iana\"},\"audio/vnd.vmx.cvsd\":{\"source\":\"iana\"},\"audio/vnd.wave\":{\"compressible\":false},\"audio/vorbis\":{\"source\":\"iana\",\"compressible\":false},\"audio/vorbis-config\":{\"source\":\"iana\"},\"audio/wav\":{\"compressible\":false,\"extensions\":[\"wav\"]},\"audio/wave\":{\"compressible\":false,\"extensions\":[\"wav\"]},\"audio/webm\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"weba\"]},\"audio/x-aac\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"aac\"]},\"audio/x-aiff\":{\"source\":\"apache\",\"extensions\":[\"aif\",\"aiff\",\"aifc\"]},\"audio/x-caf\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"caf\"]},\"audio/x-flac\":{\"source\":\"apache\",\"extensions\":[\"flac\"]},\"audio/x-m4a\":{\"source\":\"nginx\",\"extensions\":[\"m4a\"]},\"audio/x-matroska\":{\"source\":\"apache\",\"extensions\":[\"mka\"]},\"audio/x-mpegurl\":{\"source\":\"apache\",\"extensions\":[\"m3u\"]},\"audio/x-ms-wax\":{\"source\":\"apache\",\"extensions\":[\"wax\"]},\"audio/x-ms-wma\":{\"source\":\"apache\",\"extensions\":[\"wma\"]},\"audio/x-pn-realaudio\":{\"source\":\"apache\",\"extensions\":[\"ram\",\"ra\"]},\"audio/x-pn-realaudio-plugin\":{\"source\":\"apache\",\"extensions\":[\"rmp\"]},\"audio/x-realaudio\":{\"source\":\"nginx\",\"extensions\":[\"ra\"]},\"audio/x-tta\":{\"source\":\"apache\"},\"audio/x-wav\":{\"source\":\"apache\",\"extensions\":[\"wav\"]},\"audio/xm\":{\"source\":\"apache\",\"extensions\":[\"xm\"]},\"chemical/x-cdx\":{\"source\":\"apache\",\"extensions\":[\"cdx\"]},\"chemical/x-cif\":{\"source\":\"apache\",\"extensions\":[\"cif\"]},\"chemical/x-cmdf\":{\"source\":\"apache\",\"extensions\":[\"cmdf\"]},\"chemical/x-cml\":{\"source\":\"apache\",\"extensions\":[\"cml\"]},\"chemical/x-csml\":{\"source\":\"apache\",\"extensions\":[\"csml\"]},\"chemical/x-pdb\":{\"source\":\"apache\"},\"chemical/x-xyz\":{\"source\":\"apache\",\"extensions\":[\"xyz\"]},\"font/collection\":{\"source\":\"iana\",\"extensions\":[\"ttc\"]},\"font/otf\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"otf\"]},\"font/sfnt\":{\"source\":\"iana\"},\"font/ttf\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ttf\"]},\"font/woff\":{\"source\":\"iana\",\"extensions\":[\"woff\"]},\"font/woff2\":{\"source\":\"iana\",\"extensions\":[\"woff2\"]},\"image/aces\":{\"source\":\"iana\",\"extensions\":[\"exr\"]},\"image/apng\":{\"compressible\":false,\"extensions\":[\"apng\"]},\"image/avci\":{\"source\":\"iana\",\"extensions\":[\"avci\"]},\"image/avcs\":{\"source\":\"iana\",\"extensions\":[\"avcs\"]},\"image/avif\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"avif\"]},\"image/bmp\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"bmp\"]},\"image/cgm\":{\"source\":\"iana\",\"extensions\":[\"cgm\"]},\"image/dicom-rle\":{\"source\":\"iana\",\"extensions\":[\"drle\"]},\"image/emf\":{\"source\":\"iana\",\"extensions\":[\"emf\"]},\"image/fits\":{\"source\":\"iana\",\"extensions\":[\"fits\"]},\"image/g3fax\":{\"source\":\"iana\",\"extensions\":[\"g3\"]},\"image/gif\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"gif\"]},\"image/heic\":{\"source\":\"iana\",\"extensions\":[\"heic\"]},\"image/heic-sequence\":{\"source\":\"iana\",\"extensions\":[\"heics\"]},\"image/heif\":{\"source\":\"iana\",\"extensions\":[\"heif\"]},\"image/heif-sequence\":{\"source\":\"iana\",\"extensions\":[\"heifs\"]},\"image/hej2k\":{\"source\":\"iana\",\"extensions\":[\"hej2\"]},\"image/hsj2\":{\"source\":\"iana\",\"extensions\":[\"hsj2\"]},\"image/ief\":{\"source\":\"iana\",\"extensions\":[\"ief\"]},\"image/jls\":{\"source\":\"iana\",\"extensions\":[\"jls\"]},\"image/jp2\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"jp2\",\"jpg2\"]},\"image/jpeg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"jpeg\",\"jpg\",\"jpe\"]},\"image/jph\":{\"source\":\"iana\",\"extensions\":[\"jph\"]},\"image/jphc\":{\"source\":\"iana\",\"extensions\":[\"jhc\"]},\"image/jpm\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"jpm\"]},\"image/jpx\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"jpx\",\"jpf\"]},\"image/jxr\":{\"source\":\"iana\",\"extensions\":[\"jxr\"]},\"image/jxra\":{\"source\":\"iana\",\"extensions\":[\"jxra\"]},\"image/jxrs\":{\"source\":\"iana\",\"extensions\":[\"jxrs\"]},\"image/jxs\":{\"source\":\"iana\",\"extensions\":[\"jxs\"]},\"image/jxsc\":{\"source\":\"iana\",\"extensions\":[\"jxsc\"]},\"image/jxsi\":{\"source\":\"iana\",\"extensions\":[\"jxsi\"]},\"image/jxss\":{\"source\":\"iana\",\"extensions\":[\"jxss\"]},\"image/ktx\":{\"source\":\"iana\",\"extensions\":[\"ktx\"]},\"image/ktx2\":{\"source\":\"iana\",\"extensions\":[\"ktx2\"]},\"image/naplps\":{\"source\":\"iana\"},\"image/pjpeg\":{\"compressible\":false},\"image/png\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"png\"]},\"image/prs.btif\":{\"source\":\"iana\",\"extensions\":[\"btif\"]},\"image/prs.pti\":{\"source\":\"iana\",\"extensions\":[\"pti\"]},\"image/pwg-raster\":{\"source\":\"iana\"},\"image/sgi\":{\"source\":\"apache\",\"extensions\":[\"sgi\"]},\"image/svg+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"svg\",\"svgz\"]},\"image/t38\":{\"source\":\"iana\",\"extensions\":[\"t38\"]},\"image/tiff\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"tif\",\"tiff\"]},\"image/tiff-fx\":{\"source\":\"iana\",\"extensions\":[\"tfx\"]},\"image/vnd.adobe.photoshop\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"psd\"]},\"image/vnd.airzip.accelerator.azv\":{\"source\":\"iana\",\"extensions\":[\"azv\"]},\"image/vnd.cns.inf2\":{\"source\":\"iana\"},\"image/vnd.dece.graphic\":{\"source\":\"iana\",\"extensions\":[\"uvi\",\"uvvi\",\"uvg\",\"uvvg\"]},\"image/vnd.djvu\":{\"source\":\"iana\",\"extensions\":[\"djvu\",\"djv\"]},\"image/vnd.dvb.subtitle\":{\"source\":\"iana\",\"extensions\":[\"sub\"]},\"image/vnd.dwg\":{\"source\":\"iana\",\"extensions\":[\"dwg\"]},\"image/vnd.dxf\":{\"source\":\"iana\",\"extensions\":[\"dxf\"]},\"image/vnd.fastbidsheet\":{\"source\":\"iana\",\"extensions\":[\"fbs\"]},\"image/vnd.fpx\":{\"source\":\"iana\",\"extensions\":[\"fpx\"]},\"image/vnd.fst\":{\"source\":\"iana\",\"extensions\":[\"fst\"]},\"image/vnd.fujixerox.edmics-mmr\":{\"source\":\"iana\",\"extensions\":[\"mmr\"]},\"image/vnd.fujixerox.edmics-rlc\":{\"source\":\"iana\",\"extensions\":[\"rlc\"]},\"image/vnd.globalgraphics.pgb\":{\"source\":\"iana\"},\"image/vnd.microsoft.icon\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ico\"]},\"image/vnd.mix\":{\"source\":\"iana\"},\"image/vnd.mozilla.apng\":{\"source\":\"iana\"},\"image/vnd.ms-dds\":{\"compressible\":true,\"extensions\":[\"dds\"]},\"image/vnd.ms-modi\":{\"source\":\"iana\",\"extensions\":[\"mdi\"]},\"image/vnd.ms-photo\":{\"source\":\"apache\",\"extensions\":[\"wdp\"]},\"image/vnd.net-fpx\":{\"source\":\"iana\",\"extensions\":[\"npx\"]},\"image/vnd.pco.b16\":{\"source\":\"iana\",\"extensions\":[\"b16\"]},\"image/vnd.radiance\":{\"source\":\"iana\"},\"image/vnd.sealed.png\":{\"source\":\"iana\"},\"image/vnd.sealedmedia.softseal.gif\":{\"source\":\"iana\"},\"image/vnd.sealedmedia.softseal.jpg\":{\"source\":\"iana\"},\"image/vnd.svf\":{\"source\":\"iana\"},\"image/vnd.tencent.tap\":{\"source\":\"iana\",\"extensions\":[\"tap\"]},\"image/vnd.valve.source.texture\":{\"source\":\"iana\",\"extensions\":[\"vtf\"]},\"image/vnd.wap.wbmp\":{\"source\":\"iana\",\"extensions\":[\"wbmp\"]},\"image/vnd.xiff\":{\"source\":\"iana\",\"extensions\":[\"xif\"]},\"image/vnd.zbrush.pcx\":{\"source\":\"iana\",\"extensions\":[\"pcx\"]},\"image/webp\":{\"source\":\"apache\",\"extensions\":[\"webp\"]},\"image/wmf\":{\"source\":\"iana\",\"extensions\":[\"wmf\"]},\"image/x-3ds\":{\"source\":\"apache\",\"extensions\":[\"3ds\"]},\"image/x-cmu-raster\":{\"source\":\"apache\",\"extensions\":[\"ras\"]},\"image/x-cmx\":{\"source\":\"apache\",\"extensions\":[\"cmx\"]},\"image/x-freehand\":{\"source\":\"apache\",\"extensions\":[\"fh\",\"fhc\",\"fh4\",\"fh5\",\"fh7\"]},\"image/x-icon\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"ico\"]},\"image/x-jng\":{\"source\":\"nginx\",\"extensions\":[\"jng\"]},\"image/x-mrsid-image\":{\"source\":\"apache\",\"extensions\":[\"sid\"]},\"image/x-ms-bmp\":{\"source\":\"nginx\",\"compressible\":true,\"extensions\":[\"bmp\"]},\"image/x-pcx\":{\"source\":\"apache\",\"extensions\":[\"pcx\"]},\"image/x-pict\":{\"source\":\"apache\",\"extensions\":[\"pic\",\"pct\"]},\"image/x-portable-anymap\":{\"source\":\"apache\",\"extensions\":[\"pnm\"]},\"image/x-portable-bitmap\":{\"source\":\"apache\",\"extensions\":[\"pbm\"]},\"image/x-portable-graymap\":{\"source\":\"apache\",\"extensions\":[\"pgm\"]},\"image/x-portable-pixmap\":{\"source\":\"apache\",\"extensions\":[\"ppm\"]},\"image/x-rgb\":{\"source\":\"apache\",\"extensions\":[\"rgb\"]},\"image/x-tga\":{\"source\":\"apache\",\"extensions\":[\"tga\"]},\"image/x-xbitmap\":{\"source\":\"apache\",\"extensions\":[\"xbm\"]},\"image/x-xcf\":{\"compressible\":false},\"image/x-xpixmap\":{\"source\":\"apache\",\"extensions\":[\"xpm\"]},\"image/x-xwindowdump\":{\"source\":\"apache\",\"extensions\":[\"xwd\"]},\"message/cpim\":{\"source\":\"iana\"},\"message/delivery-status\":{\"source\":\"iana\"},\"message/disposition-notification\":{\"source\":\"iana\",\"extensions\":[\"disposition-notification\"]},\"message/external-body\":{\"source\":\"iana\"},\"message/feedback-report\":{\"source\":\"iana\"},\"message/global\":{\"source\":\"iana\",\"extensions\":[\"u8msg\"]},\"message/global-delivery-status\":{\"source\":\"iana\",\"extensions\":[\"u8dsn\"]},\"message/global-disposition-notification\":{\"source\":\"iana\",\"extensions\":[\"u8mdn\"]},\"message/global-headers\":{\"source\":\"iana\",\"extensions\":[\"u8hdr\"]},\"message/http\":{\"source\":\"iana\",\"compressible\":false},\"message/imdn+xml\":{\"source\":\"iana\",\"compressible\":true},\"message/news\":{\"source\":\"iana\"},\"message/partial\":{\"source\":\"iana\",\"compressible\":false},\"message/rfc822\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"eml\",\"mime\"]},\"message/s-http\":{\"source\":\"iana\"},\"message/sip\":{\"source\":\"iana\"},\"message/sipfrag\":{\"source\":\"iana\"},\"message/tracking-status\":{\"source\":\"iana\"},\"message/vnd.si.simp\":{\"source\":\"iana\"},\"message/vnd.wfa.wsc\":{\"source\":\"iana\",\"extensions\":[\"wsc\"]},\"model/3mf\":{\"source\":\"iana\",\"extensions\":[\"3mf\"]},\"model/e57\":{\"source\":\"iana\"},\"model/gltf+json\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"gltf\"]},\"model/gltf-binary\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"glb\"]},\"model/iges\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"igs\",\"iges\"]},\"model/mesh\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"msh\",\"mesh\",\"silo\"]},\"model/mtl\":{\"source\":\"iana\",\"extensions\":[\"mtl\"]},\"model/obj\":{\"source\":\"iana\",\"extensions\":[\"obj\"]},\"model/step\":{\"source\":\"iana\"},\"model/step+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"stpx\"]},\"model/step+zip\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"stpz\"]},\"model/step-xml+zip\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"stpxz\"]},\"model/stl\":{\"source\":\"iana\",\"extensions\":[\"stl\"]},\"model/vnd.collada+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"dae\"]},\"model/vnd.dwf\":{\"source\":\"iana\",\"extensions\":[\"dwf\"]},\"model/vnd.flatland.3dml\":{\"source\":\"iana\"},\"model/vnd.gdl\":{\"source\":\"iana\",\"extensions\":[\"gdl\"]},\"model/vnd.gs-gdl\":{\"source\":\"apache\"},\"model/vnd.gs.gdl\":{\"source\":\"iana\"},\"model/vnd.gtw\":{\"source\":\"iana\",\"extensions\":[\"gtw\"]},\"model/vnd.moml+xml\":{\"source\":\"iana\",\"compressible\":true},\"model/vnd.mts\":{\"source\":\"iana\",\"extensions\":[\"mts\"]},\"model/vnd.opengex\":{\"source\":\"iana\",\"extensions\":[\"ogex\"]},\"model/vnd.parasolid.transmit.binary\":{\"source\":\"iana\",\"extensions\":[\"x_b\"]},\"model/vnd.parasolid.transmit.text\":{\"source\":\"iana\",\"extensions\":[\"x_t\"]},\"model/vnd.pytha.pyox\":{\"source\":\"iana\"},\"model/vnd.rosette.annotated-data-model\":{\"source\":\"iana\"},\"model/vnd.sap.vds\":{\"source\":\"iana\",\"extensions\":[\"vds\"]},\"model/vnd.usdz+zip\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"usdz\"]},\"model/vnd.valve.source.compiled-map\":{\"source\":\"iana\",\"extensions\":[\"bsp\"]},\"model/vnd.vtu\":{\"source\":\"iana\",\"extensions\":[\"vtu\"]},\"model/vrml\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"wrl\",\"vrml\"]},\"model/x3d+binary\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"x3db\",\"x3dbz\"]},\"model/x3d+fastinfoset\":{\"source\":\"iana\",\"extensions\":[\"x3db\"]},\"model/x3d+vrml\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"x3dv\",\"x3dvz\"]},\"model/x3d+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"x3d\",\"x3dz\"]},\"model/x3d-vrml\":{\"source\":\"iana\",\"extensions\":[\"x3dv\"]},\"multipart/alternative\":{\"source\":\"iana\",\"compressible\":false},\"multipart/appledouble\":{\"source\":\"iana\"},\"multipart/byteranges\":{\"source\":\"iana\"},\"multipart/digest\":{\"source\":\"iana\"},\"multipart/encrypted\":{\"source\":\"iana\",\"compressible\":false},\"multipart/form-data\":{\"source\":\"iana\",\"compressible\":false},\"multipart/header-set\":{\"source\":\"iana\"},\"multipart/mixed\":{\"source\":\"iana\"},\"multipart/multilingual\":{\"source\":\"iana\"},\"multipart/parallel\":{\"source\":\"iana\"},\"multipart/related\":{\"source\":\"iana\",\"compressible\":false},\"multipart/report\":{\"source\":\"iana\"},\"multipart/signed\":{\"source\":\"iana\",\"compressible\":false},\"multipart/vnd.bint.med-plus\":{\"source\":\"iana\"},\"multipart/voice-message\":{\"source\":\"iana\"},\"multipart/x-mixed-replace\":{\"source\":\"iana\"},\"text/1d-interleaved-parityfec\":{\"source\":\"iana\"},\"text/cache-manifest\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"appcache\",\"manifest\"]},\"text/calendar\":{\"source\":\"iana\",\"extensions\":[\"ics\",\"ifb\"]},\"text/calender\":{\"compressible\":true},\"text/cmd\":{\"compressible\":true},\"text/coffeescript\":{\"extensions\":[\"coffee\",\"litcoffee\"]},\"text/cql\":{\"source\":\"iana\"},\"text/cql-expression\":{\"source\":\"iana\"},\"text/cql-identifier\":{\"source\":\"iana\"},\"text/css\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"css\"]},\"text/csv\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"csv\"]},\"text/csv-schema\":{\"source\":\"iana\"},\"text/directory\":{\"source\":\"iana\"},\"text/dns\":{\"source\":\"iana\"},\"text/ecmascript\":{\"source\":\"iana\"},\"text/encaprtp\":{\"source\":\"iana\"},\"text/enriched\":{\"source\":\"iana\"},\"text/fhirpath\":{\"source\":\"iana\"},\"text/flexfec\":{\"source\":\"iana\"},\"text/fwdred\":{\"source\":\"iana\"},\"text/gff3\":{\"source\":\"iana\"},\"text/grammar-ref-list\":{\"source\":\"iana\"},\"text/html\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"html\",\"htm\",\"shtml\"]},\"text/jade\":{\"extensions\":[\"jade\"]},\"text/javascript\":{\"source\":\"iana\",\"compressible\":true},\"text/jcr-cnd\":{\"source\":\"iana\"},\"text/jsx\":{\"compressible\":true,\"extensions\":[\"jsx\"]},\"text/less\":{\"compressible\":true,\"extensions\":[\"less\"]},\"text/markdown\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"markdown\",\"md\"]},\"text/mathml\":{\"source\":\"nginx\",\"extensions\":[\"mml\"]},\"text/mdx\":{\"compressible\":true,\"extensions\":[\"mdx\"]},\"text/mizar\":{\"source\":\"iana\"},\"text/n3\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"n3\"]},\"text/parameters\":{\"source\":\"iana\",\"charset\":\"UTF-8\"},\"text/parityfec\":{\"source\":\"iana\"},\"text/plain\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"txt\",\"text\",\"conf\",\"def\",\"list\",\"log\",\"in\",\"ini\"]},\"text/provenance-notation\":{\"source\":\"iana\",\"charset\":\"UTF-8\"},\"text/prs.fallenstein.rst\":{\"source\":\"iana\"},\"text/prs.lines.tag\":{\"source\":\"iana\",\"extensions\":[\"dsc\"]},\"text/prs.prop.logic\":{\"source\":\"iana\"},\"text/raptorfec\":{\"source\":\"iana\"},\"text/red\":{\"source\":\"iana\"},\"text/rfc822-headers\":{\"source\":\"iana\"},\"text/richtext\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rtx\"]},\"text/rtf\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rtf\"]},\"text/rtp-enc-aescm128\":{\"source\":\"iana\"},\"text/rtploopback\":{\"source\":\"iana\"},\"text/rtx\":{\"source\":\"iana\"},\"text/sgml\":{\"source\":\"iana\",\"extensions\":[\"sgml\",\"sgm\"]},\"text/shaclc\":{\"source\":\"iana\"},\"text/shex\":{\"source\":\"iana\",\"extensions\":[\"shex\"]},\"text/slim\":{\"extensions\":[\"slim\",\"slm\"]},\"text/spdx\":{\"source\":\"iana\",\"extensions\":[\"spdx\"]},\"text/strings\":{\"source\":\"iana\"},\"text/stylus\":{\"extensions\":[\"stylus\",\"styl\"]},\"text/t140\":{\"source\":\"iana\"},\"text/tab-separated-values\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"tsv\"]},\"text/troff\":{\"source\":\"iana\",\"extensions\":[\"t\",\"tr\",\"roff\",\"man\",\"me\",\"ms\"]},\"text/turtle\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"extensions\":[\"ttl\"]},\"text/ulpfec\":{\"source\":\"iana\"},\"text/uri-list\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"uri\",\"uris\",\"urls\"]},\"text/vcard\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"vcard\"]},\"text/vnd.a\":{\"source\":\"iana\"},\"text/vnd.abc\":{\"source\":\"iana\"},\"text/vnd.ascii-art\":{\"source\":\"iana\"},\"text/vnd.curl\":{\"source\":\"iana\",\"extensions\":[\"curl\"]},\"text/vnd.curl.dcurl\":{\"source\":\"apache\",\"extensions\":[\"dcurl\"]},\"text/vnd.curl.mcurl\":{\"source\":\"apache\",\"extensions\":[\"mcurl\"]},\"text/vnd.curl.scurl\":{\"source\":\"apache\",\"extensions\":[\"scurl\"]},\"text/vnd.debian.copyright\":{\"source\":\"iana\",\"charset\":\"UTF-8\"},\"text/vnd.dmclientscript\":{\"source\":\"iana\"},\"text/vnd.dvb.subtitle\":{\"source\":\"iana\",\"extensions\":[\"sub\"]},\"text/vnd.esmertec.theme-descriptor\":{\"source\":\"iana\",\"charset\":\"UTF-8\"},\"text/vnd.familysearch.gedcom\":{\"source\":\"iana\",\"extensions\":[\"ged\"]},\"text/vnd.ficlab.flt\":{\"source\":\"iana\"},\"text/vnd.fly\":{\"source\":\"iana\",\"extensions\":[\"fly\"]},\"text/vnd.fmi.flexstor\":{\"source\":\"iana\",\"extensions\":[\"flx\"]},\"text/vnd.gml\":{\"source\":\"iana\"},\"text/vnd.graphviz\":{\"source\":\"iana\",\"extensions\":[\"gv\"]},\"text/vnd.hans\":{\"source\":\"iana\"},\"text/vnd.hgl\":{\"source\":\"iana\"},\"text/vnd.in3d.3dml\":{\"source\":\"iana\",\"extensions\":[\"3dml\"]},\"text/vnd.in3d.spot\":{\"source\":\"iana\",\"extensions\":[\"spot\"]},\"text/vnd.iptc.newsml\":{\"source\":\"iana\"},\"text/vnd.iptc.nitf\":{\"source\":\"iana\"},\"text/vnd.latex-z\":{\"source\":\"iana\"},\"text/vnd.motorola.reflex\":{\"source\":\"iana\"},\"text/vnd.ms-mediapackage\":{\"source\":\"iana\"},\"text/vnd.net2phone.commcenter.command\":{\"source\":\"iana\"},\"text/vnd.radisys.msml-basic-layout\":{\"source\":\"iana\"},\"text/vnd.senx.warpscript\":{\"source\":\"iana\"},\"text/vnd.si.uricatalogue\":{\"source\":\"iana\"},\"text/vnd.sosi\":{\"source\":\"iana\"},\"text/vnd.sun.j2me.app-descriptor\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"extensions\":[\"jad\"]},\"text/vnd.trolltech.linguist\":{\"source\":\"iana\",\"charset\":\"UTF-8\"},\"text/vnd.wap.si\":{\"source\":\"iana\"},\"text/vnd.wap.sl\":{\"source\":\"iana\"},\"text/vnd.wap.wml\":{\"source\":\"iana\",\"extensions\":[\"wml\"]},\"text/vnd.wap.wmlscript\":{\"source\":\"iana\",\"extensions\":[\"wmls\"]},\"text/vtt\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"vtt\"]},\"text/x-asm\":{\"source\":\"apache\",\"extensions\":[\"s\",\"asm\"]},\"text/x-c\":{\"source\":\"apache\",\"extensions\":[\"c\",\"cc\",\"cxx\",\"cpp\",\"h\",\"hh\",\"dic\"]},\"text/x-component\":{\"source\":\"nginx\",\"extensions\":[\"htc\"]},\"text/x-fortran\":{\"source\":\"apache\",\"extensions\":[\"f\",\"for\",\"f77\",\"f90\"]},\"text/x-gwt-rpc\":{\"compressible\":true},\"text/x-handlebars-template\":{\"extensions\":[\"hbs\"]},\"text/x-java-source\":{\"source\":\"apache\",\"extensions\":[\"java\"]},\"text/x-jquery-tmpl\":{\"compressible\":true},\"text/x-lua\":{\"extensions\":[\"lua\"]},\"text/x-markdown\":{\"compressible\":true,\"extensions\":[\"mkd\"]},\"text/x-nfo\":{\"source\":\"apache\",\"extensions\":[\"nfo\"]},\"text/x-opml\":{\"source\":\"apache\",\"extensions\":[\"opml\"]},\"text/x-org\":{\"compressible\":true,\"extensions\":[\"org\"]},\"text/x-pascal\":{\"source\":\"apache\",\"extensions\":[\"p\",\"pas\"]},\"text/x-processing\":{\"compressible\":true,\"extensions\":[\"pde\"]},\"text/x-sass\":{\"extensions\":[\"sass\"]},\"text/x-scss\":{\"extensions\":[\"scss\"]},\"text/x-setext\":{\"source\":\"apache\",\"extensions\":[\"etx\"]},\"text/x-sfv\":{\"source\":\"apache\",\"extensions\":[\"sfv\"]},\"text/x-suse-ymp\":{\"compressible\":true,\"extensions\":[\"ymp\"]},\"text/x-uuencode\":{\"source\":\"apache\",\"extensions\":[\"uu\"]},\"text/x-vcalendar\":{\"source\":\"apache\",\"extensions\":[\"vcs\"]},\"text/x-vcard\":{\"source\":\"apache\",\"extensions\":[\"vcf\"]},\"text/xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xml\"]},\"text/xml-external-parsed-entity\":{\"source\":\"iana\"},\"text/yaml\":{\"compressible\":true,\"extensions\":[\"yaml\",\"yml\"]},\"video/1d-interleaved-parityfec\":{\"source\":\"iana\"},\"video/3gpp\":{\"source\":\"iana\",\"extensions\":[\"3gp\",\"3gpp\"]},\"video/3gpp-tt\":{\"source\":\"iana\"},\"video/3gpp2\":{\"source\":\"iana\",\"extensions\":[\"3g2\"]},\"video/av1\":{\"source\":\"iana\"},\"video/bmpeg\":{\"source\":\"iana\"},\"video/bt656\":{\"source\":\"iana\"},\"video/celb\":{\"source\":\"iana\"},\"video/dv\":{\"source\":\"iana\"},\"video/encaprtp\":{\"source\":\"iana\"},\"video/ffv1\":{\"source\":\"iana\"},\"video/flexfec\":{\"source\":\"iana\"},\"video/h261\":{\"source\":\"iana\",\"extensions\":[\"h261\"]},\"video/h263\":{\"source\":\"iana\",\"extensions\":[\"h263\"]},\"video/h263-1998\":{\"source\":\"iana\"},\"video/h263-2000\":{\"source\":\"iana\"},\"video/h264\":{\"source\":\"iana\",\"extensions\":[\"h264\"]},\"video/h264-rcdo\":{\"source\":\"iana\"},\"video/h264-svc\":{\"source\":\"iana\"},\"video/h265\":{\"source\":\"iana\"},\"video/iso.segment\":{\"source\":\"iana\",\"extensions\":[\"m4s\"]},\"video/jpeg\":{\"source\":\"iana\",\"extensions\":[\"jpgv\"]},\"video/jpeg2000\":{\"source\":\"iana\"},\"video/jpm\":{\"source\":\"apache\",\"extensions\":[\"jpm\",\"jpgm\"]},\"video/jxsv\":{\"source\":\"iana\"},\"video/mj2\":{\"source\":\"iana\",\"extensions\":[\"mj2\",\"mjp2\"]},\"video/mp1s\":{\"source\":\"iana\"},\"video/mp2p\":{\"source\":\"iana\"},\"video/mp2t\":{\"source\":\"iana\",\"extensions\":[\"ts\"]},\"video/mp4\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"mp4\",\"mp4v\",\"mpg4\"]},\"video/mp4v-es\":{\"source\":\"iana\"},\"video/mpeg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"mpeg\",\"mpg\",\"mpe\",\"m1v\",\"m2v\"]},\"video/mpeg4-generic\":{\"source\":\"iana\"},\"video/mpv\":{\"source\":\"iana\"},\"video/nv\":{\"source\":\"iana\"},\"video/ogg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"ogv\"]},\"video/parityfec\":{\"source\":\"iana\"},\"video/pointer\":{\"source\":\"iana\"},\"video/quicktime\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"qt\",\"mov\"]},\"video/raptorfec\":{\"source\":\"iana\"},\"video/raw\":{\"source\":\"iana\"},\"video/rtp-enc-aescm128\":{\"source\":\"iana\"},\"video/rtploopback\":{\"source\":\"iana\"},\"video/rtx\":{\"source\":\"iana\"},\"video/scip\":{\"source\":\"iana\"},\"video/smpte291\":{\"source\":\"iana\"},\"video/smpte292m\":{\"source\":\"iana\"},\"video/ulpfec\":{\"source\":\"iana\"},\"video/vc1\":{\"source\":\"iana\"},\"video/vc2\":{\"source\":\"iana\"},\"video/vnd.cctv\":{\"source\":\"iana\"},\"video/vnd.dece.hd\":{\"source\":\"iana\",\"extensions\":[\"uvh\",\"uvvh\"]},\"video/vnd.dece.mobile\":{\"source\":\"iana\",\"extensions\":[\"uvm\",\"uvvm\"]},\"video/vnd.dece.mp4\":{\"source\":\"iana\"},\"video/vnd.dece.pd\":{\"source\":\"iana\",\"extensions\":[\"uvp\",\"uvvp\"]},\"video/vnd.dece.sd\":{\"source\":\"iana\",\"extensions\":[\"uvs\",\"uvvs\"]},\"video/vnd.dece.video\":{\"source\":\"iana\",\"extensions\":[\"uvv\",\"uvvv\"]},\"video/vnd.directv.mpeg\":{\"source\":\"iana\"},\"video/vnd.directv.mpeg-tts\":{\"source\":\"iana\"},\"video/vnd.dlna.mpeg-tts\":{\"source\":\"iana\"},\"video/vnd.dvb.file\":{\"source\":\"iana\",\"extensions\":[\"dvb\"]},\"video/vnd.fvt\":{\"source\":\"iana\",\"extensions\":[\"fvt\"]},\"video/vnd.hns.video\":{\"source\":\"iana\"},\"video/vnd.iptvforum.1dparityfec-1010\":{\"source\":\"iana\"},\"video/vnd.iptvforum.1dparityfec-2005\":{\"source\":\"iana\"},\"video/vnd.iptvforum.2dparityfec-1010\":{\"source\":\"iana\"},\"video/vnd.iptvforum.2dparityfec-2005\":{\"source\":\"iana\"},\"video/vnd.iptvforum.ttsavc\":{\"source\":\"iana\"},\"video/vnd.iptvforum.ttsmpeg2\":{\"source\":\"iana\"},\"video/vnd.motorola.video\":{\"source\":\"iana\"},\"video/vnd.motorola.videop\":{\"source\":\"iana\"},\"video/vnd.mpegurl\":{\"source\":\"iana\",\"extensions\":[\"mxu\",\"m4u\"]},\"video/vnd.ms-playready.media.pyv\":{\"source\":\"iana\",\"extensions\":[\"pyv\"]},\"video/vnd.nokia.interleaved-multimedia\":{\"source\":\"iana\"},\"video/vnd.nokia.mp4vr\":{\"source\":\"iana\"},\"video/vnd.nokia.videovoip\":{\"source\":\"iana\"},\"video/vnd.objectvideo\":{\"source\":\"iana\"},\"video/vnd.radgamettools.bink\":{\"source\":\"iana\"},\"video/vnd.radgamettools.smacker\":{\"source\":\"iana\"},\"video/vnd.sealed.mpeg1\":{\"source\":\"iana\"},\"video/vnd.sealed.mpeg4\":{\"source\":\"iana\"},\"video/vnd.sealed.swf\":{\"source\":\"iana\"},\"video/vnd.sealedmedia.softseal.mov\":{\"source\":\"iana\"},\"video/vnd.uvvu.mp4\":{\"source\":\"iana\",\"extensions\":[\"uvu\",\"uvvu\"]},\"video/vnd.vivo\":{\"source\":\"iana\",\"extensions\":[\"viv\"]},\"video/vnd.youtube.yt\":{\"source\":\"iana\"},\"video/vp8\":{\"source\":\"iana\"},\"video/vp9\":{\"source\":\"iana\"},\"video/webm\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"webm\"]},\"video/x-f4v\":{\"source\":\"apache\",\"extensions\":[\"f4v\"]},\"video/x-fli\":{\"source\":\"apache\",\"extensions\":[\"fli\"]},\"video/x-flv\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"flv\"]},\"video/x-m4v\":{\"source\":\"apache\",\"extensions\":[\"m4v\"]},\"video/x-matroska\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"mkv\",\"mk3d\",\"mks\"]},\"video/x-mng\":{\"source\":\"apache\",\"extensions\":[\"mng\"]},\"video/x-ms-asf\":{\"source\":\"apache\",\"extensions\":[\"asf\",\"asx\"]},\"video/x-ms-vob\":{\"source\":\"apache\",\"extensions\":[\"vob\"]},\"video/x-ms-wm\":{\"source\":\"apache\",\"extensions\":[\"wm\"]},\"video/x-ms-wmv\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"wmv\"]},\"video/x-ms-wmx\":{\"source\":\"apache\",\"extensions\":[\"wmx\"]},\"video/x-ms-wvx\":{\"source\":\"apache\",\"extensions\":[\"wvx\"]},\"video/x-msvideo\":{\"source\":\"apache\",\"extensions\":[\"avi\"]},\"video/x-sgi-movie\":{\"source\":\"apache\",\"extensions\":[\"movie\"]},\"video/x-smv\":{\"source\":\"apache\",\"extensions\":[\"smv\"]},\"x-conference/x-cooltalk\":{\"source\":\"apache\",\"extensions\":[\"ice\"]},\"x-shader/x-fragment\":{\"compressible\":true},\"x-shader/x-vertex\":{\"compressible\":true}}","/*!\n * mime-db\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015-2022 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n/**\n * Module exports.\n */\n\nmodule.exports = require('./db.json')\n","/*!\n * mime-types\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar db = require('mime-db')\nvar extname = require('path').extname\n\n/**\n * Module variables.\n * @private\n */\n\nvar EXTRACT_TYPE_REGEXP = /^\\s*([^;\\s]*)(?:;|\\s|$)/\nvar TEXT_TYPE_REGEXP = /^text\\//i\n\n/**\n * Module exports.\n * @public\n */\n\nexports.charset = charset\nexports.charsets = { lookup: charset }\nexports.contentType = contentType\nexports.extension = extension\nexports.extensions = Object.create(null)\nexports.lookup = lookup\nexports.types = Object.create(null)\n\n// Populate the extensions/types maps\npopulateMaps(exports.extensions, exports.types)\n\n/**\n * Get the default charset for a MIME type.\n *\n * @param {string} type\n * @return {boolean|string}\n */\n\nfunction charset (type) {\n  if (!type || typeof type !== 'string') {\n    return false\n  }\n\n  // TODO: use media-typer\n  var match = EXTRACT_TYPE_REGEXP.exec(type)\n  var mime = match && db[match[1].toLowerCase()]\n\n  if (mime && mime.charset) {\n    return mime.charset\n  }\n\n  // default text/* to utf-8\n  if (match && TEXT_TYPE_REGEXP.test(match[1])) {\n    return 'UTF-8'\n  }\n\n  return false\n}\n\n/**\n * Create a full Content-Type header given a MIME type or extension.\n *\n * @param {string} str\n * @return {boolean|string}\n */\n\nfunction contentType (str) {\n  // TODO: should this even be in this module?\n  if (!str || typeof str !== 'string') {\n    return false\n  }\n\n  var mime = str.indexOf('/') === -1\n    ? exports.lookup(str)\n    : str\n\n  if (!mime) {\n    return false\n  }\n\n  // TODO: use content-type or other module\n  if (mime.indexOf('charset') === -1) {\n    var charset = exports.charset(mime)\n    if (charset) mime += '; charset=' + charset.toLowerCase()\n  }\n\n  return mime\n}\n\n/**\n * Get the default extension for a MIME type.\n *\n * @param {string} type\n * @return {boolean|string}\n */\n\nfunction extension (type) {\n  if (!type || typeof type !== 'string') {\n    return false\n  }\n\n  // TODO: use media-typer\n  var match = EXTRACT_TYPE_REGEXP.exec(type)\n\n  // get extensions\n  var exts = match && exports.extensions[match[1].toLowerCase()]\n\n  if (!exts || !exts.length) {\n    return false\n  }\n\n  return exts[0]\n}\n\n/**\n * Lookup the MIME type for a file path/extension.\n *\n * @param {string} path\n * @return {boolean|string}\n */\n\nfunction lookup (path) {\n  if (!path || typeof path !== 'string') {\n    return false\n  }\n\n  // get the extension (\"ext\" or \".ext\" or full path)\n  var extension = extname('x.' + path)\n    .toLowerCase()\n    .substr(1)\n\n  if (!extension) {\n    return false\n  }\n\n  return exports.types[extension] || false\n}\n\n/**\n * Populate the extensions and types maps.\n * @private\n */\n\nfunction populateMaps (extensions, types) {\n  // source preference (least -> most)\n  var preference = ['nginx', 'apache', undefined, 'iana']\n\n  Object.keys(db).forEach(function forEachMimeType (type) {\n    var mime = db[type]\n    var exts = mime.extensions\n\n    if (!exts || !exts.length) {\n      return\n    }\n\n    // mime -> extensions\n    extensions[type] = exts\n\n    // extension -> mime\n    for (var i = 0; i < exts.length; i++) {\n      var extension = exts[i]\n\n      if (types[extension]) {\n        var from = preference.indexOf(db[types[extension]].source)\n        var to = preference.indexOf(mime.source)\n\n        if (types[extension] !== 'application/octet-stream' &&\n          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {\n          // skip the remapping\n          continue\n        }\n      }\n\n      // set the extension -> mime\n      types[extension] = type\n    }\n  })\n}\n","module.exports = defer;\n\n/**\n * Runs provided function on next iteration of the event loop\n *\n * @param {function} fn - function to run\n */\nfunction defer(fn)\n{\n  var nextTick = typeof setImmediate == 'function'\n    ? setImmediate\n    : (\n      typeof process == 'object' && typeof process.nextTick == 'function'\n      ? process.nextTick\n      : null\n    );\n\n  if (nextTick)\n  {\n    nextTick(fn);\n  }\n  else\n  {\n    setTimeout(fn, 0);\n  }\n}\n","var defer = require('./defer.js');\n\n// API\nmodule.exports = async;\n\n/**\n * Runs provided callback asynchronously\n * even if callback itself is not\n *\n * @param   {function} callback - callback to invoke\n * @returns {function} - augmented callback\n */\nfunction async(callback)\n{\n  var isAsync = false;\n\n  // check if async happened\n  defer(function() { isAsync = true; });\n\n  return function async_callback(err, result)\n  {\n    if (isAsync)\n    {\n      callback(err, result);\n    }\n    else\n    {\n      defer(function nextTick_callback()\n      {\n        callback(err, result);\n      });\n    }\n  };\n}\n","// API\nmodule.exports = abort;\n\n/**\n * Aborts leftover active jobs\n *\n * @param {object} state - current state object\n */\nfunction abort(state)\n{\n  Object.keys(state.jobs).forEach(clean.bind(state));\n\n  // reset leftover jobs\n  state.jobs = {};\n}\n\n/**\n * Cleans up leftover job by invoking abort function for the provided job id\n *\n * @this  state\n * @param {string|number} key - job id to abort\n */\nfunction clean(key)\n{\n  if (typeof this.jobs[key] == 'function')\n  {\n    this.jobs[key]();\n  }\n}\n","var async = require('./async.js')\n  , abort = require('./abort.js')\n  ;\n\n// API\nmodule.exports = iterate;\n\n/**\n * Iterates over each job object\n *\n * @param {array|object} list - array or object (named list) to iterate over\n * @param {function} iterator - iterator to run\n * @param {object} state - current job status\n * @param {function} callback - invoked when all elements processed\n */\nfunction iterate(list, iterator, state, callback)\n{\n  // store current index\n  var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;\n\n  state.jobs[key] = runJob(iterator, key, list[key], function(error, output)\n  {\n    // don't repeat yourself\n    // skip secondary callbacks\n    if (!(key in state.jobs))\n    {\n      return;\n    }\n\n    // clean up jobs\n    delete state.jobs[key];\n\n    if (error)\n    {\n      // don't process rest of the results\n      // stop still active jobs\n      // and reset the list\n      abort(state);\n    }\n    else\n    {\n      state.results[key] = output;\n    }\n\n    // return salvaged results\n    callback(error, state.results);\n  });\n}\n\n/**\n * Runs iterator over provided job element\n *\n * @param   {function} iterator - iterator to invoke\n * @param   {string|number} key - key/index of the element in the list of jobs\n * @param   {mixed} item - job description\n * @param   {function} callback - invoked after iterator is done with the job\n * @returns {function|mixed} - job abort function or something else\n */\nfunction runJob(iterator, key, item, callback)\n{\n  var aborter;\n\n  // allow shortcut if iterator expects only two arguments\n  if (iterator.length == 2)\n  {\n    aborter = iterator(item, async(callback));\n  }\n  // otherwise go with full three arguments\n  else\n  {\n    aborter = iterator(item, key, async(callback));\n  }\n\n  return aborter;\n}\n","// API\nmodule.exports = state;\n\n/**\n * Creates initial state object\n * for iteration over list\n *\n * @param   {array|object} list - list to iterate over\n * @param   {function|null} sortMethod - function to use for keys sort,\n *                                     or `null` to keep them as is\n * @returns {object} - initial state object\n */\nfunction state(list, sortMethod)\n{\n  var isNamedList = !Array.isArray(list)\n    , initState =\n    {\n      index    : 0,\n      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,\n      jobs     : {},\n      results  : isNamedList ? {} : [],\n      size     : isNamedList ? Object.keys(list).length : list.length\n    }\n    ;\n\n  if (sortMethod)\n  {\n    // sort array keys based on it's values\n    // sort object's keys just on own merit\n    initState.keyedList.sort(isNamedList ? sortMethod : function(a, b)\n    {\n      return sortMethod(list[a], list[b]);\n    });\n  }\n\n  return initState;\n}\n","var abort = require('./abort.js')\n  , async = require('./async.js')\n  ;\n\n// API\nmodule.exports = terminator;\n\n/**\n * Terminates jobs in the attached state context\n *\n * @this  AsyncKitState#\n * @param {function} callback - final callback to invoke after termination\n */\nfunction terminator(callback)\n{\n  if (!Object.keys(this.jobs).length)\n  {\n    return;\n  }\n\n  // fast forward iteration index\n  this.index = this.size;\n\n  // abort jobs\n  abort(this);\n\n  // send back results we have so far\n  async(callback)(null, this.results);\n}\n","var iterate    = require('./lib/iterate.js')\n  , initState  = require('./lib/state.js')\n  , terminator = require('./lib/terminator.js')\n  ;\n\n// Public API\nmodule.exports = parallel;\n\n/**\n * Runs iterator over provided array elements in parallel\n *\n * @param   {array|object} list - array or object (named list) to iterate over\n * @param   {function} iterator - iterator to run\n * @param   {function} callback - invoked when all elements processed\n * @returns {function} - jobs terminator\n */\nfunction parallel(list, iterator, callback)\n{\n  var state = initState(list);\n\n  while (state.index < (state['keyedList'] || list).length)\n  {\n    iterate(list, iterator, state, function(error, result)\n    {\n      if (error)\n      {\n        callback(error, result);\n        return;\n      }\n\n      // looks like it's the last one\n      if (Object.keys(state.jobs).length === 0)\n      {\n        callback(null, state.results);\n        return;\n      }\n    });\n\n    state.index++;\n  }\n\n  return terminator.bind(state, callback);\n}\n","var iterate    = require('./lib/iterate.js')\n  , initState  = require('./lib/state.js')\n  , terminator = require('./lib/terminator.js')\n  ;\n\n// Public API\nmodule.exports = serialOrdered;\n// sorting helpers\nmodule.exports.ascending  = ascending;\nmodule.exports.descending = descending;\n\n/**\n * Runs iterator over provided sorted array elements in series\n *\n * @param   {array|object} list - array or object (named list) to iterate over\n * @param   {function} iterator - iterator to run\n * @param   {function} sortMethod - custom sort function\n * @param   {function} callback - invoked when all elements processed\n * @returns {function} - jobs terminator\n */\nfunction serialOrdered(list, iterator, sortMethod, callback)\n{\n  var state = initState(list, sortMethod);\n\n  iterate(list, iterator, state, function iteratorHandler(error, result)\n  {\n    if (error)\n    {\n      callback(error, result);\n      return;\n    }\n\n    state.index++;\n\n    // are we there yet?\n    if (state.index < (state['keyedList'] || list).length)\n    {\n      iterate(list, iterator, state, iteratorHandler);\n      return;\n    }\n\n    // done here\n    callback(null, state.results);\n  });\n\n  return terminator.bind(state, callback);\n}\n\n/*\n * -- Sort methods\n */\n\n/**\n * sort helper to sort array elements in ascending order\n *\n * @param   {mixed} a - an item to compare\n * @param   {mixed} b - an item to compare\n * @returns {number} - comparison result\n */\nfunction ascending(a, b)\n{\n  return a < b ? -1 : a > b ? 1 : 0;\n}\n\n/**\n * sort helper to sort array elements in descending order\n *\n * @param   {mixed} a - an item to compare\n * @param   {mixed} b - an item to compare\n * @returns {number} - comparison result\n */\nfunction descending(a, b)\n{\n  return -1 * ascending(a, b);\n}\n","var serialOrdered = require('./serialOrdered.js');\n\n// Public API\nmodule.exports = serial;\n\n/**\n * Runs iterator over provided array elements in series\n *\n * @param   {array|object} list - array or object (named list) to iterate over\n * @param   {function} iterator - iterator to run\n * @param   {function} callback - invoked when all elements processed\n * @returns {function} - jobs terminator\n */\nfunction serial(list, iterator, callback)\n{\n  return serialOrdered(list, iterator, null, callback);\n}\n","module.exports =\n{\n  parallel      : require('./parallel.js'),\n  serial        : require('./serial.js'),\n  serialOrdered : require('./serialOrdered.js')\n};\n","'use strict';\n\n/** @type {import('.')} */\nmodule.exports = Object;\n","'use strict';\n\n/** @type {import('.')} */\nmodule.exports = Error;\n","'use strict';\n\n/** @type {import('./eval')} */\nmodule.exports = EvalError;\n","'use strict';\n\n/** @type {import('./range')} */\nmodule.exports = RangeError;\n","'use strict';\n\n/** @type {import('./ref')} */\nmodule.exports = ReferenceError;\n","'use strict';\n\n/** @type {import('./syntax')} */\nmodule.exports = SyntaxError;\n","'use strict';\n\n/** @type {import('./type')} */\nmodule.exports = TypeError;\n","'use strict';\n\n/** @type {import('./uri')} */\nmodule.exports = URIError;\n","'use strict';\n\n/** @type {import('./abs')} */\nmodule.exports = Math.abs;\n","'use strict';\n\n/** @type {import('./floor')} */\nmodule.exports = Math.floor;\n","'use strict';\n\n/** @type {import('./max')} */\nmodule.exports = Math.max;\n","'use strict';\n\n/** @type {import('./min')} */\nmodule.exports = Math.min;\n","'use strict';\n\n/** @type {import('./pow')} */\nmodule.exports = Math.pow;\n","'use strict';\n\n/** @type {import('./round')} */\nmodule.exports = Math.round;\n","'use strict';\n\n/** @type {import('./isNaN')} */\nmodule.exports = Number.isNaN || function isNaN(a) {\n\treturn a !== a;\n};\n","'use strict';\n\nvar $isNaN = require('./isNaN');\n\n/** @type {import('./sign')} */\nmodule.exports = function sign(number) {\n\tif ($isNaN(number) || number === 0) {\n\t\treturn number;\n\t}\n\treturn number < 0 ? -1 : +1;\n};\n","'use strict';\n\n/** @type {import('./gOPD')} */\nmodule.exports = Object.getOwnPropertyDescriptor;\n","'use strict';\n\n/** @type {import('.')} */\nvar $gOPD = require('./gOPD');\n\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n","'use strict';\n\n/** @type {import('.')} */\nvar $defineProperty = Object.defineProperty || false;\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = false;\n\t}\n}\n\nmodule.exports = $defineProperty;\n","'use strict';\n\n/** @type {import('./shams')} */\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\t/** @type {{ [k in symbol]?: unknown }} */\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\t// eslint-disable-next-line no-extra-parens\n\t\tvar descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n","'use strict';\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = require('./shams');\n\n/** @type {import('.')} */\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n","'use strict';\n\n/** @type {import('./Reflect.getPrototypeOf')} */\nmodule.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;\n","'use strict';\n\nvar $Object = require('es-object-atoms');\n\n/** @type {import('./Object.getPrototypeOf')} */\nmodule.exports = $Object.getPrototypeOf || null;\n","'use strict';\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar toStr = Object.prototype.toString;\nvar max = Math.max;\nvar funcType = '[object Function]';\n\nvar concatty = function concatty(a, b) {\n    var arr = [];\n\n    for (var i = 0; i < a.length; i += 1) {\n        arr[i] = a[i];\n    }\n    for (var j = 0; j < b.length; j += 1) {\n        arr[j + a.length] = b[j];\n    }\n\n    return arr;\n};\n\nvar slicy = function slicy(arrLike, offset) {\n    var arr = [];\n    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {\n        arr[j] = arrLike[i];\n    }\n    return arr;\n};\n\nvar joiny = function (arr, joiner) {\n    var str = '';\n    for (var i = 0; i < arr.length; i += 1) {\n        str += arr[i];\n        if (i + 1 < arr.length) {\n            str += joiner;\n        }\n    }\n    return str;\n};\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slicy(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                concatty(args, arguments)\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        }\n        return target.apply(\n            that,\n            concatty(args, arguments)\n        );\n\n    };\n\n    var boundLength = max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs[i] = '$' + i;\n    }\n\n    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = Function.prototype.bind || implementation;\n","'use strict';\n\n/** @type {import('./functionCall')} */\nmodule.exports = Function.prototype.call;\n","'use strict';\n\n/** @type {import('./functionApply')} */\nmodule.exports = Function.prototype.apply;\n","'use strict';\n\n/** @type {import('./reflectApply')} */\nmodule.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;\n","'use strict';\n\nvar bind = require('function-bind');\n\nvar $apply = require('./functionApply');\nvar $call = require('./functionCall');\nvar $reflectApply = require('./reflectApply');\n\n/** @type {import('./actualApply')} */\nmodule.exports = $reflectApply || bind.call($call, $apply);\n","'use strict';\n\nvar bind = require('function-bind');\nvar $TypeError = require('es-errors/type');\n\nvar $call = require('./functionCall');\nvar $actualApply = require('./actualApply');\n\n/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */\nmodule.exports = function callBindBasic(args) {\n\tif (args.length < 1 || typeof args[0] !== 'function') {\n\t\tthrow new $TypeError('a function is required');\n\t}\n\treturn $actualApply(bind, $call, args);\n};\n","'use strict';\n\nvar callBind = require('call-bind-apply-helpers');\nvar gOPD = require('gopd');\n\nvar hasProtoAccessor;\ntry {\n\t// eslint-disable-next-line no-extra-parens, no-proto\n\thasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;\n} catch (e) {\n\tif (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {\n\t\tthrow e;\n\t}\n}\n\n// eslint-disable-next-line no-extra-parens\nvar desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));\n\nvar $Object = Object;\nvar $getPrototypeOf = $Object.getPrototypeOf;\n\n/** @type {import('./get')} */\nmodule.exports = desc && typeof desc.get === 'function'\n\t? callBind([desc.get])\n\t: typeof $getPrototypeOf === 'function'\n\t\t? /** @type {import('./get')} */ function getDunder(value) {\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\treturn $getPrototypeOf(value == null ? value : $Object(value));\n\t\t}\n\t\t: false;\n","'use strict';\n\nvar reflectGetProto = require('./Reflect.getPrototypeOf');\nvar originalGetProto = require('./Object.getPrototypeOf');\n\nvar getDunderProto = require('dunder-proto/get');\n\n/** @type {import('.')} */\nmodule.exports = reflectGetProto\n\t? function getProto(O) {\n\t\t// @ts-expect-error TS can't narrow inside a closure, for some reason\n\t\treturn reflectGetProto(O);\n\t}\n\t: originalGetProto\n\t\t? function getProto(O) {\n\t\t\tif (!O || (typeof O !== 'object' && typeof O !== 'function')) {\n\t\t\t\tthrow new TypeError('getProto: not an object');\n\t\t\t}\n\t\t\t// @ts-expect-error TS can't narrow inside a closure, for some reason\n\t\t\treturn originalGetProto(O);\n\t\t}\n\t\t: getDunderProto\n\t\t\t? function getProto(O) {\n\t\t\t\t// @ts-expect-error TS can't narrow inside a closure, for some reason\n\t\t\t\treturn getDunderProto(O);\n\t\t\t}\n\t\t\t: null;\n","'use strict';\n\nvar call = Function.prototype.call;\nvar $hasOwn = Object.prototype.hasOwnProperty;\nvar bind = require('function-bind');\n\n/** @type {import('.')} */\nmodule.exports = bind.call(call, $hasOwn);\n","'use strict';\n\nvar undefined;\n\nvar $Object = require('es-object-atoms');\n\nvar $Error = require('es-errors');\nvar $EvalError = require('es-errors/eval');\nvar $RangeError = require('es-errors/range');\nvar $ReferenceError = require('es-errors/ref');\nvar $SyntaxError = require('es-errors/syntax');\nvar $TypeError = require('es-errors/type');\nvar $URIError = require('es-errors/uri');\n\nvar abs = require('math-intrinsics/abs');\nvar floor = require('math-intrinsics/floor');\nvar max = require('math-intrinsics/max');\nvar min = require('math-intrinsics/min');\nvar pow = require('math-intrinsics/pow');\nvar round = require('math-intrinsics/round');\nvar sign = require('math-intrinsics/sign');\n\nvar $Function = Function;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = require('gopd');\nvar $defineProperty = require('es-define-property');\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = require('has-symbols')();\n\nvar getProto = require('get-proto');\nvar $ObjectGPO = require('get-proto/Object.getPrototypeOf');\nvar $ReflectGPO = require('get-proto/Reflect.getPrototypeOf');\n\nvar $apply = require('call-bind-apply-helpers/functionApply');\nvar $call = require('call-bind-apply-helpers/functionCall');\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t__proto__: null,\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,\n\t'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': $Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': $EvalError,\n\t'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': $Object,\n\t'%Object.getOwnPropertyDescriptor%': $gOPD,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': $RangeError,\n\t'%ReferenceError%': $ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': $URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,\n\n\t'%Function.prototype.call%': $call,\n\t'%Function.prototype.apply%': $apply,\n\t'%Object.defineProperty%': $defineProperty,\n\t'%Object.getPrototypeOf%': $ObjectGPO,\n\t'%Math.abs%': abs,\n\t'%Math.floor%': floor,\n\t'%Math.max%': max,\n\t'%Math.min%': min,\n\t'%Math.pow%': pow,\n\t'%Math.round%': round,\n\t'%Math.sign%': sign,\n\t'%Reflect.getPrototypeOf%': $ReflectGPO\n};\n\nif (getProto) {\n\ttry {\n\t\tnull.error; // eslint-disable-line no-unused-expressions\n\t} catch (e) {\n\t\t// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229\n\t\tvar errorProto = getProto(getProto(e));\n\t\tINTRINSICS['%Error.prototype%'] = errorProto;\n\t}\n}\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen && getProto) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t__proto__: null,\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = require('function-bind');\nvar hasOwn = require('hasown');\nvar $concat = bind.call($call, Array.prototype.concat);\nvar $spliceApply = bind.call($apply, Array.prototype.splice);\nvar $replace = bind.call($call, String.prototype.replace);\nvar $strSlice = bind.call($call, String.prototype.slice);\nvar $exec = bind.call($call, RegExp.prototype.exec);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tif ($exec(/^%?[^%]*%?$/, name) === null) {\n\t\tthrow new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');\n\t}\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n","'use strict';\n\nvar hasSymbols = require('has-symbols/shams');\n\n/** @type {import('.')} */\nmodule.exports = function hasToStringTagShams() {\n\treturn hasSymbols() && !!Symbol.toStringTag;\n};\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\n\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar hasOwn = require('hasown');\nvar $TypeError = require('es-errors/type');\n\nvar toStringTag = hasToStringTag ? Symbol.toStringTag : null;\n\n/** @type {import('.')} */\nmodule.exports = function setToStringTag(object, value) {\n\tvar overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;\n\tvar nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;\n\tif (\n\t\t(typeof overrideIfSet !== 'undefined' && typeof overrideIfSet !== 'boolean')\n\t\t|| (typeof nonConfigurable !== 'undefined' && typeof nonConfigurable !== 'boolean')\n\t) {\n\t\tthrow new $TypeError('if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans');\n\t}\n\tif (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {\n\t\tif ($defineProperty) {\n\t\t\t$defineProperty(object, toStringTag, {\n\t\t\t\tconfigurable: !nonConfigurable,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: value,\n\t\t\t\twritable: false\n\t\t\t});\n\t\t} else {\n\t\t\tobject[toStringTag] = value; // eslint-disable-line no-param-reassign\n\t\t}\n\t}\n};\n","'use strict';\n\n// populates missing values\nmodule.exports = function (dst, src) {\n  Object.keys(src).forEach(function (prop) {\n    dst[prop] = dst[prop] || src[prop]; // eslint-disable-line no-param-reassign\n  });\n\n  return dst;\n};\n","'use strict';\n\nvar CombinedStream = require('combined-stream');\nvar util = require('util');\nvar path = require('path');\nvar http = require('http');\nvar https = require('https');\nvar parseUrl = require('url').parse;\nvar fs = require('fs');\nvar Stream = require('stream').Stream;\nvar crypto = require('crypto');\nvar mime = require('mime-types');\nvar asynckit = require('asynckit');\nvar setToStringTag = require('es-set-tostringtag');\nvar hasOwn = require('hasown');\nvar populate = require('./populate.js');\n\n/**\n * Create readable \"multipart/form-data\" streams.\n * Can be used to submit forms\n * and file uploads to other web applications.\n *\n * @constructor\n * @param {object} options - Properties to be added/overriden for FormData and CombinedStream\n */\nfunction FormData(options) {\n  if (!(this instanceof FormData)) {\n    return new FormData(options);\n  }\n\n  this._overheadLength = 0;\n  this._valueLength = 0;\n  this._valuesToMeasure = [];\n\n  CombinedStream.call(this);\n\n  options = options || {}; // eslint-disable-line no-param-reassign\n  for (var option in options) { // eslint-disable-line no-restricted-syntax\n    this[option] = options[option];\n  }\n}\n\n// make it a Stream\nutil.inherits(FormData, CombinedStream);\n\nFormData.LINE_BREAK = '\\r\\n';\nFormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';\n\nFormData.prototype.append = function (field, value, options) {\n  options = options || {}; // eslint-disable-line no-param-reassign\n\n  // allow filename as single option\n  if (typeof options === 'string') {\n    options = { filename: options }; // eslint-disable-line no-param-reassign\n  }\n\n  var append = CombinedStream.prototype.append.bind(this);\n\n  // all that streamy business can't handle numbers\n  if (typeof value === 'number' || value == null) {\n    value = String(value); // eslint-disable-line no-param-reassign\n  }\n\n  // https://github.com/felixge/node-form-data/issues/38\n  if (Array.isArray(value)) {\n    /*\n     * Please convert your array into string\n     * the way web server expects it\n     */\n    this._error(new Error('Arrays are not supported.'));\n    return;\n  }\n\n  var header = this._multiPartHeader(field, value, options);\n  var footer = this._multiPartFooter();\n\n  append(header);\n  append(value);\n  append(footer);\n\n  // pass along options.knownLength\n  this._trackLength(header, value, options);\n};\n\nFormData.prototype._trackLength = function (header, value, options) {\n  var valueLength = 0;\n\n  /*\n   * used w/ getLengthSync(), when length is known.\n   * e.g. for streaming directly from a remote server,\n   * w/ a known file a size, and not wanting to wait for\n   * incoming file to finish to get its size.\n   */\n  if (options.knownLength != null) {\n    valueLength += Number(options.knownLength);\n  } else if (Buffer.isBuffer(value)) {\n    valueLength = value.length;\n  } else if (typeof value === 'string') {\n    valueLength = Buffer.byteLength(value);\n  }\n\n  this._valueLength += valueLength;\n\n  // @check why add CRLF? does this account for custom/multiple CRLFs?\n  this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;\n\n  // empty or either doesn't have path or not an http response or not a stream\n  if (!value || (!value.path && !(value.readable && hasOwn(value, 'httpVersion')) && !(value instanceof Stream))) {\n    return;\n  }\n\n  // no need to bother with the length\n  if (!options.knownLength) {\n    this._valuesToMeasure.push(value);\n  }\n};\n\nFormData.prototype._lengthRetriever = function (value, callback) {\n  if (hasOwn(value, 'fd')) {\n    // take read range into a account\n    // `end` = Infinity > read file till the end\n    //\n    // TODO: Looks like there is bug in Node fs.createReadStream\n    // it doesn't respect `end` options without `start` options\n    // Fix it when node fixes it.\n    // https://github.com/joyent/node/issues/7819\n    if (value.end != undefined && value.end != Infinity && value.start != undefined) {\n      // when end specified\n      // no need to calculate range\n      // inclusive, starts with 0\n      callback(null, value.end + 1 - (value.start ? value.start : 0)); // eslint-disable-line callback-return\n\n      // not that fast snoopy\n    } else {\n      // still need to fetch file size from fs\n      fs.stat(value.path, function (err, stat) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        // update final size based on the range options\n        var fileSize = stat.size - (value.start ? value.start : 0);\n        callback(null, fileSize);\n      });\n    }\n\n    // or http response\n  } else if (hasOwn(value, 'httpVersion')) {\n    callback(null, Number(value.headers['content-length'])); // eslint-disable-line callback-return\n\n    // or request stream http://github.com/mikeal/request\n  } else if (hasOwn(value, 'httpModule')) {\n    // wait till response come back\n    value.on('response', function (response) {\n      value.pause();\n      callback(null, Number(response.headers['content-length']));\n    });\n    value.resume();\n\n    // something else\n  } else {\n    callback('Unknown stream'); // eslint-disable-line callback-return\n  }\n};\n\nFormData.prototype._multiPartHeader = function (field, value, options) {\n  /*\n   * custom header specified (as string)?\n   * it becomes responsible for boundary\n   * (e.g. to handle extra CRLFs on .NET servers)\n   */\n  if (typeof options.header === 'string') {\n    return options.header;\n  }\n\n  var contentDisposition = this._getContentDisposition(value, options);\n  var contentType = this._getContentType(value, options);\n\n  var contents = '';\n  var headers = {\n    // add custom disposition as third element or keep it two elements if not\n    'Content-Disposition': ['form-data', 'name=\"' + field + '\"'].concat(contentDisposition || []),\n    // if no content type. allow it to be empty array\n    'Content-Type': [].concat(contentType || [])\n  };\n\n  // allow custom headers.\n  if (typeof options.header === 'object') {\n    populate(headers, options.header);\n  }\n\n  var header;\n  for (var prop in headers) { // eslint-disable-line no-restricted-syntax\n    if (hasOwn(headers, prop)) {\n      header = headers[prop];\n\n      // skip nullish headers.\n      if (header == null) {\n        continue; // eslint-disable-line no-restricted-syntax, no-continue\n      }\n\n      // convert all headers to arrays.\n      if (!Array.isArray(header)) {\n        header = [header];\n      }\n\n      // add non-empty headers.\n      if (header.length) {\n        contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;\n      }\n    }\n  }\n\n  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;\n};\n\nFormData.prototype._getContentDisposition = function (value, options) { // eslint-disable-line consistent-return\n  var filename;\n\n  if (typeof options.filepath === 'string') {\n    // custom filepath for relative paths\n    filename = path.normalize(options.filepath).replace(/\\\\/g, '/');\n  } else if (options.filename || (value && (value.name || value.path))) {\n    /*\n     * custom filename take precedence\n     * formidable and the browser add a name property\n     * fs- and request- streams have path property\n     */\n    filename = path.basename(options.filename || (value && (value.name || value.path)));\n  } else if (value && value.readable && hasOwn(value, 'httpVersion')) {\n    // or try http response\n    filename = path.basename(value.client._httpMessage.path || '');\n  }\n\n  if (filename) {\n    return 'filename=\"' + filename + '\"';\n  }\n};\n\nFormData.prototype._getContentType = function (value, options) {\n  // use custom content-type above all\n  var contentType = options.contentType;\n\n  // or try `name` from formidable, browser\n  if (!contentType && value && value.name) {\n    contentType = mime.lookup(value.name);\n  }\n\n  // or try `path` from fs-, request- streams\n  if (!contentType && value && value.path) {\n    contentType = mime.lookup(value.path);\n  }\n\n  // or if it's http-reponse\n  if (!contentType && value && value.readable && hasOwn(value, 'httpVersion')) {\n    contentType = value.headers['content-type'];\n  }\n\n  // or guess it from the filepath or filename\n  if (!contentType && (options.filepath || options.filename)) {\n    contentType = mime.lookup(options.filepath || options.filename);\n  }\n\n  // fallback to the default content type if `value` is not simple value\n  if (!contentType && value && typeof value === 'object') {\n    contentType = FormData.DEFAULT_CONTENT_TYPE;\n  }\n\n  return contentType;\n};\n\nFormData.prototype._multiPartFooter = function () {\n  return function (next) {\n    var footer = FormData.LINE_BREAK;\n\n    var lastPart = this._streams.length === 0;\n    if (lastPart) {\n      footer += this._lastBoundary();\n    }\n\n    next(footer);\n  }.bind(this);\n};\n\nFormData.prototype._lastBoundary = function () {\n  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;\n};\n\nFormData.prototype.getHeaders = function (userHeaders) {\n  var header;\n  var formHeaders = {\n    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()\n  };\n\n  for (header in userHeaders) { // eslint-disable-line no-restricted-syntax\n    if (hasOwn(userHeaders, header)) {\n      formHeaders[header.toLowerCase()] = userHeaders[header];\n    }\n  }\n\n  return formHeaders;\n};\n\nFormData.prototype.setBoundary = function (boundary) {\n  if (typeof boundary !== 'string') {\n    throw new TypeError('FormData boundary must be a string');\n  }\n  this._boundary = boundary;\n};\n\nFormData.prototype.getBoundary = function () {\n  if (!this._boundary) {\n    this._generateBoundary();\n  }\n\n  return this._boundary;\n};\n\nFormData.prototype.getBuffer = function () {\n  var dataBuffer = new Buffer.alloc(0); // eslint-disable-line new-cap\n  var boundary = this.getBoundary();\n\n  // Create the form content. Add Line breaks to the end of data.\n  for (var i = 0, len = this._streams.length; i < len; i++) {\n    if (typeof this._streams[i] !== 'function') {\n      // Add content to the buffer.\n      if (Buffer.isBuffer(this._streams[i])) {\n        dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);\n      } else {\n        dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);\n      }\n\n      // Add break after content.\n      if (typeof this._streams[i] !== 'string' || this._streams[i].substring(2, boundary.length + 2) !== boundary) {\n        dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData.LINE_BREAK)]);\n      }\n    }\n  }\n\n  // Add the footer and return the Buffer object.\n  return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);\n};\n\nFormData.prototype._generateBoundary = function () {\n  // This generates a 50 character boundary similar to those used by Firefox.\n\n  // They are optimized for boyer-moore parsing.\n  this._boundary = '--------------------------' + crypto.randomBytes(12).toString('hex');\n};\n\n// Note: getLengthSync DOESN'T calculate streams length\n// As workaround one can calculate file size manually and add it as knownLength option\nFormData.prototype.getLengthSync = function () {\n  var knownLength = this._overheadLength + this._valueLength;\n\n  // Don't get confused, there are 3 \"internal\" streams for each keyval pair so it basically checks if there is any value added to the form\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  }\n\n  // https://github.com/form-data/form-data/issues/40\n  if (!this.hasKnownLength()) {\n    /*\n     * Some async length retrievers are present\n     * therefore synchronous length calculation is false.\n     * Please use getLength(callback) to get proper length\n     */\n    this._error(new Error('Cannot calculate proper length in synchronous way.'));\n  }\n\n  return knownLength;\n};\n\n// Public API to check if length of added values is known\n// https://github.com/form-data/form-data/issues/196\n// https://github.com/form-data/form-data/issues/262\nFormData.prototype.hasKnownLength = function () {\n  var hasKnownLength = true;\n\n  if (this._valuesToMeasure.length) {\n    hasKnownLength = false;\n  }\n\n  return hasKnownLength;\n};\n\nFormData.prototype.getLength = function (cb) {\n  var knownLength = this._overheadLength + this._valueLength;\n\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  }\n\n  if (!this._valuesToMeasure.length) {\n    process.nextTick(cb.bind(this, null, knownLength));\n    return;\n  }\n\n  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function (err, values) {\n    if (err) {\n      cb(err);\n      return;\n    }\n\n    values.forEach(function (length) {\n      knownLength += length;\n    });\n\n    cb(null, knownLength);\n  });\n};\n\nFormData.prototype.submit = function (params, cb) {\n  var request;\n  var options;\n  var defaults = { method: 'post' };\n\n  // parse provided url if it's string or treat it as options object\n  if (typeof params === 'string') {\n    params = parseUrl(params); // eslint-disable-line no-param-reassign\n    /* eslint sort-keys: 0 */\n    options = populate({\n      port: params.port,\n      path: params.pathname,\n      host: params.hostname,\n      protocol: params.protocol\n    }, defaults);\n  } else { // use custom params\n    options = populate(params, defaults);\n    // if no port provided use default one\n    if (!options.port) {\n      options.port = options.protocol === 'https:' ? 443 : 80;\n    }\n  }\n\n  // put that good code in getHeaders to some use\n  options.headers = this.getHeaders(params.headers);\n\n  // https if specified, fallback to http in any other case\n  if (options.protocol === 'https:') {\n    request = https.request(options);\n  } else {\n    request = http.request(options);\n  }\n\n  // get content length and fire away\n  this.getLength(function (err, length) {\n    if (err && err !== 'Unknown stream') {\n      this._error(err);\n      return;\n    }\n\n    // add content length\n    if (length) {\n      request.setHeader('Content-Length', length);\n    }\n\n    this.pipe(request);\n    if (cb) {\n      var onResponse;\n\n      var callback = function (error, responce) {\n        request.removeListener('error', callback);\n        request.removeListener('response', onResponse);\n\n        return cb.call(this, error, responce); // eslint-disable-line no-invalid-this\n      };\n\n      onResponse = callback.bind(this, null);\n\n      request.on('error', callback);\n      request.on('response', onResponse);\n    }\n  }.bind(this));\n\n  return request;\n};\n\nFormData.prototype._error = function (err) {\n  if (!this.error) {\n    this.error = err;\n    this.pause();\n    this.emit('error', err);\n  }\n};\n\nFormData.prototype.toString = function () {\n  return '[object FormData]';\n};\nsetToStringTag(FormData, 'FormData');\n\n// Public API\nmodule.exports = FormData;\n","'use strict';\n\nvar parseUrl = require('url').parse;\n\nvar DEFAULT_PORTS = {\n  ftp: 21,\n  gopher: 70,\n  http: 80,\n  https: 443,\n  ws: 80,\n  wss: 443,\n};\n\nvar stringEndsWith = String.prototype.endsWith || function(s) {\n  return s.length <= this.length &&\n    this.indexOf(s, this.length - s.length) !== -1;\n};\n\n/**\n * @param {string|object} url - The URL, or the result from url.parse.\n * @return {string} The URL of the proxy that should handle the request to the\n *  given URL. If no proxy is set, this will be an empty string.\n */\nfunction getProxyForUrl(url) {\n  var parsedUrl = typeof url === 'string' ? parseUrl(url) : url || {};\n  var proto = parsedUrl.protocol;\n  var hostname = parsedUrl.host;\n  var port = parsedUrl.port;\n  if (typeof hostname !== 'string' || !hostname || typeof proto !== 'string') {\n    return '';  // Don't proxy URLs without a valid scheme or host.\n  }\n\n  proto = proto.split(':', 1)[0];\n  // Stripping ports in this way instead of using parsedUrl.hostname to make\n  // sure that the brackets around IPv6 addresses are kept.\n  hostname = hostname.replace(/:\\d*$/, '');\n  port = parseInt(port) || DEFAULT_PORTS[proto] || 0;\n  if (!shouldProxy(hostname, port)) {\n    return '';  // Don't proxy URLs that match NO_PROXY.\n  }\n\n  var proxy =\n    getEnv('npm_config_' + proto + '_proxy') ||\n    getEnv(proto + '_proxy') ||\n    getEnv('npm_config_proxy') ||\n    getEnv('all_proxy');\n  if (proxy && proxy.indexOf('://') === -1) {\n    // Missing scheme in proxy, default to the requested URL's scheme.\n    proxy = proto + '://' + proxy;\n  }\n  return proxy;\n}\n\n/**\n * Determines whether a given URL should be proxied.\n *\n * @param {string} hostname - The host name of the URL.\n * @param {number} port - The effective port of the URL.\n * @returns {boolean} Whether the given URL should be proxied.\n * @private\n */\nfunction shouldProxy(hostname, port) {\n  var NO_PROXY =\n    (getEnv('npm_config_no_proxy') || getEnv('no_proxy')).toLowerCase();\n  if (!NO_PROXY) {\n    return true;  // Always proxy if NO_PROXY is not set.\n  }\n  if (NO_PROXY === '*') {\n    return false;  // Never proxy if wildcard is set.\n  }\n\n  return NO_PROXY.split(/[,\\s]/).every(function(proxy) {\n    if (!proxy) {\n      return true;  // Skip zero-length hosts.\n    }\n    var parsedProxy = proxy.match(/^(.+):(\\d+)$/);\n    var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;\n    var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;\n    if (parsedProxyPort && parsedProxyPort !== port) {\n      return true;  // Skip if ports don't match.\n    }\n\n    if (!/^[.*]/.test(parsedProxyHostname)) {\n      // No wildcards, so stop proxying if there is an exact match.\n      return hostname !== parsedProxyHostname;\n    }\n\n    if (parsedProxyHostname.charAt(0) === '*') {\n      // Remove leading wildcard.\n      parsedProxyHostname = parsedProxyHostname.slice(1);\n    }\n    // Stop proxying if the hostname ends with the no_proxy host.\n    return !stringEndsWith.call(hostname, parsedProxyHostname);\n  });\n}\n\n/**\n * Get the value for an environment variable.\n *\n * @param {string} key - The name of the environment variable.\n * @return {string} The value of the environment variable.\n * @private\n */\nfunction getEnv(key) {\n  return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || '';\n}\n\nexports.getProxyForUrl = getProxyForUrl;\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '')\n\t\t\t.trim()\n\t\t\t.replace(/\\s+/g, ',')\n\t\t\t.split(',')\n\t\t\t.filter(Boolean);\n\n\t\tfor (const ns of split) {\n\t\t\tif (ns[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(ns.slice(1));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(ns);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the given string matches a namespace template, honoring\n\t * asterisks as wildcards.\n\t *\n\t * @param {String} search\n\t * @param {String} template\n\t * @return {Boolean}\n\t */\n\tfunction matchesTemplate(search, template) {\n\t\tlet searchIndex = 0;\n\t\tlet templateIndex = 0;\n\t\tlet starIndex = -1;\n\t\tlet matchIndex = 0;\n\n\t\twhile (searchIndex < search.length) {\n\t\t\tif (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {\n\t\t\t\t// Match character or proceed with wildcard\n\t\t\t\tif (template[templateIndex] === '*') {\n\t\t\t\t\tstarIndex = templateIndex;\n\t\t\t\t\tmatchIndex = searchIndex;\n\t\t\t\t\ttemplateIndex++; // Skip the '*'\n\t\t\t\t} else {\n\t\t\t\t\tsearchIndex++;\n\t\t\t\t\ttemplateIndex++;\n\t\t\t\t}\n\t\t\t} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition\n\t\t\t\t// Backtrack to the last '*' and try to match more characters\n\t\t\t\ttemplateIndex = starIndex + 1;\n\t\t\t\tmatchIndex++;\n\t\t\t\tsearchIndex = matchIndex;\n\t\t\t} else {\n\t\t\t\treturn false; // No match\n\t\t\t}\n\t\t}\n\n\t\t// Handle trailing '*' in template\n\t\twhile (templateIndex < template.length && template[templateIndex] === '*') {\n\t\t\ttemplateIndex++;\n\t\t}\n\n\t\treturn templateIndex === template.length;\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names,\n\t\t\t...createDebug.skips.map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tfor (const skip of createDebug.skips) {\n\t\t\tif (matchesTemplate(name, skip)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (const ns of createDebug.names) {\n\t\t\tif (matchesTemplate(name, ns)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Module dependencies.\n */\n\nconst tty = require('tty');\nconst util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(\n\t() => {},\n\t'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'\n);\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = require('supports-color');\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.split('\\n')\n\t\t.map(str => str.trim())\n\t\t.join(' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\t// eslint-disable-next-line no-return-assign\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG') ;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {\n\tmodule.exports = require('./browser.js');\n} else {\n\tmodule.exports = require('./node.js');\n}\n","var debug;\n\nmodule.exports = function () {\n  if (!debug) {\n    try {\n      /* eslint global-require: off */\n      debug = require(\"debug\")(\"follow-redirects\");\n    }\n    catch (error) { /* */ }\n    if (typeof debug !== \"function\") {\n      debug = function () { /* */ };\n    }\n  }\n  debug.apply(null, arguments);\n};\n","var url = require(\"url\");\nvar URL = url.URL;\nvar http = require(\"http\");\nvar https = require(\"https\");\nvar Writable = require(\"stream\").Writable;\nvar assert = require(\"assert\");\nvar debug = require(\"./debug\");\n\n// Preventive platform detection\n// istanbul ignore next\n(function detectUnsupportedEnvironment() {\n  var looksLikeNode = typeof process !== \"undefined\";\n  var looksLikeBrowser = typeof window !== \"undefined\" && typeof document !== \"undefined\";\n  var looksLikeV8 = isFunction(Error.captureStackTrace);\n  if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {\n    console.warn(\"The follow-redirects package should be excluded from browser builds.\");\n  }\n}());\n\n// Whether to use the native URL object or the legacy url module\nvar useNativeURL = false;\ntry {\n  assert(new URL(\"\"));\n}\ncatch (error) {\n  useNativeURL = error.code === \"ERR_INVALID_URL\";\n}\n\n// URL fields to preserve in copy operations\nvar preservedUrlFields = [\n  \"auth\",\n  \"host\",\n  \"hostname\",\n  \"href\",\n  \"path\",\n  \"pathname\",\n  \"port\",\n  \"protocol\",\n  \"query\",\n  \"search\",\n  \"hash\",\n];\n\n// Create handlers that pass events from native requests\nvar events = [\"abort\", \"aborted\", \"connect\", \"error\", \"socket\", \"timeout\"];\nvar eventHandlers = Object.create(null);\nevents.forEach(function (event) {\n  eventHandlers[event] = function (arg1, arg2, arg3) {\n    this._redirectable.emit(event, arg1, arg2, arg3);\n  };\n});\n\n// Error types with codes\nvar InvalidUrlError = createErrorType(\n  \"ERR_INVALID_URL\",\n  \"Invalid URL\",\n  TypeError\n);\nvar RedirectionError = createErrorType(\n  \"ERR_FR_REDIRECTION_FAILURE\",\n  \"Redirected request failed\"\n);\nvar TooManyRedirectsError = createErrorType(\n  \"ERR_FR_TOO_MANY_REDIRECTS\",\n  \"Maximum number of redirects exceeded\",\n  RedirectionError\n);\nvar MaxBodyLengthExceededError = createErrorType(\n  \"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\",\n  \"Request body larger than maxBodyLength limit\"\n);\nvar WriteAfterEndError = createErrorType(\n  \"ERR_STREAM_WRITE_AFTER_END\",\n  \"write after end\"\n);\n\n// istanbul ignore next\nvar destroy = Writable.prototype.destroy || noop;\n\n// An HTTP(S) request that can be redirected\nfunction RedirectableRequest(options, responseCallback) {\n  // Initialize the request\n  Writable.call(this);\n  this._sanitizeOptions(options);\n  this._options = options;\n  this._ended = false;\n  this._ending = false;\n  this._redirectCount = 0;\n  this._redirects = [];\n  this._requestBodyLength = 0;\n  this._requestBodyBuffers = [];\n\n  // Attach a callback if passed\n  if (responseCallback) {\n    this.on(\"response\", responseCallback);\n  }\n\n  // React to responses of native requests\n  var self = this;\n  this._onNativeResponse = function (response) {\n    try {\n      self._processResponse(response);\n    }\n    catch (cause) {\n      self.emit(\"error\", cause instanceof RedirectionError ?\n        cause : new RedirectionError({ cause: cause }));\n    }\n  };\n\n  // Perform the first request\n  this._performRequest();\n}\nRedirectableRequest.prototype = Object.create(Writable.prototype);\n\nRedirectableRequest.prototype.abort = function () {\n  destroyRequest(this._currentRequest);\n  this._currentRequest.abort();\n  this.emit(\"abort\");\n};\n\nRedirectableRequest.prototype.destroy = function (error) {\n  destroyRequest(this._currentRequest, error);\n  destroy.call(this, error);\n  return this;\n};\n\n// Writes buffered data to the current native request\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\n  // Writing is not allowed if end has been called\n  if (this._ending) {\n    throw new WriteAfterEndError();\n  }\n\n  // Validate input and shift parameters if necessary\n  if (!isString(data) && !isBuffer(data)) {\n    throw new TypeError(\"data should be a string, Buffer or Uint8Array\");\n  }\n  if (isFunction(encoding)) {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Ignore empty buffers, since writing them doesn't invoke the callback\n  // https://github.com/nodejs/node/issues/22066\n  if (data.length === 0) {\n    if (callback) {\n      callback();\n    }\n    return;\n  }\n  // Only write when we don't exceed the maximum body length\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n    this._requestBodyLength += data.length;\n    this._requestBodyBuffers.push({ data: data, encoding: encoding });\n    this._currentRequest.write(data, encoding, callback);\n  }\n  // Error when we exceed the maximum body length\n  else {\n    this.emit(\"error\", new MaxBodyLengthExceededError());\n    this.abort();\n  }\n};\n\n// Ends the current native request\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\n  // Shift parameters if necessary\n  if (isFunction(data)) {\n    callback = data;\n    data = encoding = null;\n  }\n  else if (isFunction(encoding)) {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Write data if needed and end\n  if (!data) {\n    this._ended = this._ending = true;\n    this._currentRequest.end(null, null, callback);\n  }\n  else {\n    var self = this;\n    var currentRequest = this._currentRequest;\n    this.write(data, encoding, function () {\n      self._ended = true;\n      currentRequest.end(null, null, callback);\n    });\n    this._ending = true;\n  }\n};\n\n// Sets a header value on the current native request\nRedirectableRequest.prototype.setHeader = function (name, value) {\n  this._options.headers[name] = value;\n  this._currentRequest.setHeader(name, value);\n};\n\n// Clears a header value on the current native request\nRedirectableRequest.prototype.removeHeader = function (name) {\n  delete this._options.headers[name];\n  this._currentRequest.removeHeader(name);\n};\n\n// Global timeout for all underlying requests\nRedirectableRequest.prototype.setTimeout = function (msecs, callback) {\n  var self = this;\n\n  // Destroys the socket on timeout\n  function destroyOnTimeout(socket) {\n    socket.setTimeout(msecs);\n    socket.removeListener(\"timeout\", socket.destroy);\n    socket.addListener(\"timeout\", socket.destroy);\n  }\n\n  // Sets up a timer to trigger a timeout event\n  function startTimer(socket) {\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n    }\n    self._timeout = setTimeout(function () {\n      self.emit(\"timeout\");\n      clearTimer();\n    }, msecs);\n    destroyOnTimeout(socket);\n  }\n\n  // Stops a timeout from triggering\n  function clearTimer() {\n    // Clear the timeout\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n      self._timeout = null;\n    }\n\n    // Clean up all attached listeners\n    self.removeListener(\"abort\", clearTimer);\n    self.removeListener(\"error\", clearTimer);\n    self.removeListener(\"response\", clearTimer);\n    self.removeListener(\"close\", clearTimer);\n    if (callback) {\n      self.removeListener(\"timeout\", callback);\n    }\n    if (!self.socket) {\n      self._currentRequest.removeListener(\"socket\", startTimer);\n    }\n  }\n\n  // Attach callback if passed\n  if (callback) {\n    this.on(\"timeout\", callback);\n  }\n\n  // Start the timer if or when the socket is opened\n  if (this.socket) {\n    startTimer(this.socket);\n  }\n  else {\n    this._currentRequest.once(\"socket\", startTimer);\n  }\n\n  // Clean up on events\n  this.on(\"socket\", destroyOnTimeout);\n  this.on(\"abort\", clearTimer);\n  this.on(\"error\", clearTimer);\n  this.on(\"response\", clearTimer);\n  this.on(\"close\", clearTimer);\n\n  return this;\n};\n\n// Proxy all other public ClientRequest methods\n[\n  \"flushHeaders\", \"getHeader\",\n  \"setNoDelay\", \"setSocketKeepAlive\",\n].forEach(function (method) {\n  RedirectableRequest.prototype[method] = function (a, b) {\n    return this._currentRequest[method](a, b);\n  };\n});\n\n// Proxy all public ClientRequest properties\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\n  Object.defineProperty(RedirectableRequest.prototype, property, {\n    get: function () { return this._currentRequest[property]; },\n  });\n});\n\nRedirectableRequest.prototype._sanitizeOptions = function (options) {\n  // Ensure headers are always present\n  if (!options.headers) {\n    options.headers = {};\n  }\n\n  // Since http.request treats host as an alias of hostname,\n  // but the url module interprets host as hostname plus port,\n  // eliminate the host property to avoid confusion.\n  if (options.host) {\n    // Use hostname if set, because it has precedence\n    if (!options.hostname) {\n      options.hostname = options.host;\n    }\n    delete options.host;\n  }\n\n  // Complete the URL object when necessary\n  if (!options.pathname && options.path) {\n    var searchPos = options.path.indexOf(\"?\");\n    if (searchPos < 0) {\n      options.pathname = options.path;\n    }\n    else {\n      options.pathname = options.path.substring(0, searchPos);\n      options.search = options.path.substring(searchPos);\n    }\n  }\n};\n\n\n// Executes the next native request (initial or redirect)\nRedirectableRequest.prototype._performRequest = function () {\n  // Load the native protocol\n  var protocol = this._options.protocol;\n  var nativeProtocol = this._options.nativeProtocols[protocol];\n  if (!nativeProtocol) {\n    throw new TypeError(\"Unsupported protocol \" + protocol);\n  }\n\n  // If specified, use the agent corresponding to the protocol\n  // (HTTP and HTTPS use different types of agents)\n  if (this._options.agents) {\n    var scheme = protocol.slice(0, -1);\n    this._options.agent = this._options.agents[scheme];\n  }\n\n  // Create the native request and set up its event handlers\n  var request = this._currentRequest =\n        nativeProtocol.request(this._options, this._onNativeResponse);\n  request._redirectable = this;\n  for (var event of events) {\n    request.on(event, eventHandlers[event]);\n  }\n\n  // RFC72305.3.1: When making a request directly to an origin server, []\n  // a client MUST send only the absolute path [] as the request-target.\n  this._currentUrl = /^\\//.test(this._options.path) ?\n    url.format(this._options) :\n    // When making a request to a proxy, []\n    // a client MUST send the target URI in absolute-form [].\n    this._options.path;\n\n  // End a redirected request\n  // (The first request must be ended explicitly with RedirectableRequest#end)\n  if (this._isRedirect) {\n    // Write the request entity and end\n    var i = 0;\n    var self = this;\n    var buffers = this._requestBodyBuffers;\n    (function writeNext(error) {\n      // Only write if this request has not been redirected yet\n      // istanbul ignore else\n      if (request === self._currentRequest) {\n        // Report any write errors\n        // istanbul ignore if\n        if (error) {\n          self.emit(\"error\", error);\n        }\n        // Write the next buffer if there are still left\n        else if (i < buffers.length) {\n          var buffer = buffers[i++];\n          // istanbul ignore else\n          if (!request.finished) {\n            request.write(buffer.data, buffer.encoding, writeNext);\n          }\n        }\n        // End the request if `end` has been called on us\n        else if (self._ended) {\n          request.end();\n        }\n      }\n    }());\n  }\n};\n\n// Processes a response from the current native request\nRedirectableRequest.prototype._processResponse = function (response) {\n  // Store the redirected response\n  var statusCode = response.statusCode;\n  if (this._options.trackRedirects) {\n    this._redirects.push({\n      url: this._currentUrl,\n      headers: response.headers,\n      statusCode: statusCode,\n    });\n  }\n\n  // RFC72316.4: The 3xx (Redirection) class of status code indicates\n  // that further action needs to be taken by the user agent in order to\n  // fulfill the request. If a Location header field is provided,\n  // the user agent MAY automatically redirect its request to the URI\n  // referenced by the Location field value,\n  // even if the specific status code is not understood.\n\n  // If the response is not a redirect; return it as-is\n  var location = response.headers.location;\n  if (!location || this._options.followRedirects === false ||\n      statusCode < 300 || statusCode >= 400) {\n    response.responseUrl = this._currentUrl;\n    response.redirects = this._redirects;\n    this.emit(\"response\", response);\n\n    // Clean up\n    this._requestBodyBuffers = [];\n    return;\n  }\n\n  // The response is a redirect, so abort the current request\n  destroyRequest(this._currentRequest);\n  // Discard the remainder of the response to avoid waiting for data\n  response.destroy();\n\n  // RFC72316.4: A client SHOULD detect and intervene\n  // in cyclical redirections (i.e., \"infinite\" redirection loops).\n  if (++this._redirectCount > this._options.maxRedirects) {\n    throw new TooManyRedirectsError();\n  }\n\n  // Store the request headers if applicable\n  var requestHeaders;\n  var beforeRedirect = this._options.beforeRedirect;\n  if (beforeRedirect) {\n    requestHeaders = Object.assign({\n      // The Host header was set by nativeProtocol.request\n      Host: response.req.getHeader(\"host\"),\n    }, this._options.headers);\n  }\n\n  // RFC72316.4: Automatic redirection needs to done with\n  // care for methods not known to be safe, []\n  // RFC72316.4.23: For historical reasons, a user agent MAY change\n  // the request method from POST to GET for the subsequent request.\n  var method = this._options.method;\n  if ((statusCode === 301 || statusCode === 302) && this._options.method === \"POST\" ||\n      // RFC72316.4.4: The 303 (See Other) status code indicates that\n      // the server is redirecting the user agent to a different resource []\n      // A user agent can perform a retrieval request targeting that URI\n      // (a GET or HEAD request if using HTTP) []\n      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {\n    this._options.method = \"GET\";\n    // Drop a possible entity and headers related to it\n    this._requestBodyBuffers = [];\n    removeMatchingHeaders(/^content-/i, this._options.headers);\n  }\n\n  // Drop the Host header, as the redirect might lead to a different host\n  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);\n\n  // If the redirect is relative, carry over the host of the last request\n  var currentUrlParts = parseUrl(this._currentUrl);\n  var currentHost = currentHostHeader || currentUrlParts.host;\n  var currentUrl = /^\\w+:/.test(location) ? this._currentUrl :\n    url.format(Object.assign(currentUrlParts, { host: currentHost }));\n\n  // Create the redirected request\n  var redirectUrl = resolveUrl(location, currentUrl);\n  debug(\"redirecting to\", redirectUrl.href);\n  this._isRedirect = true;\n  spreadUrlObject(redirectUrl, this._options);\n\n  // Drop confidential headers when redirecting to a less secure protocol\n  // or to a different domain that is not a superdomain\n  if (redirectUrl.protocol !== currentUrlParts.protocol &&\n     redirectUrl.protocol !== \"https:\" ||\n     redirectUrl.host !== currentHost &&\n     !isSubdomain(redirectUrl.host, currentHost)) {\n    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);\n  }\n\n  // Evaluate the beforeRedirect callback\n  if (isFunction(beforeRedirect)) {\n    var responseDetails = {\n      headers: response.headers,\n      statusCode: statusCode,\n    };\n    var requestDetails = {\n      url: currentUrl,\n      method: method,\n      headers: requestHeaders,\n    };\n    beforeRedirect(this._options, responseDetails, requestDetails);\n    this._sanitizeOptions(this._options);\n  }\n\n  // Perform the redirected request\n  this._performRequest();\n};\n\n// Wraps the key/value object of protocols with redirect functionality\nfunction wrap(protocols) {\n  // Default settings\n  var exports = {\n    maxRedirects: 21,\n    maxBodyLength: 10 * 1024 * 1024,\n  };\n\n  // Wrap each protocol\n  var nativeProtocols = {};\n  Object.keys(protocols).forEach(function (scheme) {\n    var protocol = scheme + \":\";\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\n\n    // Executes a request, following redirects\n    function request(input, options, callback) {\n      // Parse parameters, ensuring that input is an object\n      if (isURL(input)) {\n        input = spreadUrlObject(input);\n      }\n      else if (isString(input)) {\n        input = spreadUrlObject(parseUrl(input));\n      }\n      else {\n        callback = options;\n        options = validateUrl(input);\n        input = { protocol: protocol };\n      }\n      if (isFunction(options)) {\n        callback = options;\n        options = null;\n      }\n\n      // Set defaults\n      options = Object.assign({\n        maxRedirects: exports.maxRedirects,\n        maxBodyLength: exports.maxBodyLength,\n      }, input, options);\n      options.nativeProtocols = nativeProtocols;\n      if (!isString(options.host) && !isString(options.hostname)) {\n        options.hostname = \"::1\";\n      }\n\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\n      debug(\"options\", options);\n      return new RedirectableRequest(options, callback);\n    }\n\n    // Executes a GET request, following redirects\n    function get(input, options, callback) {\n      var wrappedRequest = wrappedProtocol.request(input, options, callback);\n      wrappedRequest.end();\n      return wrappedRequest;\n    }\n\n    // Expose the properties on the wrapped protocol\n    Object.defineProperties(wrappedProtocol, {\n      request: { value: request, configurable: true, enumerable: true, writable: true },\n      get: { value: get, configurable: true, enumerable: true, writable: true },\n    });\n  });\n  return exports;\n}\n\nfunction noop() { /* empty */ }\n\nfunction parseUrl(input) {\n  var parsed;\n  // istanbul ignore else\n  if (useNativeURL) {\n    parsed = new URL(input);\n  }\n  else {\n    // Ensure the URL is valid and absolute\n    parsed = validateUrl(url.parse(input));\n    if (!isString(parsed.protocol)) {\n      throw new InvalidUrlError({ input });\n    }\n  }\n  return parsed;\n}\n\nfunction resolveUrl(relative, base) {\n  // istanbul ignore next\n  return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));\n}\n\nfunction validateUrl(input) {\n  if (/^\\[/.test(input.hostname) && !/^\\[[:0-9a-f]+\\]$/i.test(input.hostname)) {\n    throw new InvalidUrlError({ input: input.href || input });\n  }\n  if (/^\\[/.test(input.host) && !/^\\[[:0-9a-f]+\\](:\\d+)?$/i.test(input.host)) {\n    throw new InvalidUrlError({ input: input.href || input });\n  }\n  return input;\n}\n\nfunction spreadUrlObject(urlObject, target) {\n  var spread = target || {};\n  for (var key of preservedUrlFields) {\n    spread[key] = urlObject[key];\n  }\n\n  // Fix IPv6 hostname\n  if (spread.hostname.startsWith(\"[\")) {\n    spread.hostname = spread.hostname.slice(1, -1);\n  }\n  // Ensure port is a number\n  if (spread.port !== \"\") {\n    spread.port = Number(spread.port);\n  }\n  // Concatenate path\n  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;\n\n  return spread;\n}\n\nfunction removeMatchingHeaders(regex, headers) {\n  var lastValue;\n  for (var header in headers) {\n    if (regex.test(header)) {\n      lastValue = headers[header];\n      delete headers[header];\n    }\n  }\n  return (lastValue === null || typeof lastValue === \"undefined\") ?\n    undefined : String(lastValue).trim();\n}\n\nfunction createErrorType(code, message, baseClass) {\n  // Create constructor\n  function CustomError(properties) {\n    // istanbul ignore else\n    if (isFunction(Error.captureStackTrace)) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n    Object.assign(this, properties || {});\n    this.code = code;\n    this.message = this.cause ? message + \": \" + this.cause.message : message;\n  }\n\n  // Attach constructor and set default properties\n  CustomError.prototype = new (baseClass || Error)();\n  Object.defineProperties(CustomError.prototype, {\n    constructor: {\n      value: CustomError,\n      enumerable: false,\n    },\n    name: {\n      value: \"Error [\" + code + \"]\",\n      enumerable: false,\n    },\n  });\n  return CustomError;\n}\n\nfunction destroyRequest(request, error) {\n  for (var event of events) {\n    request.removeListener(event, eventHandlers[event]);\n  }\n  request.on(\"error\", noop);\n  request.destroy(error);\n}\n\nfunction isSubdomain(subdomain, domain) {\n  assert(isString(subdomain) && isString(domain));\n  var dot = subdomain.length - domain.length - 1;\n  return dot > 0 && subdomain[dot] === \".\" && subdomain.endsWith(domain);\n}\n\nfunction isString(value) {\n  return typeof value === \"string\" || value instanceof String;\n}\n\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\n\nfunction isBuffer(value) {\n  return typeof value === \"object\" && (\"length\" in value);\n}\n\nfunction isURL(value) {\n  return URL && value instanceof URL;\n}\n\n// Exports\nmodule.exports = wrap({ http: http, https: https });\nmodule.exports.wrap = wrap;\n","'use strict';\n\nconst denyList = new Set([\n\t'ENOTFOUND',\n\t'ENETUNREACH',\n\n\t// SSL errors from https://github.com/nodejs/node/blob/fc8e3e2cdc521978351de257030db0076d79e0ab/src/crypto/crypto_common.cc#L301-L328\n\t'UNABLE_TO_GET_ISSUER_CERT',\n\t'UNABLE_TO_GET_CRL',\n\t'UNABLE_TO_DECRYPT_CERT_SIGNATURE',\n\t'UNABLE_TO_DECRYPT_CRL_SIGNATURE',\n\t'UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY',\n\t'CERT_SIGNATURE_FAILURE',\n\t'CRL_SIGNATURE_FAILURE',\n\t'CERT_NOT_YET_VALID',\n\t'CERT_HAS_EXPIRED',\n\t'CRL_NOT_YET_VALID',\n\t'CRL_HAS_EXPIRED',\n\t'ERROR_IN_CERT_NOT_BEFORE_FIELD',\n\t'ERROR_IN_CERT_NOT_AFTER_FIELD',\n\t'ERROR_IN_CRL_LAST_UPDATE_FIELD',\n\t'ERROR_IN_CRL_NEXT_UPDATE_FIELD',\n\t'OUT_OF_MEM',\n\t'DEPTH_ZERO_SELF_SIGNED_CERT',\n\t'SELF_SIGNED_CERT_IN_CHAIN',\n\t'UNABLE_TO_GET_ISSUER_CERT_LOCALLY',\n\t'UNABLE_TO_VERIFY_LEAF_SIGNATURE',\n\t'CERT_CHAIN_TOO_LONG',\n\t'CERT_REVOKED',\n\t'INVALID_CA',\n\t'PATH_LENGTH_EXCEEDED',\n\t'INVALID_PURPOSE',\n\t'CERT_UNTRUSTED',\n\t'CERT_REJECTED',\n\t'HOSTNAME_MISMATCH'\n]);\n\n// TODO: Use `error?.code` when targeting Node.js 14\nmodule.exports = error => !denyList.has(error && error.code);\n","'use strict';\n\nimport bind from './helpers/bind.js';\n\n// utils is a library of generic helper functions non-specific to axios\n\nconst {toString} = Object.prototype;\nconst {getPrototypeOf} = Object;\nconst {iterator, toStringTag} = Symbol;\n\nconst kindOf = (cache => thing => {\n    const str = toString.call(thing);\n    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n})(Object.create(null));\n\nconst kindOfTest = (type) => {\n  type = type.toLowerCase();\n  return (thing) => kindOf(thing) === type\n}\n\nconst typeOfTest = type => thing => typeof thing === type;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n *\n * @returns {boolean} True if value is an Array, otherwise false\n */\nconst {isArray} = Array;\n\n/**\n * Determine if a value is undefined\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nconst isUndefined = typeOfTest('undefined');\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nconst isArrayBuffer = kindOfTest('ArrayBuffer');\n\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  let result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a String, otherwise false\n */\nconst isString = typeOfTest('string');\n\n/**\n * Determine if a value is a Function\n *\n * @param {*} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nconst isFunction = typeOfTest('function');\n\n/**\n * Determine if a value is a Number\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Number, otherwise false\n */\nconst isNumber = typeOfTest('number');\n\n/**\n * Determine if a value is an Object\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an Object, otherwise false\n */\nconst isObject = (thing) => thing !== null && typeof thing === 'object';\n\n/**\n * Determine if a value is a Boolean\n *\n * @param {*} thing The value to test\n * @returns {boolean} True if value is a Boolean, otherwise false\n */\nconst isBoolean = thing => thing === true || thing === false;\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a plain Object, otherwise false\n */\nconst isPlainObject = (val) => {\n  if (kindOf(val) !== 'object') {\n    return false;\n  }\n\n  const prototype = getPrototypeOf(val);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);\n}\n\n/**\n * Determine if a value is an empty object (safely handles Buffers)\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an empty object, otherwise false\n */\nconst isEmptyObject = (val) => {\n  // Early return for non-objects or Buffers to prevent RangeError\n  if (!isObject(val) || isBuffer(val)) {\n    return false;\n  }\n\n  try {\n    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;\n  } catch (e) {\n    // Fallback for any other objects that might cause RangeError with Object.keys()\n    return false;\n  }\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Date, otherwise false\n */\nconst isDate = kindOfTest('Date');\n\n/**\n * Determine if a value is a File\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFile = kindOfTest('File');\n\n/**\n * Determine if a value is a Blob\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nconst isBlob = kindOfTest('Blob');\n\n/**\n * Determine if a value is a FileList\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFileList = kindOfTest('FileList');\n\n/**\n * Determine if a value is a Stream\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nconst isStream = (val) => isObject(val) && isFunction(val.pipe);\n\n/**\n * Determine if a value is a FormData\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nconst isFormData = (thing) => {\n  let kind;\n  return thing && (\n    (typeof FormData === 'function' && thing instanceof FormData) || (\n      isFunction(thing.append) && (\n        (kind = kindOf(thing)) === 'formdata' ||\n        // detect form-data instance\n        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')\n      )\n    )\n  )\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nconst isURLSearchParams = kindOfTest('URLSearchParams');\n\nconst [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n *\n * @returns {String} The String freed of excess whitespace\n */\nconst trim = (str) => str.trim ?\n  str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n *\n * @param {Boolean} [allOwnKeys = false]\n * @returns {any}\n */\nfunction forEach(obj, fn, {allOwnKeys = false} = {}) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  let i;\n  let l;\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Buffer check\n    if (isBuffer(obj)) {\n      return;\n    }\n\n    // Iterate over object keys\n    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);\n    const len = keys.length;\n    let key;\n\n    for (i = 0; i < len; i++) {\n      key = keys[i];\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n}\n\nfunction findKey(obj, key) {\n  if (isBuffer(obj)){\n    return null;\n  }\n\n  key = key.toLowerCase();\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let _key;\n  while (i-- > 0) {\n    _key = keys[i];\n    if (key === _key.toLowerCase()) {\n      return _key;\n    }\n  }\n  return null;\n}\n\nconst _global = (() => {\n  /*eslint no-undef:0*/\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  return typeof self !== \"undefined\" ? self : (typeof window !== 'undefined' ? window : global)\n})();\n\nconst isContextDefined = (context) => !isUndefined(context) && context !== _global;\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n *\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  const {caseless, skipUndefined} = isContextDefined(this) && this || {};\n  const result = {};\n  const assignValue = (val, key) => {\n    const targetKey = caseless && findKey(result, key) || key;\n    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {\n      result[targetKey] = merge(result[targetKey], val);\n    } else if (isPlainObject(val)) {\n      result[targetKey] = merge({}, val);\n    } else if (isArray(val)) {\n      result[targetKey] = val.slice();\n    } else if (!skipUndefined || !isUndefined(val)) {\n      result[targetKey] = val;\n    }\n  }\n\n  for (let i = 0, l = arguments.length; i < l; i++) {\n    arguments[i] && forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n *\n * @param {Boolean} [allOwnKeys]\n * @returns {Object} The resulting value of object a\n */\nconst extend = (a, b, thisArg, {allOwnKeys}= {}) => {\n  forEach(b, (val, key) => {\n    if (thisArg && isFunction(val)) {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  }, {allOwnKeys});\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n *\n * @returns {string} content value without BOM\n */\nconst stripBOM = (content) => {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n *\n * @returns {void}\n */\nconst inherits = (constructor, superConstructor, props, descriptors) => {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  Object.defineProperty(constructor, 'super', {\n    value: superConstructor.prototype\n  });\n  props && Object.assign(constructor.prototype, props);\n}\n\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function|Boolean} [filter]\n * @param {Function} [propFilter]\n *\n * @returns {Object}\n */\nconst toFlatObject = (sourceObj, destObj, filter, propFilter) => {\n  let props;\n  let i;\n  let prop;\n  const merged = {};\n\n  destObj = destObj || {};\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  if (sourceObj == null) return destObj;\n\n  do {\n    props = Object.getOwnPropertyNames(sourceObj);\n    i = props.length;\n    while (i-- > 0) {\n      prop = props[i];\n      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {\n        destObj[prop] = sourceObj[prop];\n        merged[prop] = true;\n      }\n    }\n    sourceObj = filter !== false && getPrototypeOf(sourceObj);\n  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n\n  return destObj;\n}\n\n/**\n * Determines whether a string ends with the characters of a specified string\n *\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n *\n * @returns {boolean}\n */\nconst endsWith = (str, searchString, position) => {\n  str = String(str);\n  if (position === undefined || position > str.length) {\n    position = str.length;\n  }\n  position -= searchString.length;\n  const lastIndex = str.indexOf(searchString, position);\n  return lastIndex !== -1 && lastIndex === position;\n}\n\n\n/**\n * Returns new array from array like object or null if failed\n *\n * @param {*} [thing]\n *\n * @returns {?Array}\n */\nconst toArray = (thing) => {\n  if (!thing) return null;\n  if (isArray(thing)) return thing;\n  let i = thing.length;\n  if (!isNumber(i)) return null;\n  const arr = new Array(i);\n  while (i-- > 0) {\n    arr[i] = thing[i];\n  }\n  return arr;\n}\n\n/**\n * Checking if the Uint8Array exists and if it does, it returns a function that checks if the\n * thing passed in is an instance of Uint8Array\n *\n * @param {TypedArray}\n *\n * @returns {Array}\n */\n// eslint-disable-next-line func-names\nconst isTypedArray = (TypedArray => {\n  // eslint-disable-next-line func-names\n  return thing => {\n    return TypedArray && thing instanceof TypedArray;\n  };\n})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));\n\n/**\n * For each entry in the object, call the function with the key and value.\n *\n * @param {Object<any, any>} obj - The object to iterate over.\n * @param {Function} fn - The function to call for each entry.\n *\n * @returns {void}\n */\nconst forEachEntry = (obj, fn) => {\n  const generator = obj && obj[iterator];\n\n  const _iterator = generator.call(obj);\n\n  let result;\n\n  while ((result = _iterator.next()) && !result.done) {\n    const pair = result.value;\n    fn.call(obj, pair[0], pair[1]);\n  }\n}\n\n/**\n * It takes a regular expression and a string, and returns an array of all the matches\n *\n * @param {string} regExp - The regular expression to match against.\n * @param {string} str - The string to search.\n *\n * @returns {Array<boolean>}\n */\nconst matchAll = (regExp, str) => {\n  let matches;\n  const arr = [];\n\n  while ((matches = regExp.exec(str)) !== null) {\n    arr.push(matches);\n  }\n\n  return arr;\n}\n\n/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */\nconst isHTMLForm = kindOfTest('HTMLFormElement');\n\nconst toCamelCase = str => {\n  return str.toLowerCase().replace(/[-_\\s]([a-z\\d])(\\w*)/g,\n    function replacer(m, p1, p2) {\n      return p1.toUpperCase() + p2;\n    }\n  );\n};\n\n/* Creating a function that will check if an object has a property. */\nconst hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);\n\n/**\n * Determine if a value is a RegExp object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a RegExp object, otherwise false\n */\nconst isRegExp = kindOfTest('RegExp');\n\nconst reduceDescriptors = (obj, reducer) => {\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  const reducedDescriptors = {};\n\n  forEach(descriptors, (descriptor, name) => {\n    let ret;\n    if ((ret = reducer(descriptor, name, obj)) !== false) {\n      reducedDescriptors[name] = ret || descriptor;\n    }\n  });\n\n  Object.defineProperties(obj, reducedDescriptors);\n}\n\n/**\n * Makes all methods read-only\n * @param {Object} obj\n */\n\nconst freezeMethods = (obj) => {\n  reduceDescriptors(obj, (descriptor, name) => {\n    // skip restricted props in strict mode\n    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {\n      return false;\n    }\n\n    const value = obj[name];\n\n    if (!isFunction(value)) return;\n\n    descriptor.enumerable = false;\n\n    if ('writable' in descriptor) {\n      descriptor.writable = false;\n      return;\n    }\n\n    if (!descriptor.set) {\n      descriptor.set = () => {\n        throw Error('Can not rewrite read-only method \\'' + name + '\\'');\n      };\n    }\n  });\n}\n\nconst toObjectSet = (arrayOrString, delimiter) => {\n  const obj = {};\n\n  const define = (arr) => {\n    arr.forEach(value => {\n      obj[value] = true;\n    });\n  }\n\n  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));\n\n  return obj;\n}\n\nconst noop = () => {}\n\nconst toFiniteNumber = (value, defaultValue) => {\n  return value != null && Number.isFinite(value = +value) ? value : defaultValue;\n}\n\n\n\n/**\n * If the thing is a FormData object, return true, otherwise return false.\n *\n * @param {unknown} thing - The thing to check.\n *\n * @returns {boolean}\n */\nfunction isSpecCompliantForm(thing) {\n  return !!(thing && isFunction(thing.append) && thing[toStringTag] === 'FormData' && thing[iterator]);\n}\n\nconst toJSONObject = (obj) => {\n  const stack = new Array(10);\n\n  const visit = (source, i) => {\n\n    if (isObject(source)) {\n      if (stack.indexOf(source) >= 0) {\n        return;\n      }\n\n      //Buffer check\n      if (isBuffer(source)) {\n        return source;\n      }\n\n      if(!('toJSON' in source)) {\n        stack[i] = source;\n        const target = isArray(source) ? [] : {};\n\n        forEach(source, (value, key) => {\n          const reducedValue = visit(value, i + 1);\n          !isUndefined(reducedValue) && (target[key] = reducedValue);\n        });\n\n        stack[i] = undefined;\n\n        return target;\n      }\n    }\n\n    return source;\n  }\n\n  return visit(obj, 0);\n}\n\nconst isAsyncFn = kindOfTest('AsyncFunction');\n\nconst isThenable = (thing) =>\n  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);\n\n// original code\n// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34\n\nconst _setImmediate = ((setImmediateSupported, postMessageSupported) => {\n  if (setImmediateSupported) {\n    return setImmediate;\n  }\n\n  return postMessageSupported ? ((token, callbacks) => {\n    _global.addEventListener(\"message\", ({source, data}) => {\n      if (source === _global && data === token) {\n        callbacks.length && callbacks.shift()();\n      }\n    }, false);\n\n    return (cb) => {\n      callbacks.push(cb);\n      _global.postMessage(token, \"*\");\n    }\n  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);\n})(\n  typeof setImmediate === 'function',\n  isFunction(_global.postMessage)\n);\n\nconst asap = typeof queueMicrotask !== 'undefined' ?\n  queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);\n\n// *********************\n\n\nconst isIterable = (thing) => thing != null && isFunction(thing[iterator]);\n\n\nexport default {\n  isArray,\n  isArrayBuffer,\n  isBuffer,\n  isFormData,\n  isArrayBufferView,\n  isString,\n  isNumber,\n  isBoolean,\n  isObject,\n  isPlainObject,\n  isEmptyObject,\n  isReadableStream,\n  isRequest,\n  isResponse,\n  isHeaders,\n  isUndefined,\n  isDate,\n  isFile,\n  isBlob,\n  isRegExp,\n  isFunction,\n  isStream,\n  isURLSearchParams,\n  isTypedArray,\n  isFileList,\n  forEach,\n  merge,\n  extend,\n  trim,\n  stripBOM,\n  inherits,\n  toFlatObject,\n  kindOf,\n  kindOfTest,\n  endsWith,\n  toArray,\n  forEachEntry,\n  matchAll,\n  isHTMLForm,\n  hasOwnProperty,\n  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection\n  reduceDescriptors,\n  freezeMethods,\n  toObjectSet,\n  toCamelCase,\n  noop,\n  toFiniteNumber,\n  findKey,\n  global: _global,\n  isContextDefined,\n  isSpecCompliantForm,\n  toJSONObject,\n  isAsyncFn,\n  isThenable,\n  setImmediate: _setImmediate,\n  asap,\n  isIterable\n};\n","const createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\" || nextState === null) ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const getInitialState = () => initialState;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const api = { setState, getState, getInitialState, subscribe };\n  const initialState = state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\n\nexport { createStore };\n","var n,l,u,t,i,o,r,f,e,c,s,a,h={},v=[],p=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,y=Array.isArray;function d(n,l){for(var u in l)n[u]=l[u];return n}function w(n){n&&n.parentNode&&n.parentNode.removeChild(n)}function _(l,u,t){var i,o,r,f={};for(r in u)\"key\"==r?i=u[r]:\"ref\"==r?o=u[r]:f[r]=u[r];if(arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):t),\"function\"==typeof l&&null!=l.defaultProps)for(r in l.defaultProps)void 0===f[r]&&(f[r]=l.defaultProps[r]);return g(l,f,i,o,null)}function g(n,t,i,o,r){var f={type:n,props:t,key:i,ref:o,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:null==r?++u:r,__i:-1,__u:0};return null==r&&null!=l.vnode&&l.vnode(f),f}function m(){return{current:null}}function b(n){return n.children}function k(n,l){this.props=n,this.context=l}function x(n,l){if(null==l)return n.__?x(n.__,n.__i+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return\"function\"==typeof n.type?x(n):null}function C(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return C(n)}}function M(n){(!n.__d&&(n.__d=!0)&&i.push(n)&&!P.__r++||o!==l.debounceRendering)&&((o=l.debounceRendering)||r)(P)}function P(){var n,u,t,o,r,e,c,s;for(i.sort(f);n=i.shift();)n.__d&&(u=i.length,o=void 0,e=(r=(t=n).__v).__e,c=[],s=[],t.__P&&((o=d({},r)).__v=r.__v+1,l.vnode&&l.vnode(o),O(t.__P,o,r,t.__n,t.__P.namespaceURI,32&r.__u?[e]:null,c,null==e?x(r):e,!!(32&r.__u),s),o.__v=r.__v,o.__.__k[o.__i]=o,j(c,o,s),o.__e!=e&&C(o)),i.length>u&&i.sort(f));P.__r=0}function S(n,l,u,t,i,o,r,f,e,c,s){var a,p,y,d,w,_=t&&t.__k||v,g=l.length;for(u.__d=e,$(u,l,_),e=u.__d,a=0;a<g;a++)null!=(y=u.__k[a])&&(p=-1===y.__i?h:_[y.__i]||h,y.__i=a,O(n,y,p,i,o,r,f,e,c,s),d=y.__e,y.ref&&p.ref!=y.ref&&(p.ref&&N(p.ref,null,y),s.push(y.ref,y.__c||d,y)),null==w&&null!=d&&(w=d),65536&y.__u||p.__k===y.__k?e=I(y,e,n):\"function\"==typeof y.type&&void 0!==y.__d?e=y.__d:d&&(e=d.nextSibling),y.__d=void 0,y.__u&=-196609);u.__d=e,u.__e=w}function $(n,l,u){var t,i,o,r,f,e=l.length,c=u.length,s=c,a=0;for(n.__k=[],t=0;t<e;t++)null!=(i=l[t])&&\"boolean\"!=typeof i&&\"function\"!=typeof i?(r=t+a,(i=n.__k[t]=\"string\"==typeof i||\"number\"==typeof i||\"bigint\"==typeof i||i.constructor==String?g(null,i,null,null,null):y(i)?g(b,{children:i},null,null,null):void 0===i.constructor&&i.__b>0?g(i.type,i.props,i.key,i.ref?i.ref:null,i.__v):i).__=n,i.__b=n.__b+1,o=null,-1!==(f=i.__i=L(i,u,r,s))&&(s--,(o=u[f])&&(o.__u|=131072)),null==o||null===o.__v?(-1==f&&a--,\"function\"!=typeof i.type&&(i.__u|=65536)):f!==r&&(f==r-1?a--:f==r+1?a++:(f>r?a--:a++,i.__u|=65536))):i=n.__k[t]=null;if(s)for(t=0;t<c;t++)null!=(o=u[t])&&0==(131072&o.__u)&&(o.__e==n.__d&&(n.__d=x(o)),V(o,o))}function I(n,l,u){var t,i;if(\"function\"==typeof n.type){for(t=n.__k,i=0;t&&i<t.length;i++)t[i]&&(t[i].__=n,l=I(t[i],l,u));return l}n.__e!=l&&(l&&n.type&&!u.contains(l)&&(l=x(n)),u.insertBefore(n.__e,l||null),l=n.__e);do{l=l&&l.nextSibling}while(null!=l&&8===l.nodeType);return l}function H(n,l){return l=l||[],null==n||\"boolean\"==typeof n||(y(n)?n.some(function(n){H(n,l)}):l.push(n)),l}function L(n,l,u,t){var i=n.key,o=n.type,r=u-1,f=u+1,e=l[u];if(null===e||e&&i==e.key&&o===e.type&&0==(131072&e.__u))return u;if(t>(null!=e&&0==(131072&e.__u)?1:0))for(;r>=0||f<l.length;){if(r>=0){if((e=l[r])&&0==(131072&e.__u)&&i==e.key&&o===e.type)return r;r--}if(f<l.length){if((e=l[f])&&0==(131072&e.__u)&&i==e.key&&o===e.type)return f;f++}}return-1}function T(n,l,u){\"-\"===l[0]?n.setProperty(l,null==u?\"\":u):n[l]=null==u?\"\":\"number\"!=typeof u||p.test(l)?u:u+\"px\"}function A(n,l,u,t,i){var o;n:if(\"style\"===l)if(\"string\"==typeof u)n.style.cssText=u;else{if(\"string\"==typeof t&&(n.style.cssText=t=\"\"),t)for(l in t)u&&l in u||T(n.style,l,\"\");if(u)for(l in u)t&&u[l]===t[l]||T(n.style,l,u[l])}else if(\"o\"===l[0]&&\"n\"===l[1])o=l!==(l=l.replace(/(PointerCapture)$|Capture$/i,\"$1\")),l=l.toLowerCase()in n||\"onFocusOut\"===l||\"onFocusIn\"===l?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+o]=u,u?t?u.u=t.u:(u.u=e,n.addEventListener(l,o?s:c,o)):n.removeEventListener(l,o?s:c,o);else{if(\"http://www.w3.org/2000/svg\"==i)l=l.replace(/xlink(H|:h)/,\"h\").replace(/sName$/,\"s\");else if(\"width\"!=l&&\"height\"!=l&&\"href\"!=l&&\"list\"!=l&&\"form\"!=l&&\"tabIndex\"!=l&&\"download\"!=l&&\"rowSpan\"!=l&&\"colSpan\"!=l&&\"role\"!=l&&\"popover\"!=l&&l in n)try{n[l]=null==u?\"\":u;break n}catch(n){}\"function\"==typeof u||(null==u||!1===u&&\"-\"!==l[4]?n.removeAttribute(l):n.setAttribute(l,\"popover\"==l&&1==u?\"\":u))}}function F(n){return function(u){if(this.l){var t=this.l[u.type+n];if(null==u.t)u.t=e++;else if(u.t<t.u)return;return t(l.event?l.event(u):u)}}}function O(n,u,t,i,o,r,f,e,c,s){var a,h,v,p,w,_,g,m,x,C,M,P,$,I,H,L,T=u.type;if(void 0!==u.constructor)return null;128&t.__u&&(c=!!(32&t.__u),r=[e=u.__e=t.__e]),(a=l.__b)&&a(u);n:if(\"function\"==typeof T)try{if(m=u.props,x=\"prototype\"in T&&T.prototype.render,C=(a=T.contextType)&&i[a.__c],M=a?C?C.props.value:a.__:i,t.__c?g=(h=u.__c=t.__c).__=h.__E:(x?u.__c=h=new T(m,M):(u.__c=h=new k(m,M),h.constructor=T,h.render=q),C&&C.sub(h),h.props=m,h.state||(h.state={}),h.context=M,h.__n=i,v=h.__d=!0,h.__h=[],h._sb=[]),x&&null==h.__s&&(h.__s=h.state),x&&null!=T.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=d({},h.__s)),d(h.__s,T.getDerivedStateFromProps(m,h.__s))),p=h.props,w=h.state,h.__v=u,v)x&&null==T.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),x&&null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else{if(x&&null==T.getDerivedStateFromProps&&m!==p&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(m,M),!h.__e&&(null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(m,h.__s,M)||u.__v===t.__v)){for(u.__v!==t.__v&&(h.props=m,h.state=h.__s,h.__d=!1),u.__e=t.__e,u.__k=t.__k,u.__k.some(function(n){n&&(n.__=u)}),P=0;P<h._sb.length;P++)h.__h.push(h._sb[P]);h._sb=[],h.__h.length&&f.push(h);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(m,h.__s,M),x&&null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(p,w,_)})}if(h.context=M,h.props=m,h.__P=n,h.__e=!1,$=l.__r,I=0,x){for(h.state=h.__s,h.__d=!1,$&&$(u),a=h.render(h.props,h.state,h.context),H=0;H<h._sb.length;H++)h.__h.push(h._sb[H]);h._sb=[]}else do{h.__d=!1,$&&$(u),a=h.render(h.props,h.state,h.context),h.state=h.__s}while(h.__d&&++I<25);h.state=h.__s,null!=h.getChildContext&&(i=d(d({},i),h.getChildContext())),x&&!v&&null!=h.getSnapshotBeforeUpdate&&(_=h.getSnapshotBeforeUpdate(p,w)),S(n,y(L=null!=a&&a.type===b&&null==a.key?a.props.children:a)?L:[L],u,t,i,o,r,f,e,c,s),h.base=u.__e,u.__u&=-161,h.__h.length&&f.push(h),g&&(h.__E=h.__=null)}catch(n){if(u.__v=null,c||null!=r){for(u.__u|=c?160:32;e&&8===e.nodeType&&e.nextSibling;)e=e.nextSibling;r[r.indexOf(e)]=null,u.__e=e}else u.__e=t.__e,u.__k=t.__k;l.__e(n,u,t)}else null==r&&u.__v===t.__v?(u.__k=t.__k,u.__e=t.__e):u.__e=z(t.__e,u,t,i,o,r,f,c,s);(a=l.diffed)&&a(u)}function j(n,u,t){u.__d=void 0;for(var i=0;i<t.length;i++)N(t[i],t[++i],t[++i]);l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u)})}catch(n){l.__e(n,u.__v)}})}function z(u,t,i,o,r,f,e,c,s){var a,v,p,d,_,g,m,b=i.props,k=t.props,C=t.type;if(\"svg\"===C?r=\"http://www.w3.org/2000/svg\":\"math\"===C?r=\"http://www.w3.org/1998/Math/MathML\":r||(r=\"http://www.w3.org/1999/xhtml\"),null!=f)for(a=0;a<f.length;a++)if((_=f[a])&&\"setAttribute\"in _==!!C&&(C?_.localName===C:3===_.nodeType)){u=_,f[a]=null;break}if(null==u){if(null===C)return document.createTextNode(k);u=document.createElementNS(r,C,k.is&&k),c&&(l.__m&&l.__m(t,f),c=!1),f=null}if(null===C)b===k||c&&u.data===k||(u.data=k);else{if(f=f&&n.call(u.childNodes),b=i.props||h,!c&&null!=f)for(b={},a=0;a<u.attributes.length;a++)b[(_=u.attributes[a]).name]=_.value;for(a in b)if(_=b[a],\"children\"==a);else if(\"dangerouslySetInnerHTML\"==a)p=_;else if(!(a in k)){if(\"value\"==a&&\"defaultValue\"in k||\"checked\"==a&&\"defaultChecked\"in k)continue;A(u,a,null,_,r)}for(a in k)_=k[a],\"children\"==a?d=_:\"dangerouslySetInnerHTML\"==a?v=_:\"value\"==a?g=_:\"checked\"==a?m=_:c&&\"function\"!=typeof _||b[a]===_||A(u,a,_,b[a],r);if(v)c||p&&(v.__html===p.__html||v.__html===u.innerHTML)||(u.innerHTML=v.__html),t.__k=[];else if(p&&(u.innerHTML=\"\"),S(u,y(d)?d:[d],t,i,o,\"foreignObject\"===C?\"http://www.w3.org/1999/xhtml\":r,f,e,f?f[0]:i.__k&&x(i,0),c,s),null!=f)for(a=f.length;a--;)w(f[a]);c||(a=\"value\",\"progress\"===C&&null==g?u.removeAttribute(\"value\"):void 0!==g&&(g!==u[a]||\"progress\"===C&&!g||\"option\"===C&&g!==b[a])&&A(u,a,g,b[a],r),a=\"checked\",void 0!==m&&m!==u[a]&&A(u,a,m,b[a],r))}return u}function N(n,u,t){try{if(\"function\"==typeof n){var i=\"function\"==typeof n.__u;i&&n.__u(),i&&null==u||(n.__u=n(u))}else n.current=u}catch(n){l.__e(n,t)}}function V(n,u,t){var i,o;if(l.unmount&&l.unmount(n),(i=n.ref)&&(i.current&&i.current!==n.__e||N(i,null,u)),null!=(i=n.__c)){if(i.componentWillUnmount)try{i.componentWillUnmount()}catch(n){l.__e(n,u)}i.base=i.__P=null}if(i=n.__k)for(o=0;o<i.length;o++)i[o]&&V(i[o],u,t||\"function\"!=typeof n.type);t||w(n.__e),n.__c=n.__=n.__e=n.__d=void 0}function q(n,l,u){return this.constructor(n,u)}function B(u,t,i){var o,r,f,e;l.__&&l.__(u,t),r=(o=\"function\"==typeof i)?null:i&&i.__k||t.__k,f=[],e=[],O(t,u=(!o&&i||t).__k=_(b,null,[u]),r||h,h,t.namespaceURI,!o&&i?[i]:r?null:t.firstChild?n.call(t.childNodes):null,f,!o&&i?i:r?r.__e:t.firstChild,o,e),j(f,u,e)}function D(n,l){B(n,l,D)}function E(l,u,t){var i,o,r,f,e=d({},l.props);for(r in l.type&&l.type.defaultProps&&(f=l.type.defaultProps),u)\"key\"==r?i=u[r]:\"ref\"==r?o=u[r]:e[r]=void 0===u[r]&&void 0!==f?f[r]:u[r];return arguments.length>2&&(e.children=arguments.length>3?n.call(arguments,2):t),g(l.type,e,i||l.key,o||l.ref,null)}function G(n,l){var u={__c:l=\"__cC\"+a++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,t;return this.getChildContext||(u=[],(t={})[l]=this,this.getChildContext=function(){return t},this.componentWillUnmount=function(){u=null},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(function(n){n.__e=!0,M(n)})},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u&&u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n=v.slice,l={__e:function(n,l,u,t){for(var i,o,r;l=l.__;)if((i=l.__c)&&!i.__)try{if((o=i.constructor)&&null!=o.getDerivedStateFromError&&(i.setState(o.getDerivedStateFromError(n)),r=i.__d),null!=i.componentDidCatch&&(i.componentDidCatch(n,t||{}),r=i.__d),r)return i.__E=i}catch(l){n=l}throw n}},u=0,t=function(n){return null!=n&&null==n.constructor},k.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=d({},this.state),\"function\"==typeof n&&(n=n(d({},u),this.props)),n&&d(u,n),null!=n&&this.__v&&(l&&this._sb.push(l),M(this))},k.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),M(this))},k.prototype.render=b,i=[],r=\"function\"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,f=function(n,l){return n.__v.__b-l.__v.__b},P.__r=0,e=0,c=F(!1),s=F(!0),a=0;export{k as Component,b as Fragment,E as cloneElement,G as createContext,_ as createElement,m as createRef,_ as h,D as hydrate,t as isValidElement,l as options,B as render,H as toChildArray};\n//# sourceMappingURL=preact.module.js.map\n","function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f);else for(t in e)e[t]&&(n&&(n+=\" \"),n+=t);return n}export function clsx(){for(var e,t,f=0,n=\"\";f<arguments.length;)(e=arguments[f++])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;","const reduxImpl = (reducer, initial) => (set, _get, api) => {\n  api.dispatch = (action) => {\n    set((state) => reducer(state, action), false, action);\n    return action;\n  };\n  api.dispatchFromDevtools = true;\n  return { dispatch: (...a) => api.dispatch(...a), ...initial };\n};\nconst redux = reduxImpl;\n\nconst trackedConnections = /* @__PURE__ */ new Map();\nconst getTrackedConnectionState = (name) => {\n  const api = trackedConnections.get(name);\n  if (!api) return {};\n  return Object.fromEntries(\n    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])\n  );\n};\nconst extractConnectionInformation = (store, extensionConnector, options) => {\n  if (store === undefined) {\n    return {\n      type: \"untracked\",\n      connection: extensionConnector.connect(options)\n    };\n  }\n  const existingConnection = trackedConnections.get(options.name);\n  if (existingConnection) {\n    return { type: \"tracked\", store, ...existingConnection };\n  }\n  const newConnection = {\n    connection: extensionConnector.connect(options),\n    stores: {}\n  };\n  trackedConnections.set(options.name, newConnection);\n  return { type: \"tracked\", store, ...newConnection };\n};\nconst devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {\n  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;\n  let extensionConnector;\n  try {\n    extensionConnector = (enabled != null ? enabled : (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (e) {\n  }\n  if (!extensionConnector) {\n    return fn(set, get, api);\n  }\n  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);\n  let isRecording = true;\n  api.setState = (state, replace, nameOrAction) => {\n    const r = set(state, replace);\n    if (!isRecording) return r;\n    const action = nameOrAction === undefined ? { type: anonymousActionType || \"anonymous\" } : typeof nameOrAction === \"string\" ? { type: nameOrAction } : nameOrAction;\n    if (store === undefined) {\n      connection == null ? undefined : connection.send(action, get());\n      return r;\n    }\n    connection == null ? undefined : connection.send(\n      {\n        ...action,\n        type: `${store}/${action.type}`\n      },\n      {\n        ...getTrackedConnectionState(options.name),\n        [store]: api.getState()\n      }\n    );\n    return r;\n  };\n  const setStateFromDevtools = (...a) => {\n    const originalIsRecording = isRecording;\n    isRecording = false;\n    set(...a);\n    isRecording = originalIsRecording;\n  };\n  const initialState = fn(api.setState, get, api);\n  if (connectionInformation.type === \"untracked\") {\n    connection == null ? undefined : connection.init(initialState);\n  } else {\n    connectionInformation.stores[connectionInformation.store] = api;\n    connection == null ? undefined : connection.init(\n      Object.fromEntries(\n        Object.entries(connectionInformation.stores).map(([key, store2]) => [\n          key,\n          key === connectionInformation.store ? initialState : store2.getState()\n        ])\n      )\n    );\n  }\n  if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n    let didWarnAboutReservedActionType = false;\n    const originalDispatch = api.dispatch;\n    api.dispatch = (...a) => {\n      if ((import.meta.env ? import.meta.env.MODE : undefined) !== \"production\" && a[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n        console.warn(\n          '[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.'\n        );\n        didWarnAboutReservedActionType = true;\n      }\n      originalDispatch(...a);\n    };\n  }\n  connection.subscribe((message) => {\n    var _a;\n    switch (message.type) {\n      case \"ACTION\":\n        if (typeof message.payload !== \"string\") {\n          console.error(\n            \"[zustand devtools middleware] Unsupported action format\"\n          );\n          return;\n        }\n        return parseJsonThen(\n          message.payload,\n          (action) => {\n            if (action.type === \"__setState\") {\n              if (store === undefined) {\n                setStateFromDevtools(action.state);\n                return;\n              }\n              if (Object.keys(action.state).length !== 1) {\n                console.error(\n                  `\n                    [zustand devtools middleware] Unsupported __setState action format.\n                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { \"type\": \"__setState\", \"state\": { \"abc123Store\": { \"foo\": \"bar\" } } }\n                    `\n                );\n              }\n              const stateFromDevtools = action.state[store];\n              if (stateFromDevtools === undefined || stateFromDevtools === null) {\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {\n                setStateFromDevtools(stateFromDevtools);\n              }\n              return;\n            }\n            if (!api.dispatchFromDevtools) return;\n            if (typeof api.dispatch !== \"function\") return;\n            api.dispatch(action);\n          }\n        );\n      case \"DISPATCH\":\n        switch (message.payload.type) {\n          case \"RESET\":\n            setStateFromDevtools(initialState);\n            if (store === undefined) {\n              return connection == null ? undefined : connection.init(api.getState());\n            }\n            return connection == null ? undefined : connection.init(getTrackedConnectionState(options.name));\n          case \"COMMIT\":\n            if (store === undefined) {\n              connection == null ? undefined : connection.init(api.getState());\n              return;\n            }\n            return connection == null ? undefined : connection.init(getTrackedConnectionState(options.name));\n          case \"ROLLBACK\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === undefined) {\n                setStateFromDevtools(state);\n                connection == null ? undefined : connection.init(api.getState());\n                return;\n              }\n              setStateFromDevtools(state[store]);\n              connection == null ? undefined : connection.init(getTrackedConnectionState(options.name));\n            });\n          case \"JUMP_TO_STATE\":\n          case \"JUMP_TO_ACTION\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === undefined) {\n                setStateFromDevtools(state);\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {\n                setStateFromDevtools(state[store]);\n              }\n            });\n          case \"IMPORT_STATE\": {\n            const { nextLiftedState } = message.payload;\n            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? undefined : _a.state;\n            if (!lastComputedState) return;\n            if (store === undefined) {\n              setStateFromDevtools(lastComputedState);\n            } else {\n              setStateFromDevtools(lastComputedState[store]);\n            }\n            connection == null ? undefined : connection.send(\n              null,\n              // FIXME no-any\n              nextLiftedState\n            );\n            return;\n          }\n          case \"PAUSE_RECORDING\":\n            return isRecording = !isRecording;\n        }\n        return;\n    }\n  });\n  return initialState;\n};\nconst devtools = devtoolsImpl;\nconst parseJsonThen = (stringified, f) => {\n  let parsed;\n  try {\n    parsed = JSON.parse(stringified);\n  } catch (e) {\n    console.error(\n      \"[zustand devtools middleware] Could not parse the received json\",\n      e\n    );\n  }\n  if (parsed !== undefined) f(parsed);\n};\n\nconst subscribeWithSelectorImpl = (fn) => (set, get, api) => {\n  const origSubscribe = api.subscribe;\n  api.subscribe = (selector, optListener, options) => {\n    let listener = selector;\n    if (optListener) {\n      const equalityFn = (options == null ? undefined : options.equalityFn) || Object.is;\n      let currentSlice = selector(api.getState());\n      listener = (state) => {\n        const nextSlice = selector(state);\n        if (!equalityFn(currentSlice, nextSlice)) {\n          const previousSlice = currentSlice;\n          optListener(currentSlice = nextSlice, previousSlice);\n        }\n      };\n      if (options == null ? undefined : options.fireImmediately) {\n        optListener(currentSlice, currentSlice);\n      }\n    }\n    return origSubscribe(listener);\n  };\n  const initialState = fn(set, get, api);\n  return initialState;\n};\nconst subscribeWithSelector = subscribeWithSelectorImpl;\n\nconst combine = (initialState, create) => (...a) => Object.assign({}, initialState, create(...a));\n\nfunction createJSONStorage(getStorage, options) {\n  let storage;\n  try {\n    storage = getStorage();\n  } catch (e) {\n    return;\n  }\n  const persistStorage = {\n    getItem: (name) => {\n      var _a;\n      const parse = (str2) => {\n        if (str2 === null) {\n          return null;\n        }\n        return JSON.parse(str2, options == null ? undefined : options.reviver);\n      };\n      const str = (_a = storage.getItem(name)) != null ? _a : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (name, newValue) => storage.setItem(\n      name,\n      JSON.stringify(newValue, options == null ? undefined : options.replacer)\n    ),\n    removeItem: (name) => storage.removeItem(name)\n  };\n  return persistStorage;\n}\nconst toThenable = (fn) => (input) => {\n  try {\n    const result = fn(input);\n    if (result instanceof Promise) {\n      return result;\n    }\n    return {\n      then(onFulfilled) {\n        return toThenable(onFulfilled)(result);\n      },\n      catch(_onRejected) {\n        return this;\n      }\n    };\n  } catch (e) {\n    return {\n      then(_onFulfilled) {\n        return this;\n      },\n      catch(onRejected) {\n        return toThenable(onRejected)(e);\n      }\n    };\n  }\n};\nconst persistImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    storage: createJSONStorage(() => localStorage),\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage = options.storage;\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    return storage.setItem(options.name, {\n      state,\n      version: options.version\n    });\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  api.getInitialState = () => configResult;\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a, _b;\n    if (!storage) return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => {\n      var _a2;\n      return cb((_a2 = get()) != null ? _a2 : configResult);\n    });\n    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? undefined : _b.call(options, (_a = get()) != null ? _a : configResult)) || undefined;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            const migration = options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n            if (migration instanceof Promise) {\n              return migration.then((result) => [true, result]);\n            }\n            return [true, migration];\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return [false, deserializedStorageValue.state];\n        }\n      }\n      return [false, undefined];\n    }).then((migrationResult) => {\n      var _a2;\n      const [migrated, migratedState] = migrationResult;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      if (migrated) {\n        return setItem();\n      }\n    }).then(() => {\n      postRehydrationCallback == null ? undefined : postRehydrationCallback(stateFromStorage, undefined);\n      stateFromStorage = get();\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? undefined : postRehydrationCallback(undefined, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.storage) {\n        storage = newOptions.storage;\n      }\n    },\n    clearStorage: () => {\n      storage == null ? undefined : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  if (!options.skipHydration) {\n    hydrate();\n  }\n  return stateFromStorage || configResult;\n};\nconst persist = persistImpl;\n\nexport { combine, createJSONStorage, devtools, persist, redux, subscribeWithSelector };\n","import FormData from 'form-data';\n\nexport default FormData;\n","'use strict';\n\nimport utils from '../utils.js';\nimport AxiosError from '../core/AxiosError.js';\n// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored\nimport PlatformFormData from '../platform/node/classes/FormData.js';\n\n/**\n * Determines if the given thing is a array or js object.\n *\n * @param {string} thing - The object or array to be visited.\n *\n * @returns {boolean}\n */\nfunction isVisitable(thing) {\n  return utils.isPlainObject(thing) || utils.isArray(thing);\n}\n\n/**\n * It removes the brackets from the end of a string\n *\n * @param {string} key - The key of the parameter.\n *\n * @returns {string} the key without the brackets.\n */\nfunction removeBrackets(key) {\n  return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;\n}\n\n/**\n * It takes a path, a key, and a boolean, and returns a string\n *\n * @param {string} path - The path to the current key.\n * @param {string} key - The key of the current object being iterated over.\n * @param {string} dots - If true, the key will be rendered with dots instead of brackets.\n *\n * @returns {string} The path to the current key.\n */\nfunction renderKey(path, key, dots) {\n  if (!path) return key;\n  return path.concat(key).map(function each(token, i) {\n    // eslint-disable-next-line no-param-reassign\n    token = removeBrackets(token);\n    return !dots && i ? '[' + token + ']' : token;\n  }).join(dots ? '.' : '');\n}\n\n/**\n * If the array is an array and none of its elements are visitable, then it's a flat array.\n *\n * @param {Array<any>} arr - The array to check\n *\n * @returns {boolean}\n */\nfunction isFlatArray(arr) {\n  return utils.isArray(arr) && !arr.some(isVisitable);\n}\n\nconst predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {\n  return /^is[A-Z]/.test(prop);\n});\n\n/**\n * Convert a data object to FormData\n *\n * @param {Object} obj\n * @param {?Object} [formData]\n * @param {?Object} [options]\n * @param {Function} [options.visitor]\n * @param {Boolean} [options.metaTokens = true]\n * @param {Boolean} [options.dots = false]\n * @param {?Boolean} [options.indexes = false]\n *\n * @returns {Object}\n **/\n\n/**\n * It converts an object into a FormData object\n *\n * @param {Object<any, any>} obj - The object to convert to form data.\n * @param {string} formData - The FormData object to append to.\n * @param {Object<string, any>} options\n *\n * @returns\n */\nfunction toFormData(obj, formData, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('target must be an object');\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  formData = formData || new (PlatformFormData || FormData)();\n\n  // eslint-disable-next-line no-param-reassign\n  options = utils.toFlatObject(options, {\n    metaTokens: true,\n    dots: false,\n    indexes: false\n  }, false, function defined(option, source) {\n    // eslint-disable-next-line no-eq-null,eqeqeq\n    return !utils.isUndefined(source[option]);\n  });\n\n  const metaTokens = options.metaTokens;\n  // eslint-disable-next-line no-use-before-define\n  const visitor = options.visitor || defaultVisitor;\n  const dots = options.dots;\n  const indexes = options.indexes;\n  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;\n  const useBlob = _Blob && utils.isSpecCompliantForm(formData);\n\n  if (!utils.isFunction(visitor)) {\n    throw new TypeError('visitor must be a function');\n  }\n\n  function convertValue(value) {\n    if (value === null) return '';\n\n    if (utils.isDate(value)) {\n      return value.toISOString();\n    }\n\n    if (utils.isBoolean(value)) {\n      return value.toString();\n    }\n\n    if (!useBlob && utils.isBlob(value)) {\n      throw new AxiosError('Blob is not supported. Use a Buffer instead.');\n    }\n\n    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {\n      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);\n    }\n\n    return value;\n  }\n\n  /**\n   * Default visitor.\n   *\n   * @param {*} value\n   * @param {String|Number} key\n   * @param {Array<String|Number>} path\n   * @this {FormData}\n   *\n   * @returns {boolean} return true to visit the each prop of the value recursively\n   */\n  function defaultVisitor(value, key, path) {\n    let arr = value;\n\n    if (value && !path && typeof value === 'object') {\n      if (utils.endsWith(key, '{}')) {\n        // eslint-disable-next-line no-param-reassign\n        key = metaTokens ? key : key.slice(0, -2);\n        // eslint-disable-next-line no-param-reassign\n        value = JSON.stringify(value);\n      } else if (\n        (utils.isArray(value) && isFlatArray(value)) ||\n        ((utils.isFileList(value) || utils.endsWith(key, '[]')) && (arr = utils.toArray(value))\n        )) {\n        // eslint-disable-next-line no-param-reassign\n        key = removeBrackets(key);\n\n        arr.forEach(function each(el, index) {\n          !(utils.isUndefined(el) || el === null) && formData.append(\n            // eslint-disable-next-line no-nested-ternary\n            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),\n            convertValue(el)\n          );\n        });\n        return false;\n      }\n    }\n\n    if (isVisitable(value)) {\n      return true;\n    }\n\n    formData.append(renderKey(path, key, dots), convertValue(value));\n\n    return false;\n  }\n\n  const stack = [];\n\n  const exposedHelpers = Object.assign(predicates, {\n    defaultVisitor,\n    convertValue,\n    isVisitable\n  });\n\n  function build(value, path) {\n    if (utils.isUndefined(value)) return;\n\n    if (stack.indexOf(value) !== -1) {\n      throw Error('Circular reference detected in ' + path.join('.'));\n    }\n\n    stack.push(value);\n\n    utils.forEach(value, function each(el, key) {\n      const result = !(utils.isUndefined(el) || el === null) && visitor.call(\n        formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers\n      );\n\n      if (result === true) {\n        build(el, path ? path.concat(key) : [key]);\n      }\n    });\n\n    stack.pop();\n  }\n\n  if (!utils.isObject(obj)) {\n    throw new TypeError('data must be an object');\n  }\n\n  build(obj);\n\n  return formData;\n}\n\nexport default toFormData;\n","'use strict';\n\nimport toFormData from './toFormData.js';\n\n/**\n * It encodes a string by replacing all characters that are not in the unreserved set with\n * their percent-encoded equivalents\n *\n * @param {string} str - The string to encode.\n *\n * @returns {string} The encoded string.\n */\nfunction encode(str) {\n  const charMap = {\n    '!': '%21',\n    \"'\": '%27',\n    '(': '%28',\n    ')': '%29',\n    '~': '%7E',\n    '%20': '+',\n    '%00': '\\x00'\n  };\n  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {\n    return charMap[match];\n  });\n}\n\n/**\n * It takes a params object and converts it to a FormData object\n *\n * @param {Object<string, any>} params - The parameters to be converted to a FormData object.\n * @param {Object<string, any>} options - The options object passed to the Axios constructor.\n *\n * @returns {void}\n */\nfunction AxiosURLSearchParams(params, options) {\n  this._pairs = [];\n\n  params && toFormData(params, this, options);\n}\n\nconst prototype = AxiosURLSearchParams.prototype;\n\nprototype.append = function append(name, value) {\n  this._pairs.push([name, value]);\n};\n\nprototype.toString = function toString(encoder) {\n  const _encode = encoder ? function(value) {\n    return encoder.call(this, value, encode);\n  } : encode;\n\n  return this._pairs.map(function each(pair) {\n    return _encode(pair[0]) + '=' + _encode(pair[1]);\n  }, '').join('&');\n};\n\nexport default AxiosURLSearchParams;\n","'use strict';\n\nimport utils from '../utils.js';\nimport AxiosURLSearchParams from '../helpers/AxiosURLSearchParams.js';\n\n/**\n * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their\n * URI encoded counterparts\n *\n * @param {string} val The value to be encoded.\n *\n * @returns {string} The encoded value.\n */\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @param {?(object|Function)} options\n *\n * @returns {string} The formatted url\n */\nexport default function buildURL(url, params, options) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n  \n  const _encode = options && options.encode || encode;\n\n  if (utils.isFunction(options)) {\n    options = {\n      serialize: options\n    };\n  } \n\n  const serializeFn = options && options.serialize;\n\n  let serializedParams;\n\n  if (serializeFn) {\n    serializedParams = serializeFn(params, options);\n  } else {\n    serializedParams = utils.isURLSearchParams(params) ?\n      params.toString() :\n      new AxiosURLSearchParams(params, options).toString(_encode);\n  }\n\n  if (serializedParams) {\n    const hashmarkIndex = url.indexOf(\"#\");\n\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n}\n","'use strict';\n\nimport utils from './../utils.js';\n\nclass InterceptorManager {\n  constructor() {\n    this.handlers = [];\n  }\n\n  /**\n   * Add a new interceptor to the stack\n   *\n   * @param {Function} fulfilled The function to handle `then` for a `Promise`\n   * @param {Function} rejected The function to handle `reject` for a `Promise`\n   *\n   * @return {Number} An ID used to remove interceptor later\n   */\n  use(fulfilled, rejected, options) {\n    this.handlers.push({\n      fulfilled,\n      rejected,\n      synchronous: options ? options.synchronous : false,\n      runWhen: options ? options.runWhen : null\n    });\n    return this.handlers.length - 1;\n  }\n\n  /**\n   * Remove an interceptor from the stack\n   *\n   * @param {Number} id The ID that was returned by `use`\n   *\n   * @returns {void}\n   */\n  eject(id) {\n    if (this.handlers[id]) {\n      this.handlers[id] = null;\n    }\n  }\n\n  /**\n   * Clear all interceptors from the stack\n   *\n   * @returns {void}\n   */\n  clear() {\n    if (this.handlers) {\n      this.handlers = [];\n    }\n  }\n\n  /**\n   * Iterate over all the registered interceptors\n   *\n   * This method is particularly useful for skipping over any\n   * interceptors that may have become `null` calling `eject`.\n   *\n   * @param {Function} fn The function to call for each interceptor\n   *\n   * @returns {void}\n   */\n  forEach(fn) {\n    utils.forEach(this.handlers, function forEachHandler(h) {\n      if (h !== null) {\n        fn(h);\n      }\n    });\n  }\n}\n\nexport default InterceptorManager;\n","import crypto from 'crypto';\nimport URLSearchParams from './classes/URLSearchParams.js'\nimport FormData from './classes/FormData.js'\n\nconst ALPHA = 'abcdefghijklmnopqrstuvwxyz'\n\nconst DIGIT = '0123456789';\n\nconst ALPHABET = {\n  DIGIT,\n  ALPHA,\n  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT\n}\n\nconst generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {\n  let str = '';\n  const {length} = alphabet;\n  const randomValues = new Uint32Array(size);\n  crypto.randomFillSync(randomValues);\n  for (let i = 0; i < size; i++) {\n    str += alphabet[randomValues[i] % length];\n  }\n\n  return str;\n}\n\n\nexport default {\n  isNode: true,\n  classes: {\n    URLSearchParams,\n    FormData,\n    Blob: typeof Blob !== 'undefined' && Blob || null\n  },\n  ALPHABET,\n  generateString,\n  protocols: [ 'http', 'https', 'file', 'data' ]\n};\n","'use strict';\n\nimport url from 'url';\nexport default url.URLSearchParams;\n","const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';\n\nconst _navigator = typeof navigator === 'object' && navigator || undefined;\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n *\n * @returns {boolean}\n */\nconst hasStandardBrowserEnv = hasBrowserEnv &&\n  (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);\n\n/**\n * Determine if we're running in a standard browser webWorker environment\n *\n * Although the `isStandardBrowserEnv` method indicates that\n * `allows axios to run in a web worker`, the WebWorker will still be\n * filtered out due to its judgment standard\n * `typeof window !== 'undefined' && typeof document !== 'undefined'`.\n * This leads to a problem when axios post `FormData` in webWorker\n */\nconst hasStandardBrowserWebWorkerEnv = (() => {\n  return (\n    typeof WorkerGlobalScope !== 'undefined' &&\n    // eslint-disable-next-line no-undef\n    self instanceof WorkerGlobalScope &&\n    typeof self.importScripts === 'function'\n  );\n})();\n\nconst origin = hasBrowserEnv && window.location.href || 'http://localhost';\n\nexport {\n  hasBrowserEnv,\n  hasStandardBrowserWebWorkerEnv,\n  hasStandardBrowserEnv,\n  _navigator as navigator,\n  origin\n}\n","'use strict';\n\nimport utils from '../utils.js';\nimport toFormData from './toFormData.js';\nimport platform from '../platform/index.js';\n\nexport default function toURLEncodedForm(data, options) {\n  return toFormData(data, new platform.classes.URLSearchParams(), {\n    visitor: function(value, key, path, helpers) {\n      if (platform.isNode && utils.isBuffer(value)) {\n        this.append(key, value.toString('base64'));\n        return false;\n      }\n\n      return helpers.defaultVisitor.apply(this, arguments);\n    },\n    ...options\n  });\n}\n","'use strict';\n\nimport utils from '../utils.js';\n\n/**\n * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']\n *\n * @param {string} name - The name of the property to get.\n *\n * @returns An array of strings.\n */\nfunction parsePropPath(name) {\n  // foo[x][y][z]\n  // foo.x.y.z\n  // foo-x-y-z\n  // foo x y z\n  return utils.matchAll(/\\w+|\\[(\\w*)]/g, name).map(match => {\n    return match[0] === '[]' ? '' : match[1] || match[0];\n  });\n}\n\n/**\n * Convert an array to an object.\n *\n * @param {Array<any>} arr - The array to convert to an object.\n *\n * @returns An object with the same keys and values as the array.\n */\nfunction arrayToObject(arr) {\n  const obj = {};\n  const keys = Object.keys(arr);\n  let i;\n  const len = keys.length;\n  let key;\n  for (i = 0; i < len; i++) {\n    key = keys[i];\n    obj[key] = arr[key];\n  }\n  return obj;\n}\n\n/**\n * It takes a FormData object and returns a JavaScript object\n *\n * @param {string} formData The FormData object to convert to JSON.\n *\n * @returns {Object<string, any> | null} The converted object.\n */\nfunction formDataToJSON(formData) {\n  function buildPath(path, value, target, index) {\n    let name = path[index++];\n\n    if (name === '__proto__') return true;\n\n    const isNumericKey = Number.isFinite(+name);\n    const isLast = index >= path.length;\n    name = !name && utils.isArray(target) ? target.length : name;\n\n    if (isLast) {\n      if (utils.hasOwnProp(target, name)) {\n        target[name] = [target[name], value];\n      } else {\n        target[name] = value;\n      }\n\n      return !isNumericKey;\n    }\n\n    if (!target[name] || !utils.isObject(target[name])) {\n      target[name] = [];\n    }\n\n    const result = buildPath(path, value, target[name], index);\n\n    if (result && utils.isArray(target[name])) {\n      target[name] = arrayToObject(target[name]);\n    }\n\n    return !isNumericKey;\n  }\n\n  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {\n    const obj = {};\n\n    utils.forEachEntry(formData, (name, value) => {\n      buildPath(parsePropPath(name), value, obj, 0);\n    });\n\n    return obj;\n  }\n\n  return null;\n}\n\nexport default formDataToJSON;\n","'use strict';\n\nimport utils from '../utils.js';\nimport AxiosError from '../core/AxiosError.js';\nimport transitionalDefaults from './transitional.js';\nimport toFormData from '../helpers/toFormData.js';\nimport toURLEncodedForm from '../helpers/toURLEncodedForm.js';\nimport platform from '../platform/index.js';\nimport formDataToJSON from '../helpers/formDataToJSON.js';\n\n/**\n * It takes a string, tries to parse it, and if it fails, it returns the stringified version\n * of the input\n *\n * @param {any} rawValue - The value to be stringified.\n * @param {Function} parser - A function that parses a string into a JavaScript object.\n * @param {Function} encoder - A function that takes a value and returns a string.\n *\n * @returns {string} A stringified version of the rawValue.\n */\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nconst defaults = {\n\n  transitional: transitionalDefaults,\n\n  adapter: ['xhr', 'http', 'fetch'],\n\n  transformRequest: [function transformRequest(data, headers) {\n    const contentType = headers.getContentType() || '';\n    const hasJSONContentType = contentType.indexOf('application/json') > -1;\n    const isObjectPayload = utils.isObject(data);\n\n    if (isObjectPayload && utils.isHTMLForm(data)) {\n      data = new FormData(data);\n    }\n\n    const isFormData = utils.isFormData(data);\n\n    if (isFormData) {\n      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;\n    }\n\n    if (utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data) ||\n      utils.isReadableStream(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);\n      return data.toString();\n    }\n\n    let isFileList;\n\n    if (isObjectPayload) {\n      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {\n        return toURLEncodedForm(data, this.formSerializer).toString();\n      }\n\n      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {\n        const _FormData = this.env && this.env.FormData;\n\n        return toFormData(\n          isFileList ? {'files[]': data} : data,\n          _FormData && new _FormData(),\n          this.formSerializer\n        );\n      }\n    }\n\n    if (isObjectPayload || hasJSONContentType ) {\n      headers.setContentType('application/json', false);\n      return stringifySafely(data);\n    }\n\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    const transitional = this.transitional || defaults.transitional;\n    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    const JSONRequested = this.responseType === 'json';\n\n    if (utils.isResponse(data) || utils.isReadableStream(data)) {\n      return data;\n    }\n\n    if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {\n      const silentJSONParsing = transitional && transitional.silentJSONParsing;\n      const strictJSONParsing = !silentJSONParsing && JSONRequested;\n\n      try {\n        return JSON.parse(data, this.parseReviver);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  env: {\n    FormData: platform.classes.FormData,\n    Blob: platform.classes.Blob\n  },\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*',\n      'Content-Type': undefined\n    }\n  }\n};\n\nutils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {\n  defaults.headers[method] = {};\n});\n\nexport default defaults;\n","'use strict';\n\nimport utils from './../utils.js';\n\n// RawAxiosHeaders whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nconst ignoreDuplicateOf = utils.toObjectSet([\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n]);\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} rawHeaders Headers needing to be parsed\n *\n * @returns {Object} Headers parsed into an object\n */\nexport default rawHeaders => {\n  const parsed = {};\n  let key;\n  let val;\n  let i;\n\n  rawHeaders && rawHeaders.split('\\n').forEach(function parser(line) {\n    i = line.indexOf(':');\n    key = line.substring(0, i).trim().toLowerCase();\n    val = line.substring(i + 1).trim();\n\n    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {\n      return;\n    }\n\n    if (key === 'set-cookie') {\n      if (parsed[key]) {\n        parsed[key].push(val);\n      } else {\n        parsed[key] = [val];\n      }\n    } else {\n      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n    }\n  });\n\n  return parsed;\n};\n","'use strict';\n\nimport utils from '../utils.js';\nimport parseHeaders from '../helpers/parseHeaders.js';\n\nconst $internals = Symbol('internals');\n\nfunction normalizeHeader(header) {\n  return header && String(header).trim().toLowerCase();\n}\n\nfunction normalizeValue(value) {\n  if (value === false || value == null) {\n    return value;\n  }\n\n  return utils.isArray(value) ? value.map(normalizeValue) : String(value);\n}\n\nfunction parseTokens(str) {\n  const tokens = Object.create(null);\n  const tokensRE = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n  let match;\n\n  while ((match = tokensRE.exec(str))) {\n    tokens[match[1]] = match[2];\n  }\n\n  return tokens;\n}\n\nconst isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());\n\nfunction matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {\n  if (utils.isFunction(filter)) {\n    return filter.call(this, value, header);\n  }\n\n  if (isHeaderNameFilter) {\n    value = header;\n  }\n\n  if (!utils.isString(value)) return;\n\n  if (utils.isString(filter)) {\n    return value.indexOf(filter) !== -1;\n  }\n\n  if (utils.isRegExp(filter)) {\n    return filter.test(value);\n  }\n}\n\nfunction formatHeader(header) {\n  return header.trim()\n    .toLowerCase().replace(/([a-z\\d])(\\w*)/g, (w, char, str) => {\n      return char.toUpperCase() + str;\n    });\n}\n\nfunction buildAccessors(obj, header) {\n  const accessorName = utils.toCamelCase(' ' + header);\n\n  ['get', 'set', 'has'].forEach(methodName => {\n    Object.defineProperty(obj, methodName + accessorName, {\n      value: function(arg1, arg2, arg3) {\n        return this[methodName].call(this, header, arg1, arg2, arg3);\n      },\n      configurable: true\n    });\n  });\n}\n\nclass AxiosHeaders {\n  constructor(headers) {\n    headers && this.set(headers);\n  }\n\n  set(header, valueOrRewrite, rewrite) {\n    const self = this;\n\n    function setHeader(_value, _header, _rewrite) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!lHeader) {\n        throw new Error('header name must be a non-empty string');\n      }\n\n      const key = utils.findKey(self, lHeader);\n\n      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {\n        self[key || _header] = normalizeValue(_value);\n      }\n    }\n\n    const setHeaders = (headers, _rewrite) =>\n      utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));\n\n    if (utils.isPlainObject(header) || header instanceof this.constructor) {\n      setHeaders(header, valueOrRewrite)\n    } else if(utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {\n      setHeaders(parseHeaders(header), valueOrRewrite);\n    } else if (utils.isObject(header) && utils.isIterable(header)) {\n      let obj = {}, dest, key;\n      for (const entry of header) {\n        if (!utils.isArray(entry)) {\n          throw TypeError('Object iterator must return a key-value pair');\n        }\n\n        obj[key = entry[0]] = (dest = obj[key]) ?\n          (utils.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]]) : entry[1];\n      }\n\n      setHeaders(obj, valueOrRewrite)\n    } else {\n      header != null && setHeader(valueOrRewrite, header, rewrite);\n    }\n\n    return this;\n  }\n\n  get(header, parser) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      if (key) {\n        const value = this[key];\n\n        if (!parser) {\n          return value;\n        }\n\n        if (parser === true) {\n          return parseTokens(value);\n        }\n\n        if (utils.isFunction(parser)) {\n          return parser.call(this, value, key);\n        }\n\n        if (utils.isRegExp(parser)) {\n          return parser.exec(value);\n        }\n\n        throw new TypeError('parser must be boolean|regexp|function');\n      }\n    }\n  }\n\n  has(header, matcher) {\n    header = normalizeHeader(header);\n\n    if (header) {\n      const key = utils.findKey(this, header);\n\n      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));\n    }\n\n    return false;\n  }\n\n  delete(header, matcher) {\n    const self = this;\n    let deleted = false;\n\n    function deleteHeader(_header) {\n      _header = normalizeHeader(_header);\n\n      if (_header) {\n        const key = utils.findKey(self, _header);\n\n        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {\n          delete self[key];\n\n          deleted = true;\n        }\n      }\n    }\n\n    if (utils.isArray(header)) {\n      header.forEach(deleteHeader);\n    } else {\n      deleteHeader(header);\n    }\n\n    return deleted;\n  }\n\n  clear(matcher) {\n    const keys = Object.keys(this);\n    let i = keys.length;\n    let deleted = false;\n\n    while (i--) {\n      const key = keys[i];\n      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {\n        delete this[key];\n        deleted = true;\n      }\n    }\n\n    return deleted;\n  }\n\n  normalize(format) {\n    const self = this;\n    const headers = {};\n\n    utils.forEach(this, (value, header) => {\n      const key = utils.findKey(headers, header);\n\n      if (key) {\n        self[key] = normalizeValue(value);\n        delete self[header];\n        return;\n      }\n\n      const normalized = format ? formatHeader(header) : String(header).trim();\n\n      if (normalized !== header) {\n        delete self[header];\n      }\n\n      self[normalized] = normalizeValue(value);\n\n      headers[normalized] = true;\n    });\n\n    return this;\n  }\n\n  concat(...targets) {\n    return this.constructor.concat(this, ...targets);\n  }\n\n  toJSON(asStrings) {\n    const obj = Object.create(null);\n\n    utils.forEach(this, (value, header) => {\n      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);\n    });\n\n    return obj;\n  }\n\n  [Symbol.iterator]() {\n    return Object.entries(this.toJSON())[Symbol.iterator]();\n  }\n\n  toString() {\n    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\\n');\n  }\n\n  getSetCookie() {\n    return this.get(\"set-cookie\") || [];\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'AxiosHeaders';\n  }\n\n  static from(thing) {\n    return thing instanceof this ? thing : new this(thing);\n  }\n\n  static concat(first, ...targets) {\n    const computed = new this(first);\n\n    targets.forEach((target) => computed.set(target));\n\n    return computed;\n  }\n\n  static accessor(header) {\n    const internals = this[$internals] = (this[$internals] = {\n      accessors: {}\n    });\n\n    const accessors = internals.accessors;\n    const prototype = this.prototype;\n\n    function defineAccessor(_header) {\n      const lHeader = normalizeHeader(_header);\n\n      if (!accessors[lHeader]) {\n        buildAccessors(prototype, _header);\n        accessors[lHeader] = true;\n      }\n    }\n\n    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);\n\n    return this;\n  }\n}\n\nAxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);\n\n// reserved names hotfix\nutils.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {\n  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`\n  return {\n    get: () => value,\n    set(headerValue) {\n      this[mapped] = headerValue;\n    }\n  }\n});\n\nutils.freezeMethods(AxiosHeaders);\n\nexport default AxiosHeaders;\n","'use strict';\n\nimport utils from './../utils.js';\nimport defaults from '../defaults/index.js';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Array|Function} fns A single function or Array of functions\n * @param {?Object} response The response object\n *\n * @returns {*} The resulting transformed data\n */\nexport default function transformData(fns, response) {\n  const config = this || defaults;\n  const context = response || config;\n  const headers = AxiosHeaders.from(context.headers);\n  let data = context.data;\n\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);\n  });\n\n  headers.normalize();\n\n  return data;\n}\n","'use strict';\n\nimport AxiosError from '../core/AxiosError.js';\nimport utils from '../utils.js';\n\n/**\n * A `CanceledError` is an object that is thrown when an operation is canceled.\n *\n * @param {string=} message The message.\n * @param {Object=} config The config.\n * @param {Object=} request The request.\n *\n * @returns {CanceledError} The created error.\n */\nfunction CanceledError(message, config, request) {\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);\n  this.name = 'CanceledError';\n}\n\nutils.inherits(CanceledError, AxiosError, {\n  __CANCEL__: true\n});\n\nexport default CanceledError;\n","'use strict';\n\nimport AxiosError from './AxiosError.js';\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n *\n * @returns {object} The response.\n */\nexport default function settle(resolve, reject, response) {\n  const validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(new AxiosError(\n      'Request failed with status code ' + response.status,\n      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],\n      response.config,\n      response.request,\n      response\n    ));\n  }\n}\n","'use strict';\n\nimport isAbsoluteURL from '../helpers/isAbsoluteURL.js';\nimport combineURLs from '../helpers/combineURLs.js';\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n *\n * @returns {string} The combined full path\n */\nexport default function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {\n  let isRelativeUrl = !isAbsoluteURL(requestedURL);\n  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n}\n","'use strict';\n\nimport AxiosError from '../core/AxiosError.js';\nimport parseProtocol from './parseProtocol.js';\nimport platform from '../platform/index.js';\n\nconst DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\\s\\S]*)$/;\n\n/**\n * Parse data uri to a Buffer or Blob\n *\n * @param {String} uri\n * @param {?Boolean} asBlob\n * @param {?Object} options\n * @param {?Function} options.Blob\n *\n * @returns {Buffer|Blob}\n */\nexport default function fromDataURI(uri, asBlob, options) {\n  const _Blob = options && options.Blob || platform.classes.Blob;\n  const protocol = parseProtocol(uri);\n\n  if (asBlob === undefined && _Blob) {\n    asBlob = true;\n  }\n\n  if (protocol === 'data') {\n    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;\n\n    const match = DATA_URL_PATTERN.exec(uri);\n\n    if (!match) {\n      throw new AxiosError('Invalid URL', AxiosError.ERR_INVALID_URL);\n    }\n\n    const mime = match[1];\n    const isBase64 = match[2];\n    const body = match[3];\n    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? 'base64' : 'utf8');\n\n    if (asBlob) {\n      if (!_Blob) {\n        throw new AxiosError('Blob is not supported', AxiosError.ERR_NOT_SUPPORT);\n      }\n\n      return new _Blob([buffer], {type: mime});\n    }\n\n    return buffer;\n  }\n\n  throw new AxiosError('Unsupported protocol ' + protocol, AxiosError.ERR_NOT_SUPPORT);\n}\n","'use strict';\n\nimport stream from 'stream';\nimport utils from '../utils.js';\n\nconst kInternals = Symbol('internals');\n\nclass AxiosTransformStream extends stream.Transform{\n  constructor(options) {\n    options = utils.toFlatObject(options, {\n      maxRate: 0,\n      chunkSize: 64 * 1024,\n      minChunkSize: 100,\n      timeWindow: 500,\n      ticksRate: 2,\n      samplesCount: 15\n    }, null, (prop, source) => {\n      return !utils.isUndefined(source[prop]);\n    });\n\n    super({\n      readableHighWaterMark: options.chunkSize\n    });\n\n    const internals = this[kInternals] = {\n      timeWindow: options.timeWindow,\n      chunkSize: options.chunkSize,\n      maxRate: options.maxRate,\n      minChunkSize: options.minChunkSize,\n      bytesSeen: 0,\n      isCaptured: false,\n      notifiedBytesLoaded: 0,\n      ts: Date.now(),\n      bytes: 0,\n      onReadCallback: null\n    };\n\n    this.on('newListener', event => {\n      if (event === 'progress') {\n        if (!internals.isCaptured) {\n          internals.isCaptured = true;\n        }\n      }\n    });\n  }\n\n  _read(size) {\n    const internals = this[kInternals];\n\n    if (internals.onReadCallback) {\n      internals.onReadCallback();\n    }\n\n    return super._read(size);\n  }\n\n  _transform(chunk, encoding, callback) {\n    const internals = this[kInternals];\n    const maxRate = internals.maxRate;\n\n    const readableHighWaterMark = this.readableHighWaterMark;\n\n    const timeWindow = internals.timeWindow;\n\n    const divider = 1000 / timeWindow;\n    const bytesThreshold = (maxRate / divider);\n    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;\n\n    const pushChunk = (_chunk, _callback) => {\n      const bytes = Buffer.byteLength(_chunk);\n      internals.bytesSeen += bytes;\n      internals.bytes += bytes;\n\n      internals.isCaptured && this.emit('progress', internals.bytesSeen);\n\n      if (this.push(_chunk)) {\n        process.nextTick(_callback);\n      } else {\n        internals.onReadCallback = () => {\n          internals.onReadCallback = null;\n          process.nextTick(_callback);\n        };\n      }\n    }\n\n    const transformChunk = (_chunk, _callback) => {\n      const chunkSize = Buffer.byteLength(_chunk);\n      let chunkRemainder = null;\n      let maxChunkSize = readableHighWaterMark;\n      let bytesLeft;\n      let passed = 0;\n\n      if (maxRate) {\n        const now = Date.now();\n\n        if (!internals.ts || (passed = (now - internals.ts)) >= timeWindow) {\n          internals.ts = now;\n          bytesLeft = bytesThreshold - internals.bytes;\n          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;\n          passed = 0;\n        }\n\n        bytesLeft = bytesThreshold - internals.bytes;\n      }\n\n      if (maxRate) {\n        if (bytesLeft <= 0) {\n          // next time window\n          return setTimeout(() => {\n            _callback(null, _chunk);\n          }, timeWindow - passed);\n        }\n\n        if (bytesLeft < maxChunkSize) {\n          maxChunkSize = bytesLeft;\n        }\n      }\n\n      if (maxChunkSize && chunkSize > maxChunkSize && (chunkSize - maxChunkSize) > minChunkSize) {\n        chunkRemainder = _chunk.subarray(maxChunkSize);\n        _chunk = _chunk.subarray(0, maxChunkSize);\n      }\n\n      pushChunk(_chunk, chunkRemainder ? () => {\n        process.nextTick(_callback, null, chunkRemainder);\n      } : _callback);\n    };\n\n    transformChunk(chunk, function transformNextChunk(err, _chunk) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (_chunk) {\n        transformChunk(_chunk, transformNextChunk);\n      } else {\n        callback(null);\n      }\n    });\n  }\n}\n\nexport default AxiosTransformStream;\n","const {asyncIterator} = Symbol;\n\nconst readBlob = async function* (blob) {\n  if (blob.stream) {\n    yield* blob.stream()\n  } else if (blob.arrayBuffer) {\n    yield await blob.arrayBuffer()\n  } else if (blob[asyncIterator]) {\n    yield* blob[asyncIterator]();\n  } else {\n    yield blob;\n  }\n}\n\nexport default readBlob;\n","\"use strict\";\n\nimport stream from \"stream\";\n\nclass ZlibHeaderTransformStream extends stream.Transform {\n  __transform(chunk, encoding, callback) {\n    this.push(chunk);\n    callback();\n  }\n\n  _transform(chunk, encoding, callback) {\n    if (chunk.length !== 0) {\n      this._transform = this.__transform;\n\n      // Add Default Compression headers if no zlib headers are present\n      if (chunk[0] !== 120) { // Hex: 78\n        const header = Buffer.alloc(2);\n        header[0] = 120; // Hex: 78\n        header[1] = 156; // Hex: 9C \n        this.push(header, encoding);\n      }\n    }\n\n    this.__transform(chunk, encoding, callback);\n  }\n}\n\nexport default ZlibHeaderTransformStream;\n","/**\n * Throttle decorator\n * @param {Function} fn\n * @param {Number} freq\n * @return {Function}\n */\nfunction throttle(fn, freq) {\n  let timestamp = 0;\n  let threshold = 1000 / freq;\n  let lastArgs;\n  let timer;\n\n  const invoke = (args, now = Date.now()) => {\n    timestamp = now;\n    lastArgs = null;\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n    fn(...args);\n  }\n\n  const throttled = (...args) => {\n    const now = Date.now();\n    const passed = now - timestamp;\n    if ( passed >= threshold) {\n      invoke(args, now);\n    } else {\n      lastArgs = args;\n      if (!timer) {\n        timer = setTimeout(() => {\n          timer = null;\n          invoke(lastArgs)\n        }, threshold - passed);\n      }\n    }\n  }\n\n  const flush = () => lastArgs && invoke(lastArgs);\n\n  return [throttled, flush];\n}\n\nexport default throttle;\n","'use strict';\n\nimport utils from '../utils.js';\nimport AxiosHeaders from \"./AxiosHeaders.js\";\n\nconst headersToObject = (thing) => thing instanceof AxiosHeaders ? { ...thing } : thing;\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n *\n * @returns {Object} New object resulting from merging config2 to config1\n */\nexport default function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  const config = {};\n\n  function getMergedValue(target, source, prop, caseless) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge.call({caseless}, target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(a, b, prop, caseless) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(a, b, prop, caseless);\n    } else if (!utils.isUndefined(a)) {\n      return getMergedValue(undefined, a, prop, caseless);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(a, b) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(a, b) {\n    if (!utils.isUndefined(b)) {\n      return getMergedValue(undefined, b);\n    } else if (!utils.isUndefined(a)) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(a, b, prop) {\n    if (prop in config2) {\n      return getMergedValue(a, b);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, a);\n    }\n  }\n\n  const mergeMap = {\n    url: valueFromConfig2,\n    method: valueFromConfig2,\n    data: valueFromConfig2,\n    baseURL: defaultToConfig2,\n    transformRequest: defaultToConfig2,\n    transformResponse: defaultToConfig2,\n    paramsSerializer: defaultToConfig2,\n    timeout: defaultToConfig2,\n    timeoutMessage: defaultToConfig2,\n    withCredentials: defaultToConfig2,\n    withXSRFToken: defaultToConfig2,\n    adapter: defaultToConfig2,\n    responseType: defaultToConfig2,\n    xsrfCookieName: defaultToConfig2,\n    xsrfHeaderName: defaultToConfig2,\n    onUploadProgress: defaultToConfig2,\n    onDownloadProgress: defaultToConfig2,\n    decompress: defaultToConfig2,\n    maxContentLength: defaultToConfig2,\n    maxBodyLength: defaultToConfig2,\n    beforeRedirect: defaultToConfig2,\n    transport: defaultToConfig2,\n    httpAgent: defaultToConfig2,\n    httpsAgent: defaultToConfig2,\n    cancelToken: defaultToConfig2,\n    socketPath: defaultToConfig2,\n    responseEncoding: defaultToConfig2,\n    validateStatus: mergeDirectKeys,\n    headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)\n  };\n\n  utils.forEach(Object.keys({...config1, ...config2}), function computeConfigValue(prop) {\n    const merge = mergeMap[prop] || mergeDeepProperties;\n    const configValue = merge(config1[prop], config2[prop], prop);\n    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n  });\n\n  return config;\n}\n","'use strict';\n\nimport transformData from './transformData.js';\nimport isCancel from '../cancel/isCancel.js';\nimport defaults from '../defaults/index.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport adapters from \"../adapters/adapters.js\";\n\n/**\n * Throws a `CanceledError` if cancellation has been requested.\n *\n * @param {Object} config The config that is to be used for the request\n *\n * @returns {void}\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new CanceledError(null, config);\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n *\n * @returns {Promise} The Promise to be fulfilled\n */\nexport default function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  config.headers = AxiosHeaders.from(config.headers);\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.transformRequest\n  );\n\n  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {\n    config.headers.setContentType('application/x-www-form-urlencoded', false);\n  }\n\n  const adapter = adapters.getAdapter(config.adapter || defaults.adapter, config);\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      config.transformResponse,\n      response\n    );\n\n    response.headers = AxiosHeaders.from(response.headers);\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          config.transformResponse,\n          reason.response\n        );\n        reason.response.headers = AxiosHeaders.from(reason.response.headers);\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n}\n","'use strict';\n\nimport {VERSION} from '../env/data.js';\nimport AxiosError from '../core/AxiosError.js';\n\nconst validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nconst deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n *\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n *\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return (value, opt, opts) => {\n    if (validator === false) {\n      throw new AxiosError(\n        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),\n        AxiosError.ERR_DEPRECATED\n      );\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\nvalidators.spelling = function spelling(correctSpelling) {\n  return (value, opt) => {\n    // eslint-disable-next-line no-console\n    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);\n    return true;\n  }\n};\n\n/**\n * Assert object's properties type\n *\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n *\n * @returns {object}\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);\n  }\n  const keys = Object.keys(options);\n  let i = keys.length;\n  while (i-- > 0) {\n    const opt = keys[i];\n    const validator = schema[opt];\n    if (validator) {\n      const value = options[opt];\n      const result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);\n    }\n  }\n}\n\nexport default {\n  assertOptions,\n  validators\n};\n","'use strict';\n\nimport utils from './../utils.js';\nimport buildURL from '../helpers/buildURL.js';\nimport InterceptorManager from './InterceptorManager.js';\nimport dispatchRequest from './dispatchRequest.js';\nimport mergeConfig from './mergeConfig.js';\nimport buildFullPath from './buildFullPath.js';\nimport validator from '../helpers/validator.js';\nimport AxiosHeaders from './AxiosHeaders.js';\n\nconst validators = validator.validators;\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n *\n * @return {Axios} A new instance of Axios\n */\nclass Axios {\n  constructor(instanceConfig) {\n    this.defaults = instanceConfig || {};\n    this.interceptors = {\n      request: new InterceptorManager(),\n      response: new InterceptorManager()\n    };\n  }\n\n  /**\n   * Dispatch a request\n   *\n   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n   * @param {?Object} config\n   *\n   * @returns {Promise} The Promise to be fulfilled\n   */\n  async request(configOrUrl, config) {\n    try {\n      return await this._request(configOrUrl, config);\n    } catch (err) {\n      if (err instanceof Error) {\n        let dummy = {};\n\n        Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());\n\n        // slice off the Error: ... line\n        const stack = dummy.stack ? dummy.stack.replace(/^.+\\n/, '') : '';\n        try {\n          if (!err.stack) {\n            err.stack = stack;\n            // match without the 2 top stack lines\n          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\\n.+\\n/, ''))) {\n            err.stack += '\\n' + stack\n          }\n        } catch (e) {\n          // ignore the case where \"stack\" is an un-writable property\n        }\n      }\n\n      throw err;\n    }\n  }\n\n  _request(configOrUrl, config) {\n    /*eslint no-param-reassign:0*/\n    // Allow for axios('example/url'[, config]) a la fetch API\n    if (typeof configOrUrl === 'string') {\n      config = config || {};\n      config.url = configOrUrl;\n    } else {\n      config = configOrUrl || {};\n    }\n\n    config = mergeConfig(this.defaults, config);\n\n    const {transitional, paramsSerializer, headers} = config;\n\n    if (transitional !== undefined) {\n      validator.assertOptions(transitional, {\n        silentJSONParsing: validators.transitional(validators.boolean),\n        forcedJSONParsing: validators.transitional(validators.boolean),\n        clarifyTimeoutError: validators.transitional(validators.boolean)\n      }, false);\n    }\n\n    if (paramsSerializer != null) {\n      if (utils.isFunction(paramsSerializer)) {\n        config.paramsSerializer = {\n          serialize: paramsSerializer\n        }\n      } else {\n        validator.assertOptions(paramsSerializer, {\n          encode: validators.function,\n          serialize: validators.function\n        }, true);\n      }\n    }\n\n    // Set config.allowAbsoluteUrls\n    if (config.allowAbsoluteUrls !== undefined) {\n      // do nothing\n    } else if (this.defaults.allowAbsoluteUrls !== undefined) {\n      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;\n    } else {\n      config.allowAbsoluteUrls = true;\n    }\n\n    validator.assertOptions(config, {\n      baseUrl: validators.spelling('baseURL'),\n      withXsrfToken: validators.spelling('withXSRFToken')\n    }, true);\n\n    // Set config.method\n    config.method = (config.method || this.defaults.method || 'get').toLowerCase();\n\n    // Flatten headers\n    let contextHeaders = headers && utils.merge(\n      headers.common,\n      headers[config.method]\n    );\n\n    headers && utils.forEach(\n      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n      (method) => {\n        delete headers[method];\n      }\n    );\n\n    config.headers = AxiosHeaders.concat(contextHeaders, headers);\n\n    // filter out skipped interceptors\n    const requestInterceptorChain = [];\n    let synchronousRequestInterceptors = true;\n    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n        return;\n      }\n\n      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    const responseInterceptorChain = [];\n    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n    });\n\n    let promise;\n    let i = 0;\n    let len;\n\n    if (!synchronousRequestInterceptors) {\n      const chain = [dispatchRequest.bind(this), undefined];\n      chain.unshift(...requestInterceptorChain);\n      chain.push(...responseInterceptorChain);\n      len = chain.length;\n\n      promise = Promise.resolve(config);\n\n      while (i < len) {\n        promise = promise.then(chain[i++], chain[i++]);\n      }\n\n      return promise;\n    }\n\n    len = requestInterceptorChain.length;\n\n    let newConfig = config;\n\n    while (i < len) {\n      const onFulfilled = requestInterceptorChain[i++];\n      const onRejected = requestInterceptorChain[i++];\n      try {\n        newConfig = onFulfilled(newConfig);\n      } catch (error) {\n        onRejected.call(this, error);\n        break;\n      }\n    }\n\n    try {\n      promise = dispatchRequest.call(this, newConfig);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    i = 0;\n    len = responseInterceptorChain.length;\n\n    while (i < len) {\n      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);\n    }\n\n    return promise;\n  }\n\n  getUri(config) {\n    config = mergeConfig(this.defaults, config);\n    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);\n    return buildURL(fullPath, config.params, config.paramsSerializer);\n  }\n}\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method,\n      url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n\n  function generateHTTPMethod(isForm) {\n    return function httpMethod(url, data, config) {\n      return this.request(mergeConfig(config || {}, {\n        method,\n        headers: isForm ? {\n          'Content-Type': 'multipart/form-data'\n        } : {},\n        url,\n        data\n      }));\n    };\n  }\n\n  Axios.prototype[method] = generateHTTPMethod();\n\n  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);\n});\n\nexport default Axios;\n","'use strict';\n\nimport CanceledError from './CanceledError.js';\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @param {Function} executor The executor function.\n *\n * @returns {CancelToken}\n */\nclass CancelToken {\n  constructor(executor) {\n    if (typeof executor !== 'function') {\n      throw new TypeError('executor must be a function.');\n    }\n\n    let resolvePromise;\n\n    this.promise = new Promise(function promiseExecutor(resolve) {\n      resolvePromise = resolve;\n    });\n\n    const token = this;\n\n    // eslint-disable-next-line func-names\n    this.promise.then(cancel => {\n      if (!token._listeners) return;\n\n      let i = token._listeners.length;\n\n      while (i-- > 0) {\n        token._listeners[i](cancel);\n      }\n      token._listeners = null;\n    });\n\n    // eslint-disable-next-line func-names\n    this.promise.then = onfulfilled => {\n      let _resolve;\n      // eslint-disable-next-line func-names\n      const promise = new Promise(resolve => {\n        token.subscribe(resolve);\n        _resolve = resolve;\n      }).then(onfulfilled);\n\n      promise.cancel = function reject() {\n        token.unsubscribe(_resolve);\n      };\n\n      return promise;\n    };\n\n    executor(function cancel(message, config, request) {\n      if (token.reason) {\n        // Cancellation has already been requested\n        return;\n      }\n\n      token.reason = new CanceledError(message, config, request);\n      resolvePromise(token.reason);\n    });\n  }\n\n  /**\n   * Throws a `CanceledError` if cancellation has been requested.\n   */\n  throwIfRequested() {\n    if (this.reason) {\n      throw this.reason;\n    }\n  }\n\n  /**\n   * Subscribe to the cancel signal\n   */\n\n  subscribe(listener) {\n    if (this.reason) {\n      listener(this.reason);\n      return;\n    }\n\n    if (this._listeners) {\n      this._listeners.push(listener);\n    } else {\n      this._listeners = [listener];\n    }\n  }\n\n  /**\n   * Unsubscribe from the cancel signal\n   */\n\n  unsubscribe(listener) {\n    if (!this._listeners) {\n      return;\n    }\n    const index = this._listeners.indexOf(listener);\n    if (index !== -1) {\n      this._listeners.splice(index, 1);\n    }\n  }\n\n  toAbortSignal() {\n    const controller = new AbortController();\n\n    const abort = (err) => {\n      controller.abort(err);\n    };\n\n    this.subscribe(abort);\n\n    controller.signal.unsubscribe = () => this.unsubscribe(abort);\n\n    return controller.signal;\n  }\n\n  /**\n   * Returns an object that contains a new `CancelToken` and a function that, when called,\n   * cancels the `CancelToken`.\n   */\n  static source() {\n    let cancel;\n    const token = new CancelToken(function executor(c) {\n      cancel = c;\n    });\n    return {\n      token,\n      cancel\n    };\n  }\n}\n\nexport default CancelToken;\n","'use strict';\n\nimport utils from './../utils.js';\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n *\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nexport default function isAxiosError(payload) {\n  return utils.isObject(payload) && (payload.isAxiosError === true);\n}\n","const HttpStatusCode = {\n  Continue: 100,\n  SwitchingProtocols: 101,\n  Processing: 102,\n  EarlyHints: 103,\n  Ok: 200,\n  Created: 201,\n  Accepted: 202,\n  NonAuthoritativeInformation: 203,\n  NoContent: 204,\n  ResetContent: 205,\n  PartialContent: 206,\n  MultiStatus: 207,\n  AlreadyReported: 208,\n  ImUsed: 226,\n  MultipleChoices: 300,\n  MovedPermanently: 301,\n  Found: 302,\n  SeeOther: 303,\n  NotModified: 304,\n  UseProxy: 305,\n  Unused: 306,\n  TemporaryRedirect: 307,\n  PermanentRedirect: 308,\n  BadRequest: 400,\n  Unauthorized: 401,\n  PaymentRequired: 402,\n  Forbidden: 403,\n  NotFound: 404,\n  MethodNotAllowed: 405,\n  NotAcceptable: 406,\n  ProxyAuthenticationRequired: 407,\n  RequestTimeout: 408,\n  Conflict: 409,\n  Gone: 410,\n  LengthRequired: 411,\n  PreconditionFailed: 412,\n  PayloadTooLarge: 413,\n  UriTooLong: 414,\n  UnsupportedMediaType: 415,\n  RangeNotSatisfiable: 416,\n  ExpectationFailed: 417,\n  ImATeapot: 418,\n  MisdirectedRequest: 421,\n  UnprocessableEntity: 422,\n  Locked: 423,\n  FailedDependency: 424,\n  TooEarly: 425,\n  UpgradeRequired: 426,\n  PreconditionRequired: 428,\n  TooManyRequests: 429,\n  RequestHeaderFieldsTooLarge: 431,\n  UnavailableForLegalReasons: 451,\n  InternalServerError: 500,\n  NotImplemented: 501,\n  BadGateway: 502,\n  ServiceUnavailable: 503,\n  GatewayTimeout: 504,\n  HttpVersionNotSupported: 505,\n  VariantAlsoNegotiates: 506,\n  InsufficientStorage: 507,\n  LoopDetected: 508,\n  NotExtended: 510,\n  NetworkAuthenticationRequired: 511,\n  WebServerIsDown: 521,\n  ConnectionTimedOut: 522,\n  OriginIsUnreachable: 523,\n  TimeoutOccurred: 524,\n  SslHandshakeFailed: 525,\n  InvalidSslCertificate: 526,\n};\n\nObject.entries(HttpStatusCode).forEach(([key, value]) => {\n  HttpStatusCode[value] = key;\n});\n\nexport default HttpStatusCode;\n","'use strict';\n\nimport utils from './utils.js';\nimport bind from './helpers/bind.js';\nimport Axios from './core/Axios.js';\nimport mergeConfig from './core/mergeConfig.js';\nimport defaults from './defaults/index.js';\nimport formDataToJSON from './helpers/formDataToJSON.js';\nimport CanceledError from './cancel/CanceledError.js';\nimport CancelToken from './cancel/CancelToken.js';\nimport isCancel from './cancel/isCancel.js';\nimport {VERSION} from './env/data.js';\nimport toFormData from './helpers/toFormData.js';\nimport AxiosError from './core/AxiosError.js';\nimport spread from './helpers/spread.js';\nimport isAxiosError from './helpers/isAxiosError.js';\nimport AxiosHeaders from \"./core/AxiosHeaders.js\";\nimport adapters from './adapters/adapters.js';\nimport HttpStatusCode from './helpers/HttpStatusCode.js';\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n *\n * @returns {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  const context = new Axios(defaultConfig);\n  const instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context, {allOwnKeys: true});\n\n  // Copy context to instance\n  utils.extend(instance, context, null, {allOwnKeys: true});\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n}\n\n// Create the default instance to be exported\nconst axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Expose Cancel & CancelToken\naxios.CanceledError = CanceledError;\naxios.CancelToken = CancelToken;\naxios.isCancel = isCancel;\naxios.VERSION = VERSION;\naxios.toFormData = toFormData;\n\n// Expose AxiosError class\naxios.AxiosError = AxiosError;\n\n// alias for CanceledError for backward compatibility\naxios.Cancel = axios.CanceledError;\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\n\naxios.spread = spread;\n\n// Expose isAxiosError\naxios.isAxiosError = isAxiosError;\n\n// Expose mergeConfig\naxios.mergeConfig = mergeConfig;\n\naxios.AxiosHeaders = AxiosHeaders;\n\naxios.formToJSON = thing => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);\n\naxios.getAdapter = adapters.getAdapter;\n\naxios.HttpStatusCode = HttpStatusCode;\n\naxios.default = axios;\n\n// this module should only have a default export\nexport default axios\n","import isRetryAllowed from 'is-retry-allowed';\nexport const namespace = 'axios-retry';\nexport function isNetworkError(error) {\n    const CODE_EXCLUDE_LIST = ['ERR_CANCELED', 'ECONNABORTED'];\n    if (error.response) {\n        return false;\n    }\n    if (!error.code) {\n        return false;\n    }\n    // Prevents retrying timed out & cancelled requests\n    if (CODE_EXCLUDE_LIST.includes(error.code)) {\n        return false;\n    }\n    // Prevents retrying unsafe errors\n    return isRetryAllowed(error);\n}\nconst SAFE_HTTP_METHODS = ['get', 'head', 'options'];\nconst IDEMPOTENT_HTTP_METHODS = SAFE_HTTP_METHODS.concat(['put', 'delete']);\nexport function isRetryableError(error) {\n    return (error.code !== 'ECONNABORTED' &&\n        (!error.response ||\n            error.response.status === 429 ||\n            (error.response.status >= 500 && error.response.status <= 599)));\n}\nexport function isSafeRequestError(error) {\n    if (!error.config?.method) {\n        // Cannot determine if the request can be retried\n        return false;\n    }\n    return isRetryableError(error) && SAFE_HTTP_METHODS.indexOf(error.config.method) !== -1;\n}\nexport function isIdempotentRequestError(error) {\n    if (!error.config?.method) {\n        // Cannot determine if the request can be retried\n        return false;\n    }\n    return isRetryableError(error) && IDEMPOTENT_HTTP_METHODS.indexOf(error.config.method) !== -1;\n}\nexport function isNetworkOrIdempotentRequestError(error) {\n    return isNetworkError(error) || isIdempotentRequestError(error);\n}\nexport function retryAfter(error = undefined) {\n    const retryAfterHeader = error?.response?.headers['retry-after'];\n    if (!retryAfterHeader) {\n        return 0;\n    }\n    // if the retry after header is a number, convert it to milliseconds\n    let retryAfterMs = (Number(retryAfterHeader) || 0) * 1000;\n    // If the retry after header is a date, get the number of milliseconds until that date\n    if (retryAfterMs === 0) {\n        retryAfterMs = (new Date(retryAfterHeader).valueOf() || 0) - Date.now();\n    }\n    return Math.max(0, retryAfterMs);\n}\nfunction noDelay(_retryNumber = 0, error = undefined) {\n    return Math.max(0, retryAfter(error));\n}\nexport function exponentialDelay(retryNumber = 0, error = undefined, delayFactor = 100) {\n    const calculatedDelay = 2 ** retryNumber * delayFactor;\n    const delay = Math.max(calculatedDelay, retryAfter(error));\n    const randomSum = delay * 0.2 * Math.random(); // 0-20% of the delay\n    return delay + randomSum;\n}\n/**\n * Linear delay\n * @param {number | undefined} delayFactor - delay factor in milliseconds (default: 100)\n * @returns {function} (retryNumber: number, error: AxiosError | undefined) => number\n */\nexport function linearDelay(delayFactor = 100) {\n    return (retryNumber = 0, error = undefined) => {\n        const delay = retryNumber * delayFactor;\n        return Math.max(delay, retryAfter(error));\n    };\n}\nexport const DEFAULT_OPTIONS = {\n    retries: 3,\n    retryCondition: isNetworkOrIdempotentRequestError,\n    retryDelay: noDelay,\n    shouldResetTimeout: false,\n    onRetry: () => { },\n    onMaxRetryTimesExceeded: () => { },\n    validateResponse: null\n};\nfunction getRequestOptions(config, defaultOptions) {\n    return { ...DEFAULT_OPTIONS, ...defaultOptions, ...config[namespace] };\n}\nfunction setCurrentState(config, defaultOptions, resetLastRequestTime = false) {\n    const currentState = getRequestOptions(config, defaultOptions || {});\n    currentState.retryCount = currentState.retryCount || 0;\n    if (!currentState.lastRequestTime || resetLastRequestTime) {\n        currentState.lastRequestTime = Date.now();\n    }\n    config[namespace] = currentState;\n    return currentState;\n}\nfunction fixConfig(axiosInstance, config) {\n    // @ts-ignore\n    if (axiosInstance.defaults.agent === config.agent) {\n        // @ts-ignore\n        delete config.agent;\n    }\n    if (axiosInstance.defaults.httpAgent === config.httpAgent) {\n        delete config.httpAgent;\n    }\n    if (axiosInstance.defaults.httpsAgent === config.httpsAgent) {\n        delete config.httpsAgent;\n    }\n}\nasync function shouldRetry(currentState, error) {\n    const { retries, retryCondition } = currentState;\n    const shouldRetryOrPromise = (currentState.retryCount || 0) < retries && retryCondition(error);\n    // This could be a promise\n    if (typeof shouldRetryOrPromise === 'object') {\n        try {\n            const shouldRetryPromiseResult = await shouldRetryOrPromise;\n            // keep return true unless shouldRetryPromiseResult return false for compatibility\n            return shouldRetryPromiseResult !== false;\n        }\n        catch (_err) {\n            return false;\n        }\n    }\n    return shouldRetryOrPromise;\n}\nasync function handleRetry(axiosInstance, currentState, error, config) {\n    currentState.retryCount += 1;\n    const { retryDelay, shouldResetTimeout, onRetry } = currentState;\n    const delay = retryDelay(currentState.retryCount, error);\n    // Axios fails merging this configuration to the default configuration because it has an issue\n    // with circular structures: https://github.com/mzabriskie/axios/issues/370\n    fixConfig(axiosInstance, config);\n    if (!shouldResetTimeout && config.timeout && currentState.lastRequestTime) {\n        const lastRequestDuration = Date.now() - currentState.lastRequestTime;\n        const timeout = config.timeout - lastRequestDuration - delay;\n        if (timeout <= 0) {\n            return Promise.reject(error);\n        }\n        config.timeout = timeout;\n    }\n    config.transformRequest = [(data) => data];\n    await onRetry(currentState.retryCount, error, config);\n    if (config.signal?.aborted) {\n        return Promise.resolve(axiosInstance(config));\n    }\n    return new Promise((resolve) => {\n        const abortListener = () => {\n            clearTimeout(timeout);\n            resolve(axiosInstance(config));\n        };\n        const timeout = setTimeout(() => {\n            resolve(axiosInstance(config));\n            if (config.signal?.removeEventListener) {\n                config.signal.removeEventListener('abort', abortListener);\n            }\n        }, delay);\n        if (config.signal?.addEventListener) {\n            config.signal.addEventListener('abort', abortListener, { once: true });\n        }\n    });\n}\nasync function handleMaxRetryTimesExceeded(currentState, error) {\n    if (currentState.retryCount >= currentState.retries)\n        await currentState.onMaxRetryTimesExceeded(error, currentState.retryCount);\n}\nconst axiosRetry = (axiosInstance, defaultOptions) => {\n    const requestInterceptorId = axiosInstance.interceptors.request.use((config) => {\n        setCurrentState(config, defaultOptions, true);\n        if (config[namespace]?.validateResponse) {\n            // by setting this, all HTTP responses will be go through the error interceptor first\n            config.validateStatus = () => false;\n        }\n        return config;\n    });\n    const responseInterceptorId = axiosInstance.interceptors.response.use(null, async (error) => {\n        const { config } = error;\n        // If we have no information to retry the request\n        if (!config) {\n            return Promise.reject(error);\n        }\n        const currentState = setCurrentState(config, defaultOptions);\n        if (error.response && currentState.validateResponse?.(error.response)) {\n            // no issue with response\n            return error.response;\n        }\n        if (await shouldRetry(currentState, error)) {\n            return handleRetry(axiosInstance, currentState, error, config);\n        }\n        await handleMaxRetryTimesExceeded(currentState, error);\n        return Promise.reject(error);\n    });\n    return { requestInterceptorId, responseInterceptorId };\n};\n// Compatibility with CommonJS\naxiosRetry.isNetworkError = isNetworkError;\naxiosRetry.isSafeRequestError = isSafeRequestError;\naxiosRetry.isIdempotentRequestError = isIdempotentRequestError;\naxiosRetry.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;\naxiosRetry.exponentialDelay = exponentialDelay;\naxiosRetry.linearDelay = linearDelay;\naxiosRetry.isRetryableError = isRetryableError;\nexport default axiosRetry;\n","const unusable = (name, prop = 'algorithm.name') => new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);\nconst isAlgorithm = (algorithm, name) => algorithm.name === name;\nfunction getHashLength(hash) {\n    return parseInt(hash.name.slice(4), 10);\n}\nfunction getNamedCurve(alg) {\n    switch (alg) {\n        case 'ES256':\n            return 'P-256';\n        case 'ES384':\n            return 'P-384';\n        case 'ES512':\n            return 'P-521';\n        default:\n            throw new Error('unreachable');\n    }\n}\nfunction checkUsage(key, usage) {\n    if (usage && !key.usages.includes(usage)) {\n        throw new TypeError(`CryptoKey does not support this operation, its usages must include ${usage}.`);\n    }\n}\nexport function checkSigCryptoKey(key, alg, usage) {\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512': {\n            if (!isAlgorithm(key.algorithm, 'HMAC'))\n                throw unusable('HMAC');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'RS256':\n        case 'RS384':\n        case 'RS512': {\n            if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5'))\n                throw unusable('RSASSA-PKCS1-v1_5');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'PS256':\n        case 'PS384':\n        case 'PS512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-PSS'))\n                throw unusable('RSA-PSS');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'Ed25519':\n        case 'EdDSA': {\n            if (!isAlgorithm(key.algorithm, 'Ed25519'))\n                throw unusable('Ed25519');\n            break;\n        }\n        case 'ML-DSA-44':\n        case 'ML-DSA-65':\n        case 'ML-DSA-87': {\n            if (!isAlgorithm(key.algorithm, alg))\n                throw unusable(alg);\n            break;\n        }\n        case 'ES256':\n        case 'ES384':\n        case 'ES512': {\n            if (!isAlgorithm(key.algorithm, 'ECDSA'))\n                throw unusable('ECDSA');\n            const expected = getNamedCurve(alg);\n            const actual = key.algorithm.namedCurve;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.namedCurve');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usage);\n}\nexport function checkEncCryptoKey(key, alg, usage) {\n    switch (alg) {\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM': {\n            if (!isAlgorithm(key.algorithm, 'AES-GCM'))\n                throw unusable('AES-GCM');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            if (!isAlgorithm(key.algorithm, 'AES-KW'))\n                throw unusable('AES-KW');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'ECDH': {\n            switch (key.algorithm.name) {\n                case 'ECDH':\n                case 'X25519':\n                    break;\n                default:\n                    throw unusable('ECDH or X25519');\n            }\n            break;\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW':\n            if (!isAlgorithm(key.algorithm, 'PBKDF2'))\n                throw unusable('PBKDF2');\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-OAEP'))\n                throw unusable('RSA-OAEP');\n            const expected = parseInt(alg.slice(9), 10) || 1;\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usage);\n}\n","function message(msg, actual, ...types) {\n    types = types.filter(Boolean);\n    if (types.length > 2) {\n        const last = types.pop();\n        msg += `one of type ${types.join(', ')}, or ${last}.`;\n    }\n    else if (types.length === 2) {\n        msg += `one of type ${types[0]} or ${types[1]}.`;\n    }\n    else {\n        msg += `of type ${types[0]}.`;\n    }\n    if (actual == null) {\n        msg += ` Received ${actual}`;\n    }\n    else if (typeof actual === 'function' && actual.name) {\n        msg += ` Received function ${actual.name}`;\n    }\n    else if (typeof actual === 'object' && actual != null) {\n        if (actual.constructor?.name) {\n            msg += ` Received an instance of ${actual.constructor.name}`;\n        }\n    }\n    return msg;\n}\nexport const invalidKeyInput = (actual, ...types) => message('Key must be ', actual, ...types);\nexport const withAlg = (alg, actual, ...types) => message(`Key for the ${alg} algorithm must be `, actual, ...types);\n","const isObjectLike = (value) => typeof value === 'object' && value !== null;\nexport function isObject(input) {\n    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(input) === null) {\n        return true;\n    }\n    let proto = input;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(input) === proto;\n}\n","'use strict';\n\nimport utils from '../utils.js';\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [config] The config.\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n *\n * @returns {Error} The created error.\n */\nfunction AxiosError(message, code, config, request, response) {\n  Error.call(this);\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = (new Error()).stack;\n  }\n\n  this.message = message;\n  this.name = 'AxiosError';\n  code && (this.code = code);\n  config && (this.config = config);\n  request && (this.request = request);\n  if (response) {\n    this.response = response;\n    this.status = response.status ? response.status : null;\n  }\n}\n\nutils.inherits(AxiosError, Error, {\n  toJSON: function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: utils.toJSONObject(this.config),\n      code: this.code,\n      status: this.status\n    };\n  }\n});\n\nconst prototype = AxiosError.prototype;\nconst descriptors = {};\n\n[\n  'ERR_BAD_OPTION_VALUE',\n  'ERR_BAD_OPTION',\n  'ECONNABORTED',\n  'ETIMEDOUT',\n  'ERR_NETWORK',\n  'ERR_FR_TOO_MANY_REDIRECTS',\n  'ERR_DEPRECATED',\n  'ERR_BAD_RESPONSE',\n  'ERR_BAD_REQUEST',\n  'ERR_CANCELED',\n  'ERR_NOT_SUPPORT',\n  'ERR_INVALID_URL'\n// eslint-disable-next-line func-names\n].forEach(code => {\n  descriptors[code] = {value: code};\n});\n\nObject.defineProperties(AxiosError, descriptors);\nObject.defineProperty(prototype, 'isAxiosError', {value: true});\n\n// eslint-disable-next-line func-names\nAxiosError.from = (error, code, config, request, response, customProps) => {\n  const axiosError = Object.create(prototype);\n\n  utils.toFlatObject(error, axiosError, function filter(obj) {\n    return obj !== Error.prototype;\n  }, prop => {\n    return prop !== 'isAxiosError';\n  });\n\n  const msg = error && error.message ? error.message : 'Error';\n\n  // Prefer explicit code; otherwise copy the low-level error's code (e.g. ECONNREFUSED)\n  const errCode = code == null && error ? error.code : code;\n  AxiosError.call(axiosError, msg, errCode, config, request, response);\n\n  // Chain the original error on the standard field; non-enumerable to avoid JSON noise\n  if (error && axiosError.cause == null) {\n    Object.defineProperty(axiosError, 'cause', { value: error, configurable: true });\n  }\n\n  axiosError.name = (error && error.name) || 'Error';\n\n  customProps && Object.assign(axiosError, customProps);\n\n  return axiosError;\n};\n\nexport default AxiosError;\n","export const VERSION = \"1.13.2\";","export const encoder = new TextEncoder();\nexport const decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\nexport function concat(...buffers) {\n    const size = buffers.reduce((acc, { length }) => acc + length, 0);\n    const buf = new Uint8Array(size);\n    let i = 0;\n    for (const buffer of buffers) {\n        buf.set(buffer, i);\n        i += buffer.length;\n    }\n    return buf;\n}\nfunction writeUInt32BE(buf, value, offset) {\n    if (value < 0 || value >= MAX_INT32) {\n        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);\n    }\n    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\nexport function uint64be(value) {\n    const high = Math.floor(value / MAX_INT32);\n    const low = value % MAX_INT32;\n    const buf = new Uint8Array(8);\n    writeUInt32BE(buf, high, 0);\n    writeUInt32BE(buf, low, 4);\n    return buf;\n}\nexport function uint32be(value) {\n    const buf = new Uint8Array(4);\n    writeUInt32BE(buf, value);\n    return buf;\n}\nexport function encode(string) {\n    const bytes = new Uint8Array(string.length);\n    for (let i = 0; i < string.length; i++) {\n        const code = string.charCodeAt(i);\n        if (code > 127) {\n            throw new TypeError('non-ASCII string encountered in encode()');\n        }\n        bytes[i] = code;\n    }\n    return bytes;\n}\n","export function encodeBase64(input) {\n    if (Uint8Array.prototype.toBase64) {\n        return input.toBase64();\n    }\n    const CHUNK_SIZE = 0x8000;\n    const arr = [];\n    for (let i = 0; i < input.length; i += CHUNK_SIZE) {\n        arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join(''));\n}\nexport function decodeBase64(encoded) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(encoded);\n    }\n    const binary = atob(encoded);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\n","export class JOSEError extends Error {\n    static code = 'ERR_JOSE_GENERIC';\n    code = 'ERR_JOSE_GENERIC';\n    constructor(message, options) {\n        super(message, options);\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nexport class JWTClaimValidationFailed extends JOSEError {\n    static code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    claim;\n    reason;\n    payload;\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {\n        super(message, { cause: { claim, reason, payload } });\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nexport class JWTExpired extends JOSEError {\n    static code = 'ERR_JWT_EXPIRED';\n    code = 'ERR_JWT_EXPIRED';\n    claim;\n    reason;\n    payload;\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {\n        super(message, { cause: { claim, reason, payload } });\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nexport class JOSEAlgNotAllowed extends JOSEError {\n    static code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n    code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n}\nexport class JOSENotSupported extends JOSEError {\n    static code = 'ERR_JOSE_NOT_SUPPORTED';\n    code = 'ERR_JOSE_NOT_SUPPORTED';\n}\nexport class JWEDecryptionFailed extends JOSEError {\n    static code = 'ERR_JWE_DECRYPTION_FAILED';\n    code = 'ERR_JWE_DECRYPTION_FAILED';\n    constructor(message = 'decryption operation failed', options) {\n        super(message, options);\n    }\n}\nexport class JWEInvalid extends JOSEError {\n    static code = 'ERR_JWE_INVALID';\n    code = 'ERR_JWE_INVALID';\n}\nexport class JWSInvalid extends JOSEError {\n    static code = 'ERR_JWS_INVALID';\n    code = 'ERR_JWS_INVALID';\n}\nexport class JWTInvalid extends JOSEError {\n    static code = 'ERR_JWT_INVALID';\n    code = 'ERR_JWT_INVALID';\n}\nexport class JWKInvalid extends JOSEError {\n    static code = 'ERR_JWK_INVALID';\n    code = 'ERR_JWK_INVALID';\n}\nexport class JWKSInvalid extends JOSEError {\n    static code = 'ERR_JWKS_INVALID';\n    code = 'ERR_JWKS_INVALID';\n}\nexport class JWKSNoMatchingKey extends JOSEError {\n    static code = 'ERR_JWKS_NO_MATCHING_KEY';\n    code = 'ERR_JWKS_NO_MATCHING_KEY';\n    constructor(message = 'no applicable key found in the JSON Web Key Set', options) {\n        super(message, options);\n    }\n}\nexport class JWKSMultipleMatchingKeys extends JOSEError {\n    [Symbol.asyncIterator];\n    static code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    constructor(message = 'multiple matching keys found in the JSON Web Key Set', options) {\n        super(message, options);\n    }\n}\nexport class JWKSTimeout extends JOSEError {\n    static code = 'ERR_JWKS_TIMEOUT';\n    code = 'ERR_JWKS_TIMEOUT';\n    constructor(message = 'request timed out', options) {\n        super(message, options);\n    }\n}\nexport class JWSSignatureVerificationFailed extends JOSEError {\n    static code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    constructor(message = 'signature verification failed', options) {\n        super(message, options);\n    }\n}\n","export function checkKeyLength(alg, key) {\n    if (alg.startsWith('RS') || alg.startsWith('PS')) {\n        const { modulusLength } = key.algorithm;\n        if (typeof modulusLength !== 'number' || modulusLength < 2048) {\n            throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);\n        }\n    }\n}\n","export function isDisjoint(...headers) {\n    const sources = headers.filter(Boolean);\n    if (sources.length === 0 || sources.length === 1) {\n        return true;\n    }\n    let acc;\n    for (const header of sources) {\n        const parameters = Object.keys(header);\n        if (!acc || acc.size === 0) {\n            acc = new Set(parameters);\n            continue;\n        }\n        for (const parameter of parameters) {\n            if (acc.has(parameter)) {\n                return false;\n            }\n            acc.add(parameter);\n        }\n    }\n    return true;\n}\n","export function assertCryptoKey(key) {\n    if (!isCryptoKey(key)) {\n        throw new Error('CryptoKey instance expected');\n    }\n}\nexport const isCryptoKey = (key) => key?.[Symbol.toStringTag] === 'CryptoKey';\nexport const isKeyObject = (key) => key?.[Symbol.toStringTag] === 'KeyObject';\nexport const isKeyLike = (key) => isCryptoKey(key) || isKeyObject(key);\n","export var util;\n(function (util) {\n    util.assertEqual = (_) => { };\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && Number.isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array.map((val) => (typeof val === \"string\" ? `'${val}'` : val)).join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nexport var objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nexport const ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nexport const getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\n","export var errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    // biome-ignore lint:\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message?.message;\n})(errorUtil || (errorUtil = {}));\n","export let extraEntropy = false\n\n/** @internal */\nexport function setExtraEntropy(entropy: boolean) {\n  extraEntropy = entropy\n}\n","import{options as n}from\"preact\";var t,r,u,i,o=0,f=[],c=n,e=c.__b,a=c.__r,v=c.diffed,l=c.__c,m=c.unmount,s=c.__;function d(n,t){c.__h&&c.__h(r,n,o||t),o=0;var u=r.__H||(r.__H={__:[],__h:[]});return n>=u.__.length&&u.__.push({}),u.__[n]}function h(n){return o=1,p(D,n)}function p(n,u,i){var o=d(t++,2);if(o.t=n,!o.__c&&(o.__=[i?i(u):D(void 0,u),function(n){var t=o.__N?o.__N[0]:o.__[0],r=o.t(t,n);t!==r&&(o.__N=[r,o.__[1]],o.__c.setState({}))}],o.__c=r,!r.u)){var f=function(n,t,r){if(!o.__c.__H)return!0;var u=o.__c.__H.__.filter(function(n){return!!n.__c});if(u.every(function(n){return!n.__N}))return!c||c.call(this,n,t,r);var i=!1;return u.forEach(function(n){if(n.__N){var t=n.__[0];n.__=n.__N,n.__N=void 0,t!==n.__[0]&&(i=!0)}}),!(!i&&o.__c.props===n)&&(!c||c.call(this,n,t,r))};r.u=!0;var c=r.shouldComponentUpdate,e=r.componentWillUpdate;r.componentWillUpdate=function(n,t,r){if(this.__e){var u=c;c=void 0,f(n,t,r),c=u}e&&e.call(this,n,t,r)},r.shouldComponentUpdate=f}return o.__N||o.__}function y(n,u){var i=d(t++,3);!c.__s&&C(i.__H,u)&&(i.__=n,i.i=u,r.__H.__h.push(i))}function _(n,u){var i=d(t++,4);!c.__s&&C(i.__H,u)&&(i.__=n,i.i=u,r.__h.push(i))}function A(n){return o=5,T(function(){return{current:n}},[])}function F(n,t,r){o=6,_(function(){return\"function\"==typeof n?(n(t()),function(){return n(null)}):n?(n.current=t(),function(){return n.current=null}):void 0},null==r?r:r.concat(n))}function T(n,r){var u=d(t++,7);return C(u.__H,r)&&(u.__=n(),u.__H=r,u.__h=n),u.__}function q(n,t){return o=8,T(function(){return n},t)}function x(n){var u=r.context[n.__c],i=d(t++,9);return i.c=n,u?(null==i.__&&(i.__=!0,u.sub(r)),u.props.value):n.__}function P(n,t){c.useDebugValue&&c.useDebugValue(t?t(n):n)}function b(n){var u=d(t++,10),i=h();return u.__=n,r.componentDidCatch||(r.componentDidCatch=function(n,t){u.__&&u.__(n,t),i[1](n)}),[i[0],function(){i[1](void 0)}]}function g(){var n=d(t++,11);if(!n.__){for(var u=r.__v;null!==u&&!u.__m&&null!==u.__;)u=u.__;var i=u.__m||(u.__m=[0,0]);n.__=\"P\"+i[0]+\"-\"+i[1]++}return n.__}function j(){for(var n;n=f.shift();)if(n.__P&&n.__H)try{n.__H.__h.forEach(z),n.__H.__h.forEach(B),n.__H.__h=[]}catch(t){n.__H.__h=[],c.__e(t,n.__v)}}c.__b=function(n){r=null,e&&e(n)},c.__=function(n,t){n&&t.__k&&t.__k.__m&&(n.__m=t.__k.__m),s&&s(n,t)},c.__r=function(n){a&&a(n),t=0;var i=(r=n.__c).__H;i&&(u===r?(i.__h=[],r.__h=[],i.__.forEach(function(n){n.__N&&(n.__=n.__N),n.i=n.__N=void 0})):(i.__h.forEach(z),i.__h.forEach(B),i.__h=[],t=0)),u=r},c.diffed=function(n){v&&v(n);var t=n.__c;t&&t.__H&&(t.__H.__h.length&&(1!==f.push(t)&&i===c.requestAnimationFrame||((i=c.requestAnimationFrame)||w)(j)),t.__H.__.forEach(function(n){n.i&&(n.__H=n.i),n.i=void 0})),u=r=null},c.__c=function(n,t){t.some(function(n){try{n.__h.forEach(z),n.__h=n.__h.filter(function(n){return!n.__||B(n)})}catch(r){t.some(function(n){n.__h&&(n.__h=[])}),t=[],c.__e(r,n.__v)}}),l&&l(n,t)},c.unmount=function(n){m&&m(n);var t,r=n.__c;r&&r.__H&&(r.__H.__.forEach(function(n){try{z(n)}catch(n){t=n}}),r.__H=void 0,t&&c.__e(t,r.__v))};var k=\"function\"==typeof requestAnimationFrame;function w(n){var t,r=function(){clearTimeout(u),k&&cancelAnimationFrame(t),setTimeout(n)},u=setTimeout(r,100);k&&(t=requestAnimationFrame(r))}function z(n){var t=r,u=n.__c;\"function\"==typeof u&&(n.__c=void 0,u()),r=t}function B(n){var t=r;n.__c=n.__(),r=t}function C(n,t){return!n||n.length!==t.length||t.some(function(t,r){return t!==n[r]})}function D(n,t){return\"function\"==typeof t?t(n):t}export{q as useCallback,x as useContext,P as useDebugValue,y as useEffect,b as useErrorBoundary,g as useId,F as useImperativeHandle,_ as useLayoutEffect,T as useMemo,p as useReducer,A as useRef,h as useState};\n//# sourceMappingURL=hooks.module.js.map\n","import type { ErrorType } from '../../../errors/utils.js'\nimport type { RpcUserOperation } from '../../types/rpc.js'\nimport type { UserOperation } from '../../types/userOperation.js'\n\nexport type FormatUserOperationErrorType = ErrorType\n\nexport function formatUserOperation(parameters: RpcUserOperation) {\n  const userOperation = { ...parameters } as unknown as UserOperation\n\n  if (parameters.callGasLimit)\n    userOperation.callGasLimit = BigInt(parameters.callGasLimit)\n  if (parameters.maxFeePerGas)\n    userOperation.maxFeePerGas = BigInt(parameters.maxFeePerGas)\n  if (parameters.maxPriorityFeePerGas)\n    userOperation.maxPriorityFeePerGas = BigInt(parameters.maxPriorityFeePerGas)\n  if (parameters.nonce) userOperation.nonce = BigInt(parameters.nonce)\n  if (parameters.paymasterPostOpGasLimit)\n    userOperation.paymasterPostOpGasLimit = BigInt(\n      parameters.paymasterPostOpGasLimit,\n    )\n  if (parameters.paymasterVerificationGasLimit)\n    userOperation.paymasterVerificationGasLimit = BigInt(\n      parameters.paymasterVerificationGasLimit,\n    )\n  if (parameters.preVerificationGas)\n    userOperation.preVerificationGas = BigInt(parameters.preVerificationGas)\n  if (parameters.verificationGasLimit)\n    userOperation.verificationGasLimit = BigInt(parameters.verificationGasLimit)\n\n  return userOperation\n}\n","import{options as r,Fragment as e}from\"preact\";export{Fragment}from\"preact\";var t=/[\"&<]/;function n(r){if(0===r.length||!1===t.test(r))return r;for(var e=0,n=0,o=\"\",f=\"\";n<r.length;n++){switch(r.charCodeAt(n)){case 34:f=\"&quot;\";break;case 38:f=\"&amp;\";break;case 60:f=\"&lt;\";break;default:continue}n!==e&&(o+=r.slice(e,n)),o+=f,e=n+1}return n!==e&&(o+=r.slice(e,n)),o}var o=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,f=0,i=Array.isArray;function u(e,t,n,o,i,u){t||(t={});var a,c,l=t;\"ref\"in t&&(a=t.ref,delete t.ref);var p={type:e,props:l,key:n,ref:a,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:--f,__i:-1,__u:0,__source:i,__self:u};if(\"function\"==typeof e&&(a=e.defaultProps))for(c in a)void 0===l[c]&&(l[c]=a[c]);return r.vnode&&r.vnode(p),p}function a(r){var t=u(e,{tpl:r,exprs:[].slice.call(arguments,1)});return t.key=t.__v,t}var c={},l=/[A-Z]/g;function p(e,t){if(r.attr){var f=r.attr(e,t);if(\"string\"==typeof f)return f}if(\"ref\"===e||\"key\"===e)return\"\";if(\"style\"===e&&\"object\"==typeof t){var i=\"\";for(var u in t){var a=t[u];if(null!=a&&\"\"!==a){var p=\"-\"==u[0]?u:c[u]||(c[u]=u.replace(l,\"-$&\").toLowerCase()),_=\";\";\"number\"!=typeof a||p.startsWith(\"--\")||o.test(p)||(_=\"px;\"),i=i+p+\":\"+a+_}}return e+'=\"'+i+'\"'}return null==t||!1===t||\"function\"==typeof t||\"object\"==typeof t?\"\":!0===t?e:e+'=\"'+n(t)+'\"'}function _(r){if(null==r||\"boolean\"==typeof r||\"function\"==typeof r)return null;if(\"object\"==typeof r){if(void 0===r.constructor)return r;if(i(r)){for(var e=0;e<r.length;e++)r[e]=_(r[e]);return r}}return n(\"\"+r)}export{u as jsx,p as jsxAttr,u as jsxDEV,_ as jsxEscape,a as jsxTemplate,u as jsxs};\n//# sourceMappingURL=jsxRuntime.module.js.map\n","import { JOSENotSupported } from '../util/errors.js';\nfunction subtleMapping(jwk) {\n    let algorithm;\n    let keyUsages;\n    switch (jwk.kty) {\n        case 'AKP': {\n            switch (jwk.alg) {\n                case 'ML-DSA-44':\n                case 'ML-DSA-65':\n                case 'ML-DSA-87':\n                    algorithm = { name: jwk.alg };\n                    keyUsages = jwk.priv ? ['sign'] : ['verify'];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'RSA': {\n            switch (jwk.alg) {\n                case 'PS256':\n                case 'PS384':\n                case 'PS512':\n                    algorithm = { name: 'RSA-PSS', hash: `SHA-${jwk.alg.slice(-3)}` };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RS256':\n                case 'RS384':\n                case 'RS512':\n                    algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${jwk.alg.slice(-3)}` };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'RSA-OAEP':\n                case 'RSA-OAEP-256':\n                case 'RSA-OAEP-384':\n                case 'RSA-OAEP-512':\n                    algorithm = {\n                        name: 'RSA-OAEP',\n                        hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`,\n                    };\n                    keyUsages = jwk.d ? ['decrypt', 'unwrapKey'] : ['encrypt', 'wrapKey'];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'EC': {\n            switch (jwk.alg) {\n                case 'ES256':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ES384':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ES512':\n                    algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = { name: 'ECDH', namedCurve: jwk.crv };\n                    keyUsages = jwk.d ? ['deriveBits'] : [];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        case 'OKP': {\n            switch (jwk.alg) {\n                case 'Ed25519':\n                case 'EdDSA':\n                    algorithm = { name: 'Ed25519' };\n                    keyUsages = jwk.d ? ['sign'] : ['verify'];\n                    break;\n                case 'ECDH-ES':\n                case 'ECDH-ES+A128KW':\n                case 'ECDH-ES+A192KW':\n                case 'ECDH-ES+A256KW':\n                    algorithm = { name: jwk.crv };\n                    keyUsages = jwk.d ? ['deriveBits'] : [];\n                    break;\n                default:\n                    throw new JOSENotSupported('Invalid or unsupported JWK \"alg\" (Algorithm) Parameter value');\n            }\n            break;\n        }\n        default:\n            throw new JOSENotSupported('Invalid or unsupported JWK \"kty\" (Key Type) Parameter value');\n    }\n    return { algorithm, keyUsages };\n}\nexport async function jwkToKey(jwk) {\n    if (!jwk.alg) {\n        throw new TypeError('\"alg\" argument is required when \"jwk.alg\" is not present');\n    }\n    const { algorithm, keyUsages } = subtleMapping(jwk);\n    const keyData = { ...jwk };\n    if (keyData.kty !== 'AKP') {\n        delete keyData.alg;\n    }\n    delete keyData.use;\n    return crypto.subtle.importKey('jwk', keyData, algorithm, jwk.ext ?? (jwk.d || jwk.priv ? false : true), jwk.key_ops ?? keyUsages);\n}\n","import platform from './node/index.js';\nimport * as utils from './common/utils.js';\n\nexport default {\n  ...utils,\n  ...platform\n}\n","import defaultErrorMap from \"./locales/en.js\";\nlet overrideErrorMap = defaultErrorMap;\nexport { defaultErrorMap };\nexport function setErrorMap(map) {\n    overrideErrorMap = map;\n}\nexport function getErrorMap() {\n    return overrideErrorMap;\n}\n","\nexport const streamChunk = function* (chunk, chunkSize) {\n  let len = chunk.byteLength;\n\n  if (!chunkSize || len < chunkSize) {\n    yield chunk;\n    return;\n  }\n\n  let pos = 0;\n  let end;\n\n  while (pos < len) {\n    end = pos + chunkSize;\n    yield chunk.slice(pos, end);\n    pos = end;\n  }\n}\n\nexport const readBytes = async function* (iterable, chunkSize) {\n  for await (const chunk of readStream(iterable)) {\n    yield* streamChunk(chunk, chunkSize);\n  }\n}\n\nconst readStream = async function* (stream) {\n  if (stream[Symbol.asyncIterator]) {\n    yield* stream;\n    return;\n  }\n\n  const reader = stream.getReader();\n  try {\n    for (;;) {\n      const {done, value} = await reader.read();\n      if (done) {\n        break;\n      }\n      yield value;\n    }\n  } finally {\n    await reader.cancel();\n  }\n}\n\nexport const trackStream = (stream, chunkSize, onProgress, onFinish) => {\n  const iterator = readBytes(stream, chunkSize);\n\n  let bytes = 0;\n  let done;\n  let _onFinish = (e) => {\n    if (!done) {\n      done = true;\n      onFinish && onFinish(e);\n    }\n  }\n\n  return new ReadableStream({\n    async pull(controller) {\n      try {\n        const {done, value} = await iterator.next();\n\n        if (done) {\n         _onFinish();\n          controller.close();\n          return;\n        }\n\n        let len = value.byteLength;\n        if (onProgress) {\n          let loadedBytes = bytes += len;\n          onProgress(loadedBytes);\n        }\n        controller.enqueue(new Uint8Array(value));\n      } catch (err) {\n        _onFinish(err);\n        throw err;\n      }\n    },\n    cancel(reason) {\n      _onFinish(reason);\n      return iterator.return();\n    }\n  }, {\n    highWaterMark: 2\n  })\n}\n","import { JOSENotSupported } from '../util/errors.js';\nexport function subtleAlgorithm(alg, algorithm) {\n    const hash = `SHA-${alg.slice(-3)}`;\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512':\n            return { hash, name: 'HMAC' };\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            return { hash, name: 'RSA-PSS', saltLength: parseInt(alg.slice(-3), 10) >> 3 };\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            return { hash, name: 'RSASSA-PKCS1-v1_5' };\n        case 'ES256':\n        case 'ES384':\n        case 'ES512':\n            return { hash, name: 'ECDSA', namedCurve: algorithm.namedCurve };\n        case 'Ed25519':\n        case 'EdDSA':\n            return { name: 'Ed25519' };\n        case 'ML-DSA-44':\n        case 'ML-DSA-65':\n        case 'ML-DSA-87':\n            return { name: alg };\n        default:\n            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n}\n","import { isObject } from './is_object.js';\nexport const isJWK = (key) => isObject(key) && typeof key.kty === 'string';\nexport const isPrivateJWK = (key) => key.kty !== 'oct' &&\n    ((key.kty === 'AKP' && typeof key.priv === 'string') || typeof key.d === 'string');\nexport const isPublicJWK = (key) => key.kty !== 'oct' && key.d === undefined && key.priv === undefined;\nexport const isSecretJWK = (key) => key.kty === 'oct' && typeof key.k === 'string';\n","import { JOSENotSupported, JWEInvalid, JWSInvalid } from '../util/errors.js';\nexport function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {\n    if (joseHeader.crit !== undefined && protectedHeader?.crit === undefined) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be integrity protected');\n    }\n    if (!protectedHeader || protectedHeader.crit === undefined) {\n        return new Set();\n    }\n    if (!Array.isArray(protectedHeader.crit) ||\n        protectedHeader.crit.length === 0 ||\n        protectedHeader.crit.some((input) => typeof input !== 'string' || input.length === 0)) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be an array of non-empty strings when present');\n    }\n    let recognized;\n    if (recognizedOption !== undefined) {\n        recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);\n    }\n    else {\n        recognized = recognizedDefault;\n    }\n    for (const parameter of protectedHeader.crit) {\n        if (!recognized.has(parameter)) {\n            throw new JOSENotSupported(`Extension Header Parameter \"${parameter}\" is not recognized`);\n        }\n        if (joseHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" is missing`);\n        }\n        if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" MUST be integrity protected`);\n        }\n    }\n    return new Set(protectedHeader.crit);\n}\n","import { FlattenedSign } from '../flattened/sign.js';\nexport class CompactSign {\n    #flattened;\n    constructor(payload) {\n        this.#flattened = new FlattenedSign(payload);\n    }\n    setProtectedHeader(protectedHeader) {\n        this.#flattened.setProtectedHeader(protectedHeader);\n        return this;\n    }\n    async sign(key, options) {\n        const jws = await this.#flattened.sign(key, options);\n        if (jws.payload === undefined) {\n            throw new TypeError('use the flattened module for creating JWS with b64: false');\n        }\n        return `${jws.protected}.${jws.payload}.${jws.signature}`;\n    }\n}\n","import { util } from \"./helpers/util.js\";\nexport const ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nexport const quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nexport class ZodError extends Error {\n    get errors() {\n        return this.issues;\n    }\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    static assert(value) {\n        if (!(value instanceof ZodError)) {\n            throw new Error(`Not a ZodError: ${value}`);\n        }\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                const firstEl = sub.path[0];\n                fieldErrors[firstEl] = fieldErrors[firstEl] || [];\n                fieldErrors[firstEl].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n","import axios from './lib/axios.js';\n\n// This module is intended to unwrap Axios default export as named.\n// Keep top-level export same with static properties\n// so that it can keep same with es module or cjs\nconst {\n  Axios,\n  AxiosError,\n  CanceledError,\n  isCancel,\n  CancelToken,\n  VERSION,\n  all,\n  Cancel,\n  isAxiosError,\n  spread,\n  toFormData,\n  AxiosHeaders,\n  HttpStatusCode,\n  formToJSON,\n  getAdapter,\n  mergeConfig\n} = axios;\n\nexport {\n  axios as default,\n  Axios,\n  AxiosError,\n  CanceledError,\n  isCancel,\n  CancelToken,\n  VERSION,\n  all,\n  Cancel,\n  isAxiosError,\n  spread,\n  toFormData,\n  AxiosHeaders,\n  HttpStatusCode,\n  formToJSON,\n  getAdapter,\n  mergeConfig\n}\n","import { ZodIssueCode } from \"../ZodError.js\";\nimport { util, ZodParsedType } from \"../helpers/util.js\";\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                }\n                else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"bigint\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\")\n                message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return { message };\n};\nexport default errorMap;\n","import utils from \"../utils.js\";\n\nconst callbackify = (fn, reducer) => {\n  return utils.isAsyncFn(fn) ? function (...args) {\n    const cb = args.pop();\n    fn.apply(this, args).then((value) => {\n      try {\n        reducer ? cb(null, ...reducer(value)) : cb(null, value);\n      } catch (err) {\n        cb(err);\n      }\n    }, cb);\n  } : fn;\n}\n\nexport default callbackify;\n","import nodeCrypto from 'node:crypto';\n\nconst subtle = nodeCrypto.webcrypto?.subtle || {};\nconst randomUUID = () => {\n  return nodeCrypto.randomUUID();\n};\nconst getRandomValues = (array) => {\n  return nodeCrypto.webcrypto.getRandomValues(array);\n};\nconst _crypto = {\n  randomUUID,\n  getRandomValues,\n  subtle\n};\n\nexport { _crypto as default, getRandomValues, randomUUID, subtle };\n","'use strict';\n\n/**\n * Calculate data maxRate\n * @param {Number} [samplesCount= 10]\n * @param {Number} [min= 1000]\n * @returns {Function}\n */\nfunction speedometer(samplesCount, min) {\n  samplesCount = samplesCount || 10;\n  const bytes = new Array(samplesCount);\n  const timestamps = new Array(samplesCount);\n  let head = 0;\n  let tail = 0;\n  let firstSampleTS;\n\n  min = min !== undefined ? min : 1000;\n\n  return function push(chunkLength) {\n    const now = Date.now();\n\n    const startedAt = timestamps[tail];\n\n    if (!firstSampleTS) {\n      firstSampleTS = now;\n    }\n\n    bytes[head] = chunkLength;\n    timestamps[head] = now;\n\n    let i = tail;\n    let bytesCount = 0;\n\n    while (i !== head) {\n      bytesCount += bytes[i++];\n      i = i % samplesCount;\n    }\n\n    head = (head + 1) % samplesCount;\n\n    if (head === tail) {\n      tail = (tail + 1) % samplesCount;\n    }\n\n    if (now - firstSampleTS < min) {\n      return;\n    }\n\n    const passed = startedAt && now - startedAt;\n\n    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;\n  };\n}\n\nexport default speedometer;\n","import { getErrorMap } from \"../errors.js\";\nimport defaultErrorMap from \"../locales/en.js\";\nexport const makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    if (issueData.message !== undefined) {\n        return {\n            ...issueData,\n            path: fullPath,\n            message: issueData.message,\n        };\n    }\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: errorMessage,\n    };\n};\nexport const EMPTY_PATH = [];\nexport function addIssueToContext(ctx, issueData) {\n    const overrideMap = getErrorMap();\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap, // contextual error map is first priority\n            ctx.schemaErrorMap, // then schema-bound map if available\n            overrideMap, // then global override map\n            overrideMap === defaultErrorMap ? undefined : defaultErrorMap, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nexport class ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n                key,\n                value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return INVALID;\n            if (value.status === \"aborted\")\n                return INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nexport const INVALID = Object.freeze({\n    status: \"aborted\",\n});\nexport const DIRTY = (value) => ({ status: \"dirty\", value });\nexport const OK = (value) => ({ status: \"valid\", value });\nexport const isAborted = (x) => x.status === \"aborted\";\nexport const isDirty = (x) => x.status === \"dirty\";\nexport const isValid = (x) => x.status === \"valid\";\nexport const isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\n","import { checkSigCryptoKey } from './crypto_key.js';\nimport { invalidKeyInput } from './invalid_key_input.js';\nexport async function getSigKey(alg, key, usage) {\n    if (key instanceof Uint8Array) {\n        if (!alg.startsWith('HS')) {\n            throw new TypeError(invalidKeyInput(key, 'CryptoKey', 'KeyObject', 'JSON Web Key'));\n        }\n        return crypto.subtle.importKey('raw', key, { hash: `SHA-${alg.slice(-3)}`, name: 'HMAC' }, false, [usage]);\n    }\n    checkSigCryptoKey(key, alg, usage);\n    return key;\n}\n","import { encoder, decoder } from '../lib/buffer_utils.js';\nimport { encodeBase64, decodeBase64 } from '../lib/base64.js';\nexport function decode(input) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(typeof input === 'string' ? input : decoder.decode(input), {\n            alphabet: 'base64url',\n        });\n    }\n    let encoded = input;\n    if (encoded instanceof Uint8Array) {\n        encoded = decoder.decode(encoded);\n    }\n    encoded = encoded.replace(/-/g, '+').replace(/_/g, '/');\n    try {\n        return decodeBase64(encoded);\n    }\n    catch {\n        throw new TypeError('The input to be decoded is not correctly encoded.');\n    }\n}\nexport function encode(input) {\n    let unencoded = input;\n    if (typeof unencoded === 'string') {\n        unencoded = encoder.encode(unencoded);\n    }\n    if (Uint8Array.prototype.toBase64) {\n        return unencoded.toBase64({ alphabet: 'base64url', omitPadding: true });\n    }\n    return encodeBase64(unencoded).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n","'use strict';\n\nexport default function parseProtocol(url) {\n  const match = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(url);\n  return match && match[1] || '';\n}\n","import platform from '../platform/index.js';\n\nexport default platform.hasStandardBrowserEnv ? ((origin, isMSIE) => (url) => {\n  url = new URL(url, platform.origin);\n\n  return (\n    origin.protocol === url.protocol &&\n    origin.host === url.host &&\n    (isMSIE || origin.port === url.port)\n  );\n})(\n  new URL(platform.origin),\n  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)\n) : () => true;\n","'use strict';\n\nexport default function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n}\n","'use strict';\n\nexport default {\n  silentJSONParsing: true,\n  forcedJSONParsing: true,\n  clarifyTimeoutError: false\n};\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nconst sourceId = 42_161 // Arbitrum One\n\nexport const huddle01Mainnet = /*#__PURE__*/ defineChain({\n  id: 12323,\n  name: 'Huddle01 dRTC Chain',\n  nativeCurrency: {\n    name: 'Ethereum',\n    symbol: 'ETH',\n    decimals: 18,\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://huddle01.calderachain.xyz/http'],\n      webSocket: ['wss://huddle01.calderachain.xyz/ws'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Huddle01 Caldera Explorer',\n      url: 'https://huddle01.calderaexplorer.xyz',\n      apiUrl: 'https://huddle01.calderaexplorer.xyz/api',\n    },\n  },\n  sourceId,\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\n// The local hyperchain setup: https://github.com/matter-labs/local-setup/blob/main/zk-chains-docker-compose.yml\n\nexport const zksyncLocalHyperchainL1 = /*#__PURE__*/ defineChain({\n  id: 9,\n  name: 'ZKsync CLI Local Hyperchain L1',\n  nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: ['http://localhost:15045'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Blockscout',\n      url: 'http://localhost:15001/',\n      apiUrl: 'http://localhost:15001/api/v2',\n    },\n  },\n  testnet: true,\n})\n","import { withAlg as invalidKeyInput } from './invalid_key_input.js';\nimport { isKeyLike } from './is_key_like.js';\nimport * as jwk from './is_jwk.js';\nconst tag = (key) => key?.[Symbol.toStringTag];\nconst jwkMatchesOp = (alg, key, usage) => {\n    if (key.use !== undefined) {\n        let expected;\n        switch (usage) {\n            case 'sign':\n            case 'verify':\n                expected = 'sig';\n                break;\n            case 'encrypt':\n            case 'decrypt':\n                expected = 'enc';\n                break;\n        }\n        if (key.use !== expected) {\n            throw new TypeError(`Invalid key for this operation, its \"use\" must be \"${expected}\" when present`);\n        }\n    }\n    if (key.alg !== undefined && key.alg !== alg) {\n        throw new TypeError(`Invalid key for this operation, its \"alg\" must be \"${alg}\" when present`);\n    }\n    if (Array.isArray(key.key_ops)) {\n        let expectedKeyOp;\n        switch (true) {\n            case usage === 'sign' || usage === 'verify':\n            case alg === 'dir':\n            case alg.includes('CBC-HS'):\n                expectedKeyOp = usage;\n                break;\n            case alg.startsWith('PBES2'):\n                expectedKeyOp = 'deriveBits';\n                break;\n            case /^A\\d{3}(?:GCM)?(?:KW)?$/.test(alg):\n                if (!alg.includes('GCM') && alg.endsWith('KW')) {\n                    expectedKeyOp = usage === 'encrypt' ? 'wrapKey' : 'unwrapKey';\n                }\n                else {\n                    expectedKeyOp = usage;\n                }\n                break;\n            case usage === 'encrypt' && alg.startsWith('RSA'):\n                expectedKeyOp = 'wrapKey';\n                break;\n            case usage === 'decrypt':\n                expectedKeyOp = alg.startsWith('RSA') ? 'unwrapKey' : 'deriveBits';\n                break;\n        }\n        if (expectedKeyOp && key.key_ops?.includes?.(expectedKeyOp) === false) {\n            throw new TypeError(`Invalid key for this operation, its \"key_ops\" must include \"${expectedKeyOp}\" when present`);\n        }\n    }\n    return true;\n};\nconst symmetricTypeCheck = (alg, key, usage) => {\n    if (key instanceof Uint8Array)\n        return;\n    if (jwk.isJWK(key)) {\n        if (jwk.isSecretJWK(key) && jwkMatchesOp(alg, key, usage))\n            return;\n        throw new TypeError(`JSON Web Key for symmetric algorithms must have JWK \"kty\" (Key Type) equal to \"oct\" and the JWK \"k\" (Key Value) present`);\n    }\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, 'CryptoKey', 'KeyObject', 'JSON Web Key', 'Uint8Array'));\n    }\n    if (key.type !== 'secret') {\n        throw new TypeError(`${tag(key)} instances for symmetric algorithms must be of type \"secret\"`);\n    }\n};\nconst asymmetricTypeCheck = (alg, key, usage) => {\n    if (jwk.isJWK(key)) {\n        switch (usage) {\n            case 'decrypt':\n            case 'sign':\n                if (jwk.isPrivateJWK(key) && jwkMatchesOp(alg, key, usage))\n                    return;\n                throw new TypeError(`JSON Web Key for this operation be a private JWK`);\n            case 'encrypt':\n            case 'verify':\n                if (jwk.isPublicJWK(key) && jwkMatchesOp(alg, key, usage))\n                    return;\n                throw new TypeError(`JSON Web Key for this operation be a public JWK`);\n        }\n    }\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, 'CryptoKey', 'KeyObject', 'JSON Web Key'));\n    }\n    if (key.type === 'secret') {\n        throw new TypeError(`${tag(key)} instances for asymmetric algorithms must not be of type \"secret\"`);\n    }\n    if (key.type === 'public') {\n        switch (usage) {\n            case 'sign':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm signing must be of type \"private\"`);\n            case 'decrypt':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm decryption must be of type \"private\"`);\n        }\n    }\n    if (key.type === 'private') {\n        switch (usage) {\n            case 'verify':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm verifying must be of type \"public\"`);\n            case 'encrypt':\n                throw new TypeError(`${tag(key)} instances for asymmetric algorithm encryption must be of type \"public\"`);\n        }\n    }\n};\nexport function checkKeyType(alg, key, usage) {\n    switch (alg.substring(0, 2)) {\n        case 'A1':\n        case 'A2':\n        case 'di':\n        case 'HS':\n        case 'PB':\n            symmetricTypeCheck(alg, key, usage);\n            break;\n        default:\n            asymmetricTypeCheck(alg, key, usage);\n    }\n}\n","import { JWTClaimValidationFailed, JWTExpired, JWTInvalid } from '../util/errors.js';\nimport { encoder, decoder } from './buffer_utils.js';\nimport { isObject } from './is_object.js';\nconst epoch = (date) => Math.floor(date.getTime() / 1000);\nconst minute = 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\nconst year = day * 365.25;\nconst REGEX = /^(\\+|\\-)? ?(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;\nexport function secs(str) {\n    const matched = REGEX.exec(str);\n    if (!matched || (matched[4] && matched[1])) {\n        throw new TypeError('Invalid time period format');\n    }\n    const value = parseFloat(matched[2]);\n    const unit = matched[3].toLowerCase();\n    let numericDate;\n    switch (unit) {\n        case 'sec':\n        case 'secs':\n        case 'second':\n        case 'seconds':\n        case 's':\n            numericDate = Math.round(value);\n            break;\n        case 'minute':\n        case 'minutes':\n        case 'min':\n        case 'mins':\n        case 'm':\n            numericDate = Math.round(value * minute);\n            break;\n        case 'hour':\n        case 'hours':\n        case 'hr':\n        case 'hrs':\n        case 'h':\n            numericDate = Math.round(value * hour);\n            break;\n        case 'day':\n        case 'days':\n        case 'd':\n            numericDate = Math.round(value * day);\n            break;\n        case 'week':\n        case 'weeks':\n        case 'w':\n            numericDate = Math.round(value * week);\n            break;\n        default:\n            numericDate = Math.round(value * year);\n            break;\n    }\n    if (matched[1] === '-' || matched[4] === 'ago') {\n        return -numericDate;\n    }\n    return numericDate;\n}\nfunction validateInput(label, input) {\n    if (!Number.isFinite(input)) {\n        throw new TypeError(`Invalid ${label} input`);\n    }\n    return input;\n}\nconst normalizeTyp = (value) => {\n    if (value.includes('/')) {\n        return value.toLowerCase();\n    }\n    return `application/${value.toLowerCase()}`;\n};\nconst checkAudiencePresence = (audPayload, audOption) => {\n    if (typeof audPayload === 'string') {\n        return audOption.includes(audPayload);\n    }\n    if (Array.isArray(audPayload)) {\n        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));\n    }\n    return false;\n};\nexport function validateClaimsSet(protectedHeader, encodedPayload, options = {}) {\n    let payload;\n    try {\n        payload = JSON.parse(decoder.decode(encodedPayload));\n    }\n    catch {\n    }\n    if (!isObject(payload)) {\n        throw new JWTInvalid('JWT Claims Set must be a top-level JSON object');\n    }\n    const { typ } = options;\n    if (typ &&\n        (typeof protectedHeader.typ !== 'string' ||\n            normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {\n        throw new JWTClaimValidationFailed('unexpected \"typ\" JWT header value', payload, 'typ', 'check_failed');\n    }\n    const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;\n    const presenceCheck = [...requiredClaims];\n    if (maxTokenAge !== undefined)\n        presenceCheck.push('iat');\n    if (audience !== undefined)\n        presenceCheck.push('aud');\n    if (subject !== undefined)\n        presenceCheck.push('sub');\n    if (issuer !== undefined)\n        presenceCheck.push('iss');\n    for (const claim of new Set(presenceCheck.reverse())) {\n        if (!(claim in payload)) {\n            throw new JWTClaimValidationFailed(`missing required \"${claim}\" claim`, payload, claim, 'missing');\n        }\n    }\n    if (issuer &&\n        !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {\n        throw new JWTClaimValidationFailed('unexpected \"iss\" claim value', payload, 'iss', 'check_failed');\n    }\n    if (subject && payload.sub !== subject) {\n        throw new JWTClaimValidationFailed('unexpected \"sub\" claim value', payload, 'sub', 'check_failed');\n    }\n    if (audience &&\n        !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n        throw new JWTClaimValidationFailed('unexpected \"aud\" claim value', payload, 'aud', 'check_failed');\n    }\n    let tolerance;\n    switch (typeof options.clockTolerance) {\n        case 'string':\n            tolerance = secs(options.clockTolerance);\n            break;\n        case 'number':\n            tolerance = options.clockTolerance;\n            break;\n        case 'undefined':\n            tolerance = 0;\n            break;\n        default:\n            throw new TypeError('Invalid clockTolerance option type');\n    }\n    const { currentDate } = options;\n    const now = epoch(currentDate || new Date());\n    if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== 'number') {\n        throw new JWTClaimValidationFailed('\"iat\" claim must be a number', payload, 'iat', 'invalid');\n    }\n    if (payload.nbf !== undefined) {\n        if (typeof payload.nbf !== 'number') {\n            throw new JWTClaimValidationFailed('\"nbf\" claim must be a number', payload, 'nbf', 'invalid');\n        }\n        if (payload.nbf > now + tolerance) {\n            throw new JWTClaimValidationFailed('\"nbf\" claim timestamp check failed', payload, 'nbf', 'check_failed');\n        }\n    }\n    if (payload.exp !== undefined) {\n        if (typeof payload.exp !== 'number') {\n            throw new JWTClaimValidationFailed('\"exp\" claim must be a number', payload, 'exp', 'invalid');\n        }\n        if (payload.exp <= now - tolerance) {\n            throw new JWTExpired('\"exp\" claim timestamp check failed', payload, 'exp', 'check_failed');\n        }\n    }\n    if (maxTokenAge) {\n        const age = now - payload.iat;\n        const max = typeof maxTokenAge === 'number' ? maxTokenAge : secs(maxTokenAge);\n        if (age - tolerance > max) {\n            throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', payload, 'iat', 'check_failed');\n        }\n        if (age < 0 - tolerance) {\n            throw new JWTClaimValidationFailed('\"iat\" claim timestamp check failed (it should be in the past)', payload, 'iat', 'check_failed');\n        }\n    }\n    return payload;\n}\nexport class JWTClaimsBuilder {\n    #payload;\n    constructor(payload) {\n        if (!isObject(payload)) {\n            throw new TypeError('JWT Claims Set MUST be an object');\n        }\n        this.#payload = structuredClone(payload);\n    }\n    data() {\n        return encoder.encode(JSON.stringify(this.#payload));\n    }\n    get iss() {\n        return this.#payload.iss;\n    }\n    set iss(value) {\n        this.#payload.iss = value;\n    }\n    get sub() {\n        return this.#payload.sub;\n    }\n    set sub(value) {\n        this.#payload.sub = value;\n    }\n    get aud() {\n        return this.#payload.aud;\n    }\n    set aud(value) {\n        this.#payload.aud = value;\n    }\n    set jti(value) {\n        this.#payload.jti = value;\n    }\n    set nbf(value) {\n        if (typeof value === 'number') {\n            this.#payload.nbf = validateInput('setNotBefore', value);\n        }\n        else if (value instanceof Date) {\n            this.#payload.nbf = validateInput('setNotBefore', epoch(value));\n        }\n        else {\n            this.#payload.nbf = epoch(new Date()) + secs(value);\n        }\n    }\n    set exp(value) {\n        if (typeof value === 'number') {\n            this.#payload.exp = validateInput('setExpirationTime', value);\n        }\n        else if (value instanceof Date) {\n            this.#payload.exp = validateInput('setExpirationTime', epoch(value));\n        }\n        else {\n            this.#payload.exp = epoch(new Date()) + secs(value);\n        }\n    }\n    set iat(value) {\n        if (value === undefined) {\n            this.#payload.iat = epoch(new Date());\n        }\n        else if (value instanceof Date) {\n            this.#payload.iat = validateInput('setIssuedAt', epoch(value));\n        }\n        else if (typeof value === 'string') {\n            this.#payload.iat = validateInput('setIssuedAt', epoch(new Date()) + secs(value));\n        }\n        else {\n            this.#payload.iat = validateInput('setIssuedAt', value);\n        }\n    }\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/store/correlation-ids/store.ts","import { subtleAlgorithm } from './subtle_dsa.js';\nimport { checkKeyLength } from './check_key_length.js';\nimport { getSigKey } from './get_sign_verify_key.js';\nexport async function sign(alg, key, data) {\n    const cryptoKey = await getSigKey(alg, key, 'sign');\n    checkKeyLength(alg, cryptoKey);\n    const signature = await crypto.subtle.sign(subtleAlgorithm(alg, cryptoKey.algorithm), cryptoKey, data);\n    return new Uint8Array(signature);\n}\n","import { CompactSign } from '../jws/compact/sign.js';\nimport { JWTInvalid } from '../util/errors.js';\nimport { JWTClaimsBuilder } from '../lib/jwt_claims_set.js';\nexport class SignJWT {\n    #protectedHeader;\n    #jwt;\n    constructor(payload = {}) {\n        this.#jwt = new JWTClaimsBuilder(payload);\n    }\n    setIssuer(issuer) {\n        this.#jwt.iss = issuer;\n        return this;\n    }\n    setSubject(subject) {\n        this.#jwt.sub = subject;\n        return this;\n    }\n    setAudience(audience) {\n        this.#jwt.aud = audience;\n        return this;\n    }\n    setJti(jwtId) {\n        this.#jwt.jti = jwtId;\n        return this;\n    }\n    setNotBefore(input) {\n        this.#jwt.nbf = input;\n        return this;\n    }\n    setExpirationTime(input) {\n        this.#jwt.exp = input;\n        return this;\n    }\n    setIssuedAt(input) {\n        this.#jwt.iat = input;\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        this.#protectedHeader = protectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        const sig = new CompactSign(this.#jwt.data());\n        sig.setProtectedHeader(this.#protectedHeader);\n        if (Array.isArray(this.#protectedHeader?.crit) &&\n            this.#protectedHeader.crit.includes('b64') &&\n            this.#protectedHeader.b64 === false) {\n            throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n        }\n        return sig.sign(key, options);\n    }\n}\n","import utils from './../utils.js';\nimport platform from '../platform/index.js';\n\nexport default platform.hasStandardBrowserEnv ?\n\n  // Standard browser envs support document.cookie\n  {\n    write(name, value, expires, path, domain, secure, sameSite) {\n      if (typeof document === 'undefined') return;\n\n      const cookie = [`${name}=${encodeURIComponent(value)}`];\n\n      if (utils.isNumber(expires)) {\n        cookie.push(`expires=${new Date(expires).toUTCString()}`);\n      }\n      if (utils.isString(path)) {\n        cookie.push(`path=${path}`);\n      }\n      if (utils.isString(domain)) {\n        cookie.push(`domain=${domain}`);\n      }\n      if (secure === true) {\n        cookie.push('secure');\n      }\n      if (utils.isString(sameSite)) {\n        cookie.push(`SameSite=${sameSite}`);\n      }\n\n      document.cookie = cookie.join('; ');\n    },\n\n    read(name) {\n      if (typeof document === 'undefined') return null;\n      const match = document.cookie.match(new RegExp('(?:^|; )' + name + '=([^;]*)'));\n      return match ? decodeURIComponent(match[1]) : null;\n    },\n\n    remove(name) {\n      this.write(name, '', Date.now() - 86400000, '/');\n    }\n  }\n\n  :\n\n  // Non-standard browser env (web workers, react-native) lack needed support.\n  {\n    write() {},\n    read() {\n      return null;\n    },\n    remove() {}\n  };\n\n","import { BaseError } from '../../errors/base.js'\n\nexport type BytecodeLengthExceedsMaxSizeErrorType =\n  BytecodeLengthExceedsMaxSizeError & {\n    name: 'BytecodeLengthExceedsMaxSizeError'\n  }\n\nexport class BytecodeLengthExceedsMaxSizeError extends BaseError {\n  constructor({\n    givenLength,\n    maxBytecodeSize,\n  }: { givenLength: number; maxBytecodeSize: bigint }) {\n    super(\n      `Bytecode cannot be longer than ${maxBytecodeSize} bytes. Given length: ${givenLength}`,\n      { name: 'BytecodeLengthExceedsMaxSizeError' },\n    )\n  }\n}\n\nexport type BytecodeLengthInWordsMustBeOddErrorType =\n  BytecodeLengthInWordsMustBeOddError & {\n    name: 'BytecodeLengthInWordsMustBeOddError'\n  }\n\nexport class BytecodeLengthInWordsMustBeOddError extends BaseError {\n  constructor({ givenLengthInWords }: { givenLengthInWords: number }) {\n    super(\n      `Bytecode length in 32-byte words must be odd. Given length in words: ${givenLengthInWords}`,\n      { name: 'BytecodeLengthInWordsMustBeOddError' },\n    )\n  }\n}\n\nexport type BytecodeLengthMustBeDivisibleBy32ErrorType =\n  BytecodeLengthMustBeDivisibleBy32Error & {\n    name: 'BytecodeLengthMustBeDivisibleBy32Error'\n  }\n\nexport class BytecodeLengthMustBeDivisibleBy32Error extends BaseError {\n  constructor({ givenLength }: { givenLength: number }) {\n    super(\n      `The bytecode length in bytes must be divisible by 32. Given length: ${givenLength}`,\n      { name: 'BytecodeLengthMustBeDivisibleBy32Error' },\n    )\n  }\n}\n","import type { Address } from 'abitype'\n\nimport type { Account } from '../accounts/types.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport type { ParseAccount } from '../types/account.js'\nimport type { Chain } from '../types/chain.js'\nimport type { RpcSchema, WalletRpcSchema } from '../types/eip1193.js'\nimport type { Prettify } from '../types/utils.js'\nimport {\n  type Client,\n  type ClientConfig,\n  type CreateClientErrorType,\n  createClient,\n} from './createClient.js'\nimport { type WalletActions, walletActions } from './decorators/wallet.js'\nimport type { Transport } from './transports/createTransport.js'\n\nexport type WalletClientConfig<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  accountOrAddress extends Account | Address | undefined =\n    | Account\n    | Address\n    | undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n> = Prettify<\n  Pick<\n    ClientConfig<transport, chain, accountOrAddress, rpcSchema>,\n    | 'account'\n    | 'cacheTime'\n    | 'ccipRead'\n    | 'chain'\n    | 'key'\n    | 'name'\n    | 'pollingInterval'\n    | 'rpcSchema'\n    | 'transport'\n  >\n>\n\nexport type WalletClient<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n> = Prettify<\n  Client<\n    transport,\n    chain,\n    account,\n    rpcSchema extends RpcSchema\n      ? [...WalletRpcSchema, ...rpcSchema]\n      : WalletRpcSchema,\n    WalletActions<chain, account>\n  >\n>\n\nexport type CreateWalletClientErrorType = CreateClientErrorType | ErrorType\n\n/**\n * Creates a Wallet Client with a given [Transport](https://viem.sh/docs/clients/intro) configured for a [Chain](https://viem.sh/docs/clients/chains).\n *\n * - Docs: https://viem.sh/docs/clients/wallet\n *\n * A Wallet Client is an interface to interact with [Ethereum Account(s)](https://ethereum.org/en/glossary/#account) and provides the ability to retrieve accounts, execute transactions, sign messages, etc. through [Wallet Actions](https://viem.sh/docs/actions/wallet/introduction).\n *\n * The Wallet Client supports signing over:\n * - [JSON-RPC Accounts](https://viem.sh/docs/clients/wallet#json-rpc-accounts) (e.g. Browser Extension Wallets, WalletConnect, etc).\n * - [Local Accounts](https://viem.sh/docs/clients/wallet#local-accounts-private-key-mnemonic-etc) (e.g. private key/mnemonic wallets).\n *\n * @param config - {@link WalletClientConfig}\n * @returns A Wallet Client. {@link WalletClient}\n *\n * @example\n * // JSON-RPC Account\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * @example\n * // Local Account\n * import { createWalletClient, custom } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x')\n *   chain: mainnet,\n *   transport: http(),\n * })\n */\nexport function createWalletClient<\n  transport extends Transport,\n  chain extends Chain | undefined = undefined,\n  accountOrAddress extends Account | Address | undefined = undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n>(\n  parameters: WalletClientConfig<transport, chain, accountOrAddress, rpcSchema>,\n): WalletClient<transport, chain, ParseAccount<accountOrAddress>, rpcSchema>\n\nexport function createWalletClient(\n  parameters: WalletClientConfig,\n): WalletClient {\n  const { key = 'wallet', name = 'Wallet Client', transport } = parameters\n  const client = createClient({\n    ...parameters,\n    key,\n    name,\n    transport,\n    type: 'walletClient',\n  })\n  return client.extend(walletActions)\n}\n","import type { ExactPartial, OneOf } from '../../types/utils.js'\nimport type {\n  ZksyncTransactionRequest,\n  ZksyncTransactionSerializable,\n} from '../types/transaction.js'\n\nexport function isEIP712Transaction(\n  transaction: ExactPartial<\n    OneOf<ZksyncTransactionRequest | ZksyncTransactionSerializable>\n  >,\n) {\n  if (transaction.type === 'eip712') return true\n  if (\n    ('customSignature' in transaction && transaction.customSignature) ||\n    ('paymaster' in transaction && transaction.paymaster) ||\n    ('paymasterInput' in transaction && transaction.paymasterInput) ||\n    ('gasPerPubdata' in transaction &&\n      typeof transaction.gasPerPubdata === 'bigint') ||\n    ('factoryDeps' in transaction && transaction.factoryDeps)\n  )\n    return true\n  return false\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/util/encoding.ts","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/sign/base-account/utils.ts","import { resolveNetworkToChain } from \"./networkToChainResolver.js\";\nimport { toNetworkScopedEvmSmartAccount } from \"./toNetworkScopedEvmSmartAccount.js\";\nimport { getUserOperation } from \"../../actions/evm/getUserOperation.js\";\nimport {\n  listTokenBalances,\n  type ListTokenBalancesOptions,\n  type ListTokenBalancesResult,\n} from \"../../actions/evm/listTokenBalances.js\";\nimport {\n  RequestFaucetResult,\n  RequestFaucetOptions,\n  requestFaucet,\n} from \"../../actions/evm/requestFaucet.js\";\nimport {\n  type SendUserOperationOptions,\n  type SendUserOperationReturnType,\n  sendUserOperation,\n} from \"../../actions/evm/sendUserOperation.js\";\nimport { signAndWrapTypedDataForSmartAccount } from \"../../actions/evm/signAndWrapTypedDataForSmartAccount.js\";\nimport { useSpendPermission } from \"../../actions/evm/spend-permissions/smartAccount.use.js\";\nimport { UseSpendPermissionOptions } from \"../../actions/evm/spend-permissions/types.js\";\nimport { createSwapQuote } from \"../../actions/evm/swap/createSwapQuote.js\";\nimport { sendSwapOperation } from \"../../actions/evm/swap/sendSwapOperation.js\";\nimport { smartAccountTransferStrategy } from \"../../actions/evm/transfer/smartAccountTransferStrategy.js\";\nimport { transfer } from \"../../actions/evm/transfer/transfer.js\";\nimport {\n  waitForUserOperation,\n  WaitForUserOperationOptions,\n  WaitForUserOperationReturnType,\n} from \"../../actions/evm/waitForUserOperation.js\";\nimport { Analytics } from \"../../analytics.js\";\nimport {\n  GetUserOperationOptions,\n  SignTypedDataOptions,\n  UserOperation,\n} from \"../../client/evm/evm.types.js\";\nimport {\n  type CdpOpenApiClientType,\n  type EvmSmartAccount as EvmSmartAccountModel,\n} from \"../../openapi-client/index.js\";\n\nimport type { EvmAccount, EvmSmartAccount, KnownEvmNetworks } from \"./types.js\";\nimport type {\n  SmartAccountQuoteSwapOptions,\n  SmartAccountQuoteSwapResult,\n  SmartAccountSwapOptions,\n  SmartAccountSwapResult,\n} from \"../../actions/evm/swap/types.js\";\nimport type { Address, Hex } from \"../../types/misc.js\";\n\n/**\n * Options for converting a pre-existing EvmSmartAccount and owner to a EvmSmartAccount\n */\nexport type ToEvmSmartAccountOptions = {\n  /** The pre-existing EvmSmartAccount. */\n  smartAccount: EvmSmartAccountModel;\n  /** The owner of the smart account. */\n  owner: EvmAccount;\n};\n\n/**\n * Creates a EvmSmartAccount instance from an existing EvmSmartAccount and owner.\n * Use this to interact with previously deployed EvmSmartAccounts, rather than creating new ones.\n *\n * The owner must be the original owner of the evm smart account.\n *\n * @param {CdpOpenApiClientType} apiClient - The API client.\n * @param {ToEvmSmartAccountOptions} options - Configuration options.\n * @param {EvmSmartAccount} options.smartAccount - The deployed evm smart account.\n * @param {EvmAccount} options.owner - The owner which signs for the smart account.\n * @returns {EvmSmartAccount} A configured EvmSmartAccount instance ready for user operation submission.\n */\nexport function toEvmSmartAccount(\n  apiClient: CdpOpenApiClientType,\n  options: ToEvmSmartAccountOptions,\n): EvmSmartAccount {\n  const account: EvmSmartAccount = {\n    address: options.smartAccount.address as Address,\n    owners: [options.owner],\n    policies: options.smartAccount.policies,\n    async transfer(transferArgs): Promise<SendUserOperationReturnType> {\n      Analytics.trackAction({\n        action: \"transfer\",\n        accountType: \"evm_smart\",\n        properties: {\n          network: transferArgs.network,\n        },\n      });\n\n      return transfer(apiClient, account, transferArgs, smartAccountTransferStrategy);\n    },\n    async listTokenBalances(\n      options: Omit<ListTokenBalancesOptions, \"address\">,\n    ): Promise<ListTokenBalancesResult> {\n      Analytics.trackAction({\n        action: \"list_token_balances\",\n        accountType: \"evm_smart\",\n        properties: {\n          network: options.network,\n        },\n      });\n\n      return listTokenBalances(apiClient, {\n        ...options,\n        address: this.address,\n      });\n    },\n    async sendUserOperation(\n      options: Omit<SendUserOperationOptions<unknown[]>, \"smartAccount\">,\n    ): Promise<SendUserOperationReturnType> {\n      Analytics.trackAction({\n        action: \"send_user_operation\",\n        accountType: \"evm_smart\",\n        properties: {\n          network: options.network,\n        },\n      });\n\n      return sendUserOperation(apiClient, {\n        ...options,\n        smartAccount: account,\n      });\n    },\n    async waitForUserOperation(\n      options: Omit<WaitForUserOperationOptions, \"smartAccountAddress\">,\n    ): Promise<WaitForUserOperationReturnType> {\n      Analytics.trackAction({\n        action: \"wait_for_user_operation\",\n        accountType: \"evm_smart\",\n      });\n\n      return waitForUserOperation(apiClient, {\n        ...options,\n        smartAccountAddress: account.address,\n      });\n    },\n    async getUserOperation(\n      options: Omit<GetUserOperationOptions, \"smartAccount\">,\n    ): Promise<UserOperation> {\n      Analytics.trackAction({\n        action: \"get_user_operation\",\n        accountType: \"evm_smart\",\n      });\n\n      return getUserOperation(apiClient, {\n        ...options,\n        smartAccount: account,\n      });\n    },\n    async requestFaucet(\n      options: Omit<RequestFaucetOptions, \"address\">,\n    ): Promise<RequestFaucetResult> {\n      Analytics.trackAction({\n        action: \"request_faucet\",\n        accountType: \"evm_smart\",\n        properties: {\n          network: options.network,\n        },\n      });\n\n      return requestFaucet(apiClient, {\n        ...options,\n        address: account.address,\n      });\n    },\n    async quoteSwap(options: SmartAccountQuoteSwapOptions): Promise<SmartAccountQuoteSwapResult> {\n      Analytics.trackAction({\n        action: \"quote_swap\",\n        accountType: \"evm_smart\",\n        properties: {\n          network: options.network,\n        },\n      });\n\n      return createSwapQuote(apiClient, {\n        ...options,\n        taker: this.address, // Always use smart account's address as taker\n        signerAddress: this.owners[0].address, // Always use owner's address as signer\n        smartAccount: account, // Pass smart account for execute method support\n      });\n    },\n    async swap(options: SmartAccountSwapOptions): Promise<SmartAccountSwapResult> {\n      Analytics.trackAction({\n        action: \"swap\",\n        accountType: \"evm_smart\",\n        properties: {\n          network: \"network\" in options ? options.network : undefined,\n        },\n      });\n\n      return sendSwapOperation(apiClient, {\n        ...options,\n        smartAccount: account,\n        taker: this.address, // Always use smart account's address as taker\n        signerAddress: this.owners[0].address, // Always use owner's address as signer\n      });\n    },\n    async signTypedData(\n      options: Omit<SignTypedDataOptions, \"address\"> & { network: KnownEvmNetworks },\n    ): Promise<Hex> {\n      Analytics.trackAction({\n        action: \"sign_typed_data\",\n        accountType: \"evm_smart\",\n        properties: {\n          network: options.network,\n        },\n      });\n\n      const result = await signAndWrapTypedDataForSmartAccount(apiClient, {\n        chainId: BigInt(resolveNetworkToChain(options.network).id),\n        smartAccount: account,\n        typedData: options,\n      });\n      return result.signature;\n    },\n    async useSpendPermission(\n      options: UseSpendPermissionOptions,\n    ): Promise<SendUserOperationReturnType> {\n      Analytics.trackAction({\n        action: \"use_spend_permission\",\n        accountType: \"evm_smart\",\n        properties: {\n          network: options.network,\n        },\n      });\n\n      return useSpendPermission(apiClient, account, options);\n    },\n\n    name: options.smartAccount.name,\n    type: \"evm-smart\",\n    useNetwork: async <Network extends KnownEvmNetworks>(network: Network) => {\n      Analytics.trackAction({\n        action: \"use_network\",\n        accountType: \"evm_smart\",\n        properties: {\n          network,\n        },\n      });\n\n      return toNetworkScopedEvmSmartAccount(apiClient, {\n        smartAccount: account,\n        owner: options.owner,\n        network,\n      });\n    },\n  };\n\n  return account;\n}\n","import type { EstimateFeesPerGasReturnType } from '../../actions/public/estimateFeesPerGas.js'\nimport {\n  type Client,\n  type ClientConfig,\n  type CreateClientErrorType,\n  createClient,\n} from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { BundlerRpcSchema, RpcSchema } from '../../types/eip1193.js'\nimport type { Prettify } from '../../types/utils.js'\nimport type { SmartAccount } from '../accounts/types.js'\nimport type { UserOperationRequest } from '../types/userOperation.js'\nimport { type BundlerActions, bundlerActions } from './decorators/bundler.js'\nimport type { PaymasterActions } from './decorators/paymaster.js'\n\nexport type BundlerClientConfig<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  client extends Client | undefined = Client | undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n> = Prettify<\n  Pick<\n    ClientConfig<transport, chain, account, rpcSchema>,\n    | 'account'\n    | 'cacheTime'\n    | 'chain'\n    | 'key'\n    | 'name'\n    | 'pollingInterval'\n    | 'rpcSchema'\n    | 'transport'\n  >\n> & {\n  /** Client that points to an Execution RPC URL. */\n  client?: client | Client | undefined\n  /** Paymaster configuration. */\n  paymaster?:\n    | true\n    | {\n        /** Retrieves paymaster-related User Operation properties to be used for sending the User Operation. */\n        getPaymasterData?: PaymasterActions['getPaymasterData'] | undefined\n        /** Retrieves paymaster-related User Operation properties to be used for gas estimation. */\n        getPaymasterStubData?:\n          | PaymasterActions['getPaymasterStubData']\n          | undefined\n      }\n    | undefined\n  /** Paymaster context to pass to `getPaymasterData` and `getPaymasterStubData` calls. */\n  paymasterContext?: unknown\n  /** User Operation configuration. */\n  userOperation?:\n    | {\n        /** Prepares fee properties for the User Operation request. */\n        estimateFeesPerGas?:\n          | ((parameters: {\n              account: account | SmartAccount\n              bundlerClient: Client\n              userOperation: UserOperationRequest\n            }) => Promise<EstimateFeesPerGasReturnType<'eip1559'>>)\n          | undefined\n      }\n    | undefined\n}\n\nexport type BundlerClient<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  client extends Client | undefined = Client | undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n> = Prettify<\n  Client<\n    transport,\n    chain extends Chain\n      ? chain\n      : client extends Client<any, infer chain>\n        ? chain\n        : undefined,\n    account,\n    rpcSchema extends RpcSchema\n      ? [...BundlerRpcSchema, ...rpcSchema]\n      : BundlerRpcSchema,\n    BundlerActions<account>\n  >\n> & {\n  client: client\n  paymaster: BundlerClientConfig['paymaster'] | undefined\n  paymasterContext: BundlerClientConfig['paymasterContext'] | undefined\n  userOperation: BundlerClientConfig['userOperation'] | undefined\n}\n\nexport type CreateBundlerClientErrorType = CreateClientErrorType | ErrorType\n\n/**\n * Creates a Bundler Client with a given [Transport](https://viem.sh/docs/clients/intro) configured for a [Chain](https://viem.sh/docs/clients/chains).\n *\n * - Docs: https://viem.sh/account-abstraction/clients/bundler\n *\n * @param config - {@link BundlerClientConfig}\n * @returns A Bundler Client. {@link BundlerClient}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { createBundlerClient } from 'viem/account-abstraction'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const bundlerClient = createBundlerClient({\n *   client,\n *   transport: http('https://public.pimlico.io/v2/1/rpc'),\n * })\n */\nexport function createBundlerClient<\n  transport extends Transport,\n  chain extends Chain | undefined = undefined,\n  account extends SmartAccount | undefined = undefined,\n  client extends Client | undefined = undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n>(\n  parameters: BundlerClientConfig<transport, chain, account, client, rpcSchema>,\n): BundlerClient<transport, chain, account, client, rpcSchema>\n\nexport function createBundlerClient(\n  parameters: BundlerClientConfig,\n): BundlerClient {\n  const {\n    client: client_,\n    key = 'bundler',\n    name = 'Bundler Client',\n    paymaster,\n    paymasterContext,\n    transport,\n    userOperation,\n  } = parameters\n  const client = Object.assign(\n    createClient({\n      ...parameters,\n      chain: parameters.chain ?? client_?.chain,\n      key,\n      name,\n      transport,\n      type: 'bundlerClient',\n    }),\n    { client: client_, paymaster, paymasterContext, userOperation },\n  )\n  return client.extend(bundlerActions) as any\n}\n","import type { Address, Narrow } from 'abitype'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../../accounts/utils/parseAccount.js'\nimport { prepareAuthorization } from '../../../actions/index.js'\nimport {\n  type EstimateFeesPerGasErrorType,\n  estimateFeesPerGas,\n} from '../../../actions/public/estimateFeesPerGas.js'\nimport { getChainId as getChainId_ } from '../../../actions/public/getChainId.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../../errors/account.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { SignedAuthorization } from '../../../types/authorization.js'\nimport type { Call, Calls } from '../../../types/calls.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { StateOverride } from '../../../types/stateOverride.js'\nimport type {\n  Assign,\n  OneOf,\n  Prettify,\n  UnionOmit,\n} from '../../../types/utils.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../../utils/abi/encodeFunctionData.js'\nimport { type ConcatErrorType, concat } from '../../../utils/data/concat.js'\nimport { getAction } from '../../../utils/getAction.js'\nimport type { SmartAccount } from '../../accounts/types.js'\nimport type { BundlerClient } from '../../clients/createBundlerClient.js'\nimport type { PaymasterActions } from '../../clients/decorators/paymaster.js'\nimport type {\n  DeriveSmartAccount,\n  GetSmartAccountParameter,\n} from '../../types/account.js'\nimport type {\n  DeriveEntryPointVersion,\n  EntryPointVersion,\n} from '../../types/entryPointVersion.js'\nimport type {\n  UserOperation,\n  UserOperationRequest,\n} from '../../types/userOperation.js'\nimport {\n  type GetPaymasterDataErrorType,\n  getPaymasterData as getPaymasterData_,\n} from '../paymaster/getPaymasterData.js'\nimport {\n  type GetPaymasterStubDataErrorType,\n  getPaymasterStubData as getPaymasterStubData_,\n} from '../paymaster/getPaymasterStubData.js'\nimport {\n  type EstimateUserOperationGasParameters,\n  estimateUserOperationGas,\n} from './estimateUserOperationGas.js'\n\nconst defaultParameters = [\n  'factory',\n  'fees',\n  'gas',\n  'paymaster',\n  'nonce',\n  'signature',\n  'authorization',\n] as const\n\nexport type PrepareUserOperationParameterType =\n  | 'factory'\n  | 'fees'\n  | 'gas'\n  | 'paymaster'\n  | 'nonce'\n  | 'signature'\n  | 'authorization'\n\ntype FactoryProperties<\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n> =\n  | (entryPointVersion extends '0.8'\n      ? {\n          factory: UserOperation['factory']\n          factoryData: UserOperation['factoryData']\n        }\n      : never)\n  | (entryPointVersion extends '0.7'\n      ? {\n          factory: UserOperation['factory']\n          factoryData: UserOperation['factoryData']\n        }\n      : never)\n  | (entryPointVersion extends '0.6'\n      ? {\n          initCode: UserOperation['initCode']\n        }\n      : never)\n\ntype GasProperties<\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n> =\n  | (entryPointVersion extends '0.8'\n      ? {\n          callGasLimit: UserOperation['callGasLimit']\n          preVerificationGas: UserOperation['preVerificationGas']\n          verificationGasLimit: UserOperation['verificationGasLimit']\n          paymasterPostOpGasLimit: UserOperation['paymasterPostOpGasLimit']\n          paymasterVerificationGasLimit: UserOperation['paymasterVerificationGasLimit']\n        }\n      : never)\n  | (entryPointVersion extends '0.7'\n      ? {\n          callGasLimit: UserOperation['callGasLimit']\n          preVerificationGas: UserOperation['preVerificationGas']\n          verificationGasLimit: UserOperation['verificationGasLimit']\n          paymasterPostOpGasLimit: UserOperation['paymasterPostOpGasLimit']\n          paymasterVerificationGasLimit: UserOperation['paymasterVerificationGasLimit']\n        }\n      : never)\n  | (entryPointVersion extends '0.6'\n      ? {\n          callGasLimit: UserOperation['callGasLimit']\n          preVerificationGas: UserOperation['preVerificationGas']\n          verificationGasLimit: UserOperation['verificationGasLimit']\n        }\n      : never)\n\ntype FeeProperties = {\n  maxFeePerGas: UserOperation['maxFeePerGas']\n  maxPriorityFeePerGas: UserOperation['maxPriorityFeePerGas']\n}\n\ntype NonceProperties = {\n  nonce: UserOperation['nonce']\n}\n\ntype PaymasterProperties<\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n> =\n  | (entryPointVersion extends '0.8'\n      ? {\n          paymaster: UserOperation['paymaster']\n          paymasterData: UserOperation['paymasterData']\n          paymasterPostOpGasLimit: UserOperation['paymasterPostOpGasLimit']\n          paymasterVerificationGasLimit: UserOperation['paymasterVerificationGasLimit']\n        }\n      : never)\n  | (entryPointVersion extends '0.7'\n      ? {\n          paymaster: UserOperation['paymaster']\n          paymasterData: UserOperation['paymasterData']\n          paymasterPostOpGasLimit: UserOperation['paymasterPostOpGasLimit']\n          paymasterVerificationGasLimit: UserOperation['paymasterVerificationGasLimit']\n        }\n      : never)\n  | (entryPointVersion extends '0.6'\n      ? {\n          paymasterAndData: UserOperation['paymasterAndData']\n        }\n      : never)\n\ntype SignatureProperties = {\n  signature: UserOperation['signature']\n}\n\ntype AuthorizationProperties = {\n  authorization: UserOperation['authorization']\n}\n\nexport type PrepareUserOperationRequest<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  //\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = Assign<\n  UserOperationRequest<_derivedVersion>,\n  OneOf<{ calls: Calls<Narrow<calls>> } | { callData: Hex }> & {\n    parameters?: readonly PrepareUserOperationParameterType[] | undefined\n    paymaster?:\n      | Address\n      | true\n      | {\n          /** Retrieves paymaster-related User Operation properties to be used for sending the User Operation. */\n          getPaymasterData?: PaymasterActions['getPaymasterData'] | undefined\n          /** Retrieves paymaster-related User Operation properties to be used for gas estimation. */\n          getPaymasterStubData?:\n            | PaymasterActions['getPaymasterStubData']\n            | undefined\n        }\n      | undefined\n    /** Paymaster context to pass to `getPaymasterData` and `getPaymasterStubData` calls. */\n    paymasterContext?: unknown | undefined\n    /** State overrides for the User Operation call. */\n    stateOverride?: StateOverride | undefined\n  }\n>\n\nexport type PrepareUserOperationParameters<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  request extends PrepareUserOperationRequest<\n    account,\n    accountOverride,\n    calls\n  > = PrepareUserOperationRequest<account, accountOverride, calls>,\n> = request & GetSmartAccountParameter<account, accountOverride>\n\nexport type PrepareUserOperationReturnType<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  request extends PrepareUserOperationRequest<\n    account,\n    accountOverride,\n    calls\n  > = PrepareUserOperationRequest<account, accountOverride, calls>,\n  //\n  _parameters extends\n    PrepareUserOperationParameterType = request['parameters'] extends readonly PrepareUserOperationParameterType[]\n    ? request['parameters'][number]\n    : (typeof defaultParameters)[number],\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = Prettify<\n  UnionOmit<request, 'calls' | 'parameters'> & {\n    callData: Hex\n    paymasterAndData: _derivedVersion extends '0.6' ? Hex : undefined\n    sender: UserOperation['sender']\n  } & (Extract<_parameters, 'authorization'> extends never\n      ? {}\n      : AuthorizationProperties) &\n    (Extract<_parameters, 'factory'> extends never\n      ? {}\n      : FactoryProperties<_derivedVersion>) &\n    (Extract<_parameters, 'nonce'> extends never ? {} : NonceProperties) &\n    (Extract<_parameters, 'fees'> extends never ? {} : FeeProperties) &\n    (Extract<_parameters, 'gas'> extends never\n      ? {}\n      : GasProperties<_derivedVersion>) &\n    (Extract<_parameters, 'paymaster'> extends never\n      ? {}\n      : PaymasterProperties<_derivedVersion>) &\n    (Extract<_parameters, 'signature'> extends never ? {} : SignatureProperties)\n>\n\nexport type PrepareUserOperationErrorType =\n  | ParseAccountErrorType\n  | GetPaymasterStubDataErrorType\n  | GetPaymasterDataErrorType\n  | EncodeFunctionDataErrorType\n  | ConcatErrorType\n  | EstimateFeesPerGasErrorType\n  | ErrorType\n\n/**\n * Prepares a User Operation and fills in missing properties.\n *\n * - Docs: https://viem.sh/actions/bundler/prepareUserOperation\n *\n * @param args - {@link PrepareUserOperationParameters}\n * @returns The User Operation. {@link PrepareUserOperationReturnType}\n *\n * @example\n * import { createBundlerClient, http } from 'viem'\n * import { toSmartAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { prepareUserOperation } from 'viem/actions'\n *\n * const account = await toSmartAccount({ ... })\n *\n * const client = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const request = await prepareUserOperation(client, {\n *   account,\n *   calls: [{ to: '0x...', value: parseEther('1') }],\n * })\n */\nexport async function prepareUserOperation<\n  account extends SmartAccount | undefined,\n  const calls extends readonly unknown[],\n  const request extends PrepareUserOperationRequest<\n    account,\n    accountOverride,\n    calls\n  >,\n  accountOverride extends SmartAccount | undefined = undefined,\n>(\n  client: Client<Transport, Chain | undefined, account>,\n  parameters_: PrepareUserOperationParameters<\n    account,\n    accountOverride,\n    calls,\n    request\n  >,\n): Promise<\n  PrepareUserOperationReturnType<account, accountOverride, calls, request>\n> {\n  const parameters = parameters_ as PrepareUserOperationParameters\n  const {\n    account: account_ = client.account,\n    parameters: properties = defaultParameters,\n    stateOverride,\n  } = parameters\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Assert that an Account is defined.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  if (!account_) throw new AccountNotFoundError()\n  const account = parseAccount(account_)\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Declare typed Bundler Client.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  const bundlerClient = client as unknown as BundlerClient\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Declare Paymaster properties.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  const paymaster = parameters.paymaster ?? bundlerClient?.paymaster\n  const paymasterAddress = typeof paymaster === 'string' ? paymaster : undefined\n  const { getPaymasterStubData, getPaymasterData } = (() => {\n    // If `paymaster: true`, we will assume the Bundler Client supports Paymaster Actions.\n    if (paymaster === true)\n      return {\n        getPaymasterStubData: (parameters: any) =>\n          getAction(\n            bundlerClient,\n            getPaymasterStubData_,\n            'getPaymasterStubData',\n          )(parameters),\n        getPaymasterData: (parameters: any) =>\n          getAction(\n            bundlerClient,\n            getPaymasterData_,\n            'getPaymasterData',\n          )(parameters),\n      }\n\n    // If Actions are passed to `paymaster` (via Paymaster Client or directly), we will use them.\n    if (typeof paymaster === 'object') {\n      const { getPaymasterStubData, getPaymasterData } = paymaster\n      return {\n        getPaymasterStubData: (getPaymasterData && getPaymasterStubData\n          ? getPaymasterStubData\n          : getPaymasterData) as typeof getPaymasterStubData,\n        getPaymasterData:\n          getPaymasterData && getPaymasterStubData\n            ? getPaymasterData\n            : undefined,\n      }\n    }\n\n    // No Paymaster functions.\n    return {\n      getPaymasterStubData: undefined,\n      getPaymasterData: undefined,\n    }\n  })()\n  const paymasterContext = parameters.paymasterContext\n    ? parameters.paymasterContext\n    : bundlerClient?.paymasterContext\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Set up the User Operation request.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  let request = {\n    ...parameters,\n    paymaster: paymasterAddress,\n    sender: account.address,\n  } as PrepareUserOperationRequest\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Concurrently prepare properties required to fill the User Operation.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  const [callData, factory, fees, nonce, authorization] = await Promise.all([\n    (async () => {\n      if (parameters.calls)\n        return account.encodeCalls(\n          parameters.calls.map((call_) => {\n            const call = call_ as Call\n            if (call.abi)\n              return {\n                data: encodeFunctionData(call),\n                to: call.to,\n                value: call.value,\n              } as Call\n            return call as Call\n          }),\n        )\n      return parameters.callData\n    })(),\n    (async () => {\n      if (!properties.includes('factory')) return undefined\n      if (parameters.initCode) return { initCode: parameters.initCode }\n      if (parameters.factory && parameters.factoryData) {\n        return {\n          factory: parameters.factory,\n          factoryData: parameters.factoryData,\n        }\n      }\n\n      const { factory, factoryData } = await account.getFactoryArgs()\n\n      if (account.entryPoint.version === '0.6')\n        return {\n          initCode:\n            factory && factoryData ? concat([factory, factoryData]) : undefined,\n        }\n      return {\n        factory,\n        factoryData,\n      }\n    })(),\n    (async () => {\n      if (!properties.includes('fees')) return undefined\n\n      // If we have sufficient properties for fees, return them.\n      if (\n        typeof parameters.maxFeePerGas === 'bigint' &&\n        typeof parameters.maxPriorityFeePerGas === 'bigint'\n      )\n        return request\n\n      // If the Bundler Client has a `estimateFeesPerGas` hook, run it.\n      if (bundlerClient?.userOperation?.estimateFeesPerGas) {\n        const fees = await bundlerClient.userOperation.estimateFeesPerGas({\n          account,\n          bundlerClient,\n          userOperation: request as UserOperation,\n        })\n        return {\n          ...request,\n          ...fees,\n        }\n      }\n\n      // Otherwise, we will need to estimate the fees to fill the fee properties.\n      try {\n        const client_ = bundlerClient.client ?? client\n        const fees = await getAction(\n          client_,\n          estimateFeesPerGas,\n          'estimateFeesPerGas',\n        )({\n          chain: client_.chain,\n          type: 'eip1559',\n        })\n        return {\n          maxFeePerGas:\n            typeof parameters.maxFeePerGas === 'bigint'\n              ? parameters.maxFeePerGas\n              : BigInt(\n                  // Bundlers unfortunately have strict rules on fee prechecks  we will need to set a generous buffer.\n                  2n * fees.maxFeePerGas,\n                ),\n          maxPriorityFeePerGas:\n            typeof parameters.maxPriorityFeePerGas === 'bigint'\n              ? parameters.maxPriorityFeePerGas\n              : BigInt(\n                  // Bundlers unfortunately have strict rules on fee prechecks  we will need to set a generous buffer.\n                  2n * fees.maxPriorityFeePerGas,\n                ),\n        }\n      } catch {\n        return undefined\n      }\n    })(),\n    (async () => {\n      if (!properties.includes('nonce')) return undefined\n      if (typeof parameters.nonce === 'bigint') return parameters.nonce\n      return account.getNonce()\n    })(),\n    (async () => {\n      if (!properties.includes('authorization')) return undefined\n      if (typeof parameters.authorization === 'object')\n        return parameters.authorization\n      if (account.authorization && !(await account.isDeployed())) {\n        const authorization = await prepareAuthorization(\n          account.client,\n          account.authorization,\n        )\n        return {\n          ...authorization,\n          r: '0xfffffffffffffffffffffffffffffff000000000000000000000000000000000',\n          s: '0x7aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n          yParity: 1,\n        } satisfies SignedAuthorization\n      }\n      return undefined\n    })(),\n  ])\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with the prepared properties from above.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  if (typeof callData !== 'undefined') request.callData = callData\n  if (typeof factory !== 'undefined')\n    request = { ...request, ...(factory as any) }\n  if (typeof fees !== 'undefined') request = { ...request, ...(fees as any) }\n  if (typeof nonce !== 'undefined') request.nonce = nonce\n  if (typeof authorization !== 'undefined')\n    request.authorization = authorization\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with the `signature` property.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  if (properties.includes('signature')) {\n    if (typeof parameters.signature !== 'undefined')\n      request.signature = parameters.signature\n    else\n      request.signature = await account.getStubSignature(\n        request as UserOperation,\n      )\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // `initCode` is required to be filled with EntryPoint 0.6.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  // If no `initCode` is provided, we use an empty bytes string.\n  if (account.entryPoint.version === '0.6' && !request.initCode)\n    request.initCode = '0x'\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with paymaster-related properties for **gas estimation**.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  let chainId: number | undefined\n  async function getChainId(): Promise<number> {\n    if (chainId) return chainId\n    if (client.chain) return client.chain.id\n    const chainId_ = await getAction(client, getChainId_, 'getChainId')({})\n    chainId = chainId_\n    return chainId\n  }\n\n  // If the User Operation is intended to be sponsored, we will need to fill the paymaster-related\n  // User Operation properties required to estimate the User Operation gas.\n  let isPaymasterPopulated = false\n  if (\n    properties.includes('paymaster') &&\n    getPaymasterStubData &&\n    !paymasterAddress &&\n    !parameters.paymasterAndData\n  ) {\n    const {\n      isFinal = false,\n      sponsor: _,\n      ...paymasterArgs\n    } = await getPaymasterStubData({\n      chainId: await getChainId(),\n      entryPointAddress: account.entryPoint.address,\n      context: paymasterContext,\n      ...(request as UserOperation),\n    })\n    isPaymasterPopulated = isFinal\n    request = {\n      ...request,\n      ...paymasterArgs,\n    } as PrepareUserOperationRequest\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // `paymasterAndData` is required to be filled with EntryPoint 0.6.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  // If no `paymasterAndData` is provided, we use an empty bytes string.\n  if (account.entryPoint.version === '0.6' && !request.paymasterAndData)\n    request.paymasterAndData = '0x'\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with gas-related properties.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  if (properties.includes('gas')) {\n    // If the Account has opinionated gas estimation logic, run the `estimateGas` hook and\n    // fill the request with the prepared gas properties.\n    if (account.userOperation?.estimateGas) {\n      const gas = await account.userOperation.estimateGas(\n        request as UserOperation,\n      )\n      request = {\n        ...request,\n        ...gas,\n      } as PrepareUserOperationRequest\n    }\n\n    // If not all the gas properties are already populated, we will need to estimate the gas\n    // to fill the gas properties.\n    if (\n      typeof request.callGasLimit === 'undefined' ||\n      typeof request.preVerificationGas === 'undefined' ||\n      typeof request.verificationGasLimit === 'undefined' ||\n      (request.paymaster &&\n        typeof request.paymasterPostOpGasLimit === 'undefined') ||\n      (request.paymaster &&\n        typeof request.paymasterVerificationGasLimit === 'undefined')\n    ) {\n      const gas = await getAction(\n        bundlerClient,\n        estimateUserOperationGas,\n        'estimateUserOperationGas',\n      )({\n        account,\n        // Some Bundlers fail if nullish gas values are provided for gas estimation :') \n        // so we will need to set a default zeroish value.\n        callGasLimit: 0n,\n        preVerificationGas: 0n,\n        verificationGasLimit: 0n,\n        stateOverride,\n        ...(request.paymaster\n          ? {\n              paymasterPostOpGasLimit: 0n,\n              paymasterVerificationGasLimit: 0n,\n            }\n          : {}),\n        ...request,\n      } as EstimateUserOperationGasParameters)\n      request = {\n        ...request,\n        callGasLimit: request.callGasLimit ?? gas.callGasLimit,\n        preVerificationGas:\n          request.preVerificationGas ?? gas.preVerificationGas,\n        verificationGasLimit:\n          request.verificationGasLimit ?? gas.verificationGasLimit,\n        paymasterPostOpGasLimit:\n          request.paymasterPostOpGasLimit ?? gas.paymasterPostOpGasLimit,\n        paymasterVerificationGasLimit:\n          request.paymasterVerificationGasLimit ??\n          gas.paymasterVerificationGasLimit,\n      } as PrepareUserOperationRequest\n    }\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Fill User Operation with paymaster-related properties for **sending** the User Operation.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  // If the User Operation is intended to be sponsored, we will need to fill the paymaster-related\n  // User Operation properties required to send the User Operation.\n  if (\n    properties.includes('paymaster') &&\n    getPaymasterData &&\n    !paymasterAddress &&\n    !parameters.paymasterAndData &&\n    !isPaymasterPopulated\n  ) {\n    // Retrieve paymaster-related User Operation properties to be used for **sending** the User Operation.\n    const paymaster = await getPaymasterData({\n      chainId: await getChainId(),\n      entryPointAddress: account.entryPoint.address,\n      context: paymasterContext,\n      ...(request as UserOperation),\n    })\n    request = {\n      ...request,\n      ...paymaster,\n    } as PrepareUserOperationRequest\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Remove redundant properties that do not conform to the User Operation schema.\n  ////////////////////////////////////////////////////////////////////////////////\n\n  delete request.calls\n  delete request.parameters\n  delete request.paymasterContext\n  if (typeof request.paymaster !== 'string') delete request.paymaster\n\n  ////////////////////////////////////////////////////////////////////////////////\n\n  return request as unknown as PrepareUserOperationReturnType<\n    account,\n    accountOverride,\n    calls,\n    request\n  >\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/ui/assets/injectFontStyle.ts","import { chainConfig } from '../../celo/chainConfig.js'\nimport { defineChain } from '../../utils/chain/defineChain.js'\n\nconst sourceId = 17000 // holsky\n// source https://storage.googleapis.com/cel2-rollup-files/alfajores/deployment-l1.json\n\nexport const celoAlfajores = /*#__PURE__*/ defineChain({\n  ...chainConfig,\n  id: 44_787,\n  name: 'Alfajores',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'CELO',\n    symbol: 'A-CELO',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://alfajores-forno.celo-testnet.org'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Celo Alfajores Explorer',\n      url: 'https://celo-alfajores.blockscout.com',\n      apiUrl: 'https://celo-alfajores.blockscout.com/api',\n    },\n  },\n  contracts: {\n    ...chainConfig.contracts,\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 14569001,\n    },\n    portal: {\n      [sourceId]: {\n        address: '0x82527353927d8D069b3B452904c942dA149BA381',\n        blockCreated: 2411324,\n      },\n    },\n    disputeGameFactory: {\n      [sourceId]: {\n        address: '0xE28AAdcd9883746c0e5068F58f9ea06027b214cb',\n        blockCreated: 2411324,\n      },\n    },\n    l2OutputOracle: {\n      [sourceId]: {\n        address: '0x4a2635e9e4f6e45817b1D402ac4904c1d1752438',\n        blockCreated: 2411324,\n      },\n    },\n    l1StandardBridge: {\n      [sourceId]: {\n        address: '0xD1B0E0581973c9eB7f886967A606b9441A897037',\n        blockCreated: 2411324,\n      },\n    },\n  },\n  testnet: true,\n})\n","import type {\n  AbiItemType,\n  AbiType,\n  SolidityArray,\n  SolidityBytes,\n  SolidityString,\n  SolidityTuple,\n} from '../../abi.js'\nimport {\n  bytesRegex,\n  execTyped,\n  integerRegex,\n  isTupleRegex,\n} from '../../regex.js'\nimport { UnknownSolidityTypeError } from '../errors/abiItem.js'\nimport {\n  InvalidFunctionModifierError,\n  InvalidModifierError,\n  InvalidParameterError,\n  SolidityProtectedKeywordError,\n} from '../errors/abiParameter.js'\nimport {\n  InvalidSignatureError,\n  UnknownSignatureError,\n} from '../errors/signature.js'\nimport { InvalidParenthesisError } from '../errors/splitParameters.js'\nimport type { FunctionModifier, Modifier } from '../types/signatures.js'\nimport type { StructLookup } from '../types/structs.js'\nimport { getParameterCacheKey, parameterCache } from './cache.js'\nimport {\n  eventModifiers,\n  execConstructorSignature,\n  execErrorSignature,\n  execEventSignature,\n  execFunctionSignature,\n  functionModifiers,\n  isConstructorSignature,\n  isErrorSignature,\n  isEventSignature,\n  isFallbackSignature,\n  isFunctionSignature,\n  isReceiveSignature,\n} from './signatures.js'\n\nexport function parseSignature(signature: string, structs: StructLookup = {}) {\n  if (isFunctionSignature(signature)) {\n    const match = execFunctionSignature(signature)\n    if (!match) throw new InvalidSignatureError({ signature, type: 'function' })\n\n    const inputParams = splitParameters(match.parameters)\n    const inputs = []\n    const inputLength = inputParams.length\n    for (let i = 0; i < inputLength; i++) {\n      inputs.push(\n        parseAbiParameter(inputParams[i]!, {\n          modifiers: functionModifiers,\n          structs,\n          type: 'function',\n        }),\n      )\n    }\n\n    const outputs = []\n    if (match.returns) {\n      const outputParams = splitParameters(match.returns)\n      const outputLength = outputParams.length\n      for (let i = 0; i < outputLength; i++) {\n        outputs.push(\n          parseAbiParameter(outputParams[i]!, {\n            modifiers: functionModifiers,\n            structs,\n            type: 'function',\n          }),\n        )\n      }\n    }\n\n    return {\n      name: match.name,\n      type: 'function',\n      stateMutability: match.stateMutability ?? 'nonpayable',\n      inputs,\n      outputs,\n    }\n  }\n\n  if (isEventSignature(signature)) {\n    const match = execEventSignature(signature)\n    if (!match) throw new InvalidSignatureError({ signature, type: 'event' })\n\n    const params = splitParameters(match.parameters)\n    const abiParameters = []\n    const length = params.length\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i]!, {\n          modifiers: eventModifiers,\n          structs,\n          type: 'event',\n        }),\n      )\n    }\n    return { name: match.name, type: 'event', inputs: abiParameters }\n  }\n\n  if (isErrorSignature(signature)) {\n    const match = execErrorSignature(signature)\n    if (!match) throw new InvalidSignatureError({ signature, type: 'error' })\n\n    const params = splitParameters(match.parameters)\n    const abiParameters = []\n    const length = params.length\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i]!, { structs, type: 'error' }),\n      )\n    }\n    return { name: match.name, type: 'error', inputs: abiParameters }\n  }\n\n  if (isConstructorSignature(signature)) {\n    const match = execConstructorSignature(signature)\n    if (!match)\n      throw new InvalidSignatureError({ signature, type: 'constructor' })\n\n    const params = splitParameters(match.parameters)\n    const abiParameters = []\n    const length = params.length\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i]!, { structs, type: 'constructor' }),\n      )\n    }\n    return {\n      type: 'constructor',\n      stateMutability: match.stateMutability ?? 'nonpayable',\n      inputs: abiParameters,\n    }\n  }\n\n  if (isFallbackSignature(signature)) return { type: 'fallback' }\n  if (isReceiveSignature(signature))\n    return {\n      type: 'receive',\n      stateMutability: 'payable',\n    }\n\n  throw new UnknownSignatureError({ signature })\n}\n\nconst abiParameterWithoutTupleRegex =\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/\nconst abiParameterWithTupleRegex =\n  /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/\nconst dynamicIntegerRegex = /^u?int$/\n\ntype ParseOptions = {\n  modifiers?: Set<Modifier>\n  structs?: StructLookup\n  type?: AbiItemType | 'struct'\n}\n\nexport function parseAbiParameter(param: string, options?: ParseOptions) {\n  // optional namespace cache by `type`\n  const parameterCacheKey = getParameterCacheKey(param, options?.type)\n  if (parameterCache.has(parameterCacheKey))\n    return parameterCache.get(parameterCacheKey)!\n\n  const isTuple = isTupleRegex.test(param)\n  const match = execTyped<{\n    array?: string\n    modifier?: Modifier\n    name?: string\n    type: string\n  }>(\n    isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex,\n    param,\n  )\n  if (!match) throw new InvalidParameterError({ param })\n\n  if (match.name && isSolidityKeyword(match.name))\n    throw new SolidityProtectedKeywordError({ param, name: match.name })\n\n  const name = match.name ? { name: match.name } : {}\n  const indexed = match.modifier === 'indexed' ? { indexed: true } : {}\n  const structs = options?.structs ?? {}\n  let type: string\n  let components = {}\n  if (isTuple) {\n    type = 'tuple'\n    const params = splitParameters(match.type)\n    const components_ = []\n    const length = params.length\n    for (let i = 0; i < length; i++) {\n      // remove `modifiers` from `options` to prevent from being added to tuple components\n      components_.push(parseAbiParameter(params[i]!, { structs }))\n    }\n    components = { components: components_ }\n  } else if (match.type in structs) {\n    type = 'tuple'\n    components = { components: structs[match.type] }\n  } else if (dynamicIntegerRegex.test(match.type)) {\n    type = `${match.type}256`\n  } else {\n    type = match.type\n    if (!(options?.type === 'struct') && !isSolidityType(type))\n      throw new UnknownSolidityTypeError({ type })\n  }\n\n  if (match.modifier) {\n    // Check if modifier exists, but is not allowed (e.g. `indexed` in `functionModifiers`)\n    if (!options?.modifiers?.has?.(match.modifier))\n      throw new InvalidModifierError({\n        param,\n        type: options?.type,\n        modifier: match.modifier,\n      })\n\n    // Check if resolved `type` is valid if there is a function modifier\n    if (\n      functionModifiers.has(match.modifier as FunctionModifier) &&\n      !isValidDataLocation(type, !!match.array)\n    )\n      throw new InvalidFunctionModifierError({\n        param,\n        type: options?.type,\n        modifier: match.modifier,\n      })\n  }\n\n  const abiParameter = {\n    type: `${type}${match.array ?? ''}`,\n    ...name,\n    ...indexed,\n    ...components,\n  }\n  parameterCache.set(parameterCacheKey, abiParameter)\n  return abiParameter\n}\n\n// s/o latika for this\nexport function splitParameters(\n  params: string,\n  result: string[] = [],\n  current = '',\n  depth = 0,\n): readonly string[] {\n  const length = params.trim().length\n  // biome-ignore lint/correctness/noUnreachable: recursive\n  for (let i = 0; i < length; i++) {\n    const char = params[i]\n    const tail = params.slice(i + 1)\n    switch (char) {\n      case ',':\n        return depth === 0\n          ? splitParameters(tail, [...result, current.trim()])\n          : splitParameters(tail, result, `${current}${char}`, depth)\n      case '(':\n        return splitParameters(tail, result, `${current}${char}`, depth + 1)\n      case ')':\n        return splitParameters(tail, result, `${current}${char}`, depth - 1)\n      default:\n        return splitParameters(tail, result, `${current}${char}`, depth)\n    }\n  }\n\n  if (current === '') return result\n  if (depth !== 0) throw new InvalidParenthesisError({ current, depth })\n\n  result.push(current.trim())\n  return result\n}\n\nexport function isSolidityType(\n  type: string,\n): type is Exclude<AbiType, SolidityTuple | SolidityArray> {\n  return (\n    type === 'address' ||\n    type === 'bool' ||\n    type === 'function' ||\n    type === 'string' ||\n    bytesRegex.test(type) ||\n    integerRegex.test(type)\n  )\n}\n\nconst protectedKeywordsRegex =\n  /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/\n\n/** @internal */\nexport function isSolidityKeyword(name: string) {\n  return (\n    name === 'address' ||\n    name === 'bool' ||\n    name === 'function' ||\n    name === 'string' ||\n    name === 'tuple' ||\n    bytesRegex.test(name) ||\n    integerRegex.test(name) ||\n    protectedKeywordsRegex.test(name)\n  )\n}\n\n/** @internal */\nexport function isValidDataLocation(\n  type: string,\n  isArray: boolean,\n): type is Exclude<\n  AbiType,\n  SolidityString | Extract<SolidityBytes, 'bytes'> | SolidityArray\n> {\n  return isArray || type === 'bytes' || type === 'string' || type === 'tuple'\n}\n","export const GENESIS_HASH_MAINNET = \"5eykt4UsFv8P8NJdTREpY1vzqKqZKvdpKuc147dw2N9d\";\nexport const GENESIS_HASH_DEVNET = \"EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG\";\nexport const GENESIS_HASH_TESTNET = \"4uhcVJyU9pJkvQyS88uRDiswHXSCkY3zQawwpjk2NsNY\";\n\nexport const USDC_MAINNET_MINT_ADDRESS = \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\";\nexport const USDC_DEVNET_MINT_ADDRESS = \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\";\n","import type { Signature } from '../index.js'\nimport type { ChainSerializers } from '../types/chain.js'\nimport type { TransactionSerializable } from '../types/transaction.js'\nimport { concatHex } from '../utils/data/concat.js'\nimport { toHex } from '../utils/encoding/toHex.js'\nimport { toRlp } from '../utils/encoding/toRlp.js'\nimport { serializeTransaction as serializeTransaction_ } from '../utils/transaction/serializeTransaction.js'\nimport { gasPerPubdataDefault } from './constants/number.js'\nimport type {\n  ZksyncTransactionSerializable,\n  ZksyncTransactionSerializableEIP712,\n  ZksyncTransactionSerializedEIP712,\n} from './types/transaction.js'\nimport { assertEip712Transaction } from './utils/assertEip712Transaction.js'\nimport { isEIP712Transaction } from './utils/isEip712Transaction.js'\n\nexport function serializeTransaction(\n  transaction: ZksyncTransactionSerializable,\n  signature?: Signature | undefined,\n) {\n  if (isEIP712Transaction(transaction))\n    return serializeTransactionEIP712(\n      transaction as ZksyncTransactionSerializableEIP712,\n    )\n  return serializeTransaction_(\n    transaction as TransactionSerializable,\n    signature,\n  )\n}\n\nexport const serializers = {\n  transaction: serializeTransaction,\n} as const satisfies ChainSerializers\n\ntype SerializeTransactionEIP712ReturnType = ZksyncTransactionSerializedEIP712\n\nfunction serializeTransactionEIP712(\n  transaction: ZksyncTransactionSerializableEIP712,\n): SerializeTransactionEIP712ReturnType {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    from,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    customSignature,\n    factoryDeps,\n    paymaster,\n    paymasterInput,\n    gasPerPubdata,\n    data,\n  } = transaction\n\n  assertEip712Transaction(transaction)\n\n  const serializedTransaction = [\n    nonce ? toHex(nonce) : '0x',\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\n    maxFeePerGas ? toHex(maxFeePerGas) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n    toHex(chainId),\n    toHex(''),\n    toHex(''),\n    toHex(chainId),\n    from ?? '0x',\n    gasPerPubdata ? toHex(gasPerPubdata) : toHex(gasPerPubdataDefault),\n    factoryDeps ?? [],\n    customSignature ?? '0x', // EIP712 signature\n    paymaster && paymasterInput ? [paymaster, paymasterInput] : [],\n  ]\n\n  return concatHex([\n    '0x71',\n    toRlp(serializedTransaction),\n  ]) as SerializeTransactionEIP712ReturnType\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/sign/base-account/Signer.ts","import { isJWK } from './is_jwk.js';\nimport { decode } from '../util/base64url.js';\nimport { jwkToKey } from './jwk_to_key.js';\nimport { isCryptoKey, isKeyObject } from './is_key_like.js';\nlet cache;\nconst handleJWK = async (key, jwk, alg, freeze = false) => {\n    cache ||= new WeakMap();\n    let cached = cache.get(key);\n    if (cached?.[alg]) {\n        return cached[alg];\n    }\n    const cryptoKey = await jwkToKey({ ...jwk, alg });\n    if (freeze)\n        Object.freeze(key);\n    if (!cached) {\n        cache.set(key, { [alg]: cryptoKey });\n    }\n    else {\n        cached[alg] = cryptoKey;\n    }\n    return cryptoKey;\n};\nconst handleKeyObject = (keyObject, alg) => {\n    cache ||= new WeakMap();\n    let cached = cache.get(keyObject);\n    if (cached?.[alg]) {\n        return cached[alg];\n    }\n    const isPublic = keyObject.type === 'public';\n    const extractable = isPublic ? true : false;\n    let cryptoKey;\n    if (keyObject.asymmetricKeyType === 'x25519') {\n        switch (alg) {\n            case 'ECDH-ES':\n            case 'ECDH-ES+A128KW':\n            case 'ECDH-ES+A192KW':\n            case 'ECDH-ES+A256KW':\n                break;\n            default:\n                throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, isPublic ? [] : ['deriveBits']);\n    }\n    if (keyObject.asymmetricKeyType === 'ed25519') {\n        if (alg !== 'EdDSA' && alg !== 'Ed25519') {\n            throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [\n            isPublic ? 'verify' : 'sign',\n        ]);\n    }\n    switch (keyObject.asymmetricKeyType) {\n        case 'ml-dsa-44':\n        case 'ml-dsa-65':\n        case 'ml-dsa-87': {\n            if (alg !== keyObject.asymmetricKeyType.toUpperCase()) {\n                throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n            }\n            cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [\n                isPublic ? 'verify' : 'sign',\n            ]);\n        }\n    }\n    if (keyObject.asymmetricKeyType === 'rsa') {\n        let hash;\n        switch (alg) {\n            case 'RSA-OAEP':\n                hash = 'SHA-1';\n                break;\n            case 'RS256':\n            case 'PS256':\n            case 'RSA-OAEP-256':\n                hash = 'SHA-256';\n                break;\n            case 'RS384':\n            case 'PS384':\n            case 'RSA-OAEP-384':\n                hash = 'SHA-384';\n                break;\n            case 'RS512':\n            case 'PS512':\n            case 'RSA-OAEP-512':\n                hash = 'SHA-512';\n                break;\n            default:\n                throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        if (alg.startsWith('RSA-OAEP')) {\n            return keyObject.toCryptoKey({\n                name: 'RSA-OAEP',\n                hash,\n            }, extractable, isPublic ? ['encrypt'] : ['decrypt']);\n        }\n        cryptoKey = keyObject.toCryptoKey({\n            name: alg.startsWith('PS') ? 'RSA-PSS' : 'RSASSA-PKCS1-v1_5',\n            hash,\n        }, extractable, [isPublic ? 'verify' : 'sign']);\n    }\n    if (keyObject.asymmetricKeyType === 'ec') {\n        const nist = new Map([\n            ['prime256v1', 'P-256'],\n            ['secp384r1', 'P-384'],\n            ['secp521r1', 'P-521'],\n        ]);\n        const namedCurve = nist.get(keyObject.asymmetricKeyDetails?.namedCurve);\n        if (!namedCurve) {\n            throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n        }\n        if (alg === 'ES256' && namedCurve === 'P-256') {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDSA',\n                namedCurve,\n            }, extractable, [isPublic ? 'verify' : 'sign']);\n        }\n        if (alg === 'ES384' && namedCurve === 'P-384') {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDSA',\n                namedCurve,\n            }, extractable, [isPublic ? 'verify' : 'sign']);\n        }\n        if (alg === 'ES512' && namedCurve === 'P-521') {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDSA',\n                namedCurve,\n            }, extractable, [isPublic ? 'verify' : 'sign']);\n        }\n        if (alg.startsWith('ECDH-ES')) {\n            cryptoKey = keyObject.toCryptoKey({\n                name: 'ECDH',\n                namedCurve,\n            }, extractable, isPublic ? [] : ['deriveBits']);\n        }\n    }\n    if (!cryptoKey) {\n        throw new TypeError('given KeyObject instance cannot be used for this algorithm');\n    }\n    if (!cached) {\n        cache.set(keyObject, { [alg]: cryptoKey });\n    }\n    else {\n        cached[alg] = cryptoKey;\n    }\n    return cryptoKey;\n};\nexport async function normalizeKey(key, alg) {\n    if (key instanceof Uint8Array) {\n        return key;\n    }\n    if (isCryptoKey(key)) {\n        return key;\n    }\n    if (isKeyObject(key)) {\n        if (key.type === 'secret') {\n            return key.export();\n        }\n        if ('toCryptoKey' in key && typeof key.toCryptoKey === 'function') {\n            try {\n                return handleKeyObject(key, alg);\n            }\n            catch (err) {\n                if (err instanceof TypeError) {\n                    throw err;\n                }\n            }\n        }\n        let jwk = key.export({ format: 'jwk' });\n        return handleJWK(key, jwk, alg);\n    }\n    if (isJWK(key)) {\n        if (key.k) {\n            return decode(key.k);\n        }\n        return handleJWK(key, key, alg, true);\n    }\n    throw new Error('unreachable');\n}\n","import { invalidKeyInput } from './invalid_key_input.js';\nimport { encodeBase64, decodeBase64 } from '../lib/base64.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { isCryptoKey, isKeyObject } from './is_key_like.js';\nconst formatPEM = (b64, descriptor) => {\n    const newlined = (b64.match(/.{1,64}/g) || []).join('\\n');\n    return `-----BEGIN ${descriptor}-----\\n${newlined}\\n-----END ${descriptor}-----`;\n};\nconst genericExport = async (keyType, keyFormat, key) => {\n    if (isKeyObject(key)) {\n        if (key.type !== keyType) {\n            throw new TypeError(`key is not a ${keyType} key`);\n        }\n        return key.export({ format: 'pem', type: keyFormat });\n    }\n    if (!isCryptoKey(key)) {\n        throw new TypeError(invalidKeyInput(key, 'CryptoKey', 'KeyObject'));\n    }\n    if (!key.extractable) {\n        throw new TypeError('CryptoKey is not extractable');\n    }\n    if (key.type !== keyType) {\n        throw new TypeError(`key is not a ${keyType} key`);\n    }\n    return formatPEM(encodeBase64(new Uint8Array(await crypto.subtle.exportKey(keyFormat, key))), `${keyType.toUpperCase()} KEY`);\n};\nexport const toSPKI = (key) => genericExport('public', 'spki', key);\nexport const toPKCS8 = (key) => genericExport('private', 'pkcs8', key);\nconst bytesEqual = (a, b) => {\n    if (a.byteLength !== b.length)\n        return false;\n    for (let i = 0; i < a.byteLength; i++) {\n        if (a[i] !== b[i])\n            return false;\n    }\n    return true;\n};\nconst createASN1State = (data) => ({ data, pos: 0 });\nconst parseLength = (state) => {\n    const first = state.data[state.pos++];\n    if (first & 0x80) {\n        const lengthOfLen = first & 0x7f;\n        let length = 0;\n        for (let i = 0; i < lengthOfLen; i++) {\n            length = (length << 8) | state.data[state.pos++];\n        }\n        return length;\n    }\n    return first;\n};\nconst skipElement = (state, count = 1) => {\n    if (count <= 0)\n        return;\n    state.pos++;\n    const length = parseLength(state);\n    state.pos += length;\n    if (count > 1) {\n        skipElement(state, count - 1);\n    }\n};\nconst expectTag = (state, expectedTag, errorMessage) => {\n    if (state.data[state.pos++] !== expectedTag) {\n        throw new Error(errorMessage);\n    }\n};\nconst getSubarray = (state, length) => {\n    const result = state.data.subarray(state.pos, state.pos + length);\n    state.pos += length;\n    return result;\n};\nconst parseAlgorithmOID = (state) => {\n    expectTag(state, 0x06, 'Expected algorithm OID');\n    const oidLen = parseLength(state);\n    return getSubarray(state, oidLen);\n};\nfunction parsePKCS8Header(state) {\n    expectTag(state, 0x30, 'Invalid PKCS#8 structure');\n    parseLength(state);\n    expectTag(state, 0x02, 'Expected version field');\n    const verLen = parseLength(state);\n    state.pos += verLen;\n    expectTag(state, 0x30, 'Expected algorithm identifier');\n    const algIdLen = parseLength(state);\n    const algIdStart = state.pos;\n    return { algIdStart, algIdLength: algIdLen };\n}\nfunction parseSPKIHeader(state) {\n    expectTag(state, 0x30, 'Invalid SPKI structure');\n    parseLength(state);\n    expectTag(state, 0x30, 'Expected algorithm identifier');\n    const algIdLen = parseLength(state);\n    const algIdStart = state.pos;\n    return { algIdStart, algIdLength: algIdLen };\n}\nconst parseECAlgorithmIdentifier = (state) => {\n    const algOid = parseAlgorithmOID(state);\n    if (bytesEqual(algOid, [0x2b, 0x65, 0x6e])) {\n        return 'X25519';\n    }\n    if (!bytesEqual(algOid, [0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01])) {\n        throw new Error('Unsupported key algorithm');\n    }\n    expectTag(state, 0x06, 'Expected curve OID');\n    const curveOidLen = parseLength(state);\n    const curveOid = getSubarray(state, curveOidLen);\n    for (const { name, oid } of [\n        { name: 'P-256', oid: [0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07] },\n        { name: 'P-384', oid: [0x2b, 0x81, 0x04, 0x00, 0x22] },\n        { name: 'P-521', oid: [0x2b, 0x81, 0x04, 0x00, 0x23] },\n    ]) {\n        if (bytesEqual(curveOid, oid)) {\n            return name;\n        }\n    }\n    throw new Error('Unsupported named curve');\n};\nconst genericImport = async (keyFormat, keyData, alg, options) => {\n    let algorithm;\n    let keyUsages;\n    const isPublic = keyFormat === 'spki';\n    const getSigUsages = () => (isPublic ? ['verify'] : ['sign']);\n    const getEncUsages = () => isPublic ? ['encrypt', 'wrapKey'] : ['decrypt', 'unwrapKey'];\n    switch (alg) {\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            algorithm = { name: 'RSA-PSS', hash: `SHA-${alg.slice(-3)}` };\n            keyUsages = getSigUsages();\n            break;\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${alg.slice(-3)}` };\n            keyUsages = getSigUsages();\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            algorithm = {\n                name: 'RSA-OAEP',\n                hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,\n            };\n            keyUsages = getEncUsages();\n            break;\n        case 'ES256':\n        case 'ES384':\n        case 'ES512': {\n            const curveMap = { ES256: 'P-256', ES384: 'P-384', ES512: 'P-521' };\n            algorithm = { name: 'ECDSA', namedCurve: curveMap[alg] };\n            keyUsages = getSigUsages();\n            break;\n        }\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            try {\n                const namedCurve = options.getNamedCurve(keyData);\n                algorithm = namedCurve === 'X25519' ? { name: 'X25519' } : { name: 'ECDH', namedCurve };\n            }\n            catch (cause) {\n                throw new JOSENotSupported('Invalid or unsupported key format');\n            }\n            keyUsages = isPublic ? [] : ['deriveBits'];\n            break;\n        }\n        case 'Ed25519':\n        case 'EdDSA':\n            algorithm = { name: 'Ed25519' };\n            keyUsages = getSigUsages();\n            break;\n        case 'ML-DSA-44':\n        case 'ML-DSA-65':\n        case 'ML-DSA-87':\n            algorithm = { name: alg };\n            keyUsages = getSigUsages();\n            break;\n        default:\n            throw new JOSENotSupported('Invalid or unsupported \"alg\" (Algorithm) value');\n    }\n    return crypto.subtle.importKey(keyFormat, keyData, algorithm, options?.extractable ?? (isPublic ? true : false), keyUsages);\n};\nconst processPEMData = (pem, pattern) => {\n    return decodeBase64(pem.replace(pattern, ''));\n};\nexport const fromPKCS8 = (pem, alg, options) => {\n    const keyData = processPEMData(pem, /(?:-----(?:BEGIN|END) PRIVATE KEY-----|\\s)/g);\n    let opts = options;\n    if (alg?.startsWith?.('ECDH-ES')) {\n        opts ||= {};\n        opts.getNamedCurve = (keyData) => {\n            const state = createASN1State(keyData);\n            parsePKCS8Header(state);\n            return parseECAlgorithmIdentifier(state);\n        };\n    }\n    return genericImport('pkcs8', keyData, alg, opts);\n};\nexport const fromSPKI = (pem, alg, options) => {\n    const keyData = processPEMData(pem, /(?:-----(?:BEGIN|END) PUBLIC KEY-----|\\s)/g);\n    let opts = options;\n    if (alg?.startsWith?.('ECDH-ES')) {\n        opts ||= {};\n        opts.getNamedCurve = (keyData) => {\n            const state = createASN1State(keyData);\n            parseSPKIHeader(state);\n            return parseECAlgorithmIdentifier(state);\n        };\n    }\n    return genericImport('spki', keyData, alg, opts);\n};\nfunction spkiFromX509(buf) {\n    const state = createASN1State(buf);\n    expectTag(state, 0x30, 'Invalid certificate structure');\n    parseLength(state);\n    expectTag(state, 0x30, 'Invalid tbsCertificate structure');\n    parseLength(state);\n    if (buf[state.pos] === 0xa0) {\n        skipElement(state, 6);\n    }\n    else {\n        skipElement(state, 5);\n    }\n    const spkiStart = state.pos;\n    expectTag(state, 0x30, 'Invalid SPKI structure');\n    const spkiContentLen = parseLength(state);\n    return buf.subarray(spkiStart, spkiStart + spkiContentLen + (state.pos - spkiStart));\n}\nfunction extractX509SPKI(x509) {\n    const derBytes = processPEMData(x509, /(?:-----(?:BEGIN|END) CERTIFICATE-----|\\s)/g);\n    return spkiFromX509(derBytes);\n}\nexport const fromX509 = (pem, alg, options) => {\n    let spki;\n    try {\n        spki = extractX509SPKI(pem);\n    }\n    catch (cause) {\n        throw new TypeError('Failed to parse the X.509 certificate', { cause });\n    }\n    return fromSPKI(formatPEM(encodeBase64(spki), 'PUBLIC KEY'), alg, options);\n};\n","import utils from './../utils.js';\nimport settle from './../core/settle.js';\nimport buildFullPath from '../core/buildFullPath.js';\nimport buildURL from './../helpers/buildURL.js';\nimport proxyFromEnv from 'proxy-from-env';\nimport http from 'http';\nimport https from 'https';\nimport http2 from 'http2';\nimport util from 'util';\nimport followRedirects from 'follow-redirects';\nimport zlib from 'zlib';\nimport {VERSION} from '../env/data.js';\nimport transitionalDefaults from '../defaults/transitional.js';\nimport AxiosError from '../core/AxiosError.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport platform from '../platform/index.js';\nimport fromDataURI from '../helpers/fromDataURI.js';\nimport stream from 'stream';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport AxiosTransformStream from '../helpers/AxiosTransformStream.js';\nimport {EventEmitter} from 'events';\nimport formDataToStream from \"../helpers/formDataToStream.js\";\nimport readBlob from \"../helpers/readBlob.js\";\nimport ZlibHeaderTransformStream from '../helpers/ZlibHeaderTransformStream.js';\nimport callbackify from \"../helpers/callbackify.js\";\nimport {progressEventReducer, progressEventDecorator, asyncDecorator} from \"../helpers/progressEventReducer.js\";\nimport estimateDataURLDecodedBytes from '../helpers/estimateDataURLDecodedBytes.js';\n\nconst zlibOptions = {\n  flush: zlib.constants.Z_SYNC_FLUSH,\n  finishFlush: zlib.constants.Z_SYNC_FLUSH\n};\n\nconst brotliOptions = {\n  flush: zlib.constants.BROTLI_OPERATION_FLUSH,\n  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH\n}\n\nconst isBrotliSupported = utils.isFunction(zlib.createBrotliDecompress);\n\nconst {http: httpFollow, https: httpsFollow} = followRedirects;\n\nconst isHttps = /https:?/;\n\nconst supportedProtocols = platform.protocols.map(protocol => {\n  return protocol + ':';\n});\n\n\nconst flushOnFinish = (stream, [throttled, flush]) => {\n  stream\n    .on('end', flush)\n    .on('error', flush);\n\n  return throttled;\n}\n\nclass Http2Sessions {\n  constructor() {\n    this.sessions = Object.create(null);\n  }\n\n  getSession(authority, options) {\n    options = Object.assign({\n      sessionTimeout: 1000\n    }, options);\n\n    let authoritySessions = this.sessions[authority];\n\n    if (authoritySessions) {\n      let len = authoritySessions.length;\n\n      for (let i = 0; i < len; i++) {\n        const [sessionHandle, sessionOptions] = authoritySessions[i];\n        if (!sessionHandle.destroyed && !sessionHandle.closed && util.isDeepStrictEqual(sessionOptions, options)) {\n          return sessionHandle;\n        }\n      }\n    }\n\n    const session = http2.connect(authority, options);\n\n    let removed;\n\n    const removeSession = () => {\n      if (removed) {\n        return;\n      }\n\n      removed = true;\n\n      let entries = authoritySessions, len = entries.length, i = len;\n\n      while (i--) {\n        if (entries[i][0] === session) {\n          if (len === 1) {\n            delete this.sessions[authority];\n          } else {\n            entries.splice(i, 1);\n          }\n          return;\n        }\n      }\n    };\n\n    const originalRequestFn = session.request;\n\n    const {sessionTimeout} = options;\n\n    if(sessionTimeout != null) {\n\n      let timer;\n      let streamsCount = 0;\n\n      session.request = function () {\n        const stream = originalRequestFn.apply(this, arguments);\n\n        streamsCount++;\n\n        if (timer) {\n          clearTimeout(timer);\n          timer = null;\n        }\n\n        stream.once('close', () => {\n          if (!--streamsCount) {\n            timer = setTimeout(() => {\n              timer = null;\n              removeSession();\n            }, sessionTimeout);\n          }\n        });\n\n        return stream;\n      }\n    }\n\n    session.once('close', removeSession);\n\n    let entry = [\n        session,\n        options\n      ];\n\n    authoritySessions ? authoritySessions.push(entry) : authoritySessions =  this.sessions[authority] = [entry];\n\n    return session;\n  }\n}\n\nconst http2Sessions = new Http2Sessions();\n\n\n/**\n * If the proxy or config beforeRedirects functions are defined, call them with the options\n * object.\n *\n * @param {Object<string, any>} options - The options object that was passed to the request.\n *\n * @returns {Object<string, any>}\n */\nfunction dispatchBeforeRedirect(options, responseDetails) {\n  if (options.beforeRedirects.proxy) {\n    options.beforeRedirects.proxy(options);\n  }\n  if (options.beforeRedirects.config) {\n    options.beforeRedirects.config(options, responseDetails);\n  }\n}\n\n/**\n * If the proxy or config afterRedirects functions are defined, call them with the options\n *\n * @param {http.ClientRequestArgs} options\n * @param {AxiosProxyConfig} configProxy configuration from Axios options object\n * @param {string} location\n *\n * @returns {http.ClientRequestArgs}\n */\nfunction setProxy(options, configProxy, location) {\n  let proxy = configProxy;\n  if (!proxy && proxy !== false) {\n    const proxyUrl = proxyFromEnv.getProxyForUrl(location);\n    if (proxyUrl) {\n      proxy = new URL(proxyUrl);\n    }\n  }\n  if (proxy) {\n    // Basic proxy authorization\n    if (proxy.username) {\n      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');\n    }\n\n    if (proxy.auth) {\n      // Support proxy auth object form\n      if (proxy.auth.username || proxy.auth.password) {\n        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');\n      }\n      const base64 = Buffer\n        .from(proxy.auth, 'utf8')\n        .toString('base64');\n      options.headers['Proxy-Authorization'] = 'Basic ' + base64;\n    }\n\n    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');\n    const proxyHost = proxy.hostname || proxy.host;\n    options.hostname = proxyHost;\n    // Replace 'host' since options is not a URL object\n    options.host = proxyHost;\n    options.port = proxy.port;\n    options.path = location;\n    if (proxy.protocol) {\n      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : `${proxy.protocol}:`;\n    }\n  }\n\n  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {\n    // Configure proxy for redirected request, passing the original config proxy to apply\n    // the exact same logic as if the redirected request was performed by axios directly.\n    setProxy(redirectOptions, configProxy, redirectOptions.href);\n  };\n}\n\nconst isHttpAdapterSupported = typeof process !== 'undefined' && utils.kindOf(process) === 'process';\n\n// temporary hotfix\n\nconst wrapAsync = (asyncExecutor) => {\n  return new Promise((resolve, reject) => {\n    let onDone;\n    let isDone;\n\n    const done = (value, isRejected) => {\n      if (isDone) return;\n      isDone = true;\n      onDone && onDone(value, isRejected);\n    }\n\n    const _resolve = (value) => {\n      done(value);\n      resolve(value);\n    };\n\n    const _reject = (reason) => {\n      done(reason, true);\n      reject(reason);\n    }\n\n    asyncExecutor(_resolve, _reject, (onDoneHandler) => (onDone = onDoneHandler)).catch(_reject);\n  })\n};\n\nconst resolveFamily = ({address, family}) => {\n  if (!utils.isString(address)) {\n    throw TypeError('address must be a string');\n  }\n  return ({\n    address,\n    family: family || (address.indexOf('.') < 0 ? 6 : 4)\n  });\n}\n\nconst buildAddressEntry = (address, family) => resolveFamily(utils.isObject(address) ? address : {address, family});\n\nconst http2Transport = {\n  request(options, cb) {\n      const authority = options.protocol + '//' + options.hostname + ':' + (options.port || 80);\n\n      const {http2Options, headers} = options;\n\n      const session = http2Sessions.getSession(authority, http2Options);\n\n      const {\n        HTTP2_HEADER_SCHEME,\n        HTTP2_HEADER_METHOD,\n        HTTP2_HEADER_PATH,\n        HTTP2_HEADER_STATUS\n      } = http2.constants;\n\n      const http2Headers = {\n        [HTTP2_HEADER_SCHEME]: options.protocol.replace(':', ''),\n        [HTTP2_HEADER_METHOD]: options.method,\n        [HTTP2_HEADER_PATH]: options.path,\n      }\n\n      utils.forEach(headers, (header, name) => {\n        name.charAt(0) !== ':' && (http2Headers[name] = header);\n      });\n\n      const req = session.request(http2Headers);\n\n      req.once('response', (responseHeaders) => {\n        const response = req; //duplex\n\n        responseHeaders = Object.assign({}, responseHeaders);\n\n        const status = responseHeaders[HTTP2_HEADER_STATUS];\n\n        delete responseHeaders[HTTP2_HEADER_STATUS];\n\n        response.headers = responseHeaders;\n\n        response.statusCode = +status;\n\n        cb(response);\n      })\n\n      return req;\n  }\n}\n\n/*eslint consistent-return:0*/\nexport default isHttpAdapterSupported && function httpAdapter(config) {\n  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {\n    let {data, lookup, family, httpVersion = 1, http2Options} = config;\n    const {responseType, responseEncoding} = config;\n    const method = config.method.toUpperCase();\n    let isDone;\n    let rejected = false;\n    let req;\n\n    httpVersion = +httpVersion;\n\n    if (Number.isNaN(httpVersion)) {\n      throw TypeError(`Invalid protocol version: '${config.httpVersion}' is not a number`);\n    }\n\n    if (httpVersion !== 1 && httpVersion !== 2) {\n      throw TypeError(`Unsupported protocol version '${httpVersion}'`);\n    }\n\n    const isHttp2 = httpVersion === 2;\n\n    if (lookup) {\n      const _lookup = callbackify(lookup, (value) => utils.isArray(value) ? value : [value]);\n      // hotfix to support opt.all option which is required for node 20.x\n      lookup = (hostname, opt, cb) => {\n        _lookup(hostname, opt, (err, arg0, arg1) => {\n          if (err) {\n            return cb(err);\n          }\n\n          const addresses = utils.isArray(arg0) ? arg0.map(addr => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];\n\n          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);\n        });\n      }\n    }\n\n    const abortEmitter = new EventEmitter();\n\n    function abort(reason) {\n      try {\n        abortEmitter.emit('abort', !reason || reason.type ? new CanceledError(null, config, req) : reason);\n      } catch(err) {\n        console.warn('emit error', err);\n      }\n    }\n\n    abortEmitter.once('abort', reject);\n\n    const onFinished = () => {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(abort);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', abort);\n      }\n\n      abortEmitter.removeAllListeners();\n    }\n\n    if (config.cancelToken || config.signal) {\n      config.cancelToken && config.cancelToken.subscribe(abort);\n      if (config.signal) {\n        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);\n      }\n    }\n\n    onDone((response, isRejected) => {\n      isDone = true;\n\n      if (isRejected) {\n        rejected = true;\n        onFinished();\n        return;\n      }\n\n      const {data} = response;\n\n      if (data instanceof stream.Readable || data instanceof stream.Duplex) {\n        const offListeners = stream.finished(data, () => {\n          offListeners();\n          onFinished();\n        });\n      } else {\n        onFinished();\n      }\n    });\n\n\n\n\n\n    // Parse url\n    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);\n    const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : undefined);\n    const protocol = parsed.protocol || supportedProtocols[0];\n\n    if (protocol === 'data:') {\n      // Apply the same semantics as HTTP: only enforce if a finite, non-negative cap is set.\n      if (config.maxContentLength > -1) {\n        // Use the exact string passed to fromDataURI (config.url); fall back to fullPath if needed.\n        const dataUrl = String(config.url || fullPath || '');\n        const estimated = estimateDataURLDecodedBytes(dataUrl);\n\n        if (estimated > config.maxContentLength) {\n          return reject(new AxiosError(\n            'maxContentLength size of ' + config.maxContentLength + ' exceeded',\n            AxiosError.ERR_BAD_RESPONSE,\n            config\n          ));\n        }\n      }\n\n      let convertedData;\n\n      if (method !== 'GET') {\n        return settle(resolve, reject, {\n          status: 405,\n          statusText: 'method not allowed',\n          headers: {},\n          config\n        });\n      }\n\n      try {\n        convertedData = fromDataURI(config.url, responseType === 'blob', {\n          Blob: config.env && config.env.Blob\n        });\n      } catch (err) {\n        throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);\n      }\n\n      if (responseType === 'text') {\n        convertedData = convertedData.toString(responseEncoding);\n\n        if (!responseEncoding || responseEncoding === 'utf8') {\n          convertedData = utils.stripBOM(convertedData);\n        }\n      } else if (responseType === 'stream') {\n        convertedData = stream.Readable.from(convertedData);\n      }\n\n      return settle(resolve, reject, {\n        data: convertedData,\n        status: 200,\n        statusText: 'OK',\n        headers: new AxiosHeaders(),\n        config\n      });\n    }\n\n    if (supportedProtocols.indexOf(protocol) === -1) {\n      return reject(new AxiosError(\n        'Unsupported protocol ' + protocol,\n        AxiosError.ERR_BAD_REQUEST,\n        config\n      ));\n    }\n\n    const headers = AxiosHeaders.from(config.headers).normalize();\n\n    // Set User-Agent (required by some servers)\n    // See https://github.com/axios/axios/issues/69\n    // User-Agent is specified; handle case where no UA header is desired\n    // Only set header if it hasn't been set in config\n    headers.set('User-Agent', 'axios/' + VERSION, false);\n\n    const {onUploadProgress, onDownloadProgress} = config;\n    const maxRate = config.maxRate;\n    let maxUploadRate = undefined;\n    let maxDownloadRate = undefined;\n\n    // support for spec compliant FormData objects\n    if (utils.isSpecCompliantForm(data)) {\n      const userBoundary = headers.getContentType(/boundary=([-_\\w\\d]{10,70})/i);\n\n      data = formDataToStream(data, (formHeaders) => {\n        headers.set(formHeaders);\n      }, {\n        tag: `axios-${VERSION}-boundary`,\n        boundary: userBoundary && userBoundary[1] || undefined\n      });\n      // support for https://www.npmjs.com/package/form-data api\n    } else if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {\n      headers.set(data.getHeaders());\n\n      if (!headers.hasContentLength()) {\n        try {\n          const knownLength = await util.promisify(data.getLength).call(data);\n          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);\n          /*eslint no-empty:0*/\n        } catch (e) {\n        }\n      }\n    } else if (utils.isBlob(data) || utils.isFile(data)) {\n      data.size && headers.setContentType(data.type || 'application/octet-stream');\n      headers.setContentLength(data.size || 0);\n      data = stream.Readable.from(readBlob(data));\n    } else if (data && !utils.isStream(data)) {\n      if (Buffer.isBuffer(data)) {\n        // Nothing to do...\n      } else if (utils.isArrayBuffer(data)) {\n        data = Buffer.from(new Uint8Array(data));\n      } else if (utils.isString(data)) {\n        data = Buffer.from(data, 'utf-8');\n      } else {\n        return reject(new AxiosError(\n          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',\n          AxiosError.ERR_BAD_REQUEST,\n          config\n        ));\n      }\n\n      // Add Content-Length header if data exists\n      headers.setContentLength(data.length, false);\n\n      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {\n        return reject(new AxiosError(\n          'Request body larger than maxBodyLength limit',\n          AxiosError.ERR_BAD_REQUEST,\n          config\n        ));\n      }\n    }\n\n    const contentLength = utils.toFiniteNumber(headers.getContentLength());\n\n    if (utils.isArray(maxRate)) {\n      maxUploadRate = maxRate[0];\n      maxDownloadRate = maxRate[1];\n    } else {\n      maxUploadRate = maxDownloadRate = maxRate;\n    }\n\n    if (data && (onUploadProgress || maxUploadRate)) {\n      if (!utils.isStream(data)) {\n        data = stream.Readable.from(data, {objectMode: false});\n      }\n\n      data = stream.pipeline([data, new AxiosTransformStream({\n        maxRate: utils.toFiniteNumber(maxUploadRate)\n      })], utils.noop);\n\n      onUploadProgress && data.on('progress', flushOnFinish(\n        data,\n        progressEventDecorator(\n          contentLength,\n          progressEventReducer(asyncDecorator(onUploadProgress), false, 3)\n        )\n      ));\n    }\n\n    // HTTP basic authentication\n    let auth = undefined;\n    if (config.auth) {\n      const username = config.auth.username || '';\n      const password = config.auth.password || '';\n      auth = username + ':' + password;\n    }\n\n    if (!auth && parsed.username) {\n      const urlUsername = parsed.username;\n      const urlPassword = parsed.password;\n      auth = urlUsername + ':' + urlPassword;\n    }\n\n    auth && headers.delete('authorization');\n\n    let path;\n\n    try {\n      path = buildURL(\n        parsed.pathname + parsed.search,\n        config.params,\n        config.paramsSerializer\n      ).replace(/^\\?/, '');\n    } catch (err) {\n      const customErr = new Error(err.message);\n      customErr.config = config;\n      customErr.url = config.url;\n      customErr.exists = true;\n      return reject(customErr);\n    }\n\n    headers.set(\n      'Accept-Encoding',\n      'gzip, compress, deflate' + (isBrotliSupported ? ', br' : ''), false\n      );\n\n    const options = {\n      path,\n      method: method,\n      headers: headers.toJSON(),\n      agents: { http: config.httpAgent, https: config.httpsAgent },\n      auth,\n      protocol,\n      family,\n      beforeRedirect: dispatchBeforeRedirect,\n      beforeRedirects: {},\n      http2Options\n    };\n\n    // cacheable-lookup integration hotfix\n    !utils.isUndefined(lookup) && (options.lookup = lookup);\n\n    if (config.socketPath) {\n      options.socketPath = config.socketPath;\n    } else {\n      options.hostname = parsed.hostname.startsWith(\"[\") ? parsed.hostname.slice(1, -1) : parsed.hostname;\n      options.port = parsed.port;\n      setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);\n    }\n\n    let transport;\n    const isHttpsRequest = isHttps.test(options.protocol);\n    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\n\n    if (isHttp2) {\n       transport = http2Transport;\n    } else {\n      if (config.transport) {\n        transport = config.transport;\n      } else if (config.maxRedirects === 0) {\n        transport = isHttpsRequest ? https : http;\n      } else {\n        if (config.maxRedirects) {\n          options.maxRedirects = config.maxRedirects;\n        }\n        if (config.beforeRedirect) {\n          options.beforeRedirects.config = config.beforeRedirect;\n        }\n        transport = isHttpsRequest ? httpsFollow : httpFollow;\n      }\n    }\n\n    if (config.maxBodyLength > -1) {\n      options.maxBodyLength = config.maxBodyLength;\n    } else {\n      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited\n      options.maxBodyLength = Infinity;\n    }\n\n    if (config.insecureHTTPParser) {\n      options.insecureHTTPParser = config.insecureHTTPParser;\n    }\n\n    // Create the request\n    req = transport.request(options, function handleResponse(res) {\n      if (req.destroyed) return;\n\n      const streams = [res];\n\n      const responseLength = utils.toFiniteNumber(res.headers['content-length']);\n\n      if (onDownloadProgress || maxDownloadRate) {\n        const transformStream = new AxiosTransformStream({\n          maxRate: utils.toFiniteNumber(maxDownloadRate)\n        });\n\n        onDownloadProgress && transformStream.on('progress', flushOnFinish(\n          transformStream,\n          progressEventDecorator(\n            responseLength,\n            progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)\n          )\n        ));\n\n        streams.push(transformStream);\n      }\n\n      // decompress the response body transparently if required\n      let responseStream = res;\n\n      // return the last request in case of redirects\n      const lastRequest = res.req || req;\n\n      // if decompress disabled we should not decompress\n      if (config.decompress !== false && res.headers['content-encoding']) {\n        // if no content, but headers still say that it is encoded,\n        // remove the header not confuse downstream operations\n        if (method === 'HEAD' || res.statusCode === 204) {\n          delete res.headers['content-encoding'];\n        }\n\n        switch ((res.headers['content-encoding'] || '').toLowerCase()) {\n        /*eslint default-case:0*/\n        case 'gzip':\n        case 'x-gzip':\n        case 'compress':\n        case 'x-compress':\n          // add the unzipper to the body stream processing pipeline\n          streams.push(zlib.createUnzip(zlibOptions));\n\n          // remove the content-encoding in order to not confuse downstream operations\n          delete res.headers['content-encoding'];\n          break;\n        case 'deflate':\n          streams.push(new ZlibHeaderTransformStream());\n\n          // add the unzipper to the body stream processing pipeline\n          streams.push(zlib.createUnzip(zlibOptions));\n\n          // remove the content-encoding in order to not confuse downstream operations\n          delete res.headers['content-encoding'];\n          break;\n        case 'br':\n          if (isBrotliSupported) {\n            streams.push(zlib.createBrotliDecompress(brotliOptions));\n            delete res.headers['content-encoding'];\n          }\n        }\n      }\n\n      responseStream = streams.length > 1 ? stream.pipeline(streams, utils.noop) : streams[0];\n\n\n\n      const response = {\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: new AxiosHeaders(res.headers),\n        config,\n        request: lastRequest\n      };\n\n      if (responseType === 'stream') {\n        response.data = responseStream;\n        settle(resolve, reject, response);\n      } else {\n        const responseBuffer = [];\n        let totalResponseBytes = 0;\n\n        responseStream.on('data', function handleStreamData(chunk) {\n          responseBuffer.push(chunk);\n          totalResponseBytes += chunk.length;\n\n          // make sure the content length is not over the maxContentLength if specified\n          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {\n            // stream.destroy() emit aborted event before calling reject() on Node.js v16\n            rejected = true;\n            responseStream.destroy();\n            abort(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded',\n              AxiosError.ERR_BAD_RESPONSE, config, lastRequest));\n          }\n        });\n\n        responseStream.on('aborted', function handlerStreamAborted() {\n          if (rejected) {\n            return;\n          }\n\n          const err = new AxiosError(\n            'stream has been aborted',\n            AxiosError.ERR_BAD_RESPONSE,\n            config,\n            lastRequest\n          );\n          responseStream.destroy(err);\n          reject(err);\n        });\n\n        responseStream.on('error', function handleStreamError(err) {\n          if (req.destroyed) return;\n          reject(AxiosError.from(err, null, config, lastRequest));\n        });\n\n        responseStream.on('end', function handleStreamEnd() {\n          try {\n            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);\n            if (responseType !== 'arraybuffer') {\n              responseData = responseData.toString(responseEncoding);\n              if (!responseEncoding || responseEncoding === 'utf8') {\n                responseData = utils.stripBOM(responseData);\n              }\n            }\n            response.data = responseData;\n          } catch (err) {\n            return reject(AxiosError.from(err, null, config, response.request, response));\n          }\n          settle(resolve, reject, response);\n        });\n      }\n\n      abortEmitter.once('abort', err => {\n        if (!responseStream.destroyed) {\n          responseStream.emit('error', err);\n          responseStream.destroy();\n        }\n      });\n    });\n\n    abortEmitter.once('abort', err => {\n      if (req.close) {\n        req.close();\n      } else {\n        req.destroy(err);\n      }\n    });\n\n    // Handle errors\n    req.on('error', function handleRequestError(err) {\n      // @todo remove\n      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;\n      reject(AxiosError.from(err, null, config, req));\n    });\n\n    // set tcp keep alive to prevent drop connection by peer\n    req.on('socket', function handleRequestSocket(socket) {\n      // default interval of sending ack packet is 1 minute\n      socket.setKeepAlive(true, 1000 * 60);\n    });\n\n    // Handle request timeout\n    if (config.timeout) {\n      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.\n      const timeout = parseInt(config.timeout, 10);\n\n      if (Number.isNaN(timeout)) {\n        abort(new AxiosError(\n          'error trying to parse `config.timeout` to int',\n          AxiosError.ERR_BAD_OPTION_VALUE,\n          config,\n          req\n        ));\n\n        return;\n      }\n\n      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.\n      // And timer callback will be fired, and abort() will be invoked before connection, then get \"socket hang up\" and code ECONNRESET.\n      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.\n      // And then these socket which be hang up will devouring CPU little by little.\n      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.\n      req.setTimeout(timeout, function handleRequestTimeout() {\n        if (isDone) return;\n        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n        const transitional = config.transitional || transitionalDefaults;\n        if (config.timeoutErrorMessage) {\n          timeoutErrorMessage = config.timeoutErrorMessage;\n        }\n        abort(new AxiosError(\n          timeoutErrorMessage,\n          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n          config,\n          req\n        ));\n      });\n    } else {\n      // explicitly reset the socket timeout value for a possible `keep-alive` request\n      req.setTimeout(0);\n    }\n\n\n    // Send the request\n    if (utils.isStream(data)) {\n      let ended = false;\n      let errored = false;\n\n      data.on('end', () => {\n        ended = true;\n      });\n\n      data.once('error', err => {\n        errored = true;\n        req.destroy(err);\n      });\n\n      data.on('close', () => {\n        if (!ended && !errored) {\n          abort(new CanceledError('Request stream has been aborted', config, req));\n        }\n      });\n\n      data.pipe(req);\n    } else {\n      data && req.write(data);\n      req.end();\n    }\n  });\n}\n\nexport const __setProxy = setProxy;\n","import CanceledError from \"../cancel/CanceledError.js\";\nimport AxiosError from \"../core/AxiosError.js\";\nimport utils from '../utils.js';\n\nconst composeSignals = (signals, timeout) => {\n  const {length} = (signals = signals ? signals.filter(Boolean) : []);\n\n  if (timeout || length) {\n    let controller = new AbortController();\n\n    let aborted;\n\n    const onabort = function (reason) {\n      if (!aborted) {\n        aborted = true;\n        unsubscribe();\n        const err = reason instanceof Error ? reason : this.reason;\n        controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));\n      }\n    }\n\n    let timer = timeout && setTimeout(() => {\n      timer = null;\n      onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT))\n    }, timeout)\n\n    const unsubscribe = () => {\n      if (signals) {\n        timer && clearTimeout(timer);\n        timer = null;\n        signals.forEach(signal => {\n          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);\n        });\n        signals = null;\n      }\n    }\n\n    signals.forEach((signal) => signal.addEventListener('abort', onabort));\n\n    const {signal} = controller;\n\n    signal.unsubscribe = () => utils.asap(unsubscribe);\n\n    return signal;\n  }\n}\n\nexport default composeSignals;\n","import speedometer from \"./speedometer.js\";\nimport throttle from \"./throttle.js\";\nimport utils from \"../utils.js\";\n\nexport const progressEventReducer = (listener, isDownloadStream, freq = 3) => {\n  let bytesNotified = 0;\n  const _speedometer = speedometer(50, 250);\n\n  return throttle(e => {\n    const loaded = e.loaded;\n    const total = e.lengthComputable ? e.total : undefined;\n    const progressBytes = loaded - bytesNotified;\n    const rate = _speedometer(progressBytes);\n    const inRange = loaded <= total;\n\n    bytesNotified = loaded;\n\n    const data = {\n      loaded,\n      total,\n      progress: total ? (loaded / total) : undefined,\n      bytes: progressBytes,\n      rate: rate ? rate : undefined,\n      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,\n      event: e,\n      lengthComputable: total != null,\n      [isDownloadStream ? 'download' : 'upload']: true\n    };\n\n    listener(data);\n  }, freq);\n}\n\nexport const progressEventDecorator = (total, throttled) => {\n  const lengthComputable = total != null;\n\n  return [(loaded) => throttled[0]({\n    lengthComputable,\n    total,\n    loaded\n  }), throttled[1]];\n}\n\nexport const asyncDecorator = (fn) => (...args) => utils.asap(() => fn(...args));\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const hychainTestnet = /*#__PURE__*/ defineChain({\n  id: 29112,\n  name: 'HYCHAIN Testnet',\n  nativeCurrency: { name: 'HYTOPIA', symbol: 'TOPIA', decimals: 18 },\n  rpcUrls: {\n    default: { http: ['https://rpc.hychain.com/http'] },\n  },\n  blockExplorers: {\n    default: {\n      name: 'HYCHAIN Explorer',\n      url: 'https://testnet-rpc.hychain.com/http',\n    },\n  },\n  testnet: true,\n})\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/sign/base-account/utils/handleInsufficientBalance.ts","import { encodeFunctionData, erc20Abi } from \"viem\";\n\nimport { getErc20Address } from \"./utils.js\";\nimport { sendUserOperation } from \"../sendUserOperation.js\";\n\nimport type { TransferExecutionStrategy } from \"./types.js\";\nimport type { EvmSmartAccount } from \"../../../accounts/evm/types.js\";\nimport type { EvmUserOperationNetwork } from \"../../../openapi-client/index.js\";\n\nexport const smartAccountTransferStrategy: TransferExecutionStrategy<EvmSmartAccount> = {\n  executeTransfer: async ({ apiClient, from, to, value, token, network, paymasterUrl }) => {\n    const smartAccountNetwork = network as EvmUserOperationNetwork;\n\n    if (token === \"eth\") {\n      const result = await sendUserOperation(apiClient, {\n        smartAccount: from,\n        paymasterUrl,\n        network: smartAccountNetwork,\n        calls: [\n          {\n            to,\n            value,\n            data: \"0x\",\n          },\n        ],\n      });\n      return result;\n    } else {\n      const erc20Address = getErc20Address(token, network);\n\n      const result = await sendUserOperation(apiClient, {\n        smartAccount: from,\n        paymasterUrl,\n        network: smartAccountNetwork,\n        calls: [\n          {\n            to: erc20Address,\n            data: encodeFunctionData({\n              abi: erc20Abi,\n              functionName: \"transfer\",\n              args: [to, value],\n            }),\n          },\n        ],\n      });\n\n      return result;\n    }\n  },\n};\n","import { SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED, SolanaError } from '@solana/errors';\n\n/**\n * Throws an exception unless {@link Crypto#getRandomValues | `crypto.getRandomValues()`} is\n * available in the current JavaScript environment.\n */\nexport function assertPRNGIsAvailable() {\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.getRandomValues !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED);\n    }\n}\n","import { BaseError } from '../../errors/base.js'\nimport { prettyPrint } from '../../errors/transaction.js'\nimport type { Hash } from '../../types/misc.js'\nimport { formatGwei } from '../../utils/index.js'\nimport type { UserOperation } from '../types/userOperation.js'\n\nexport type UserOperationExecutionErrorType = UserOperationExecutionError & {\n  name: 'UserOperationExecutionError'\n}\nexport class UserOperationExecutionError extends BaseError {\n  override cause: BaseError\n\n  constructor(\n    cause: BaseError,\n    {\n      callData,\n      callGasLimit,\n      docsPath,\n      factory,\n      factoryData,\n      initCode,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      paymaster,\n      paymasterAndData,\n      paymasterData,\n      paymasterPostOpGasLimit,\n      paymasterVerificationGasLimit,\n      preVerificationGas,\n      sender,\n      signature,\n      verificationGasLimit,\n    }: UserOperation & {\n      docsPath?: string | undefined\n    },\n  ) {\n    const prettyArgs = prettyPrint({\n      callData,\n      callGasLimit,\n      factory,\n      factoryData,\n      initCode,\n      maxFeePerGas:\n        typeof maxFeePerGas !== 'undefined' &&\n        `${formatGwei(maxFeePerGas)} gwei`,\n      maxPriorityFeePerGas:\n        typeof maxPriorityFeePerGas !== 'undefined' &&\n        `${formatGwei(maxPriorityFeePerGas)} gwei`,\n      nonce,\n      paymaster,\n      paymasterAndData,\n      paymasterData,\n      paymasterPostOpGasLimit,\n      paymasterVerificationGasLimit,\n      preVerificationGas,\n      sender,\n      signature,\n      verificationGasLimit,\n    })\n\n    super(cause.shortMessage, {\n      cause,\n      docsPath,\n      metaMessages: [\n        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n        'Request Arguments:',\n        prettyArgs,\n      ].filter(Boolean) as string[],\n      name: 'UserOperationExecutionError',\n    })\n    this.cause = cause\n  }\n}\n\nexport type UserOperationReceiptNotFoundErrorType =\n  UserOperationReceiptNotFoundError & {\n    name: 'UserOperationReceiptNotFoundError'\n  }\nexport class UserOperationReceiptNotFoundError extends BaseError {\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `User Operation receipt with hash \"${hash}\" could not be found. The User Operation may not have been processed yet.`,\n      { name: 'UserOperationReceiptNotFoundError' },\n    )\n  }\n}\n\nexport type UserOperationNotFoundErrorType = UserOperationNotFoundError & {\n  name: 'UserOperationNotFoundError'\n}\nexport class UserOperationNotFoundError extends BaseError {\n  constructor({ hash }: { hash: Hash }) {\n    super(`User Operation with hash \"${hash}\" could not be found.`, {\n      name: 'UserOperationNotFoundError',\n    })\n  }\n}\n\nexport type WaitForUserOperationReceiptTimeoutErrorType =\n  WaitForUserOperationReceiptTimeoutError & {\n    name: 'WaitForUserOperationReceiptTimeoutError'\n  }\nexport class WaitForUserOperationReceiptTimeoutError extends BaseError {\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `Timed out while waiting for User Operation with hash \"${hash}\" to be confirmed.`,\n      { name: 'WaitForUserOperationReceiptTimeoutError' },\n    )\n  }\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { pad } from '../../utils/data/pad.js'\nimport { type ToBytesErrorType, toBytes } from '../../utils/encoding/toBytes.js'\nimport { type Sha256ErrorType, sha256 } from '../../utils/hash/sha256.js'\nimport { maxBytecodeSize } from '../constants/number.js'\nimport {\n  BytecodeLengthExceedsMaxSizeError,\n  type BytecodeLengthExceedsMaxSizeErrorType,\n  BytecodeLengthInWordsMustBeOddError,\n  type BytecodeLengthInWordsMustBeOddErrorType,\n  BytecodeLengthMustBeDivisibleBy32Error,\n  type BytecodeLengthMustBeDivisibleBy32ErrorType,\n} from '../errors/bytecode.js'\n\nexport type HashBytecodeErrorType =\n  | BytecodeLengthExceedsMaxSizeErrorType\n  | BytecodeLengthInWordsMustBeOddErrorType\n  | BytecodeLengthMustBeDivisibleBy32ErrorType\n  | Sha256ErrorType\n  | ToBytesErrorType\n  | ErrorType\n\nexport function hashBytecode(bytecode: Hex): Uint8Array {\n  const bytecodeBytes = toBytes(bytecode)\n  if (bytecodeBytes.length % 32 !== 0)\n    throw new BytecodeLengthMustBeDivisibleBy32Error({\n      givenLength: bytecodeBytes.length,\n    })\n\n  if (bytecodeBytes.length > maxBytecodeSize)\n    throw new BytecodeLengthExceedsMaxSizeError({\n      givenLength: bytecodeBytes.length,\n      maxBytecodeSize,\n    })\n\n  const hashStr = sha256(bytecodeBytes)\n  const hash = toBytes(hashStr)\n\n  // Note that the length of the bytecode\n  // should be provided in 32-byte words.\n  const bytecodeLengthInWords = bytecodeBytes.length / 32\n  if (bytecodeLengthInWords % 2 === 0) {\n    throw new BytecodeLengthInWordsMustBeOddError({\n      givenLengthInWords: bytecodeLengthInWords,\n    })\n  }\n\n  const bytecodeLength = toBytes(bytecodeLengthInWords)\n\n  // The bytecode should always take the first 2 bytes of the bytecode hash,\n  // so we pad it from the left in case the length is smaller than 2 bytes.\n  const bytecodeLengthPadded = pad(bytecodeLength, { size: 2 })\n\n  const codeHashVersion = new Uint8Array([1, 0])\n  hash.set(codeHashVersion, 0)\n  hash.set(bytecodeLengthPadded, 2)\n\n  return hash\n}\n","import * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\nconst decoder = /*#__PURE__*/ new TextDecoder()\n\nconst integerToCharacter = /*#__PURE__*/ Object.fromEntries(\n  Array.from(\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  ).map((a, i) => [i, a.charCodeAt(0)]),\n)\n\nconst characterToInteger = /*#__PURE__*/ {\n  ...Object.fromEntries(\n    Array.from(\n      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n    ).map((a, i) => [a.charCodeAt(0), i]),\n  ),\n  ['='.charCodeAt(0)]: 0,\n  ['-'.charCodeAt(0)]: 62,\n  ['_'.charCodeAt(0)]: 63,\n} as Record<number, number>\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello world'))\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello world'), { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.fromBytes(Bytes.fromString('hello wod'), { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The byte array to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */\nexport function fromBytes(value: Bytes.Bytes, options: fromBytes.Options = {}) {\n  const { pad = true, url = false } = options\n\n  const encoded = new Uint8Array(Math.ceil(value.length / 3) * 4)\n\n  for (let i = 0, j = 0; j < value.length; i += 4, j += 3) {\n    const y = (value[j]! << 16) + (value[j + 1]! << 8) + (value[j + 2]! | 0)\n    encoded[i] = integerToCharacter[y >> 18]!\n    encoded[i + 1] = integerToCharacter[(y >> 12) & 0x3f]!\n    encoded[i + 2] = integerToCharacter[(y >> 6) & 0x3f]!\n    encoded[i + 3] = integerToCharacter[y & 0x3f]!\n  }\n\n  const k = value.length % 3\n  const end = Math.floor(value.length / 3) * 4 + (k && k + 1)\n  let base64 = decoder.decode(new Uint8Array(encoded.buffer, 0, end))\n  if (pad && k === 1) base64 += '=='\n  if (pad && k === 2) base64 += '='\n  if (url) base64 = base64.replaceAll('+', '-').replaceAll('/', '_')\n  return base64\n}\n\nexport declare namespace fromBytes {\n  type Options = {\n    /**\n     * Whether to [pad](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) the Base64 encoded string.\n     *\n     * @default true\n     */\n    pad?: boolean | undefined\n    /**\n     * Whether to Base64 encode with [URL safe characters](https://datatracker.ietf.org/doc/html/rfc4648#section-5).\n     *\n     * @default false\n     */\n    url?: boolean | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Hex.Hex} to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello world'))\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello world'), { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.fromHex(Hex.fromString('hello wod'), { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The hex value to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */\nexport function fromHex(value: Hex.Hex, options: fromHex.Options = {}) {\n  return fromBytes(Bytes.fromHex(value), options)\n}\n\nexport declare namespace fromHex {\n  type Options = {\n    /**\n     * Whether to [pad](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) the Base64 encoded string.\n     *\n     * @default true\n     */\n    pad?: boolean | undefined\n    /**\n     * Whether to Base64 encode with [URL safe characters](https://datatracker.ietf.org/doc/html/rfc4648#section-5).\n     *\n     * @default false\n     */\n    url?: boolean | undefined\n  }\n\n  type ErrorType = fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a string to a Base64-encoded string (with optional padding and/or URL-safe characters).\n *\n * @example\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello world')\n * // @log: 'aGVsbG8gd29ybGQ='\n * ```\n *\n * @example\n * ### No Padding\n *\n * Turn off [padding of encoded data](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) with the `pad` option:\n *\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello world', { pad: false })\n * // @log: 'aGVsbG8gd29ybGQ'\n * ```\n *\n * ### URL-safe Encoding\n *\n * Turn on [URL-safe encoding](https://datatracker.ietf.org/doc/html/rfc4648#section-5) (Base64 URL) with the `url` option:\n *\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.fromString('hello wod', { url: true })\n * // @log: 'aGVsbG8gd29_77-9ZA=='\n * ```\n *\n * @param value - The string to encode.\n * @param options - Encoding options.\n * @returns The Base64 encoded string.\n */\nexport function fromString(value: string, options: fromString.Options = {}) {\n  return fromBytes(Bytes.fromString(value), options)\n}\n\nexport declare namespace fromString {\n  type Options = {\n    /**\n     * Whether to [pad](https://datatracker.ietf.org/doc/html/rfc4648#section-3.2) the Base64 encoded string.\n     *\n     * @default true\n     */\n    pad?: boolean | undefined\n    /**\n     * Whether to Base64 encode with [URL safe characters](https://datatracker.ietf.org/doc/html/rfc4648#section-5).\n     *\n     * @default false\n     */\n    url?: boolean | undefined\n  }\n\n  type ErrorType = fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Base64, Bytes } from 'ox'\n *\n * const value = Base64.toBytes('aGVsbG8gd29ybGQ=')\n * // @log: Uint8Array([104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded {@link ox#Bytes.Bytes}.\n */\nexport function toBytes(value: string): Bytes.Bytes {\n  const base64 = value.replace(/=+$/, '')\n\n  const size = base64.length\n\n  const decoded = new Uint8Array(size + 3)\n  encoder.encodeInto(base64 + '===', decoded)\n\n  for (let i = 0, j = 0; i < base64.length; i += 4, j += 3) {\n    const x =\n      (characterToInteger[decoded[i]!]! << 18) +\n      (characterToInteger[decoded[i + 1]!]! << 12) +\n      (characterToInteger[decoded[i + 2]!]! << 6) +\n      characterToInteger[decoded[i + 3]!]!\n    decoded[j] = x >> 16\n    decoded[j + 1] = (x >> 8) & 0xff\n    decoded[j + 2] = x & 0xff\n  }\n\n  const decodedSize = (size >> 2) * 3 + (size % 4 && (size % 4) - 1)\n  return new Uint8Array(decoded.buffer, 0, decodedSize)\n}\n\nexport declare namespace toBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Base64, Hex } from 'ox'\n *\n * const value = Base64.toHex('aGVsbG8gd29ybGQ=')\n * // @log: 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded {@link ox#Hex.Hex}.\n */\nexport function toHex(value: string): Hex.Hex {\n  return Hex.fromBytes(toBytes(value))\n}\n\nexport declare namespace toHex {\n  type ErrorType = toBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a Base64-encoded string (with optional padding and/or URL-safe characters) to a string.\n *\n * @example\n * ```ts twoslash\n * import { Base64 } from 'ox'\n *\n * const value = Base64.toString('aGVsbG8gd29ybGQ=')\n * // @log: 'hello world'\n * ```\n *\n * @param value - The string, hex value, or byte array to encode.\n * @returns The Base64 decoded string.\n */\nexport function toString(value: string): string {\n  return Bytes.toString(toBytes(value))\n}\n\nexport declare namespace toString {\n  type ErrorType = toBytes.ErrorType | Errors.GlobalErrorType\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/ui/assets/BaseLogo.tsx","import { ZodError, ZodIssueCode, } from \"./ZodError.js\";\nimport { defaultErrorMap, getErrorMap } from \"./errors.js\";\nimport { errorUtil } from \"./helpers/errorUtil.js\";\nimport { DIRTY, INVALID, OK, ParseStatus, addIssueToContext, isAborted, isAsync, isDirty, isValid, makeIssue, } from \"./helpers/parseUtil.js\";\nimport { util, ZodParsedType, getParsedType } from \"./helpers/util.js\";\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (Array.isArray(this._key)) {\n                this._cachedPath.push(...this._path, ...this._key);\n            }\n            else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result) => {\n    if (isValid(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error() {\n                if (this._error)\n                    return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            },\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        const { message } = params;\n        if (iss.code === \"invalid_enum_value\") {\n            return { message: message ?? ctx.defaultError };\n        }\n        if (typeof ctx.data === \"undefined\") {\n            return { message: message ?? required_error ?? ctx.defaultError };\n        }\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        return { message: message ?? invalid_type_error ?? ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nexport class ZodType {\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: params?.async ?? false,\n                contextualErrorMap: params?.errorMap,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    \"~validate\"(data) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: !!this[\"~standard\"].async,\n            },\n            path: [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        if (!this[\"~standard\"].async) {\n            try {\n                const result = this._parseSync({ data, path: [], parent: ctx });\n                return isValid(result)\n                    ? {\n                        value: result.value,\n                    }\n                    : {\n                        issues: ctx.common.issues,\n                    };\n            }\n            catch (err) {\n                if (err?.message?.toLowerCase()?.includes(\"encountered\")) {\n                    this[\"~standard\"].async = true;\n                }\n                ctx.common = {\n                    issues: [],\n                    async: true,\n                };\n            }\n        }\n        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result)\n            ? {\n                value: result.value,\n            }\n            : {\n                issues: ctx.common.issues,\n            });\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params?.errorMap,\n                async: true,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n        this[\"~standard\"] = {\n            version: 1,\n            vendor: \"zod\",\n            validate: (data) => this[\"~validate\"](data),\n        };\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([this, option], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def),\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[0-9a-z]+$/;\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nconst nanoidRegex = /^[a-z0-9_-]{21}$/i;\nconst jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\nconst durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nlet emojiRegex;\n// faster, simpler, safer\nconst ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nconst ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\n// const ipv6Regex =\n// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nconst ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\nconst ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\nconst base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\n// https://base64.guru/standards/base64url\nconst base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\n// simple\n// const dateRegexSource = `\\\\d{4}-\\\\d{2}-\\\\d{2}`;\n// no leap year validation\n// const dateRegexSource = `\\\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\\\d|2\\\\d))`;\n// with leap year validation\nconst dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nconst dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n    let secondsRegexSource = `[0-5]\\\\d`;\n    if (args.precision) {\n        secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n    }\n    else if (args.precision == null) {\n        secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n    }\n    const secondsQuantifier = args.precision ? \"+\" : \"?\"; // require seconds if precision is nonzero\n    return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\nfunction timeRegex(args) {\n    return new RegExp(`^${timeRegexSource(args)}$`);\n}\n// Adapted from https://stackoverflow.com/a/3143231\nexport function datetimeRegex(args) {\n    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n    const opts = [];\n    opts.push(args.local ? `Z?` : `Z`);\n    if (args.offset)\n        opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n    regex = `${regex}(${opts.join(\"|\")})`;\n    return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nfunction isValidJWT(jwt, alg) {\n    if (!jwtRegex.test(jwt))\n        return false;\n    try {\n        const [header] = jwt.split(\".\");\n        if (!header)\n            return false;\n        // Convert base64url to base64\n        const base64 = header\n            .replace(/-/g, \"+\")\n            .replace(/_/g, \"/\")\n            .padEnd(header.length + ((4 - (header.length % 4)) % 4), \"=\");\n        const decoded = JSON.parse(atob(base64));\n        if (typeof decoded !== \"object\" || decoded === null)\n            return false;\n        if (\"typ\" in decoded && decoded?.typ !== \"JWT\")\n            return false;\n        if (!decoded.alg)\n            return false;\n        if (alg && decoded.alg !== alg)\n            return false;\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nfunction isValidCidr(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4CidrRegex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6CidrRegex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nexport class ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"nanoid\") {\n                if (!nanoidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"nanoid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                }\n                catch {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { includes: check.value, position: check.position },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            }\n            else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"date\") {\n                const regex = dateRegex;\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"date\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"time\") {\n                const regex = timeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"time\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"duration\") {\n                if (!durationRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"duration\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"jwt\") {\n                if (!isValidJWT(input.data, check.alg)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"jwt\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cidr\") {\n                if (!isValidCidr(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cidr\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64\") {\n                if (!base64Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64url\") {\n                if (!base64urlRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data) => regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n    }\n    emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n    }\n    nanoid(message) {\n        return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n    }\n    ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n    }\n    base64(message) {\n        return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message) });\n    }\n    base64url(message) {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return this._addCheck({\n            kind: \"base64url\",\n            ...errorUtil.errToObj(message),\n        });\n    }\n    jwt(options) {\n        return this._addCheck({ kind: \"jwt\", ...errorUtil.errToObj(options) });\n    }\n    ip(options) {\n        return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n    }\n    cidr(options) {\n        return this._addCheck({ kind: \"cidr\", ...errorUtil.errToObj(options) });\n    }\n    datetime(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                local: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            offset: options?.offset ?? false,\n            local: options?.local ?? false,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    date(message) {\n        return this._addCheck({ kind: \"date\", message });\n    }\n    time(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"time\",\n                precision: null,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"time\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    duration(message) {\n        return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message) });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options?.position,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    /**\n     * Equivalent to `.min(1)`\n     */\n    nonempty(message) {\n        return this.min(1, errorUtil.errToObj(message));\n    }\n    trim() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n    }\n    toLowerCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n        });\n    }\n    toUpperCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isDate() {\n        return !!this._def.checks.find((ch) => ch.kind === \"date\");\n    }\n    get isTime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"time\");\n    }\n    get isDuration() {\n        return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isNANOID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n    }\n    get isCIDR() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cidr\");\n    }\n    get isBase64() {\n        return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n    }\n    get isBase64url() {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return !!this._def.checks.find((ch) => ch.kind === \"base64url\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params) => {\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / 10 ** decCount;\n}\nexport class ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message),\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" || (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\n    }\n    get isFinite() {\n        let max = null;\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n                return true;\n            }\n            else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n            else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodBigInt extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            try {\n                input.data = BigInt(input.data);\n            }\n            catch {\n                return this._getInvalidInput(input);\n            }\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            return this._getInvalidInput(input);\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _getInvalidInput(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.bigint,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodBigInt.create = (params) => {\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (Number.isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_date,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: params?.coerce || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n}\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([...ctx.data].map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [...ctx.data].map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element),\n        });\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nexport class ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        this._cached = { shape, keys };\n        return this._cached;\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") {\n            }\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    syncPairs.push({\n                        key,\n                        value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: errorUtil.errToObj(message).message ?? defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: () => ({\n                ...this._def.shape(),\n                ...augmentation,\n            }),\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => ({\n                ...this._def.shape(),\n                ...merging._def.shape(),\n            }),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(mask)) {\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    /**\n     * @deprecated\n     */\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            }\n            else {\n                newShape[key] = fieldSchema.optional();\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            }\n            else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new ZodError(issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return util.objectValues(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else if (type instanceof ZodOptional) {\n        return [undefined, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodNullable) {\n        return [null, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodBranded) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodReadonly) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodCatch) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else {\n        return [];\n    }\n};\nexport class ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues.length) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nexport class ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types,\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\n// type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];\nexport class ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = [...ctx.data]\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nexport class ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(async function (...args) {\n                const error = new ZodError([]);\n                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(function (...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args ? args : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nexport class ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nexport class ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(this._def.values);\n        }\n        if (!this._cache.has(input.data)) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values, newDef = this._def) {\n        return ZodEnum.create(values, {\n            ...this._def,\n            ...newDef,\n        });\n    }\n    exclude(values, newDef = this._def) {\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\n            ...this._def,\n            ...newDef,\n        });\n    }\n}\nZodEnum.create = createZodEnum;\nexport class ZodNativeEnum extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(util.getValidEnumValues(this._def.values));\n        }\n        if (!this._cache.has(input.data)) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n        return OK(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg) => {\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then(async (processed) => {\n                    if (status.value === \"aborted\")\n                        return INVALID;\n                    const result = await this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                    if (result.status === \"aborted\")\n                        return INVALID;\n                    if (result.status === \"dirty\")\n                        return DIRTY(result.value);\n                    if (status.value === \"dirty\")\n                        return DIRTY(result.value);\n                    return result;\n                });\n            }\n            else {\n                if (status.value === \"aborted\")\n                    return INVALID;\n                const result = this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (result.status === \"aborted\")\n                    return INVALID;\n                if (result.status === \"dirty\")\n                    return DIRTY(result.value);\n                if (status.value === \"dirty\")\n                    return DIRTY(result.value);\n                return result;\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (!isValid(base))\n                    return INVALID;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n                    if (!isValid(base))\n                        return INVALID;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({\n                        status: status.value,\n                        value: result,\n                    }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\nexport { ZodEffects as ZodTransformer };\nexport class ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\" ? params.default : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: [],\n            },\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx,\n            },\n        });\n        if (isAsync(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\"\n                        ? result.value\n                        : this._def.catchValue({\n                            get error() {\n                                return new ZodError(newCtx.common.issues);\n                            },\n                            input: newCtx.data,\n                        }),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\"\n                    ? result.value\n                    : this._def.catchValue({\n                        get error() {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data,\n                    }),\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nexport const BRAND = Symbol(\"zod_brand\");\nexport class ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nexport class ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nexport class ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        const freeze = (data) => {\n            if (isValid(data)) {\n                data.value = Object.freeze(data.value);\n            }\n            return data;\n        };\n        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodReadonly.create = (type, params) => {\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params),\n    });\n};\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      z.custom      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nfunction cleanParams(params, data) {\n    const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? { message: params } : params;\n    const p2 = typeof p === \"string\" ? { message: p } : p;\n    return p2;\n}\nexport function custom(check, _params = {}, \n/**\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */\nfatal) {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            const r = check(data);\n            if (r instanceof Promise) {\n                return r.then((r) => {\n                    if (!r) {\n                        const params = cleanParams(_params, data);\n                        const _fatal = params.fatal ?? fatal ?? true;\n                        ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n                    }\n                });\n            }\n            if (!r) {\n                const params = cleanParams(_params, data);\n                const _fatal = params.fatal ?? fatal ?? true;\n                ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n            }\n            return;\n        });\n    return ZodAny.create();\n}\nexport { ZodType as Schema, ZodType as ZodSchema };\nexport const late = {\n    object: ZodObject.lazycreate,\n};\nexport var ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\n// requires TS 4.4+\nclass Class {\n    constructor(..._) { }\n}\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => custom((data) => data instanceof cls, params);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = () => stringType().optional();\nconst onumber = () => numberType().optional();\nconst oboolean = () => booleanType().optional();\nexport const coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true,\n    })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\nexport { anyType as any, arrayType as array, bigIntType as bigint, booleanType as boolean, dateType as date, discriminatedUnionType as discriminatedUnion, effectsType as effect, enumType as enum, functionType as function, instanceOfType as instanceof, intersectionType as intersection, lazyType as lazy, literalType as literal, mapType as map, nanType as nan, nativeEnumType as nativeEnum, neverType as never, nullType as null, nullableType as nullable, numberType as number, objectType as object, oboolean, onumber, optionalType as optional, ostring, pipelineType as pipeline, preprocessType as preprocess, promiseType as promise, recordType as record, setType as set, strictObjectType as strictObject, stringType as string, symbolType as symbol, effectsType as transformer, tupleType as tuple, undefinedType as undefined, unionType as union, unknownType as unknown, voidType as void, };\nexport const NEVER = INVALID;\n","import { decode as decodeBase64URL } from '../util/base64url.js';\nimport { fromSPKI, fromPKCS8, fromX509 } from '../lib/asn1.js';\nimport { jwkToKey } from '../lib/jwk_to_key.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { isObject } from '../lib/is_object.js';\nexport async function importSPKI(spki, alg, options) {\n    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {\n        throw new TypeError('\"spki\" must be SPKI formatted string');\n    }\n    return fromSPKI(spki, alg, options);\n}\nexport async function importX509(x509, alg, options) {\n    if (typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0) {\n        throw new TypeError('\"x509\" must be X.509 formatted string');\n    }\n    return fromX509(x509, alg, options);\n}\nexport async function importPKCS8(pkcs8, alg, options) {\n    if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {\n        throw new TypeError('\"pkcs8\" must be PKCS#8 formatted string');\n    }\n    return fromPKCS8(pkcs8, alg, options);\n}\nexport async function importJWK(jwk, alg, options) {\n    if (!isObject(jwk)) {\n        throw new TypeError('JWK must be an object');\n    }\n    let ext;\n    alg ??= jwk.alg;\n    ext ??= options?.extractable ?? jwk.ext;\n    switch (jwk.kty) {\n        case 'oct':\n            if (typeof jwk.k !== 'string' || !jwk.k) {\n                throw new TypeError('missing \"k\" (Key Value) Parameter value');\n            }\n            return decodeBase64URL(jwk.k);\n        case 'RSA':\n            if ('oth' in jwk && jwk.oth !== undefined) {\n                throw new JOSENotSupported('RSA JWK \"oth\" (Other Primes Info) Parameter value is not supported');\n            }\n            return jwkToKey({ ...jwk, alg, ext });\n        case 'AKP': {\n            if (typeof jwk.alg !== 'string' || !jwk.alg) {\n                throw new TypeError('missing \"alg\" (Algorithm) Parameter value');\n            }\n            if (alg !== undefined && alg !== jwk.alg) {\n                throw new TypeError('JWK alg and alg option value mismatch');\n            }\n            return jwkToKey({ ...jwk, ext });\n        }\n        case 'EC':\n        case 'OKP':\n            return jwkToKey({ ...jwk, alg, ext });\n        default:\n            throw new JOSENotSupported('Unsupported \"kty\" (Key Type) Parameter value');\n    }\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/core/error/errors.ts","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const bitTorrentTestnet = /*#__PURE__*/ defineChain({\n  id: 1028,\n  name: 'BitTorrent Chain Testnet',\n  network: 'bittorrent-chain-testnet',\n  nativeCurrency: { name: 'BitTorrent', symbol: 'BTT', decimals: 18 },\n  rpcUrls: {\n    default: { http: ['https://testrpc.bittorrentchain.io'] },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Bttcscan',\n      url: 'https://testnet.bttcscan.com',\n      apiUrl: 'https://testnet.bttcscan.com/api',\n    },\n  },\n  testnet: true,\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const bitkubTestnet = /*#__PURE__*/ defineChain({\n  id: 25925,\n  name: 'Bitkub Testnet',\n  network: 'Bitkub Testnet',\n  nativeCurrency: { name: 'Bitkub Test', symbol: 'tKUB', decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: ['https://rpc-testnet.bitkubchain.io'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Bitkub Chain Testnet Explorer',\n      url: 'https://testnet.bkcscan.com',\n      apiUrl: 'https://testnet.bkcscan.com/api',\n    },\n  },\n  testnet: true,\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const bitTorrent = /*#__PURE__*/ defineChain({\n  id: 199,\n  name: 'BitTorrent',\n  network: 'bittorrent-chain-mainnet',\n  nativeCurrency: { name: 'BitTorrent', symbol: 'BTT', decimals: 18 },\n  rpcUrls: {\n    default: { http: ['https://rpc.bittorrentchain.io'] },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Bttcscan',\n      url: 'https://bttcscan.com',\n      apiUrl: 'https://api.bttcscan.com/api',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 31078552,\n    },\n  },\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\n/** @deprecated Use `loadAlphanet` instead. */\nexport const weaveVMAlphanet = /*#__PURE__*/ defineChain({\n  id: 9496,\n  name: 'WeaveVM Alphanet',\n  nativeCurrency: { name: 'Testnet WeaveVM', symbol: 'tWVM', decimals: 18 },\n  rpcUrls: {\n    default: { http: ['https://testnet-rpc.wvm.dev'] },\n  },\n  blockExplorers: {\n    default: {\n      name: 'WeaveVM Alphanet Explorer',\n      url: 'https://explorer.wvm.dev',\n    },\n  },\n  testnet: true,\n})\n","import { concat } from '../../../utils/data/concat.js'\nimport { pad } from '../../../utils/data/pad.js'\nimport { numberToHex } from '../../../utils/index.js'\nimport type {\n  PackedUserOperation,\n  UserOperation,\n} from '../../types/userOperation.js'\nimport { getInitCode } from './getInitCode.js'\n\nexport function toPackedUserOperation(\n  userOperation: UserOperation,\n): PackedUserOperation {\n  const {\n    callGasLimit,\n    callData,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n    paymaster,\n    paymasterData,\n    paymasterPostOpGasLimit,\n    paymasterVerificationGasLimit,\n    sender,\n    signature = '0x',\n    verificationGasLimit,\n  } = userOperation\n\n  const accountGasLimits = concat([\n    pad(numberToHex(verificationGasLimit || 0n), { size: 16 }),\n    pad(numberToHex(callGasLimit || 0n), { size: 16 }),\n  ])\n  const initCode = getInitCode(userOperation)\n  const gasFees = concat([\n    pad(numberToHex(maxPriorityFeePerGas || 0n), { size: 16 }),\n    pad(numberToHex(maxFeePerGas || 0n), { size: 16 }),\n  ])\n  const nonce = userOperation.nonce ?? 0n\n  const paymasterAndData = paymaster\n    ? concat([\n        paymaster,\n        pad(numberToHex(paymasterVerificationGasLimit || 0n), {\n          size: 16,\n        }),\n        pad(numberToHex(paymasterPostOpGasLimit || 0n), {\n          size: 16,\n        }),\n        paymasterData || '0x',\n      ])\n    : '0x'\n  const preVerificationGas = userOperation.preVerificationGas ?? 0n\n\n  return {\n    accountGasLimits,\n    callData,\n    initCode,\n    gasFees,\n    nonce,\n    paymasterAndData,\n    preVerificationGas,\n    sender,\n    signature,\n  }\n}\n","import {\n  pipe,\n  createTransactionMessage,\n  setTransactionMessageLifetimeUsingBlockhash,\n  appendTransactionMessageInstructions,\n  Instruction,\n  createSolanaRpc,\n  address,\n  compileTransaction,\n  setTransactionMessageFeePayer,\n  createNoopSigner,\n  getBase64EncodedWireTransaction,\n} from \"@solana/kit\";\nimport { Connection } from \"@solana/web3.js\";\nimport { getTransferSolInstruction } from \"@solana-program/system\";\nimport {\n  findAssociatedTokenPda,\n  getCreateAssociatedTokenInstructionAsync,\n  getTransferCheckedInstruction,\n  fetchToken,\n  fetchMint,\n  TOKEN_PROGRAM_ADDRESS,\n} from \"@solana-program/token\";\n\nimport { createRpcClient } from \"./rpc.js\";\nimport { sendTransaction } from \"./sendTransaction.js\";\nimport {\n  getConnectedNetwork,\n  getOrCreateConnection,\n  getUsdcMintAddress,\n  type Network,\n} from \"./utils.js\";\n\nimport type { SignatureResult } from \"../../client/solana/solana.types.js\";\nimport type { CdpOpenApiClientType } from \"../../openapi-client/index.js\";\n\nexport interface TransferOptions {\n  /**\n   * The base58 encoded Solana address of the source account.\n   */\n  from: string;\n  /**\n   * The base58 encoded Solana address of the destination account.\n   */\n  to: string;\n  /**\n   * The amount to transfer, represented as an atomic unit of the token.\n   */\n  amount: bigint;\n  /**\n   * The token to transfer, or mint address of the SPL token to transfer.\n   */\n  token: \"sol\" | \"usdc\" | string;\n  /**\n   * The network to use which will be used to create an RPC client, otherwise an RPC client can be provided.\n   */\n  network: Network | Connection;\n}\n\n/**\n * Transfers SOL or SPL tokens between accounts\n *\n * @param apiClient - The API client to use\n * @param options - The transfer options\n *\n * @returns The transfer result\n */\nexport async function transfer(\n  apiClient: CdpOpenApiClientType,\n  options: TransferOptions,\n): Promise<SignatureResult> {\n  const connection = getOrCreateConnection({ networkOrConnection: options.network });\n  const connectedNetwork = await getConnectedNetwork(connection);\n  const rpc = createRpcClient(connectedNetwork);\n\n  const base64Transaction =\n    options.token === \"sol\"\n      ? await getNativeTransferBase64Transaction({\n          rpc,\n          from: options.from,\n          to: options.to,\n          amount: options.amount,\n        })\n      : await getSplTransferBase64Transaction({\n          rpc,\n          from: options.from,\n          to: options.to,\n          mintAddress:\n            options.token === \"usdc\" ? getUsdcMintAddress(connectedNetwork) : options.token,\n          amount: options.amount,\n        });\n\n  const signature = await sendTransaction(apiClient, {\n    network: connectedNetwork === \"mainnet\" ? \"solana\" : \"solana-devnet\",\n    transaction: base64Transaction,\n  });\n\n  return signature;\n}\n\ntype GetNativeTransferOptions = Omit<TransferOptions, \"token\" | \"network\"> & {\n  rpc: ReturnType<typeof createSolanaRpc>;\n};\n\n/**\n * Gets the transaction for a SOL transfer\n *\n * @param options - The options for the SOL transfer\n *\n * @param options.rpc - The Solana RPC client\n * @param options.from - The source address\n * @param options.to - The destination address\n * @param options.amount - The amount in lamports to transfer\n *\n * @returns The SOL transfer transaction\n */\nexport async function getNativeTransferBase64Transaction({\n  rpc,\n  from,\n  to,\n  amount,\n}: GetNativeTransferOptions): Promise<string> {\n  const fromAddr = address(from);\n  const toAddr = address(to);\n\n  const instructions: Instruction[] = [\n    getTransferSolInstruction({\n      source: createNoopSigner(fromAddr),\n      destination: toAddr,\n      amount,\n    }),\n  ];\n\n  const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n\n  const txMsg = pipe(\n    createTransactionMessage({ version: 0 }),\n    tx => setTransactionMessageFeePayer(fromAddr, tx),\n    tx => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n    tx => appendTransactionMessageInstructions(instructions, tx),\n  );\n\n  const compiledTransaction = compileTransaction(txMsg);\n  return getBase64EncodedWireTransaction(compiledTransaction);\n}\n\ntype GetSplTokenTransferOptions = Omit<TransferOptions, \"network\" | \"token\"> & {\n  mintAddress: string;\n  rpc: ReturnType<typeof createSolanaRpc>;\n};\n\n/**\n * Gets the transaction for a SPL token transfer\n *\n * @param options - The options for the SPL token transfer\n *\n * @param options.rpc - The Solana RPC client\n * @param options.from - The source address\n * @param options.to - The destination address\n * @param options.mintAddress - The mint address of the token\n * @param options.amount - The amount in units of the token to transfer\n *\n * @returns The SPL token transfer transaction\n */\nexport async function getSplTransferBase64Transaction({\n  rpc,\n  from,\n  to,\n  mintAddress,\n  amount,\n}: GetSplTokenTransferOptions): Promise<string> {\n  const fromAddr = address(from);\n  const toAddr = address(to);\n  const mintAddr = address(mintAddress);\n\n  const mintInfo = await fetchMint(rpc, mintAddr);\n\n  const [sourceAta] = await findAssociatedTokenPda({\n    mint: mintAddr,\n    owner: fromAddr,\n    tokenProgram: TOKEN_PROGRAM_ADDRESS,\n  });\n  const [destAta] = await findAssociatedTokenPda({\n    mint: mintAddr,\n    owner: toAddr,\n    tokenProgram: TOKEN_PROGRAM_ADDRESS,\n  });\n\n  const sourceAcct = await fetchToken(rpc, sourceAta);\n  if (sourceAcct.data.amount < amount) {\n    throw new Error(`Insufficient token balance: have ${sourceAcct.data.amount}, need ${amount}`);\n  }\n\n  const instructions: Instruction[] = [];\n\n  // If destination ATA does not exist, add create instruction\n  try {\n    await fetchToken(rpc, destAta);\n  } catch {\n    const createDestIx = await getCreateAssociatedTokenInstructionAsync({\n      payer: createNoopSigner(fromAddr),\n      owner: toAddr,\n      ata: destAta,\n      mint: mintAddr,\n    });\n    instructions.push(createDestIx);\n  }\n\n  instructions.push(\n    getTransferCheckedInstruction({\n      source: sourceAta,\n      mint: mintAddr,\n      destination: destAta,\n      authority: fromAddr,\n      amount,\n      decimals: mintInfo.data.decimals,\n    }),\n  );\n\n  const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n\n  const txMsg = pipe(\n    createTransactionMessage({ version: 0 }),\n    tx => setTransactionMessageFeePayer(fromAddr, tx),\n    tx => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n    tx => appendTransactionMessageInstructions(instructions, tx),\n  );\n\n  const compiledTransaction = compileTransaction(txMsg);\n  return getBase64EncodedWireTransaction(compiledTransaction);\n}\n","import { maxUint256 } from '../constants/number.js'\nimport { InvalidAddressError } from '../errors/address.js'\nimport { BaseError } from '../errors/base.js'\nimport { InvalidChainIdError } from '../errors/chain.js'\nimport { FeeCapTooHighError, TipAboveFeeCapError } from '../errors/node.js'\nimport { serializeTransaction as serializeTransaction_op } from '../op-stack/serializers.js'\nimport type { ChainSerializers } from '../types/chain.js'\nimport type { Signature } from '../types/misc.js'\nimport { isAddress } from '../utils/address/isAddress.js'\nimport { concatHex } from '../utils/data/concat.js'\nimport { toHex } from '../utils/encoding/toHex.js'\nimport { toRlp } from '../utils/encoding/toRlp.js'\nimport { serializeAccessList } from '../utils/transaction/serializeAccessList.js'\nimport { toYParitySignatureArray } from '../utils/transaction/serializeTransaction.js'\nimport type {\n  CeloTransactionSerializable,\n  TransactionSerializableCIP42,\n  TransactionSerializableCIP64,\n  TransactionSerializedCIP64,\n} from './types.js'\nimport { isCIP64, isEmpty, isPresent } from './utils.js'\n\nexport function serializeTransaction(\n  transaction: CeloTransactionSerializable,\n  signature?: Signature | undefined,\n) {\n  if (isCIP64(transaction))\n    return serializeTransactionCIP64(transaction, signature)\n  return serializeTransaction_op(transaction, signature)\n}\n\nexport const serializers = {\n  transaction: serializeTransaction,\n} as const satisfies ChainSerializers\n\n//////////////////////////////////////////////////////////////////////////////\n// Serializers\n\nexport type SerializeTransactionCIP64ReturnType = TransactionSerializedCIP64\n\nfunction serializeTransactionCIP64(\n  transaction: TransactionSerializableCIP64,\n  signature?: Signature | undefined,\n): SerializeTransactionCIP64ReturnType {\n  assertTransactionCIP64(transaction)\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    feeCurrency,\n    data,\n  } = transaction\n\n  const serializedTransaction = [\n    toHex(chainId),\n    nonce ? toHex(nonce) : '0x',\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\n    maxFeePerGas ? toHex(maxFeePerGas) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n    serializeAccessList(accessList),\n    feeCurrency!,\n    ...toYParitySignatureArray(transaction, signature),\n  ]\n\n  return concatHex([\n    '0x7b',\n    toRlp(serializedTransaction),\n  ]) as SerializeTransactionCIP64ReturnType\n}\n\n// maxFeePerGas must be less than maxUint256\nconst MAX_MAX_FEE_PER_GAS = maxUint256\n\nexport function assertTransactionCIP42(\n  transaction: TransactionSerializableCIP42,\n) {\n  const {\n    chainId,\n    maxPriorityFeePerGas,\n    gasPrice,\n    maxFeePerGas,\n    to,\n    feeCurrency,\n    gatewayFee,\n    gatewayFeeRecipient,\n  } = transaction\n  if (chainId <= 0) throw new InvalidChainIdError({ chainId })\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (gasPrice)\n    throw new BaseError(\n      '`gasPrice` is not a valid CIP-42 Transaction attribute.',\n    )\n\n  if (isPresent(maxFeePerGas) && maxFeePerGas > MAX_MAX_FEE_PER_GAS)\n    throw new FeeCapTooHighError({ maxFeePerGas })\n\n  if (\n    isPresent(maxPriorityFeePerGas) &&\n    isPresent(maxFeePerGas) &&\n    maxPriorityFeePerGas > maxFeePerGas\n  )\n    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas })\n\n  if (\n    (isPresent(gatewayFee) && isEmpty(gatewayFeeRecipient)) ||\n    (isPresent(gatewayFeeRecipient) && isEmpty(gatewayFee))\n  ) {\n    throw new BaseError(\n      '`gatewayFee` and `gatewayFeeRecipient` must be provided together.',\n    )\n  }\n\n  if (isPresent(feeCurrency) && !isAddress(feeCurrency)) {\n    throw new BaseError(\n      '`feeCurrency` MUST be a token address for CIP-42 transactions.',\n    )\n  }\n\n  if (isPresent(gatewayFeeRecipient) && !isAddress(gatewayFeeRecipient)) {\n    throw new InvalidAddressError(gatewayFeeRecipient)\n  }\n\n  if (isEmpty(feeCurrency) && isEmpty(gatewayFeeRecipient)) {\n    throw new BaseError(\n      'Either `feeCurrency` or `gatewayFeeRecipient` must be provided for CIP-42 transactions.',\n    )\n  }\n}\n\nexport function assertTransactionCIP64(\n  transaction: TransactionSerializableCIP64,\n) {\n  const {\n    chainId,\n    maxPriorityFeePerGas,\n    gasPrice,\n    maxFeePerGas,\n    to,\n    feeCurrency,\n  } = transaction\n\n  if (chainId <= 0) throw new InvalidChainIdError({ chainId })\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n\n  if (gasPrice)\n    throw new BaseError(\n      '`gasPrice` is not a valid CIP-64 Transaction attribute.',\n    )\n\n  if (isPresent(maxFeePerGas) && maxFeePerGas > MAX_MAX_FEE_PER_GAS)\n    throw new FeeCapTooHighError({ maxFeePerGas })\n  if (\n    isPresent(maxPriorityFeePerGas) &&\n    isPresent(maxFeePerGas) &&\n    maxPriorityFeePerGas > maxFeePerGas\n  )\n    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas })\n\n  if (isPresent(feeCurrency) && !isAddress(feeCurrency)) {\n    throw new BaseError(\n      '`feeCurrency` MUST be a token address for CIP-64 transactions.',\n    )\n  }\n\n  if (isEmpty(feeCurrency)) {\n    throw new BaseError(\n      '`feeCurrency` must be provided for CIP-64 transactions.',\n    )\n  }\n}\n","import { type Abi, parseAbi } from 'abitype'\n\nimport { getCode } from '../../actions/public/getCode.js'\nimport { readContract } from '../../actions/public/readContract.js'\nimport type { Prettify } from '../../types/utils.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { createNonceManager } from '../../utils/nonceManager.js'\nimport { serializeErc6492Signature } from '../../utils/signature/serializeErc6492Signature.js'\nimport type { EntryPointVersion } from '../types/entryPointVersion.js'\nimport type { SmartAccount, SmartAccountImplementation } from './types.js'\n\nexport type ToSmartAccountParameters<\n  entryPointAbi extends Abi | readonly unknown[] = Abi,\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n  extend extends object = object,\n> = SmartAccountImplementation<entryPointAbi, entryPointVersion, extend>\n\nexport type ToSmartAccountReturnType<\n  implementation extends\n    SmartAccountImplementation = SmartAccountImplementation,\n> = Prettify<SmartAccount<implementation>>\n\n/**\n * @description Creates a Smart Account with a provided account implementation.\n *\n * @param parameters - {@link ToSmartAccountParameters}\n * @returns A Smart Account. {@link ToSmartAccountReturnType}\n */\nexport async function toSmartAccount<\n  implementation extends SmartAccountImplementation,\n>(\n  implementation: implementation,\n): Promise<ToSmartAccountReturnType<implementation>> {\n  const {\n    extend,\n    nonceKeyManager = createNonceManager({\n      source: {\n        get() {\n          return Date.now()\n        },\n        set() {},\n      },\n    }),\n    ...rest\n  } = implementation\n\n  let deployed = false\n\n  const address = await implementation.getAddress()\n\n  return {\n    ...extend,\n    ...rest,\n    address,\n    async getFactoryArgs() {\n      if ('isDeployed' in this && (await this.isDeployed()))\n        return { factory: undefined, factoryData: undefined }\n      return implementation.getFactoryArgs()\n    },\n    async getNonce(parameters) {\n      const key =\n        parameters?.key ??\n        BigInt(\n          await nonceKeyManager.consume({\n            address,\n            chainId: implementation.client.chain!.id!,\n            client: implementation.client,\n          }),\n        )\n\n      if (implementation.getNonce)\n        return await implementation.getNonce({ ...parameters, key })\n\n      const nonce = await readContract(implementation.client, {\n        abi: parseAbi([\n          'function getNonce(address, uint192) pure returns (uint256)',\n        ]),\n        address: implementation.entryPoint.address,\n        functionName: 'getNonce',\n        args: [address, key],\n      })\n      return nonce\n    },\n    async isDeployed() {\n      if (deployed) return true\n      const code = await getAction(\n        implementation.client,\n        getCode,\n        'getCode',\n      )({\n        address,\n      })\n      deployed = Boolean(code)\n      return deployed\n    },\n    ...(implementation.sign\n      ? {\n          async sign(parameters) {\n            const [{ factory, factoryData }, signature] = await Promise.all([\n              this.getFactoryArgs(),\n              implementation.sign!(parameters),\n            ])\n            if (factory && factoryData)\n              return serializeErc6492Signature({\n                address: factory,\n                data: factoryData,\n                signature,\n              })\n            return signature\n          },\n        }\n      : {}),\n    async signMessage(parameters) {\n      const [{ factory, factoryData }, signature] = await Promise.all([\n        this.getFactoryArgs(),\n        implementation.signMessage(parameters),\n      ])\n      if (factory && factoryData && factory !== '0x7702')\n        return serializeErc6492Signature({\n          address: factory,\n          data: factoryData,\n          signature,\n        })\n      return signature\n    },\n    async signTypedData(parameters) {\n      const [{ factory, factoryData }, signature] = await Promise.all([\n        this.getFactoryArgs(),\n        implementation.signTypedData(parameters),\n      ])\n      if (factory && factoryData && factory !== '0x7702')\n        return serializeErc6492Signature({\n          address: factory,\n          data: factoryData,\n          signature,\n        })\n      return signature\n    },\n    type: 'smart',\n  } as ToSmartAccountReturnType<implementation>\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/index.node.ts","import { BaseError } from '../../errors.js'\n\nexport class InvalidParenthesisError extends BaseError {\n  override name = 'InvalidParenthesisError'\n\n  constructor({ current, depth }: { current: string; depth: number }) {\n    super('Unbalanced parentheses.', {\n      metaMessages: [\n        `\"${current.trim()}\" has too many ${\n          depth > 0 ? 'opening' : 'closing'\n        } parentheses.`,\n      ],\n      details: `Depth \"${depth}\"`,\n    })\n  }\n}\n","import util from 'util';\nimport {Readable} from 'stream';\nimport utils from \"../utils.js\";\nimport readBlob from \"./readBlob.js\";\nimport platform from \"../platform/index.js\";\n\nconst BOUNDARY_ALPHABET = platform.ALPHABET.ALPHA_DIGIT + '-_';\n\nconst textEncoder = typeof TextEncoder === 'function' ? new TextEncoder() : new util.TextEncoder();\n\nconst CRLF = '\\r\\n';\nconst CRLF_BYTES = textEncoder.encode(CRLF);\nconst CRLF_BYTES_COUNT = 2;\n\nclass FormDataPart {\n  constructor(name, value) {\n    const {escapeName} = this.constructor;\n    const isStringValue = utils.isString(value);\n\n    let headers = `Content-Disposition: form-data; name=\"${escapeName(name)}\"${\n      !isStringValue && value.name ? `; filename=\"${escapeName(value.name)}\"` : ''\n    }${CRLF}`;\n\n    if (isStringValue) {\n      value = textEncoder.encode(String(value).replace(/\\r?\\n|\\r\\n?/g, CRLF));\n    } else {\n      headers += `Content-Type: ${value.type || \"application/octet-stream\"}${CRLF}`\n    }\n\n    this.headers = textEncoder.encode(headers + CRLF);\n\n    this.contentLength = isStringValue ? value.byteLength : value.size;\n\n    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;\n\n    this.name = name;\n    this.value = value;\n  }\n\n  async *encode(){\n    yield this.headers;\n\n    const {value} = this;\n\n    if(utils.isTypedArray(value)) {\n      yield value;\n    } else {\n      yield* readBlob(value);\n    }\n\n    yield CRLF_BYTES;\n  }\n\n  static escapeName(name) {\n      return String(name).replace(/[\\r\\n\"]/g, (match) => ({\n        '\\r' : '%0D',\n        '\\n' : '%0A',\n        '\"' : '%22',\n      }[match]));\n  }\n}\n\nconst formDataToStream = (form, headersHandler, options) => {\n  const {\n    tag = 'form-data-boundary',\n    size = 25,\n    boundary = tag + '-' + platform.generateString(size, BOUNDARY_ALPHABET)\n  } = options || {};\n\n  if(!utils.isFormData(form)) {\n    throw TypeError('FormData instance required');\n  }\n\n  if (boundary.length < 1 || boundary.length > 70) {\n    throw Error('boundary must be 10-70 characters long')\n  }\n\n  const boundaryBytes = textEncoder.encode('--' + boundary + CRLF);\n  const footerBytes = textEncoder.encode('--' + boundary + '--' + CRLF);\n  let contentLength = footerBytes.byteLength;\n\n  const parts = Array.from(form.entries()).map(([name, value]) => {\n    const part = new FormDataPart(name, value);\n    contentLength += part.size;\n    return part;\n  });\n\n  contentLength += boundaryBytes.byteLength * parts.length;\n\n  contentLength = utils.toFiniteNumber(contentLength);\n\n  const computedHeaders = {\n    'Content-Type': `multipart/form-data; boundary=${boundary}`\n  }\n\n  if (Number.isFinite(contentLength)) {\n    computedHeaders['Content-Length'] = contentLength;\n  }\n\n  headersHandler && headersHandler(computedHeaders);\n\n  return Readable.from((async function *() {\n    for(const part of parts) {\n      yield boundaryBytes;\n      yield* part.encode();\n    }\n\n    yield footerBytes;\n  })());\n};\n\nexport default formDataToStream;\n","import utils from '../utils.js';\nimport httpAdapter from './http.js';\nimport xhrAdapter from './xhr.js';\nimport * as fetchAdapter from './fetch.js';\nimport AxiosError from \"../core/AxiosError.js\";\n\n/**\n * Known adapters mapping.\n * Provides environment-specific adapters for Axios:\n * - `http` for Node.js\n * - `xhr` for browsers\n * - `fetch` for fetch API-based requests\n * \n * @type {Object<string, Function|Object>}\n */\nconst knownAdapters = {\n  http: httpAdapter,\n  xhr: xhrAdapter,\n  fetch: {\n    get: fetchAdapter.getFetch,\n  }\n};\n\n// Assign adapter names for easier debugging and identification\nutils.forEach(knownAdapters, (fn, value) => {\n  if (fn) {\n    try {\n      Object.defineProperty(fn, 'name', { value });\n    } catch (e) {\n      // eslint-disable-next-line no-empty\n    }\n    Object.defineProperty(fn, 'adapterName', { value });\n  }\n});\n\n/**\n * Render a rejection reason string for unknown or unsupported adapters\n * \n * @param {string} reason\n * @returns {string}\n */\nconst renderReason = (reason) => `- ${reason}`;\n\n/**\n * Check if the adapter is resolved (function, null, or false)\n * \n * @param {Function|null|false} adapter\n * @returns {boolean}\n */\nconst isResolvedHandle = (adapter) => utils.isFunction(adapter) || adapter === null || adapter === false;\n\n/**\n * Get the first suitable adapter from the provided list.\n * Tries each adapter in order until a supported one is found.\n * Throws an AxiosError if no adapter is suitable.\n * \n * @param {Array<string|Function>|string|Function} adapters - Adapter(s) by name or function.\n * @param {Object} config - Axios request configuration\n * @throws {AxiosError} If no suitable adapter is available\n * @returns {Function} The resolved adapter function\n */\nfunction getAdapter(adapters, config) {\n  adapters = utils.isArray(adapters) ? adapters : [adapters];\n\n  const { length } = adapters;\n  let nameOrAdapter;\n  let adapter;\n\n  const rejectedReasons = {};\n\n  for (let i = 0; i < length; i++) {\n    nameOrAdapter = adapters[i];\n    let id;\n\n    adapter = nameOrAdapter;\n\n    if (!isResolvedHandle(nameOrAdapter)) {\n      adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];\n\n      if (adapter === undefined) {\n        throw new AxiosError(`Unknown adapter '${id}'`);\n      }\n    }\n\n    if (adapter && (utils.isFunction(adapter) || (adapter = adapter.get(config)))) {\n      break;\n    }\n\n    rejectedReasons[id || '#' + i] = adapter;\n  }\n\n  if (!adapter) {\n    const reasons = Object.entries(rejectedReasons)\n      .map(([id, state]) => `adapter ${id} ` +\n        (state === false ? 'is not supported by the environment' : 'is not available in the build')\n      );\n\n    let s = length ?\n      (reasons.length > 1 ? 'since :\\n' + reasons.map(renderReason).join('\\n') : ' ' + renderReason(reasons[0])) :\n      'as no adapter specified';\n\n    throw new AxiosError(\n      `There is no suitable adapter to dispatch the request ` + s,\n      'ERR_NOT_SUPPORT'\n    );\n  }\n\n  return adapter;\n}\n\n/**\n * Exports Axios adapters and utility to resolve an adapter\n */\nexport default {\n  /**\n   * Resolve an adapter from a list of adapter names or functions.\n   * @type {Function}\n   */\n  getAdapter,\n\n  /**\n   * Exposes all known adapters\n   * @type {Object<string, Function|Object>}\n   */\n  adapters: knownAdapters\n};\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/util/assertPresence.ts","/**\n * Generated by orval v7.6.0 \n * Do not edit manually.\n * Coinbase Developer Platform APIs\n * The Coinbase Developer Platform APIs - leading the world's transition onchain.\n * OpenAPI spec version: 2.0.0\n */\nimport type {\n  CreateEvmSwapQuoteBody,\n  CreateSwapQuoteResponseWrapper,\n  GetEvmSwapPriceParams,\n  GetSwapPriceResponseWrapper,\n} from \"../coinbaseDeveloperPlatformAPIs.schemas.js\";\n\nimport { cdpApiClient } from \"../../cdpApiClient.js\";\n\ntype SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];\n\n/**\n * Get a price estimate for a swap between two tokens on an EVM network.\n * @summary Get a price estimate for a swap\n */\nexport const getEvmSwapPrice = (\n  params: GetEvmSwapPriceParams,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<GetSwapPriceResponseWrapper>(\n    { url: `/v2/evm/swaps/quote`, method: \"GET\", params },\n    options,\n  );\n};\n/**\n * Create a swap quote, which includes the payload to sign as well as the transaction data needed to execute the swap. The developer is responsible for signing the payload and submitting the transaction to the network in order to execute the swap.\n * @summary Create a swap quote\n */\nexport const createEvmSwapQuote = (\n  createEvmSwapQuoteBody: CreateEvmSwapQuoteBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<CreateSwapQuoteResponseWrapper>(\n    {\n      url: `/v2/evm/swaps`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: createEvmSwapQuoteBody,\n    },\n    options,\n  );\n};\nexport type GetEvmSwapPriceResult = NonNullable<Awaited<ReturnType<typeof getEvmSwapPrice>>>;\nexport type CreateEvmSwapQuoteResult = NonNullable<Awaited<ReturnType<typeof createEvmSwapQuote>>>;\n","import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { SignTransactionErrorType } from '../../accounts/utils/signTransaction.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  AccountNotFoundError,\n  type AccountNotFoundErrorType,\n  AccountTypeNotSupportedError,\n  type AccountTypeNotSupportedErrorType,\n} from '../../errors/account.js'\nimport { BaseError } from '../../errors/base.js'\nimport {\n  TransactionReceiptRevertedError,\n  type TransactionReceiptRevertedErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type { GetTransactionRequestKzgParameter } from '../../types/kzg.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport {\n  type RecoverAuthorizationAddressErrorType,\n  recoverAuthorizationAddress,\n} from '../../utils/authorization/recoverAuthorizationAddress.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type AssertCurrentChainErrorType,\n  assertCurrentChain,\n} from '../../utils/chain/assertCurrentChain.js'\nimport {\n  type GetTransactionErrorReturnType,\n  getTransactionError,\n} from '../../utils/errors/getTransactionError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { LruMap } from '../../utils/lru.js'\nimport {\n  type AssertRequestErrorType,\n  type AssertRequestParameters,\n  assertRequest,\n} from '../../utils/transaction/assertRequest.js'\nimport { type GetChainIdErrorType, getChainId } from '../public/getChainId.js'\nimport {\n  type WaitForTransactionReceiptErrorType,\n  waitForTransactionReceipt,\n} from '../public/waitForTransactionReceipt.js'\nimport {\n  defaultParameters,\n  type PrepareTransactionRequestErrorType,\n  prepareTransactionRequest,\n} from './prepareTransactionRequest.js'\nimport {\n  type SendRawTransactionSyncErrorType,\n  type SendRawTransactionSyncReturnType,\n  sendRawTransactionSync,\n} from './sendRawTransactionSync.js'\n\nconst supportsWalletNamespace = new LruMap<boolean>(128)\n\nexport type SendTransactionSyncRequest<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  ///\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'> &\n  GetTransactionRequestKzgParameter\n\nexport type SendTransactionSyncParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  request extends SendTransactionSyncRequest<\n    chain,\n    chainOverride\n  > = SendTransactionSyncRequest<chain, chainOverride>,\n> = request &\n  GetAccountParameter<account, Account | Address, true, true> &\n  GetChainParameter<chain, chainOverride> &\n  GetTransactionRequestKzgParameter<request> & {\n    /** Polling interval (ms) to poll for the transaction receipt. @default client.pollingInterval */\n    pollingInterval?: number | undefined\n    /** Whether to throw an error if the transaction was detected as reverted. @default true */\n    throwOnReceiptRevert?: boolean | undefined\n    /** Timeout (ms) to wait for a response. @default Math.max(chain.blockTime * 3, 5_000) */\n    timeout?: number | undefined\n  }\n\nexport type SendTransactionSyncReturnType<\n  chain extends Chain | undefined = Chain | undefined,\n> = SendRawTransactionSyncReturnType<chain>\n\nexport type SendTransactionSyncErrorType =\n  | ParseAccountErrorType\n  | GetTransactionErrorReturnType<\n      | AccountNotFoundErrorType\n      | AccountTypeNotSupportedErrorType\n      | AssertCurrentChainErrorType\n      | AssertRequestErrorType\n      | GetChainIdErrorType\n      | PrepareTransactionRequestErrorType\n      | SendRawTransactionSyncErrorType\n      | RecoverAuthorizationAddressErrorType\n      | SignTransactionErrorType\n      | TransactionReceiptRevertedErrorType\n      | RequestErrorType\n    >\n  | WaitForTransactionReceiptErrorType\n  | ErrorType\n\n/**\n * Creates, signs, and sends a new transaction to the network synchronously.\n * Returns the transaction receipt.\n *\n * @param client - Client to use\n * @param parameters - {@link SendTransactionSyncParameters}\n * @returns The transaction receipt. {@link SendTransactionSyncReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendTransactionSync } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const receipt = await sendTransactionSync(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { sendTransactionSync } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const receipt = await sendTransactionSync(client, {\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n */\nexport async function sendTransactionSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  const request extends SendTransactionSyncRequest<chain, chainOverride>,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SendTransactionSyncParameters<\n    chain,\n    account,\n    chainOverride,\n    request\n  >,\n): Promise<SendTransactionSyncReturnType<chain>> {\n  const {\n    account: account_ = client.account,\n    chain = client.chain,\n    accessList,\n    authorizationList,\n    blobs,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    pollingInterval,\n    throwOnReceiptRevert,\n    type,\n    value,\n    ...rest\n  } = parameters\n  const timeout =\n    parameters.timeout ?? Math.max((chain?.blockTime ?? 0) * 3, 5_000)\n\n  if (typeof account_ === 'undefined')\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/sendTransactionSync',\n    })\n  const account = account_ ? parseAccount(account_) : null\n\n  try {\n    assertRequest(parameters as AssertRequestParameters)\n\n    const to = await (async () => {\n      // If `to` exists on the parameters, use that.\n      if (parameters.to) return parameters.to\n\n      // If `to` is null, we are sending a deployment transaction.\n      if (parameters.to === null) return undefined\n\n      // If no `to` exists, and we are sending a EIP-7702 transaction, use the\n      // address of the first authorization in the list.\n      if (authorizationList && authorizationList.length > 0)\n        return await recoverAuthorizationAddress({\n          authorization: authorizationList[0],\n        }).catch(() => {\n          throw new BaseError(\n            '`to` is required. Could not infer from `authorizationList`.',\n          )\n        })\n\n      // Otherwise, we are sending a deployment transaction.\n      return undefined\n    })()\n\n    if (account?.type === 'json-rpc' || account === null) {\n      let chainId: number | undefined\n      if (chain !== null) {\n        chainId = await getAction(client, getChainId, 'getChainId')({})\n        assertCurrentChain({\n          currentChainId: chainId,\n          chain,\n        })\n      }\n\n      const chainFormat = client.chain?.formatters?.transactionRequest?.format\n      const format = chainFormat || formatTransactionRequest\n\n      const request = format(\n        {\n          // Pick out extra data that might exist on the chain's transaction request type.\n          ...extract(rest, { format: chainFormat }),\n          accessList,\n          account,\n          authorizationList,\n          blobs,\n          chainId,\n          data,\n          gas,\n          gasPrice,\n          maxFeePerBlobGas,\n          maxFeePerGas,\n          maxPriorityFeePerGas,\n          nonce,\n          to,\n          type,\n          value,\n        } as TransactionRequest,\n        'sendTransaction',\n      )\n\n      const isWalletNamespaceSupported = supportsWalletNamespace.get(client.uid)\n      const method = isWalletNamespaceSupported\n        ? 'wallet_sendTransaction'\n        : 'eth_sendTransaction'\n\n      const hash = await (async () => {\n        try {\n          return await client.request(\n            {\n              method,\n              params: [request],\n            },\n            { retryCount: 0 },\n          )\n        } catch (e) {\n          if (isWalletNamespaceSupported === false) throw e\n\n          const error = e as BaseError\n          // If the transport does not support the method or input, attempt to use the\n          // `wallet_sendTransaction` method.\n          if (\n            error.name === 'InvalidInputRpcError' ||\n            error.name === 'InvalidParamsRpcError' ||\n            error.name === 'MethodNotFoundRpcError' ||\n            error.name === 'MethodNotSupportedRpcError'\n          ) {\n            return (await client\n              .request(\n                {\n                  method: 'wallet_sendTransaction',\n                  params: [request],\n                },\n                { retryCount: 0 },\n              )\n              .then((hash) => {\n                supportsWalletNamespace.set(client.uid, true)\n                return hash\n              })\n              .catch((e) => {\n                const walletNamespaceError = e as BaseError\n                if (\n                  walletNamespaceError.name === 'MethodNotFoundRpcError' ||\n                  walletNamespaceError.name === 'MethodNotSupportedRpcError'\n                ) {\n                  supportsWalletNamespace.set(client.uid, false)\n                  throw error\n                }\n\n                throw walletNamespaceError\n              })) as never\n          }\n\n          throw error\n        }\n      })()\n\n      const receipt = await getAction(\n        client,\n        waitForTransactionReceipt,\n        'waitForTransactionReceipt',\n      )({\n        checkReplacement: false,\n        hash,\n        pollingInterval,\n        timeout,\n      })\n      if (throwOnReceiptRevert && receipt.status === 'reverted')\n        throw new TransactionReceiptRevertedError({ receipt })\n      return receipt\n    }\n\n    if (account?.type === 'local') {\n      // Prepare the request for signing (assign appropriate fees, etc.)\n      const request = await getAction(\n        client,\n        prepareTransactionRequest,\n        'prepareTransactionRequest',\n      )({\n        account,\n        accessList,\n        authorizationList,\n        blobs,\n        chain,\n        data,\n        gas,\n        gasPrice,\n        maxFeePerBlobGas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        nonceManager: account.nonceManager,\n        parameters: [...defaultParameters, 'sidecars'],\n        type,\n        value,\n        ...rest,\n        to,\n      } as any)\n\n      const serializer = chain?.serializers?.transaction\n      const serializedTransaction = (await account.signTransaction(request, {\n        serializer,\n      })) as Hash\n      return (await getAction(\n        client,\n        sendRawTransactionSync,\n        'sendRawTransactionSync',\n      )({\n        serializedTransaction,\n        throwOnReceiptRevert,\n      })) as never\n    }\n\n    if (account?.type === 'smart')\n      throw new AccountTypeNotSupportedError({\n        metaMessages: [\n          'Consider using the `sendUserOperation` Action instead.',\n        ],\n        docsPath: '/docs/actions/bundler/sendUserOperation',\n        type: 'smart',\n      })\n\n    throw new AccountTypeNotSupportedError({\n      docsPath: '/docs/actions/wallet/sendTransactionSync',\n      type: (account as any)?.type,\n    })\n  } catch (err) {\n    if (err instanceof AccountTypeNotSupportedError) throw err\n    throw getTransactionError(err as BaseError, {\n      ...parameters,\n      account,\n      chain: parameters.chain || undefined,\n    })\n  }\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/sign/base-account/utils/createSubAccountSigner.ts","export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n\nexport const maxInt8 = 2n ** (8n - 1n) - 1n\nexport const maxInt16 = 2n ** (16n - 1n) - 1n\nexport const maxInt24 = 2n ** (24n - 1n) - 1n\nexport const maxInt32 = 2n ** (32n - 1n) - 1n\nexport const maxInt40 = 2n ** (40n - 1n) - 1n\nexport const maxInt48 = 2n ** (48n - 1n) - 1n\nexport const maxInt56 = 2n ** (56n - 1n) - 1n\nexport const maxInt64 = 2n ** (64n - 1n) - 1n\nexport const maxInt72 = 2n ** (72n - 1n) - 1n\nexport const maxInt80 = 2n ** (80n - 1n) - 1n\nexport const maxInt88 = 2n ** (88n - 1n) - 1n\nexport const maxInt96 = 2n ** (96n - 1n) - 1n\nexport const maxInt104 = 2n ** (104n - 1n) - 1n\nexport const maxInt112 = 2n ** (112n - 1n) - 1n\nexport const maxInt120 = 2n ** (120n - 1n) - 1n\nexport const maxInt128 = 2n ** (128n - 1n) - 1n\nexport const maxInt136 = 2n ** (136n - 1n) - 1n\nexport const maxInt144 = 2n ** (144n - 1n) - 1n\nexport const maxInt152 = 2n ** (152n - 1n) - 1n\nexport const maxInt160 = 2n ** (160n - 1n) - 1n\nexport const maxInt168 = 2n ** (168n - 1n) - 1n\nexport const maxInt176 = 2n ** (176n - 1n) - 1n\nexport const maxInt184 = 2n ** (184n - 1n) - 1n\nexport const maxInt192 = 2n ** (192n - 1n) - 1n\nexport const maxInt200 = 2n ** (200n - 1n) - 1n\nexport const maxInt208 = 2n ** (208n - 1n) - 1n\nexport const maxInt216 = 2n ** (216n - 1n) - 1n\nexport const maxInt224 = 2n ** (224n - 1n) - 1n\nexport const maxInt232 = 2n ** (232n - 1n) - 1n\nexport const maxInt240 = 2n ** (240n - 1n) - 1n\nexport const maxInt248 = 2n ** (248n - 1n) - 1n\nexport const maxInt256 = 2n ** (256n - 1n) - 1n\n\nexport const minInt8 = -(2n ** (8n - 1n))\nexport const minInt16 = -(2n ** (16n - 1n))\nexport const minInt24 = -(2n ** (24n - 1n))\nexport const minInt32 = -(2n ** (32n - 1n))\nexport const minInt40 = -(2n ** (40n - 1n))\nexport const minInt48 = -(2n ** (48n - 1n))\nexport const minInt56 = -(2n ** (56n - 1n))\nexport const minInt64 = -(2n ** (64n - 1n))\nexport const minInt72 = -(2n ** (72n - 1n))\nexport const minInt80 = -(2n ** (80n - 1n))\nexport const minInt88 = -(2n ** (88n - 1n))\nexport const minInt96 = -(2n ** (96n - 1n))\nexport const minInt104 = -(2n ** (104n - 1n))\nexport const minInt112 = -(2n ** (112n - 1n))\nexport const minInt120 = -(2n ** (120n - 1n))\nexport const minInt128 = -(2n ** (128n - 1n))\nexport const minInt136 = -(2n ** (136n - 1n))\nexport const minInt144 = -(2n ** (144n - 1n))\nexport const minInt152 = -(2n ** (152n - 1n))\nexport const minInt160 = -(2n ** (160n - 1n))\nexport const minInt168 = -(2n ** (168n - 1n))\nexport const minInt176 = -(2n ** (176n - 1n))\nexport const minInt184 = -(2n ** (184n - 1n))\nexport const minInt192 = -(2n ** (192n - 1n))\nexport const minInt200 = -(2n ** (200n - 1n))\nexport const minInt208 = -(2n ** (208n - 1n))\nexport const minInt216 = -(2n ** (216n - 1n))\nexport const minInt224 = -(2n ** (224n - 1n))\nexport const minInt232 = -(2n ** (232n - 1n))\nexport const minInt240 = -(2n ** (240n - 1n))\nexport const minInt248 = -(2n ** (248n - 1n))\nexport const minInt256 = -(2n ** (256n - 1n))\n\nexport const maxUint8 = 2n ** 8n - 1n\nexport const maxUint16 = 2n ** 16n - 1n\nexport const maxUint24 = 2n ** 24n - 1n\nexport const maxUint32 = 2n ** 32n - 1n\nexport const maxUint40 = 2n ** 40n - 1n\nexport const maxUint48 = 2n ** 48n - 1n\nexport const maxUint56 = 2n ** 56n - 1n\nexport const maxUint64 = 2n ** 64n - 1n\nexport const maxUint72 = 2n ** 72n - 1n\nexport const maxUint80 = 2n ** 80n - 1n\nexport const maxUint88 = 2n ** 88n - 1n\nexport const maxUint96 = 2n ** 96n - 1n\nexport const maxUint104 = 2n ** 104n - 1n\nexport const maxUint112 = 2n ** 112n - 1n\nexport const maxUint120 = 2n ** 120n - 1n\nexport const maxUint128 = 2n ** 128n - 1n\nexport const maxUint136 = 2n ** 136n - 1n\nexport const maxUint144 = 2n ** 144n - 1n\nexport const maxUint152 = 2n ** 152n - 1n\nexport const maxUint160 = 2n ** 160n - 1n\nexport const maxUint168 = 2n ** 168n - 1n\nexport const maxUint176 = 2n ** 176n - 1n\nexport const maxUint184 = 2n ** 184n - 1n\nexport const maxUint192 = 2n ** 192n - 1n\nexport const maxUint200 = 2n ** 200n - 1n\nexport const maxUint208 = 2n ** 208n - 1n\nexport const maxUint216 = 2n ** 216n - 1n\nexport const maxUint224 = 2n ** 224n - 1n\nexport const maxUint232 = 2n ** 232n - 1n\nexport const maxUint240 = 2n ** 240n - 1n\nexport const maxUint248 = 2n ** 248n - 1n\nexport const maxUint256 = 2n ** 256n - 1n\n","/**\n * Generated by orval v7.6.0 \n * Do not edit manually.\n * Coinbase Developer Platform APIs\n * The Coinbase Developer Platform APIs - leading the world's transition onchain.\n * OpenAPI spec version: 2.0.0\n */\nimport type {\n  CreateEvmAccountBody,\n  EIP712Message,\n  EvmAccount,\n  ExportEvmAccount200,\n  ExportEvmAccountBody,\n  ExportEvmAccountByName200,\n  ExportEvmAccountByNameBody,\n  ImportEvmAccountBody,\n  ListEvmAccounts200,\n  ListEvmAccountsParams,\n  SendEvmTransaction200,\n  SendEvmTransactionBody,\n  SignEvmHash200,\n  SignEvmHashBody,\n  SignEvmMessage200,\n  SignEvmMessageBody,\n  SignEvmTransaction200,\n  SignEvmTransactionBody,\n  SignEvmTypedData200,\n  UpdateEvmAccountBody,\n} from \"../coinbaseDeveloperPlatformAPIs.schemas.js\";\n\nimport { cdpApiClient } from \"../../cdpApiClient.js\";\n\ntype SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];\n\n/**\n * Lists the EVM accounts belonging to the developer's CDP Project.\nThe response is paginated, and by default, returns 20 accounts per page.\n * @summary List EVM accounts\n */\nexport const listEvmAccounts = (\n  params?: ListEvmAccountsParams,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<ListEvmAccounts200>(\n    { url: `/v2/evm/accounts`, method: \"GET\", params },\n    options,\n  );\n};\n/**\n * Creates a new EVM account.\n * @summary Create an EVM account\n */\nexport const createEvmAccount = (\n  createEvmAccountBody?: CreateEvmAccountBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<EvmAccount>(\n    {\n      url: `/v2/evm/accounts`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: createEvmAccountBody,\n    },\n    options,\n  );\n};\n/**\n * Gets an EVM account by its address.\n * @summary Get an EVM account by address\n */\nexport const getEvmAccount = (address: string, options?: SecondParameter<typeof cdpApiClient>) => {\n  return cdpApiClient<EvmAccount>({ url: `/v2/evm/accounts/${address}`, method: \"GET\" }, options);\n};\n/**\n * Updates an existing EVM account. Use this to update the account's name or account-level policy.\n * @summary Update an EVM account\n */\nexport const updateEvmAccount = (\n  address: string,\n  updateEvmAccountBody: UpdateEvmAccountBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<EvmAccount>(\n    {\n      url: `/v2/evm/accounts/${address}`,\n      method: \"PUT\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: updateEvmAccountBody,\n    },\n    options,\n  );\n};\n/**\n * Gets an EVM account by its name.\n * @summary Get an EVM account by name\n */\nexport const getEvmAccountByName = (\n  name: string,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<EvmAccount>(\n    { url: `/v2/evm/accounts/by-name/${name}`, method: \"GET\" },\n    options,\n  );\n};\n/**\n * Signs a transaction with the given EVM account and sends it to the indicated supported network. This API handles nonce management and gas estimation, leaving the developer to provide only the minimal set of fields necessary to send the transaction. The transaction should be serialized as a hex string using [RLP](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/).\n\nThe transaction must be an [EIP-1559 dynamic fee transaction](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md).\n\n\n**Transaction fields and API behavior**\n\n- `to` *(Required)*: The address of the contract or account to send the transaction to.\n- `chainId` *(Ignored)*: The value of the `chainId` field in the transaction is ignored.\n  The transaction will be sent to the network indicated by the `network` field in the request body.\n\n- `nonce` *(Optional)*: The nonce to use for the transaction. If not provided, the API will assign\n   a nonce to the transaction based on the current state of the account.\n\n- `maxPriorityFeePerGas` *(Optional)*: The maximum priority fee per gas to use for the transaction.\n   If not provided, the API will estimate a value based on current network conditions.\n\n- `maxFeePerGas` *(Optional)*: The maximum fee per gas to use for the transaction.\n   If not provided, the API will estimate a value based on current network conditions.\n\n- `gasLimit` *(Optional)*: The gas limit to use for the transaction. If not provided, the API will estimate a value\n  based on the `to` and `data` fields of the transaction.\n\n- `value` *(Optional)*: The amount of ETH, in wei, to send with the transaction.\n- `data` *(Optional)*: The data to send with the transaction; only used for contract calls.\n- `accessList` *(Optional)*: The access list to use for the transaction.\n * @summary Send a transaction\n */\nexport const sendEvmTransaction = (\n  address: string,\n  sendEvmTransactionBody: SendEvmTransactionBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<SendEvmTransaction200>(\n    {\n      url: `/v2/evm/accounts/${address}/send/transaction`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: sendEvmTransactionBody,\n    },\n    options,\n  );\n};\n/**\n * Signs a transaction with the given EVM account.\nThe transaction should be serialized as a hex string using [RLP](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/).\n\nThe transaction must be an [EIP-1559 dynamic fee transaction](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md). The developer is responsible for ensuring that the unsigned transaction is valid, as the API will not validate the transaction.\n * @summary Sign a transaction\n */\nexport const signEvmTransaction = (\n  address: string,\n  signEvmTransactionBody: SignEvmTransactionBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<SignEvmTransaction200>(\n    {\n      url: `/v2/evm/accounts/${address}/sign/transaction`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: signEvmTransactionBody,\n    },\n    options,\n  );\n};\n/**\n * Signs an arbitrary 32 byte hash with the given EVM account.\n * @summary Sign a hash\n */\nexport const signEvmHash = (\n  address: string,\n  signEvmHashBody: SignEvmHashBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<SignEvmHash200>(\n    {\n      url: `/v2/evm/accounts/${address}/sign`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: signEvmHashBody,\n    },\n    options,\n  );\n};\n/**\n * Signs an [EIP-191](https://eips.ethereum.org/EIPS/eip-191) message with the given EVM account.\n\nPer the specification, the message in the request body is prepended with `0x19 <0x45 (E)> <thereum Signed Message:\\n\" + len(message)>` before being signed.\n * @summary Sign an EIP-191 message\n */\nexport const signEvmMessage = (\n  address: string,\n  signEvmMessageBody: SignEvmMessageBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<SignEvmMessage200>(\n    {\n      url: `/v2/evm/accounts/${address}/sign/message`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: signEvmMessageBody,\n    },\n    options,\n  );\n};\n/**\n * Signs [EIP-712](https://eips.ethereum.org/EIPS/eip-712) typed data with the given EVM account.\n * @summary Sign EIP-712 typed data\n */\nexport const signEvmTypedData = (\n  address: string,\n  eIP712Message: EIP712Message,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<SignEvmTypedData200>(\n    {\n      url: `/v2/evm/accounts/${address}/sign/typed-data`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: eIP712Message,\n    },\n    options,\n  );\n};\n/**\n * Import an existing EVM account into the developer's CDP Project. This API should be called from the [CDP SDK](https://github.com/coinbase/cdp-sdk) to ensure that the associated private key is properly encrypted.\n * @summary Import an EVM account\n */\nexport const importEvmAccount = (\n  importEvmAccountBody: ImportEvmAccountBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<EvmAccount>(\n    {\n      url: `/v2/evm/accounts/import`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: importEvmAccountBody,\n    },\n    options,\n  );\n};\n/**\n * Export an existing EVM account's private key. It is important to store the private key in a secure place after it's exported.\n * @summary Export an EVM account\n */\nexport const exportEvmAccount = (\n  address: string,\n  exportEvmAccountBody: ExportEvmAccountBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<ExportEvmAccount200>(\n    {\n      url: `/v2/evm/accounts/${address}/export`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: exportEvmAccountBody,\n    },\n    options,\n  );\n};\n/**\n * Export an existing EVM account's private key by its name. It is important to store the private key in a secure place after it's exported.\n * @summary Export an EVM account by name\n */\nexport const exportEvmAccountByName = (\n  name: string,\n  exportEvmAccountByNameBody: ExportEvmAccountByNameBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<ExportEvmAccountByName200>(\n    {\n      url: `/v2/evm/accounts/export/by-name/${name}`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: exportEvmAccountByNameBody,\n    },\n    options,\n  );\n};\nexport type ListEvmAccountsResult = NonNullable<Awaited<ReturnType<typeof listEvmAccounts>>>;\nexport type CreateEvmAccountResult = NonNullable<Awaited<ReturnType<typeof createEvmAccount>>>;\nexport type GetEvmAccountResult = NonNullable<Awaited<ReturnType<typeof getEvmAccount>>>;\nexport type UpdateEvmAccountResult = NonNullable<Awaited<ReturnType<typeof updateEvmAccount>>>;\nexport type GetEvmAccountByNameResult = NonNullable<\n  Awaited<ReturnType<typeof getEvmAccountByName>>\n>;\nexport type SendEvmTransactionResult = NonNullable<Awaited<ReturnType<typeof sendEvmTransaction>>>;\nexport type SignEvmTransactionResult = NonNullable<Awaited<ReturnType<typeof signEvmTransaction>>>;\nexport type SignEvmHashResult = NonNullable<Awaited<ReturnType<typeof signEvmHash>>>;\nexport type SignEvmMessageResult = NonNullable<Awaited<ReturnType<typeof signEvmMessage>>>;\nexport type SignEvmTypedDataResult = NonNullable<Awaited<ReturnType<typeof signEvmTypedData>>>;\nexport type ImportEvmAccountResult = NonNullable<Awaited<ReturnType<typeof importEvmAccount>>>;\nexport type ExportEvmAccountResult = NonNullable<Awaited<ReturnType<typeof exportEvmAccount>>>;\nexport type ExportEvmAccountByNameResult = NonNullable<\n  Awaited<ReturnType<typeof exportEvmAccountByName>>\n>;\n","import type { AbiStateMutability } from '../../abi.js'\nimport { execTyped } from '../../regex.js'\nimport type {\n  EventModifier,\n  FunctionModifier,\n  Modifier,\n} from '../types/signatures.js'\n\n// https://regexr.com/7gmok\nconst errorSignatureRegex =\n  /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/\nexport function isErrorSignature(signature: string) {\n  return errorSignatureRegex.test(signature)\n}\nexport function execErrorSignature(signature: string) {\n  return execTyped<{ name: string; parameters: string }>(\n    errorSignatureRegex,\n    signature,\n  )\n}\n\n// https://regexr.com/7gmoq\nconst eventSignatureRegex =\n  /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/\nexport function isEventSignature(signature: string) {\n  return eventSignatureRegex.test(signature)\n}\nexport function execEventSignature(signature: string) {\n  return execTyped<{ name: string; parameters: string }>(\n    eventSignatureRegex,\n    signature,\n  )\n}\n\n// https://regexr.com/7gmot\nconst functionSignatureRegex =\n  /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\\s?\\((?<returns>.*?)\\))?$/\nexport function isFunctionSignature(signature: string) {\n  return functionSignatureRegex.test(signature)\n}\nexport function execFunctionSignature(signature: string) {\n  return execTyped<{\n    name: string\n    parameters: string\n    stateMutability?: AbiStateMutability\n    returns?: string\n  }>(functionSignatureRegex, signature)\n}\n\n// https://regexr.com/7gmp3\nconst structSignatureRegex =\n  /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \\{(?<properties>.*?)\\}$/\nexport function isStructSignature(signature: string) {\n  return structSignatureRegex.test(signature)\n}\nexport function execStructSignature(signature: string) {\n  return execTyped<{ name: string; properties: string }>(\n    structSignatureRegex,\n    signature,\n  )\n}\n\n// https://regexr.com/78u01\nconst constructorSignatureRegex =\n  /^constructor\\((?<parameters>.*?)\\)(?:\\s(?<stateMutability>payable{1}))?$/\nexport function isConstructorSignature(signature: string) {\n  return constructorSignatureRegex.test(signature)\n}\nexport function execConstructorSignature(signature: string) {\n  return execTyped<{\n    parameters: string\n    stateMutability?: Extract<AbiStateMutability, 'payable'>\n  }>(constructorSignatureRegex, signature)\n}\n\n// https://regexr.com/7srtn\nconst fallbackSignatureRegex =\n  /^fallback\\(\\) external(?:\\s(?<stateMutability>payable{1}))?$/\nexport function isFallbackSignature(signature: string) {\n  return fallbackSignatureRegex.test(signature)\n}\n\n// https://regexr.com/78u1k\nconst receiveSignatureRegex = /^receive\\(\\) external payable$/\nexport function isReceiveSignature(signature: string) {\n  return receiveSignatureRegex.test(signature)\n}\n\nexport const modifiers = new Set<Modifier>([\n  'memory',\n  'indexed',\n  'storage',\n  'calldata',\n])\nexport const eventModifiers = new Set<EventModifier>(['indexed'])\nexport const functionModifiers = new Set<FunctionModifier>([\n  'calldata',\n  'memory',\n  'storage',\n])\n","import { chainConfig } from '../../op-stack/chainConfig.js'\nimport { defineChain } from '../../utils/chain/defineChain.js'\n\nconst sourceId = 11_155_111 // sepolia\n\nexport const optimismSepolia = /*#__PURE__*/ defineChain({\n  ...chainConfig,\n  id: 11155420,\n  name: 'OP Sepolia',\n  nativeCurrency: { name: 'Sepolia Ether', symbol: 'ETH', decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: ['https://sepolia.optimism.io'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Blockscout',\n      url: 'https://optimism-sepolia.blockscout.com',\n      apiUrl: 'https://optimism-sepolia.blockscout.com/api',\n    },\n  },\n  contracts: {\n    ...chainConfig.contracts,\n    disputeGameFactory: {\n      [sourceId]: {\n        address: '0x05F9613aDB30026FFd634f38e5C4dFd30a197Fa1',\n      },\n    },\n    l2OutputOracle: {\n      [sourceId]: {\n        address: '0x90E9c4f8a994a250F6aEfd61CAFb4F2e895D458F',\n      },\n    },\n    multicall3: {\n      address: '0xca11bde05977b3631167028862be2a173976ca11',\n      blockCreated: 1620204,\n    },\n    portal: {\n      [sourceId]: {\n        address: '0x16Fc5058F25648194471939df75CF27A2fdC48BC',\n      },\n    },\n    l1StandardBridge: {\n      [sourceId]: {\n        address: '0xFBb0621E0B23b5478B630BD55a5f21f67730B0F1',\n      },\n    },\n  },\n  testnet: true,\n  sourceId,\n})\n","/**\n * Generated by orval v7.6.0 \n * Do not edit manually.\n * Coinbase Developer Platform APIs\n * The Coinbase Developer Platform APIs - leading the world's transition onchain.\n * OpenAPI spec version: 2.0.0\n */\nimport type {\n  CreatePolicyBody,\n  ListPolicies200,\n  ListPoliciesParams,\n  Policy,\n  UpdatePolicyBody,\n} from \"../coinbaseDeveloperPlatformAPIs.schemas.js\";\n\nimport { cdpApiClient } from \"../../cdpApiClient.js\";\n\ntype SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];\n\n/**\n * Lists the policies belonging to the developer's CDP Project. Use the `scope` parameter to filter the policies by scope.\nThe response is paginated, and by default, returns 20 policies per page.\n * @summary List policies\n */\nexport const listPolicies = (\n  params?: ListPoliciesParams,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<ListPolicies200>(\n    { url: `/v2/policy-engine/policies`, method: \"GET\", params },\n    options,\n  );\n};\n/**\n * Create a policy that can be used to govern the behavior of accounts.\n * @summary Create a policy\n */\nexport const createPolicy = (\n  createPolicyBody: CreatePolicyBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<Policy>(\n    {\n      url: `/v2/policy-engine/policies`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: createPolicyBody,\n    },\n    options,\n  );\n};\n/**\n * Get a policy by its ID.\n * @summary Get a policy by ID\n */\nexport const getPolicyById = (policyId: string, options?: SecondParameter<typeof cdpApiClient>) => {\n  return cdpApiClient<Policy>(\n    { url: `/v2/policy-engine/policies/${policyId}`, method: \"GET\" },\n    options,\n  );\n};\n/**\n * Delete a policy by its ID. This will have the effect of removing the policy from all accounts that are currently using it.\n * @summary Delete a policy\n */\nexport const deletePolicy = (policyId: string, options?: SecondParameter<typeof cdpApiClient>) => {\n  return cdpApiClient<void>(\n    { url: `/v2/policy-engine/policies/${policyId}`, method: \"DELETE\" },\n    options,\n  );\n};\n/**\n * Updates a policy by its ID. This will have the effect of applying the updated policy to all accounts that are currently using it.\n * @summary Update a policy\n */\nexport const updatePolicy = (\n  policyId: string,\n  updatePolicyBody: UpdatePolicyBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<Policy>(\n    {\n      url: `/v2/policy-engine/policies/${policyId}`,\n      method: \"PUT\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: updatePolicyBody,\n    },\n    options,\n  );\n};\nexport type ListPoliciesResult = NonNullable<Awaited<ReturnType<typeof listPolicies>>>;\nexport type CreatePolicyResult = NonNullable<Awaited<ReturnType<typeof createPolicy>>>;\nexport type GetPolicyByIdResult = NonNullable<Awaited<ReturnType<typeof getPolicyById>>>;\nexport type DeletePolicyResult = NonNullable<Awaited<ReturnType<typeof deletePolicy>>>;\nexport type UpdatePolicyResult = NonNullable<Awaited<ReturnType<typeof updatePolicy>>>;\n","import type { Address } from '@solana/addresses';\nimport { isSolanaError, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM, SolanaError } from '@solana/errors';\n\n/**\n * Identifies whether an error -- typically caused by a transaction failure -- is a custom program\n * error from the provided program address.\n *\n * @param transactionMessage The transaction message that failed to execute. Since the RPC response\n * only provides the index of the failed instruction, the transaction message is required to\n * determine its program address\n * @param programAddress The address of the program from which the error is expected to have\n * originated\n * @param code The expected error code of the custom program error. When provided, the function will\n * check that the custom program error code matches the given value.\n *\n * @example\n * ```ts\n * try {\n *     // Send and confirm your transaction.\n * } catch (error) {\n *     if (isProgramError(error, transactionMessage, myProgramAddress, 42)) {\n *         // Handle custom program error 42 from this program.\n *     } else if (isProgramError(error, transactionMessage, myProgramAddress)) {\n *         // Handle all other custom program errors from this program.\n *     } else {\n *         throw error;\n *     }\n * }\n * ```\n */\nexport function isProgramError<TProgramErrorCode extends number>(\n    error: unknown,\n    transactionMessage: { instructions: Record<number, { programAddress: Address }> },\n    programAddress: Address,\n    code?: TProgramErrorCode,\n): error is Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> &\n    SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> {\n    if (!isSolanaError(error, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM)) {\n        return false;\n    }\n    const instructionProgramAddress = transactionMessage.instructions[error.context.index]?.programAddress;\n    if (!instructionProgramAddress || instructionProgramAddress !== programAddress) {\n        return false;\n    }\n    return typeof code === 'undefined' || error.context.code === code;\n}\n","/**\n * An implementation of the Rust `Option<T>` type in JavaScript.\n *\n * In Rust, optional values are represented using `Option<T>`, which can be either:\n * - `Some(T)`, indicating a present value.\n * - `None`, indicating the absence of a value.\n *\n * In JavaScript, this is typically represented as `T | null`. However, this approach fails with nested options.\n * For example, `Option<Option<T>>` in Rust would translate to `T | null | null` in JavaScript, which is equivalent to `T | null`.\n * This means there is no way to differentiate between `Some(None)` and `None`, making nested options impossible.\n *\n * This `Option` type helps solve this by mirroring Rusts `Option<T>` type.\n *\n * ```ts\n * type Option<T> = Some<T> | None;\n * type Some<T> = { __option: 'Some'; value: T };\n * type None = { __option: 'None' };\n * ```\n *\n * @typeParam T - The type of the contained value.\n *\n * @example\n * Here's how you can create `Option` values.\n *\n * To improve developer experience, helper functions are available.\n * TypeScript can infer the type of `T` or it can be explicitly provided.\n *\n * ```ts\n * // Create an option with a value.\n * some('Hello World');\n * some<number | string>(123);\n *\n * // Create an empty option.\n * none();\n * none<number | string>();\n * ```\n *\n * @see {@link Some}\n * @see {@link None}\n * @see {@link some}\n * @see {@link none}\n */\nexport type Option<T> = None | Some<T>;\n\n/**\n * A flexible type that allows working with {@link Option} values or nullable values.\n *\n * It defines a looser type that can be used when encoding {@link Option | Options}.\n * This allows us to pass `null` or the nested value directly whilst still\n * supporting the Option type for use-cases that need more type safety.\n *\n * @typeParam T - The type of the contained value.\n *\n * @example\n * Accepting both `Option<T>` and `T | null` as input.\n * ```ts\n * function double(value: OptionOrNullable<number>) {\n *   const option = isOption(value) ? value : wrapNullable(value);\n *   return isSome(option) ? option.value * 2 : 'No value';\n * }\n *\n * double(42);       // 84\n * double(some(21)); // 42\n * double(none());   // \"No value\"\n * double(null);     // \"No value\"\n * ```\n *\n * @see {@link Option}\n * @see {@link isOption}\n * @see {@link wrapNullable}\n */\nexport type OptionOrNullable<T> = Option<T> | T | null;\n\n/**\n * Represents an {@link Option} that contains a value.\n *\n * This type mirrors Rusts `Some(T)`, indicating that a value is present.\n *\n * For more details, see {@link Option}.\n *\n * @typeParam T - The type of the contained value.\n *\n * @example\n * Creating a `Some` value.\n * ```ts\n * const value = some(42);\n * isSome(value); // true\n * isNone(value); // false\n * ```\n *\n * @see {@link Option}\n * @see {@link some}\n * @see {@link isSome}\n */\nexport type Some<T> = Readonly<{ __option: 'Some'; value: T }>;\n\n/**\n * Represents an {@link Option} that contains no value.\n *\n * This type mirrors Rusts `None`, indicating the absence of a value.\n *\n * For more details, see {@link Option}.\n *\n * @example\n * Creating a `None` value.\n * ```ts\n * const empty = none();\n * isNone(empty); // true\n * isSome(empty); // false\n * ```\n *\n * @see {@link Option}\n * @see {@link none}\n * @see {@link isNone}\n */\nexport type None = Readonly<{ __option: 'None' }>;\n\n/**\n * Creates a new {@link Option} that contains a value.\n *\n * This function explicitly wraps a value in an {@link Option} type.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param value - The value to wrap in an {@link Option}.\n * @returns An {@link Option} containing the provided value.\n *\n * @example\n * Wrapping a value in an `Option`.\n * ```ts\n * const option = some('Hello');\n * option.value;     // \"Hello\"\n * isOption(option); // true\n * isSome(option);   // true\n * isNone(option);   // false\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n */\nexport const some = <T>(value: T): Option<T> => ({ __option: 'Some', value });\n\n/**\n * Creates a new {@link Option} that contains no value.\n *\n * This function explicitly represents an absent value.\n *\n * @typeParam T - The type of the expected absent value.\n *\n * @returns An {@link Option} containing no value.\n *\n * @example\n * Creating an empty `Option`.\n * ```ts\n * const empty = none<number>();\n * isOption(empty); // true\n * isSome(empty);   // false\n * isNone(empty);   // true\n * ```\n *\n * @see {@link Option}\n * @see {@link None}\n */\nexport const none = <T>(): Option<T> => ({ __option: 'None' });\n\n/**\n * Checks whether the given value is an {@link Option}.\n *\n * This function determines whether an input follows the `Option<T>` structure.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param input - The value to check.\n * @returns `true` if the value is an {@link Option}, `false` otherwise.\n *\n * @example\n * Checking for `Option` values.\n * ```ts\n * isOption(some(42));        // true\n * isOption(none());          // true\n * isOption(42);              // false\n * isOption(null);            // false\n * isOption(\"anything else\"); // false\n * ```\n *\n * @see {@link Option}\n */\nexport const isOption = <T = unknown>(input: unknown): input is Option<T> =>\n    !!(\n        input &&\n        typeof input === 'object' &&\n        '__option' in input &&\n        ((input.__option === 'Some' && 'value' in input) || input.__option === 'None')\n    );\n\n/**\n * Checks whether the given {@link Option} contains a value.\n *\n * This function acts as a type guard, ensuring the value is a {@link Some}.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param option - The {@link Option} to check.\n * @returns `true` if the option is a {@link Some}, `false` otherwise.\n *\n * @example\n * Checking for `Some` values.\n * ```ts\n * isSome(some(42)); // true\n * isSome(none());   // false\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n */\nexport const isSome = <T>(option: Option<T>): option is Some<T> => option.__option === 'Some';\n\n/**\n * Checks whether the given {@link Option} contains no value.\n *\n * This function acts as a type guard, ensuring the value is a {@link None}.\n *\n * @typeParam T - The type of the expected value.\n *\n * @param option - The {@link Option} to check.\n * @returns `true` if the option is a {@link None}, `false` otherwise.\n *\n * @example\n * Checking for `None` values.\n * ```ts\n * isNone(some(42)); // false\n * isNone(none());   // true\n * ```\n *\n * @see {@link Option}\n * @see {@link None}\n */\nexport const isNone = <T>(option: Option<T>): option is None => option.__option === 'None';\n","/**\n * Generated by orval v7.6.0 \n * Do not edit manually.\n * Coinbase Developer Platform APIs\n * The Coinbase Developer Platform APIs - leading the world's transition onchain.\n * OpenAPI spec version: 2.0.0\n */\nimport type {\n  ListEvmTokenBalances200,\n  ListEvmTokenBalancesNetwork,\n  ListEvmTokenBalancesParams,\n} from \"../coinbaseDeveloperPlatformAPIs.schemas.js\";\n\nimport { cdpApiClient } from \"../../cdpApiClient.js\";\n\ntype SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];\n\n/**\n * Lists the token balances of an EVM address on a given network. The balances include ERC-20 tokens and the native gas token (usually ETH). The response is paginated, and by default, returns 20 balances per page.\n **Note:** This endpoint is still under development and does not yet provide strong freshness guarantees. Specifically, balances of new tokens can, on occasion, take up to ~30 seconds to appear, while balances of tokens already belonging to an address will generally be close to chain tip. Freshness of new token balances will improve over the coming weeks.\n * @summary List EVM token balances\n */\nexport const listEvmTokenBalances = (\n  network: ListEvmTokenBalancesNetwork,\n  address: string,\n  params?: ListEvmTokenBalancesParams,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<ListEvmTokenBalances200>(\n    { url: `/v2/evm/token-balances/${network}/${address}`, method: \"GET\", params },\n    options,\n  );\n};\nexport type ListEvmTokenBalancesResult = NonNullable<\n  Awaited<ReturnType<typeof listEvmTokenBalances>>\n>;\n","import { encode as b64u } from '../../util/base64url.js';\nimport { sign } from '../../lib/sign.js';\nimport { isDisjoint } from '../../lib/is_disjoint.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { concat, encode } from '../../lib/buffer_utils.js';\nimport { checkKeyType } from '../../lib/check_key_type.js';\nimport { validateCrit } from '../../lib/validate_crit.js';\nimport { normalizeKey } from '../../lib/normalize_key.js';\nexport class FlattenedSign {\n    #payload;\n    #protectedHeader;\n    #unprotectedHeader;\n    constructor(payload) {\n        if (!(payload instanceof Uint8Array)) {\n            throw new TypeError('payload must be an instance of Uint8Array');\n        }\n        this.#payload = payload;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this.#protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this.#protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this.#unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this.#unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        if (!this.#protectedHeader && !this.#unprotectedHeader) {\n            throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n        }\n        if (!isDisjoint(this.#protectedHeader, this.#unprotectedHeader)) {\n            throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this.#protectedHeader,\n            ...this.#unprotectedHeader,\n        };\n        const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options?.crit, this.#protectedHeader, joseHeader);\n        let b64 = true;\n        if (extensions.has('b64')) {\n            b64 = this.#protectedHeader.b64;\n            if (typeof b64 !== 'boolean') {\n                throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n            }\n        }\n        const { alg } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        checkKeyType(alg, key, 'sign');\n        let payloadS;\n        let payloadB;\n        if (b64) {\n            payloadS = b64u(this.#payload);\n            payloadB = encode(payloadS);\n        }\n        else {\n            payloadB = this.#payload;\n            payloadS = '';\n        }\n        let protectedHeaderString;\n        let protectedHeaderBytes;\n        if (this.#protectedHeader) {\n            protectedHeaderString = b64u(JSON.stringify(this.#protectedHeader));\n            protectedHeaderBytes = encode(protectedHeaderString);\n        }\n        else {\n            protectedHeaderString = '';\n            protectedHeaderBytes = new Uint8Array();\n        }\n        const data = concat(protectedHeaderBytes, encode('.'), payloadB);\n        const k = await normalizeKey(key, alg);\n        const signature = await sign(alg, k, data);\n        const jws = {\n            signature: b64u(signature),\n            payload: payloadS,\n        };\n        if (this.#unprotectedHeader) {\n            jws.header = this.#unprotectedHeader;\n        }\n        if (this.#protectedHeader) {\n            jws.protected = protectedHeaderString;\n        }\n        return jws;\n    }\n}\n","import { chainConfig } from '../../op-stack/chainConfig.js'\nimport { defineChain } from '../../utils/chain/defineChain.js'\n\nconst sourceId = 1 // Ethereum mainnet\n\nexport const redstone = defineChain({\n  ...chainConfig,\n  name: 'Redstone',\n  id: 690,\n  sourceId,\n  nativeCurrency: { decimals: 18, name: 'Ether', symbol: 'ETH' },\n  rpcUrls: {\n    default: {\n      http: ['https://rpc.redstonechain.com'],\n      webSocket: ['wss://rpc.redstonechain.com'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Blockscout',\n      url: 'https://explorer.redstone.xyz',\n    },\n  },\n  contracts: {\n    ...chainConfig.contracts,\n    multicall3: {\n      address: '0xca11bde05977b3631167028862be2a173976ca11',\n    },\n    portal: {\n      [sourceId]: {\n        address: '0xC7bCb0e8839a28A1cFadd1CF716de9016CdA51ae',\n        blockCreated: 19578329,\n      },\n    },\n    l2OutputOracle: {\n      [sourceId]: {\n        address: '0xa426A052f657AEEefc298b3B5c35a470e4739d69',\n        blockCreated: 19578337,\n      },\n    },\n    l1StandardBridge: {\n      [sourceId]: {\n        address: '0xc473ca7E02af24c129c2eEf51F2aDf0411c1Df69',\n        blockCreated: 19578331,\n      },\n    },\n  },\n})\n","import { defineChain } from '../../../utils/chain/defineChain.js'\n\nexport const skaleEuropa = /*#__PURE__*/ defineChain({\n  id: 2_046_399_126,\n  name: 'SKALE Europa Hub',\n  nativeCurrency: { name: 'sFUEL', symbol: 'sFUEL', decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: ['https://mainnet.skalenodes.com/v1/elated-tan-skat'],\n      webSocket: ['wss://mainnet.skalenodes.com/v1/ws/elated-tan-skat'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'SKALE Explorer',\n      url: 'https://elated-tan-skat.explorer.mainnet.skalenodes.com',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 3_113_495,\n    },\n  },\n})\n","/**\n * Generated by orval v7.6.0 \n * Do not edit manually.\n * Coinbase Developer Platform APIs\n * The Coinbase Developer Platform APIs - leading the world's transition onchain.\n * OpenAPI spec version: 2.0.0\n */\nimport type {\n  ListSolanaTokenBalances200,\n  ListSolanaTokenBalancesNetwork,\n  ListSolanaTokenBalancesParams,\n} from \"../coinbaseDeveloperPlatformAPIs.schemas.js\";\n\nimport { cdpApiClient } from \"../../cdpApiClient.js\";\n\ntype SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];\n\n/**\n * Lists the token balances of a Solana address on a given network. The balances include SPL tokens and the native SOL token. The response is paginated, and by default, returns 20 balances per page.\n\n**Note:** This endpoint is still under development and does not yet provide strong availability or freshness guarantees. Freshness and availability of new token balances will improve over the coming weeks.\n * @summary List Solana token balances\n */\nexport const listSolanaTokenBalances = (\n  network: ListSolanaTokenBalancesNetwork,\n  address: string,\n  params?: ListSolanaTokenBalancesParams,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<ListSolanaTokenBalances200>(\n    { url: `/v2/solana/token-balances/${network}/${address}`, method: \"GET\", params },\n    options,\n  );\n};\nexport type ListSolanaTokenBalancesResult = NonNullable<\n  Awaited<ReturnType<typeof listSolanaTokenBalances>>\n>;\n","import { defineChain } from '../../../utils/chain/defineChain.js'\n\nexport const skaleExorde = /*#__PURE__*/ defineChain({\n  id: 2_139_927_552,\n  name: 'Exorde Network',\n  nativeCurrency: { name: 'sFUEL', symbol: 'sFUEL', decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: ['https://mainnet.skalenodes.com/v1/light-vast-diphda'],\n      webSocket: ['wss://mainnet.skalenodes.com/v1/ws/light-vast-diphda'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'SKALE Explorer',\n      url: 'https://light-vast-diphda.explorer.mainnet.skalenodes.com',\n    },\n  },\n  contracts: {},\n})\n","/**\n * Generated by orval v7.6.0 \n * Do not edit manually.\n * Coinbase Developer Platform APIs\n * The Coinbase Developer Platform APIs - leading the world's transition onchain.\n * OpenAPI spec version: 2.0.0\n */\nimport type {\n  AccountTokenAddressesResponse,\n  ListDataTokenBalances200,\n  ListDataTokenBalancesParams,\n  ListEvmTokenBalancesNetwork,\n} from \"../coinbaseDeveloperPlatformAPIs.schemas.js\";\n\nimport { cdpApiClient } from \"../../cdpApiClient.js\";\n\ntype SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];\n\n/**\n * Retrieve all ERC-20 token contract addresses that an account has ever received tokens from. \nAnalyzes transaction history to discover token interactions.\n\n * @summary List token addresses for account\n */\nexport const listTokensForAccount = (\n  network: \"base\" | \"base-sepolia\",\n  address: string,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<AccountTokenAddressesResponse>(\n    { url: `/v2/data/evm/token-ownership/${network}/${address}`, method: \"GET\" },\n    options,\n  );\n};\n/**\n * Lists the token balances of an EVM address on a given network. The balances include ERC-20 tokens and the native gas token (usually ETH). The response is paginated, and by default, returns 20 balances per page.\n\n**Note:** This endpoint provides <1 second freshness from chain tip, <500ms response latency for wallets with reasonable token history, and 99.9% uptime for production use.\n * @summary List EVM token balances\n */\nexport const listDataTokenBalances = (\n  network: ListEvmTokenBalancesNetwork,\n  address: string,\n  params?: ListDataTokenBalancesParams,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<ListDataTokenBalances200>(\n    { url: `/v2/data/evm/token-balances/${network}/${address}`, method: \"GET\", params },\n    options,\n  );\n};\nexport type ListTokensForAccountResult = NonNullable<\n  Awaited<ReturnType<typeof listTokensForAccount>>\n>;\nexport type ListDataTokenBalancesResult = NonNullable<\n  Awaited<ReturnType<typeof listDataTokenBalances>>\n>;\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/payment/subscribe.ts","/**\n * @module JWT\n */\n\nimport { SignJWT, importPKCS8, importJWK, JWTPayload } from \"jose\";\nimport { getRandomValues } from \"uncrypto\";\n\nimport { authHash } from \"./hash.js\";\nimport { UserInputValidationError } from \"../../errors.js\";\nimport { sortKeys } from \"../../utils/sortKeys.js\";\nimport { InvalidWalletSecretFormatError, UndefinedWalletSecretError } from \"../errors.js\";\n\n/**\n * JwtOptions contains configuration for JWT generation.\n *\n * This interface holds all necessary parameters for generating a JWT token\n * for authenticating with Coinbase's REST APIs. It supports both EC (ES256)\n * and Ed25519 (EdDSA) keys.\n */\nexport interface JwtOptions {\n  /**\n   * The API key ID\n   *\n   * Examples:\n   *  'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'\n   *  'organizations/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/apiKeys/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'\n   */\n  apiKeyId: string;\n\n  /**\n   * The API key secret\n   *\n   * Examples:\n   *  'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx==' (Edwards key (Ed25519))\n   *  '-----BEGIN EC PRIVATE KEY-----\\n...\\n...\\n...==\\n-----END EC PRIVATE KEY-----\\n' (EC key (ES256))\n   */\n  apiKeySecret: string;\n\n  /**\n   * The HTTP method for the request (e.g. 'GET', 'POST'), or null for JWTs intended for websocket connections\n   */\n  requestMethod?: string | null;\n\n  /**\n   * The host for the request (e.g. 'api.cdp.coinbase.com'), or null for JWTs intended for websocket connections\n   */\n  requestHost?: string | null;\n\n  /**\n   * The path for the request (e.g. '/platform/v1/wallets'), or null for JWTs intended for websocket connections\n   */\n  requestPath?: string | null;\n\n  /**\n   * Optional expiration time in seconds (defaults to 120)\n   */\n  expiresIn?: number;\n\n  /**\n   * Optional audience claim for the JWT\n   */\n  audience?: string[];\n}\n\n/**\n * WalletJwtOptions contains configuration for Wallet Auth JWT generation.\n *\n * This interface holds all necessary parameters for generating a Wallet Auth JWT\n * for authenticating with endpoints that require wallet authentication.\n */\nexport interface WalletJwtOptions {\n  /**\n   * - The Wallet Secret\n   */\n  walletSecret: string;\n\n  /**\n   * - The HTTP method for the request (e.g. 'GET', 'POST')\n   */\n  requestMethod: string;\n\n  /**\n   * - The host for the request (e.g. 'api.cdp.coinbase.com')\n   */\n  requestHost: string;\n\n  /**\n   * - The path for the request (e.g. '/platform/v1/wallets/{wallet_id}/addresses')\n   */\n  requestPath: string;\n\n  /**\n   * - The request data for the request (e.g. `{ \"wallet_id\": \"1234567890\" }`)\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  requestData: Record<string, any>;\n}\n\n/**\n * Generates a JWT (also known as a Bearer token) for authenticating with Coinbase's REST APIs.\n * Supports both EC (ES256) and Ed25519 (EdDSA) keys. Also supports JWTs meant for\n * websocket connections by allowing requestMethod, requestHost, and requestPath to all be\n * null, in which case the 'uris' claim is omitted from the JWT.\n *\n * @param options - The configuration options for generating the JWT\n * @returns The generated JWT (Bearer token) string\n * @throws {Error} If required parameters are missing, invalid, or if JWT signing fails\n */\nexport async function generateJwt(options: JwtOptions): Promise<string> {\n  // Validate required parameters\n  if (!options.apiKeyId) {\n    throw new Error(\"Key name is required\");\n  }\n  if (!options.apiKeySecret) {\n    throw new Error(\"Private key is required\");\n  }\n\n  // Check if we have a REST API request or a websocket connection\n  const hasAllRequestParams = Boolean(\n    options.requestMethod && options.requestHost && options.requestPath,\n  );\n  const hasNoRequestParams =\n    (options.requestMethod === undefined || options.requestMethod === null) &&\n    (options.requestHost === undefined || options.requestHost === null) &&\n    (options.requestPath === undefined || options.requestPath === null);\n\n  // Ensure we either have all request parameters or none (for websocket)\n  if (!hasAllRequestParams && !hasNoRequestParams) {\n    throw new Error(\n      \"Either all request details (method, host, path) must be provided, or all must be null for JWTs intended for websocket connections\",\n    );\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n  const expiresIn = options.expiresIn || 120; // Default to 120 seconds if not specified\n\n  // Prepare the JWT payload\n  const claims: JWTPayload = {\n    sub: options.apiKeyId,\n    iss: \"cdp\",\n    aud: options.audience,\n  };\n\n  // Add the uris claim only for REST API requests\n  if (hasAllRequestParams) {\n    claims.uris = [`${options.requestMethod} ${options.requestHost}${options.requestPath}`];\n  }\n\n  // Generate random nonce for the header\n  const randomNonce = nonce();\n\n  // Determine if we're using EC or Edwards key based on the key format\n  if (await isValidECKey(options.apiKeySecret)) {\n    return await buildECJWT(\n      options.apiKeySecret,\n      options.apiKeyId,\n      claims,\n      now,\n      expiresIn,\n      randomNonce,\n    );\n  } else if (isValidEd25519Key(options.apiKeySecret)) {\n    return await buildEdwardsJWT(\n      options.apiKeySecret,\n      options.apiKeyId,\n      claims,\n      now,\n      expiresIn,\n      randomNonce,\n    );\n  } else {\n    throw new UserInputValidationError(\n      \"Invalid key format - must be either PEM EC key or base64 Ed25519 key\",\n    );\n  }\n}\n\n/**\n * Generates a wallet authentication JWT for the given API endpoint URL.\n * Used for authenticating with specific endpoints that require wallet authentication.\n *\n * @param options - The configuration options for generating the JWT\n * @returns The generated JWT (Bearer token) string\n * @throws {UndefinedWalletSecretError} If the Wallet Secret is not defined.\n * @throws {InvalidWalletSecretFormatError} If the private key is not in the correct format or signing fails.\n */\nexport async function generateWalletJwt(options: WalletJwtOptions): Promise<string> {\n  if (!options.walletSecret) {\n    throw new UndefinedWalletSecretError(\"Wallet Secret is not defined\");\n  }\n\n  const uri = `${options.requestMethod} ${options.requestHost}${options.requestPath}`;\n  const now = Math.floor(Date.now() / 1000);\n\n  const claims: JWTPayload = {\n    uris: [uri],\n  };\n\n  const shouldIncludeReqHash =\n    typeof options.requestData === \"object\" &&\n    Object.keys(options.requestData).length > 0 &&\n    Object.values(options.requestData).some(value => value !== undefined);\n  if (shouldIncludeReqHash) {\n    const sortedData = sortKeys(options.requestData);\n    claims.reqHash = await authHash(Buffer.from(JSON.stringify(sortedData)));\n  }\n\n  try {\n    // Convert base64 DER to PEM format for jose\n    const derBuffer = Buffer.from(options.walletSecret, \"base64\");\n    const pemKey = `-----BEGIN PRIVATE KEY-----\\n${derBuffer\n      .toString(\"base64\")\n      .match(/.{1,64}/g)\n      ?.join(\"\\n\")}\\n-----END PRIVATE KEY-----`;\n\n    const ecKey = await importPKCS8(pemKey, \"ES256\");\n\n    return await new SignJWT(claims)\n      .setProtectedHeader({ alg: \"ES256\", typ: \"JWT\" })\n      .setIssuedAt(now)\n      .setNotBefore(now)\n      .setJti(nonce())\n      .sign(ecKey);\n  } catch (error) {\n    throw new InvalidWalletSecretFormatError(\"Could not create the EC key: \" + error);\n  }\n}\n\n/**\n * Determines if a string could be a valid Ed25519 key\n *\n * @param str - The string to test\n * @returns True if the string could be a valid Ed25519 key, false otherwise\n */\nfunction isValidEd25519Key(str: string): boolean {\n  try {\n    const decoded = Buffer.from(str, \"base64\");\n    return decoded.length === 64;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Determines if a string is a valid EC private key in PEM format\n *\n * @param str - The string to test\n * @returns True if the string is a valid EC private key in PEM format\n */\nasync function isValidECKey(str: string): Promise<boolean> {\n  try {\n    // Try to import the key with jose - if it works, it's a valid EC key\n    await importPKCS8(str, \"ES256\");\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Builds a JWT using an EC key.\n *\n * @param privateKey - The EC private key in PEM format\n * @param keyName - The key name/ID\n * @param claims - The JWT claims\n * @param now - Current timestamp in seconds\n * @param expiresIn - Number of seconds until the token expires\n * @param nonce - Random nonce for the JWT header\n * @returns A JWT token signed with an EC key\n * @throws {Error} If key conversion, import, or signing fails\n */\nasync function buildECJWT(\n  privateKey: string,\n  keyName: string,\n  claims: JWTPayload,\n  now: number,\n  expiresIn: number,\n  nonce: string,\n): Promise<string> {\n  try {\n    // Import the key directly with jose\n    const ecKey = await importPKCS8(privateKey, \"ES256\");\n\n    // Sign and return the JWT\n    return await new SignJWT(claims)\n      .setProtectedHeader({ alg: \"ES256\", kid: keyName, typ: \"JWT\", nonce })\n      .setIssuedAt(Math.floor(now))\n      .setNotBefore(Math.floor(now))\n      .setExpirationTime(Math.floor(now + expiresIn))\n      .sign(ecKey);\n  } catch (error) {\n    throw new Error(`Failed to generate EC JWT: ${(error as Error).message}`);\n  }\n}\n\n/**\n * Builds a JWT using an Ed25519 key.\n *\n * @param privateKey - The Ed25519 private key in base64 format\n * @param keyName - The key name/ID\n * @param claims - The JWT claims\n * @param now - Current timestamp in seconds\n * @param expiresIn - Number of seconds until the token expires\n * @param nonce - Random nonce for the JWT header\n * @returns A JWT token using an Ed25519 key\n * @throws {Error} If key parsing, import, or signing fails\n */\nasync function buildEdwardsJWT(\n  privateKey: string,\n  keyName: string,\n  claims: JWTPayload,\n  now: number,\n  expiresIn: number,\n  nonce: string,\n): Promise<string> {\n  try {\n    // Decode the base64 key (expecting 64 bytes: 32 for seed + 32 for public key)\n    const decoded = Buffer.from(privateKey, \"base64\");\n    if (decoded.length !== 64) {\n      throw new UserInputValidationError(\"Invalid Ed25519 key length\");\n    }\n\n    const seed = decoded.subarray(0, 32);\n    const publicKey = decoded.subarray(32);\n\n    // Create JWK from the key components\n    const jwk = {\n      kty: \"OKP\",\n      crv: \"Ed25519\",\n      d: seed.toString(\"base64url\"),\n      x: publicKey.toString(\"base64url\"),\n    };\n\n    // Import the key for signing\n    const key = await importJWK(jwk, \"EdDSA\");\n\n    // Sign and return the JWT\n    return await new SignJWT(claims)\n      .setProtectedHeader({ alg: \"EdDSA\", kid: keyName, typ: \"JWT\", nonce })\n      .setIssuedAt(Math.floor(now))\n      .setNotBefore(Math.floor(now))\n      .setExpirationTime(Math.floor(now + expiresIn))\n      .sign(key);\n  } catch (error) {\n    throw new Error(`Failed to generate Ed25519 JWT: ${(error as Error).message}`);\n  }\n}\n\n/**\n * Generates a random nonce for the JWT.\n *\n * @returns {string} The generated nonce.\n */\nfunction nonce(): string {\n  const bytes = new Uint8Array(16);\n  getRandomValues(bytes);\n  return Buffer.from(bytes).toString(\"hex\");\n}\n","import { BaseError } from '../../errors/base.js'\n\nexport type InvalidEip712TransactionErrorType =\n  InvalidEip712TransactionError & {\n    name: 'InvalidEip712TransactionError'\n  }\nexport class InvalidEip712TransactionError extends BaseError {\n  constructor() {\n    super(\n      [\n        'Transaction is not an EIP712 transaction.',\n        '',\n        'Transaction must:',\n        '  - include `type: \"eip712\"`',\n        '  - include one of the following: `customSignature`, `paymaster`, `paymasterInput`, `gasPerPubdata`, `factoryDeps`',\n      ].join('\\n'),\n      { name: 'InvalidEip712TransactionError' },\n    )\n  }\n}\n","import * as Base64 from './Base64.js'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport * as P256 from './P256.js'\nimport type * as PublicKey from './PublicKey.js'\nimport type * as Signature from './Signature.js'\nimport type { Compute, OneOf } from './internal/types.js'\nimport * as internal from './internal/webauthn.js'\n\n/** A WebAuthn-flavored P256 credential. */\nexport type P256Credential = {\n  id: string\n  publicKey: PublicKey.PublicKey\n  raw: internal.PublicKeyCredential\n}\n\n/** Metadata for a WebAuthn P256 signature. */\nexport type SignMetadata = Compute<{\n  authenticatorData: Hex.Hex\n  challengeIndex: number\n  clientDataJSON: string\n  typeIndex: number\n  userVerificationRequired: boolean\n}>\n\nexport const createChallenge = Uint8Array.from([\n  105, 171, 180, 181, 160, 222, 75, 198, 42, 42, 32, 31, 141, 37, 186, 233,\n])\n\n/**\n * Creates a new WebAuthn P256 Credential, which can be stored and later used for signing.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({ name: 'Example' }) // [!code focus]\n * // @log: {\n * // @log:   id: 'oZ48...',\n * // @log:   publicKey: { x: 51421...5123n, y: 12345...6789n },\n * // @log:   raw: PublicKeyCredential {},\n * // @log: }\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n * ```\n *\n * @param options - Credential creation options.\n * @returns A WebAuthn P256 credential.\n */\nexport async function createCredential(\n  options: createCredential.Options,\n): Promise<P256Credential> {\n  const {\n    createFn = window.navigator.credentials.create.bind(\n      window.navigator.credentials,\n    ),\n    ...rest\n  } = options\n  const creationOptions = getCredentialCreationOptions(rest)\n  try {\n    const credential = (await createFn(\n      creationOptions,\n    )) as internal.PublicKeyCredential\n    if (!credential) throw new CredentialCreationFailedError()\n\n    const response = credential.response as AuthenticatorAttestationResponse\n    const publicKey = await internal.parseCredentialPublicKey(response)\n\n    return {\n      id: credential.id,\n      publicKey,\n      raw: credential,\n    }\n  } catch (error) {\n    throw new CredentialCreationFailedError({\n      cause: error as Error,\n    })\n  }\n}\n\nexport declare namespace createCredential {\n  type Options = getCredentialCreationOptions.Options & {\n    /**\n     * Credential creation function. Useful for environments that do not support\n     * the WebAuthn API natively (i.e. React Native or testing environments).\n     *\n     * @default window.navigator.credentials.create\n     */\n    createFn?:\n      | ((\n          options?: internal.CredentialCreationOptions | undefined,\n        ) => Promise<internal.Credential | null>)\n      | undefined\n  }\n\n  type ErrorType =\n    | getCredentialCreationOptions.ErrorType\n    | internal.parseCredentialPublicKey.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Gets the authenticator data which contains information about the\n * processing of an authenticator request (ie. from `WebAuthnP256.sign`).\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * autenticator data. In most cases you will not need this function.\n * `authenticatorData` is typically returned as part of the\n * {@link ox#WebAuthnP256.(sign:function)} response (ie. an authenticator response).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const authenticatorData = WebAuthnP256.getAuthenticatorData({\n *   rpId: 'example.com',\n *   signCount: 420,\n * })\n * // @log: \"0xa379a6f6eeafb9a55e378c118034e2751e682fab9f2d30ab13d2125586ce194705000001a4\"\n * ```\n *\n * @param options - Options to construct the authenticator data.\n * @returns The authenticator data.\n */\nexport function getAuthenticatorData(\n  options: getAuthenticatorData.Options = {},\n): Hex.Hex {\n  const { flag = 5, rpId = window.location.hostname, signCount = 0 } = options\n  const rpIdHash = Hash.sha256(Hex.fromString(rpId))\n  const flag_bytes = Hex.fromNumber(flag, { size: 1 })\n  const signCount_bytes = Hex.fromNumber(signCount, { size: 4 })\n  return Hex.concat(rpIdHash, flag_bytes, signCount_bytes)\n}\n\nexport declare namespace getAuthenticatorData {\n  type Options = {\n    /** A bitfield that indicates various attributes that were asserted by the authenticator. [Read more](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/Authenticator_data#flags) */\n    flag?: number | undefined\n    /** The [Relying Party ID](https://w3c.github.io/webauthn/#relying-party-identifier) that the credential is scoped to. */\n    rpId?: internal.PublicKeyCredentialRequestOptions['rpId'] | undefined\n    /** A signature counter, if supported by the authenticator (set to 0 otherwise). */\n    signCount?: number | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Constructs the Client Data in stringified JSON format which represents client data that\n * was passed to `credentials.get()` in {@link ox#WebAuthnP256.(sign:function)}.\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * client data. In most cases you will not need this function.\n * `clientDataJSON` is typically returned as part of the\n * {@link ox#WebAuthnP256.(sign:function)} response (ie. an authenticator response).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const clientDataJSON = WebAuthnP256.getClientDataJSON({\n *   challenge: '0xdeadbeef',\n *   origin: 'https://example.com',\n * })\n * // @log: \"{\"type\":\"webauthn.get\",\"challenge\":\"3q2-7w\",\"origin\":\"https://example.com\",\"crossOrigin\":false}\"\n * ```\n *\n * @param options - Options to construct the client data.\n * @returns The client data.\n */\nexport function getClientDataJSON(options: getClientDataJSON.Options): string {\n  const {\n    challenge,\n    crossOrigin = false,\n    extraClientData,\n    origin = window.location.origin,\n  } = options\n\n  return JSON.stringify({\n    type: 'webauthn.get',\n    challenge: Base64.fromHex(challenge, { url: true, pad: false }),\n    origin,\n    crossOrigin,\n    ...extraClientData,\n  })\n}\n\nexport declare namespace getClientDataJSON {\n  type Options = {\n    /** The challenge to sign. */\n    challenge: Hex.Hex\n    /** If set to `true`, it means that the calling context is an `<iframe>` that is not same origin with its ancestor frames. */\n    crossOrigin?: boolean | undefined\n    /** Additional client data to include in the client data JSON. */\n    extraClientData?: Record<string, unknown> | undefined\n    /** The fully qualified origin of the relying party which has been given by the client/browser to the authenticator. */\n    origin?: string | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Returns the creation options for a P256 WebAuthn Credential to be used with\n * the Web Authentication API.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const options = WebAuthnP256.getCredentialCreationOptions({ name: 'Example' })\n *\n * const credential = await window.navigator.credentials.create(options)\n * ```\n *\n * @param options - Options.\n * @returns The credential creation options.\n */\nexport function getCredentialCreationOptions(\n  options: getCredentialCreationOptions.Options,\n): internal.CredentialCreationOptions {\n  const {\n    attestation = 'none',\n    authenticatorSelection = {\n      residentKey: 'preferred',\n      requireResidentKey: false,\n      userVerification: 'required',\n    },\n    challenge = createChallenge,\n    excludeCredentialIds,\n    name: name_,\n    rp = {\n      id: window.location.hostname,\n      name: window.document.title,\n    },\n    user,\n    extensions,\n  } = options\n  const name = (user?.name ?? name_)!\n  return {\n    publicKey: {\n      attestation,\n      authenticatorSelection,\n      challenge,\n      ...(excludeCredentialIds\n        ? {\n            excludeCredentials: excludeCredentialIds?.map((id) => ({\n              id: Base64.toBytes(id),\n              type: 'public-key',\n            })),\n          }\n        : {}),\n      pubKeyCredParams: [\n        {\n          type: 'public-key',\n          alg: -7, // p256\n        },\n      ],\n      rp,\n      user: {\n        id: user?.id ?? Hash.keccak256(Bytes.fromString(name), { as: 'Bytes' }),\n        name,\n        displayName: user?.displayName ?? name,\n      },\n      extensions,\n    },\n  } as internal.CredentialCreationOptions\n}\n\nexport declare namespace getCredentialCreationOptions {\n  type Options = {\n    /**\n     * A string specifying the relying party's preference for how the attestation statement\n     * (i.e., provision of verifiable evidence of the authenticity of the authenticator and its data)\n     * is conveyed during credential creation.\n     */\n    attestation?:\n      | internal.PublicKeyCredentialCreationOptions['attestation']\n      | undefined\n    /**\n     * An object whose properties are criteria used to filter out the potential authenticators\n     * for the credential creation operation.\n     */\n    authenticatorSelection?:\n      | internal.PublicKeyCredentialCreationOptions['authenticatorSelection']\n      | undefined\n    /**\n     * An `ArrayBuffer`, `TypedArray`, or `DataView` used as a cryptographic challenge.\n     */\n    challenge?:\n      | internal.PublicKeyCredentialCreationOptions['challenge']\n      | undefined\n    /**\n     * List of credential IDs to exclude from the creation. This property can be used\n     * to prevent creation of a credential if it already exists.\n     */\n    excludeCredentialIds?: readonly string[] | undefined\n    /**\n     * List of Web Authentication API credentials to use during creation or authentication.\n     */\n    extensions?:\n      | internal.PublicKeyCredentialCreationOptions['extensions']\n      | undefined\n    /**\n     * An object describing the relying party that requested the credential creation\n     */\n    rp?:\n      | {\n          id: string\n          name: string\n        }\n      | undefined\n    /**\n     * A numerical hint, in milliseconds, which indicates the time the calling web app is willing to wait for the creation operation to complete.\n     */\n    timeout?: internal.PublicKeyCredentialCreationOptions['timeout'] | undefined\n  } & OneOf<\n    | {\n        /** Name for the credential (user.name). */\n        name: string\n      }\n    | {\n        /**\n         * An object describing the user account for which the credential is generated.\n         */\n        user: {\n          displayName?: string\n          id?: BufferSource\n          name: string\n        }\n      }\n  >\n\n  type ErrorType =\n    | Base64.toBytes.ErrorType\n    | Hash.keccak256.ErrorType\n    | Bytes.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Returns the request options to sign a challenge with the Web Authentication API.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const options = WebAuthnP256.getCredentialRequestOptions({\n *   challenge: '0xdeadbeef',\n * })\n *\n * const credential = await window.navigator.credentials.get(options)\n * ```\n *\n * @param options - Options.\n * @returns The credential request options.\n */\nexport function getCredentialRequestOptions(\n  options: getCredentialRequestOptions.Options,\n): internal.CredentialRequestOptions {\n  const {\n    credentialId,\n    challenge,\n    rpId = window.location.hostname,\n    userVerification = 'required',\n  } = options\n  return {\n    publicKey: {\n      ...(credentialId\n        ? {\n            allowCredentials: [\n              {\n                id: Base64.toBytes(credentialId),\n                type: 'public-key',\n              },\n            ],\n          }\n        : {}),\n      challenge: Bytes.fromHex(challenge),\n      rpId,\n      userVerification,\n    },\n  }\n}\n\nexport declare namespace getCredentialRequestOptions {\n  type Options = {\n    /** The credential ID to use. */\n    credentialId?: string | undefined\n    /** The challenge to sign. */\n    challenge: Hex.Hex\n    /** The relying party identifier to use. */\n    rpId?: internal.PublicKeyCredentialRequestOptions['rpId'] | undefined\n    /** The user verification requirement. */\n    userVerification?:\n      | internal.PublicKeyCredentialRequestOptions['userVerification']\n      | undefined\n  }\n\n  type ErrorType =\n    | Bytes.fromHex.ErrorType\n    | Base64.toBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Constructs the final digest that was signed and computed by the authenticator. This payload includes\n * the cryptographic `challenge`, as well as authenticator metadata (`authenticatorData` + `clientDataJSON`).\n * This value can be also used with raw P256 verification (such as {@link ox#P256.(verify:function)} or\n * {@link ox#WebCryptoP256.(verify:function)}).\n *\n * :::warning\n *\n * This function is mainly for testing purposes or for manually constructing\n * signing payloads. In most cases you will not need this function and\n * instead use {@link ox#WebAuthnP256.(sign:function)}.\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256, WebCryptoP256 } from 'ox'\n *\n * const { metadata, payload } = WebAuthnP256.getSignPayload({ // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: \"0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000\",\n * // @log:     challengeIndex: 23,\n * // @log:     clientDataJSON: \"{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}\",\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   payload: \"0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d9763050000000045086dcb06a5f234db625bcdc94e657f86b76b6fd3eb9c30543eabc1e577a4b0\",\n * // @log: }\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPair()\n *\n * const signature = await WebCryptoP256.sign({\n *   payload,\n *   privateKey,\n * })\n * ```\n *\n * @param options - Options to construct the signing payload.\n * @returns The signing payload.\n */\nexport function getSignPayload(\n  options: getSignPayload.Options,\n): getSignPayload.ReturnType {\n  const {\n    challenge,\n    crossOrigin,\n    extraClientData,\n    flag,\n    origin,\n    rpId,\n    signCount,\n    userVerification = 'required',\n  } = options\n\n  const authenticatorData = getAuthenticatorData({\n    flag,\n    rpId,\n    signCount,\n  })\n  const clientDataJSON = getClientDataJSON({\n    challenge,\n    crossOrigin,\n    extraClientData,\n    origin,\n  })\n  const clientDataJSONHash = Hash.sha256(Hex.fromString(clientDataJSON))\n\n  const challengeIndex = clientDataJSON.indexOf('\"challenge\"')\n  const typeIndex = clientDataJSON.indexOf('\"type\"')\n\n  const metadata = {\n    authenticatorData,\n    clientDataJSON,\n    challengeIndex,\n    typeIndex,\n    userVerificationRequired: userVerification === 'required',\n  }\n\n  const payload = Hex.concat(authenticatorData, clientDataJSONHash)\n\n  return { metadata, payload }\n}\n\nexport declare namespace getSignPayload {\n  type Options = {\n    /** The challenge to sign. */\n    challenge: Hex.Hex\n    /** If set to `true`, it means that the calling context is an `<iframe>` that is not same origin with its ancestor frames. */\n    crossOrigin?: boolean | undefined\n    /** Additional client data to include in the client data JSON. */\n    extraClientData?: Record<string, unknown> | undefined\n    /** If set to `true`, the payload will be hashed before being returned. */\n    hash?: boolean | undefined\n    /** A bitfield that indicates various attributes that were asserted by the authenticator. [Read more](https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/Authenticator_data#flags) */\n    flag?: number | undefined\n    /** The fully qualified origin of the relying party which has been given by the client/browser to the authenticator. */\n    origin?: string | undefined\n    /** The [Relying Party ID](https://w3c.github.io/webauthn/#relying-party-identifier) that the credential is scoped to. */\n    rpId?: internal.PublicKeyCredentialRequestOptions['rpId'] | undefined\n    /** A signature counter, if supported by the authenticator (set to 0 otherwise). */\n    signCount?: number | undefined\n    /** The user verification requirement that the authenticator will enforce. */\n    userVerification?:\n      | internal.PublicKeyCredentialRequestOptions['userVerification']\n      | undefined\n  }\n\n  type ReturnType = {\n    metadata: SignMetadata\n    payload: Hex.Hex\n  }\n\n  type ErrorType =\n    | Hash.sha256.ErrorType\n    | Hex.concat.ErrorType\n    | Hex.fromString.ErrorType\n    | getAuthenticatorData.ErrorType\n    | getClientDataJSON.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Signs a challenge using a stored WebAuthn P256 Credential. If no Credential is provided,\n * a prompt will be displayed for the user to select an existing Credential\n * that was previously registered.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({ // [!code focus]\n *   credentialId: credential.id, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   metadata: {\n * // @log:     authenticatorData: '0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000',\n * // @log:     clientDataJSON: '{\"type\":\"webauthn.get\",\"challenge\":\"9jEFijuhEWrM4SOW-tChJbUEHEP44VcjcJ-Bqo1fTM8\",\"origin\":\"http://localhost:5173\",\"crossOrigin\":false}',\n * // @log:     challengeIndex: 23,\n * // @log:     typeIndex: 1,\n * // @log:     userVerificationRequired: true,\n * // @log:   },\n * // @log:   signature: { r: 51231...4215n, s: 12345...6789n },\n * // @log: }\n * ```\n *\n * @param options - Options.\n * @returns The signature.\n */\nexport async function sign(options: sign.Options): Promise<sign.ReturnType> {\n  const {\n    getFn = window.navigator.credentials.get.bind(window.navigator.credentials),\n    ...rest\n  } = options\n  const requestOptions = getCredentialRequestOptions(rest)\n  try {\n    const credential = (await getFn(\n      requestOptions,\n    )) as internal.PublicKeyCredential\n    if (!credential) throw new CredentialRequestFailedError()\n    const response = credential.response as AuthenticatorAssertionResponse\n\n    const clientDataJSON = String.fromCharCode(\n      ...new Uint8Array(response.clientDataJSON),\n    )\n    const challengeIndex = clientDataJSON.indexOf('\"challenge\"')\n    const typeIndex = clientDataJSON.indexOf('\"type\"')\n\n    const signature = internal.parseAsn1Signature(\n      new Uint8Array(response.signature),\n    )\n\n    return {\n      metadata: {\n        authenticatorData: Hex.fromBytes(\n          new Uint8Array(response.authenticatorData),\n        ),\n        clientDataJSON,\n        challengeIndex,\n        typeIndex,\n        userVerificationRequired:\n          requestOptions.publicKey!.userVerification === 'required',\n      },\n      signature,\n      raw: credential,\n    }\n  } catch (error) {\n    throw new CredentialRequestFailedError({\n      cause: error as Error,\n    })\n  }\n}\n\nexport declare namespace sign {\n  type Options = getCredentialRequestOptions.Options & {\n    /**\n     * Credential request function. Useful for environments that do not support\n     * the WebAuthn API natively (i.e. React Native or testing environments).\n     *\n     * @default window.navigator.credentials.get\n     */\n    getFn?:\n      | ((\n          options?: internal.CredentialRequestOptions | undefined,\n        ) => Promise<internal.Credential | null>)\n      | undefined\n  }\n\n  type ReturnType = {\n    metadata: SignMetadata\n    raw: internal.PublicKeyCredential\n    signature: Signature.Signature<false>\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | getCredentialRequestOptions.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a signature using the Credential's public key and the challenge which was signed.\n *\n * @example\n * ```ts twoslash\n * import { WebAuthnP256 } from 'ox'\n *\n * const credential = await WebAuthnP256.createCredential({\n *   name: 'Example',\n * })\n *\n * const { metadata, signature } = await WebAuthnP256.sign({\n *   credentialId: credential.id,\n *   challenge: '0xdeadbeef',\n * })\n *\n * const result = await WebAuthnP256.verify({ // [!code focus]\n *   metadata, // [!code focus]\n *   challenge: '0xdeadbeef', // [!code focus]\n *   publicKey: credential.publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @param options - Options.\n * @returns Whether the signature is valid.\n */\nexport function verify(options: verify.Options): boolean {\n  const { challenge, hash = true, metadata, publicKey, signature } = options\n  const {\n    authenticatorData,\n    challengeIndex,\n    clientDataJSON,\n    typeIndex,\n    userVerificationRequired,\n  } = metadata\n\n  const authenticatorDataBytes = Bytes.fromHex(authenticatorData)\n\n  // Check length of `authenticatorData`.\n  if (authenticatorDataBytes.length < 37) return false\n\n  const flag = authenticatorDataBytes[32]!\n\n  // Verify that the UP bit of the flags in authData is set.\n  if ((flag & 0x01) !== 0x01) return false\n\n  // If user verification was determined to be required, verify that\n  // the UV bit of the flags in authData is set. Otherwise, ignore the\n  // value of the UV flag.\n  if (userVerificationRequired && (flag & 0x04) !== 0x04) return false\n\n  // If the BE bit of the flags in authData is not set, verify that\n  // the BS bit is not set.\n  if ((flag & 0x08) !== 0x08 && (flag & 0x10) === 0x10) return false\n\n  // Check that response is for an authentication assertion\n  const type = '\"type\":\"webauthn.get\"'\n  if (type !== clientDataJSON.slice(Number(typeIndex), type.length + 1))\n    return false\n\n  // Check that hash is in the clientDataJSON.\n  const match = clientDataJSON\n    .slice(Number(challengeIndex))\n    .match(/^\"challenge\":\"(.*?)\"/)\n  if (!match) return false\n\n  // Validate the challenge in the clientDataJSON.\n  const [_, challenge_extracted] = match\n  if (Hex.fromBytes(Base64.toBytes(challenge_extracted!)) !== challenge)\n    return false\n\n  const clientDataJSONHash = Hash.sha256(Bytes.fromString(clientDataJSON), {\n    as: 'Bytes',\n  })\n  const payload = Bytes.concat(authenticatorDataBytes, clientDataJSONHash)\n\n  return P256.verify({\n    hash,\n    payload,\n    publicKey,\n    signature,\n  })\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** The challenge to verify. */\n    challenge: Hex.Hex\n    /** If set to `true`, the payload will be hashed (sha256) before being verified. */\n    hash?: boolean | undefined\n    /** The public key to verify the signature with. */\n    publicKey: PublicKey.PublicKey\n    /** The signature to verify. */\n    signature: Signature.Signature<false>\n    /** The metadata to verify the signature with. */\n    metadata: SignMetadata\n  }\n\n  type ErrorType =\n    | Base64.toBytes.ErrorType\n    | Bytes.concat.ErrorType\n    | Bytes.fromHex.ErrorType\n    | P256.verify.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** Thrown when a WebAuthn P256 credential creation fails. */\nexport class CredentialCreationFailedError extends Errors.BaseError<Error> {\n  override readonly name = 'WebAuthnP256.CredentialCreationFailedError'\n\n  constructor({ cause }: { cause?: Error | undefined } = {}) {\n    super('Failed to create credential.', {\n      cause,\n    })\n  }\n}\n\n/** Thrown when a WebAuthn P256 credential request fails. */\nexport class CredentialRequestFailedError extends Errors.BaseError<Error> {\n  override readonly name = 'WebAuthnP256.CredentialRequestFailedError'\n\n  constructor({ cause }: { cause?: Error | undefined } = {}) {\n    super('Failed to request credential.', {\n      cause,\n    })\n  }\n}\n","'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n *\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nexport default function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\n","/**\n * Estimate decoded byte length of a data:// URL *without* allocating large buffers.\n * - For base64: compute exact decoded size using length and padding;\n *               handle %XX at the character-count level (no string allocation).\n * - For non-base64: use UTF-8 byteLength of the encoded body as a safe upper bound.\n *\n * @param {string} url\n * @returns {number}\n */\nexport default function estimateDataURLDecodedBytes(url) {\n  if (!url || typeof url !== 'string') return 0;\n  if (!url.startsWith('data:')) return 0;\n\n  const comma = url.indexOf(',');\n  if (comma < 0) return 0;\n\n  const meta = url.slice(5, comma);\n  const body = url.slice(comma + 1);\n  const isBase64 = /;base64/i.test(meta);\n\n  if (isBase64) {\n    let effectiveLen = body.length;\n    const len = body.length; // cache length\n\n    for (let i = 0; i < len; i++) {\n      if (body.charCodeAt(i) === 37 /* '%' */ && i + 2 < len) {\n        const a = body.charCodeAt(i + 1);\n        const b = body.charCodeAt(i + 2);\n        const isHex =\n          ((a >= 48 && a <= 57) || (a >= 65 && a <= 70) || (a >= 97 && a <= 102)) &&\n          ((b >= 48 && b <= 57) || (b >= 65 && b <= 70) || (b >= 97 && b <= 102));\n\n        if (isHex) {\n          effectiveLen -= 2;\n          i += 2;\n        }\n      }\n    }\n\n    let pad = 0;\n    let idx = len - 1;\n\n    const tailIsPct3D = (j) =>\n      j >= 2 &&\n      body.charCodeAt(j - 2) === 37 && // '%'\n      body.charCodeAt(j - 1) === 51 && // '3'\n      (body.charCodeAt(j) === 68 || body.charCodeAt(j) === 100); // 'D' or 'd'\n\n    if (idx >= 0) {\n      if (body.charCodeAt(idx) === 61 /* '=' */) {\n        pad++;\n        idx--;\n      } else if (tailIsPct3D(idx)) {\n        pad++;\n        idx -= 3;\n      }\n    }\n\n    if (pad === 1 && idx >= 0) {\n      if (body.charCodeAt(idx) === 61 /* '=' */) {\n        pad++;\n      } else if (tailIsPct3D(idx)) {\n        pad++;\n      }\n    }\n\n    const groups = Math.floor(effectiveLen / 4);\n    const bytes = groups * 3 - (pad || 0);\n    return bytes > 0 ? bytes : 0;\n  }\n\n  return Buffer.byteLength(body, 'utf8');\n}\n","'use strict';\n\n/**\n * Create a bound version of a function with a specified `this` context\n *\n * @param {Function} fn - The function to bind\n * @param {*} thisArg - The value to be passed as the `this` parameter\n * @returns {Function} A new function that will call the original function with the specified `this` context\n */\nexport default function bind(fn, thisArg) {\n  return function wrap() {\n    return fn.apply(thisArg, arguments);\n  };\n}\n","import platform from \"../platform/index.js\";\nimport utils from \"../utils.js\";\nimport isURLSameOrigin from \"./isURLSameOrigin.js\";\nimport cookies from \"./cookies.js\";\nimport buildFullPath from \"../core/buildFullPath.js\";\nimport mergeConfig from \"../core/mergeConfig.js\";\nimport AxiosHeaders from \"../core/AxiosHeaders.js\";\nimport buildURL from \"./buildURL.js\";\n\nexport default (config) => {\n  const newConfig = mergeConfig({}, config);\n\n  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;\n\n  newConfig.headers = headers = AxiosHeaders.from(headers);\n\n  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);\n\n  // HTTP basic authentication\n  if (auth) {\n    headers.set('Authorization', 'Basic ' +\n      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))\n    );\n  }\n\n  if (utils.isFormData(data)) {\n    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {\n      headers.setContentType(undefined); // browser handles it\n    } else if (utils.isFunction(data.getHeaders)) {\n      // Node.js FormData (like form-data package)\n      const formHeaders = data.getHeaders();\n      // Only set safe headers to avoid overwriting security headers\n      const allowedHeaders = ['content-type', 'content-length'];\n      Object.entries(formHeaders).forEach(([key, val]) => {\n        if (allowedHeaders.includes(key.toLowerCase())) {\n          headers.set(key, val);\n        }\n      });\n    }\n  }  \n\n  // Add xsrf header\n  // This is only done if running in a standard browser environment.\n  // Specifically not if we're in a web worker, or react-native.\n\n  if (platform.hasStandardBrowserEnv) {\n    withXSRFToken && utils.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));\n\n    if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(newConfig.url))) {\n      // Add xsrf header\n      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);\n\n      if (xsrfValue) {\n        headers.set(xsrfHeaderName, xsrfValue);\n      }\n    }\n  }\n\n  return newConfig;\n}\n\n","import type { Address } from 'abitype'\n\nimport type { Hash, Hex } from '../../../types/misc.js'\nimport { encodeAbiParameters } from '../../../utils/abi/encodeAbiParameters.js'\nimport { keccak256 } from '../../../utils/hash/keccak256.js'\nimport { hashTypedData } from '../../../utils/signature/hashTypedData.js'\nimport type { EntryPointVersion } from '../../types/entryPointVersion.js'\nimport type { UserOperation } from '../../types/userOperation.js'\nimport { getInitCode } from './getInitCode.js'\nimport { getUserOperationTypedData } from './getUserOperationTypedData.js'\nimport { toPackedUserOperation } from './toPackedUserOperation.js'\n\nexport type GetUserOperationHashParameters<\n  entryPointVersion extends EntryPointVersion = EntryPointVersion,\n> = {\n  chainId: number\n  entryPointAddress: Address\n  entryPointVersion: entryPointVersion | EntryPointVersion\n  userOperation: UserOperation<entryPointVersion>\n}\n\nexport type GetUserOperationHashReturnType = Hash\n\nexport function getUserOperationHash<\n  entryPointVersion extends EntryPointVersion,\n>(\n  parameters: GetUserOperationHashParameters<entryPointVersion>,\n): GetUserOperationHashReturnType {\n  const { chainId, entryPointAddress, entryPointVersion } = parameters\n  const userOperation = parameters.userOperation as UserOperation\n  const {\n    authorization,\n    callData = '0x',\n    callGasLimit,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    paymasterAndData = '0x',\n    preVerificationGas,\n    sender,\n    verificationGasLimit,\n  } = userOperation\n\n  if (entryPointVersion === '0.8')\n    return hashTypedData(\n      getUserOperationTypedData({\n        chainId,\n        entryPointAddress,\n        userOperation,\n      }),\n    )\n\n  const packedUserOp = (() => {\n    if (entryPointVersion === '0.6') {\n      const factory = userOperation.initCode?.slice(0, 42) as Hex\n      const factoryData = userOperation.initCode?.slice(42) as Hex | undefined\n      const initCode = getInitCode({\n        authorization,\n        factory,\n        factoryData,\n      })\n      return encodeAbiParameters(\n        [\n          { type: 'address' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n        ],\n        [\n          sender,\n          nonce,\n          keccak256(initCode),\n          keccak256(callData),\n          callGasLimit,\n          verificationGasLimit,\n          preVerificationGas,\n          maxFeePerGas,\n          maxPriorityFeePerGas,\n          keccak256(paymasterAndData),\n        ],\n      )\n    }\n\n    if (entryPointVersion === '0.7') {\n      const packedUserOp = toPackedUserOperation(userOperation)\n      return encodeAbiParameters(\n        [\n          { type: 'address' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n          { type: 'uint256' },\n          { type: 'bytes32' },\n          { type: 'bytes32' },\n        ],\n        [\n          packedUserOp.sender,\n          packedUserOp.nonce,\n          keccak256(packedUserOp.initCode),\n          keccak256(packedUserOp.callData),\n          packedUserOp.accountGasLimits,\n          packedUserOp.preVerificationGas,\n          packedUserOp.gasFees,\n          keccak256(packedUserOp.paymasterAndData),\n        ],\n      )\n    }\n\n    throw new Error(`entryPointVersion \"${entryPointVersion}\" not supported.`)\n  })()\n\n  return keccak256(\n    encodeAbiParameters(\n      [{ type: 'bytes32' }, { type: 'address' }, { type: 'uint256' }],\n      [keccak256(packedUserOp), entryPointAddress, BigInt(chainId)],\n    ),\n  )\n}\n","import { chainConfig } from '../../op-stack/chainConfig.js'\nimport { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const dchain = /*#__PURE__*/ defineChain({\n  ...chainConfig,\n  id: 2716446429837000,\n  name: 'Dchain',\n  nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: ['https://dchain-2716446429837000-1.jsonrpc.sagarpc.io'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Dchain Explorer',\n      url: 'https://dchain-2716446429837000-1.sagaexplorer.io',\n      apiUrl: 'https://api-dchain-2716446429837000-1.sagaexplorer.io/api',\n    },\n  },\n  contracts: {\n    ...chainConfig.contracts,\n  },\n})\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/sign/base-account/utils/findOwnerIndex.ts","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/util/assertSubAccount.ts","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/util/web.ts","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/sign/base-account/utils/handleAddSubAccountOwner.ts","import { type CdpOpenApiClientType } from \"../../openapi-client/index.js\";\nimport { Hex } from \"../../types/misc.js\";\n\n/**\n * Options for requesting funds from an EVM faucet.\n */\nexport interface RequestFaucetOptions {\n  /** The address of the account. */\n  address: string;\n  /** The network to request funds from. */\n  network: \"base-sepolia\" | \"ethereum-sepolia\";\n  /** The token to request funds for. */\n  token: \"eth\" | \"usdc\" | \"eurc\" | \"cbbtc\";\n  /** The idempotency key. */\n  idempotencyKey?: string;\n}\n\n/**\n * The result of requesting funds from an EVM faucet.\n */\nexport interface RequestFaucetResult {\n  /** The transaction hash. */\n  transactionHash: Hex;\n}\n\n/**\n * Requests funds from an EVM faucet.\n *\n * @param apiClient - The API client.\n * @param options - The options for requesting funds from the EVM faucet.\n *\n * @returns A promise that resolves to the transaction hash.\n */\nexport async function requestFaucet(\n  apiClient: CdpOpenApiClientType,\n  options: RequestFaucetOptions,\n) {\n  const { transactionHash } = await apiClient.requestEvmFaucet(\n    { address: options.address, network: options.network, token: options.token },\n    options.idempotencyKey,\n  );\n\n  return {\n    transactionHash: transactionHash as Hex,\n  };\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/sign/base-account/utils/routeThroughGlobalAccount.ts","import type { Address, Narrow } from 'abitype'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BaseError } from '../../errors/base.js'\nimport {\n  AtomicityNotSupportedError,\n  UnsupportedNonOptionalCapabilityError,\n} from '../../errors/rpc.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account, GetAccountParameter } from '../../types/account.js'\nimport type { Call, Calls } from '../../types/calls.js'\nimport type { ExtractCapabilities } from '../../types/capabilities.js'\nimport type { Chain, DeriveChain } from '../../types/chain.js'\nimport type { WalletSendCallsParameters } from '../../types/eip1193.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { concat } from '../../utils/data/concat.js'\nimport { hexToBigInt } from '../../utils/encoding/fromHex.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\nimport { getTransactionError } from '../../utils/errors/getTransactionError.js'\nimport { sendTransaction } from './sendTransaction.js'\n\nexport const fallbackMagicIdentifier =\n  '0x5792579257925792579257925792579257925792579257925792579257925792'\nexport const fallbackTransactionErrorMagicIdentifier = numberToHex(0, {\n  size: 32,\n})\n\nexport type SendCallsParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  //\n  _chain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = {\n  chain?: chainOverride | Chain | undefined\n  calls: Calls<Narrow<calls>>\n  capabilities?: ExtractCapabilities<'sendCalls', 'Request'> | undefined\n  experimental_fallback?: boolean | undefined\n  experimental_fallbackDelay?: number | undefined\n  forceAtomic?: boolean | undefined\n  id?: string | undefined\n  version?: WalletSendCallsParameters[number]['version'] | undefined\n} & GetAccountParameter<account, Account | Address, false, true>\n\nexport type SendCallsReturnType = Prettify<{\n  capabilities?: ExtractCapabilities<'sendCalls', 'ReturnType'> | undefined\n  id: string\n}>\n\nexport type SendCallsErrorType = RequestErrorType | ErrorType\n\n/**\n * Requests the connected wallet to send a batch of calls.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendCalls\n * - JSON-RPC Methods: [`wallet_sendCalls`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns Transaction identifier. {@link SendCallsReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendCalls } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const id = await sendCalls(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   calls: [\n *     {\n *       data: '0xdeadbeef',\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     },\n *     {\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       value: 69420n,\n *     },\n *   ],\n * })\n */\nexport async function sendCalls<\n  const calls extends readonly unknown[],\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SendCallsParameters<chain, account, chainOverride, calls>,\n): Promise<SendCallsReturnType> {\n  const {\n    account: account_ = client.account,\n    capabilities,\n    chain = client.chain,\n    experimental_fallback,\n    experimental_fallbackDelay = 32,\n    forceAtomic = false,\n    id,\n    version = '2.0.0',\n  } = parameters\n\n  const account = account_ ? parseAccount(account_) : null\n\n  const calls = parameters.calls.map((call_: unknown) => {\n    const call = call_ as Call\n\n    const data = call.abi\n      ? encodeFunctionData({\n          abi: call.abi,\n          functionName: call.functionName,\n          args: call.args,\n        })\n      : call.data\n\n    return {\n      data: call.dataSuffix && data ? concat([data, call.dataSuffix]) : data,\n      to: call.to,\n      value: call.value ? numberToHex(call.value) : undefined,\n    }\n  })\n\n  try {\n    const response = await client.request(\n      {\n        method: 'wallet_sendCalls',\n        params: [\n          {\n            atomicRequired: forceAtomic,\n            calls,\n            capabilities,\n            chainId: numberToHex(chain!.id),\n            from: account?.address,\n            id,\n            version,\n          },\n        ],\n      },\n      { retryCount: 0 },\n    )\n    if (typeof response === 'string') return { id: response }\n    return response as never\n  } catch (err) {\n    const error = err as BaseError\n\n    // If the transport does not support EIP-5792, fall back to\n    // `eth_sendTransaction`.\n    if (\n      experimental_fallback &&\n      (error.name === 'MethodNotFoundRpcError' ||\n        error.name === 'MethodNotSupportedRpcError' ||\n        error.name === 'UnknownRpcError' ||\n        error.details\n          .toLowerCase()\n          .includes('does not exist / is not available') ||\n        error.details.toLowerCase().includes('missing or invalid. request()') ||\n        error.details\n          .toLowerCase()\n          .includes('did not match any variant of untagged enum') ||\n        error.details\n          .toLowerCase()\n          .includes('account upgraded to unsupported contract') ||\n        error.details.toLowerCase().includes('eip-7702 not supported') ||\n        error.details.toLowerCase().includes('unsupported wc_ method') ||\n        // magic.link\n        error.details\n          .toLowerCase()\n          .includes('feature toggled misconfigured') ||\n        // Trust Wallet\n        error.details\n          .toLowerCase()\n          .includes(\n            'jsonrpcengine: response has no error or result for request',\n          ))\n    ) {\n      if (capabilities) {\n        const hasNonOptionalCapability = Object.values(capabilities).some(\n          (capability) => !capability.optional,\n        )\n        if (hasNonOptionalCapability) {\n          const message =\n            'non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.'\n          throw new UnsupportedNonOptionalCapabilityError(\n            new BaseError(message, {\n              details: message,\n            }),\n          )\n        }\n      }\n      if (forceAtomic && calls.length > 1) {\n        const message =\n          '`forceAtomic` is not supported on fallback to `eth_sendTransaction`.'\n        throw new AtomicityNotSupportedError(\n          new BaseError(message, {\n            details: message,\n          }),\n        )\n      }\n\n      const promises: Promise<Hex>[] = []\n      for (const call of calls) {\n        const promise = sendTransaction(client, {\n          account,\n          chain,\n          data: call.data,\n          to: call.to,\n          value: call.value ? hexToBigInt(call.value) : undefined,\n        })\n        promises.push(promise)\n\n        // Note: some browser wallets require a small delay between transactions\n        // to prevent duplicate JSON-RPC requests.\n        if (experimental_fallbackDelay > 0)\n          await new Promise((resolve) =>\n            setTimeout(resolve, experimental_fallbackDelay),\n          )\n      }\n\n      const results = await Promise.allSettled(promises)\n      if (results.every((r) => r.status === 'rejected')) throw results[0].reason\n\n      const hashes = results.map((result) => {\n        if (result.status === 'fulfilled') return result.value\n        return fallbackTransactionErrorMagicIdentifier\n      })\n      return {\n        id: concat([\n          ...hashes,\n          numberToHex(chain!.id, { size: 32 }),\n          fallbackMagicIdentifier,\n        ]),\n      }\n    }\n\n    throw getTransactionError(err as BaseError, {\n      ...parameters,\n      account,\n      chain: parameters.chain!,\n    })\n  }\n}\n","import { createSolanaRpc } from \"@solana/kit\";\n\nimport type { Network } from \"./utils.js\";\n\n/**\n * Create a Solana RPC client for the given network\n *\n * @param network - The network to connect to\n *\n * @returns The RPC client\n */\nexport function createRpcClient(network: Network) {\n  const endpoint =\n    network === \"mainnet\" ? \"https://api.mainnet-beta.solana.com\" : \"https://api.devnet.solana.com\";\n\n  return createSolanaRpc(endpoint);\n}\n","import platform from \"../platform/index.js\";\nimport utils from \"../utils.js\";\nimport AxiosError from \"../core/AxiosError.js\";\nimport composeSignals from \"../helpers/composeSignals.js\";\nimport {trackStream} from \"../helpers/trackStream.js\";\nimport AxiosHeaders from \"../core/AxiosHeaders.js\";\nimport {progressEventReducer, progressEventDecorator, asyncDecorator} from \"../helpers/progressEventReducer.js\";\nimport resolveConfig from \"../helpers/resolveConfig.js\";\nimport settle from \"../core/settle.js\";\n\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\n\nconst {isFunction} = utils;\n\nconst globalFetchAPI = (({Request, Response}) => ({\n  Request, Response\n}))(utils.global);\n\nconst {\n  ReadableStream, TextEncoder\n} = utils.global;\n\n\nconst test = (fn, ...args) => {\n  try {\n    return !!fn(...args);\n  } catch (e) {\n    return false\n  }\n}\n\nconst factory = (env) => {\n  env = utils.merge.call({\n    skipUndefined: true\n  }, globalFetchAPI, env);\n\n  const {fetch: envFetch, Request, Response} = env;\n  const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === 'function';\n  const isRequestSupported = isFunction(Request);\n  const isResponseSupported = isFunction(Response);\n\n  if (!isFetchSupported) {\n    return false;\n  }\n\n  const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream);\n\n  const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?\n      ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :\n      async (str) => new Uint8Array(await new Request(str).arrayBuffer())\n  );\n\n  const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {\n    let duplexAccessed = false;\n\n    const hasContentType = new Request(platform.origin, {\n      body: new ReadableStream(),\n      method: 'POST',\n      get duplex() {\n        duplexAccessed = true;\n        return 'half';\n      },\n    }).headers.has('Content-Type');\n\n    return duplexAccessed && !hasContentType;\n  });\n\n  const supportsResponseStream = isResponseSupported && isReadableStreamSupported &&\n    test(() => utils.isReadableStream(new Response('').body));\n\n  const resolvers = {\n    stream: supportsResponseStream && ((res) => res.body)\n  };\n\n  isFetchSupported && ((() => {\n    ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {\n      !resolvers[type] && (resolvers[type] = (res, config) => {\n        let method = res && res[type];\n\n        if (method) {\n          return method.call(res);\n        }\n\n        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);\n      })\n    });\n  })());\n\n  const getBodyLength = async (body) => {\n    if (body == null) {\n      return 0;\n    }\n\n    if (utils.isBlob(body)) {\n      return body.size;\n    }\n\n    if (utils.isSpecCompliantForm(body)) {\n      const _request = new Request(platform.origin, {\n        method: 'POST',\n        body,\n      });\n      return (await _request.arrayBuffer()).byteLength;\n    }\n\n    if (utils.isArrayBufferView(body) || utils.isArrayBuffer(body)) {\n      return body.byteLength;\n    }\n\n    if (utils.isURLSearchParams(body)) {\n      body = body + '';\n    }\n\n    if (utils.isString(body)) {\n      return (await encodeText(body)).byteLength;\n    }\n  }\n\n  const resolveBodyLength = async (headers, body) => {\n    const length = utils.toFiniteNumber(headers.getContentLength());\n\n    return length == null ? getBodyLength(body) : length;\n  }\n\n  return async (config) => {\n    let {\n      url,\n      method,\n      data,\n      signal,\n      cancelToken,\n      timeout,\n      onDownloadProgress,\n      onUploadProgress,\n      responseType,\n      headers,\n      withCredentials = 'same-origin',\n      fetchOptions\n    } = resolveConfig(config);\n\n    let _fetch = envFetch || fetch;\n\n    responseType = responseType ? (responseType + '').toLowerCase() : 'text';\n\n    let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);\n\n    let request = null;\n\n    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {\n      composedSignal.unsubscribe();\n    });\n\n    let requestContentLength;\n\n    try {\n      if (\n        onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&\n        (requestContentLength = await resolveBodyLength(headers, data)) !== 0\n      ) {\n        let _request = new Request(url, {\n          method: 'POST',\n          body: data,\n          duplex: \"half\"\n        });\n\n        let contentTypeHeader;\n\n        if (utils.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {\n          headers.setContentType(contentTypeHeader)\n        }\n\n        if (_request.body) {\n          const [onProgress, flush] = progressEventDecorator(\n            requestContentLength,\n            progressEventReducer(asyncDecorator(onUploadProgress))\n          );\n\n          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);\n        }\n      }\n\n      if (!utils.isString(withCredentials)) {\n        withCredentials = withCredentials ? 'include' : 'omit';\n      }\n\n      // Cloudflare Workers throws when credentials are defined\n      // see https://github.com/cloudflare/workerd/issues/902\n      const isCredentialsSupported = isRequestSupported && \"credentials\" in Request.prototype;\n\n      const resolvedOptions = {\n        ...fetchOptions,\n        signal: composedSignal,\n        method: method.toUpperCase(),\n        headers: headers.normalize().toJSON(),\n        body: data,\n        duplex: \"half\",\n        credentials: isCredentialsSupported ? withCredentials : undefined\n      };\n\n      request = isRequestSupported && new Request(url, resolvedOptions);\n\n      let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));\n\n      const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');\n\n      if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {\n        const options = {};\n\n        ['status', 'statusText', 'headers'].forEach(prop => {\n          options[prop] = response[prop];\n        });\n\n        const responseContentLength = utils.toFiniteNumber(response.headers.get('content-length'));\n\n        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(\n          responseContentLength,\n          progressEventReducer(asyncDecorator(onDownloadProgress), true)\n        ) || [];\n\n        response = new Response(\n          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {\n            flush && flush();\n            unsubscribe && unsubscribe();\n          }),\n          options\n        );\n      }\n\n      responseType = responseType || 'text';\n\n      let responseData = await resolvers[utils.findKey(resolvers, responseType) || 'text'](response, config);\n\n      !isStreamResponse && unsubscribe && unsubscribe();\n\n      return await new Promise((resolve, reject) => {\n        settle(resolve, reject, {\n          data: responseData,\n          headers: AxiosHeaders.from(response.headers),\n          status: response.status,\n          statusText: response.statusText,\n          config,\n          request\n        })\n      })\n    } catch (err) {\n      unsubscribe && unsubscribe();\n\n      if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {\n        throw Object.assign(\n          new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request),\n          {\n            cause: err.cause || err\n          }\n        )\n      }\n\n      throw AxiosError.from(err, err && err.code, config, request);\n    }\n  }\n}\n\nconst seedCache = new Map();\n\nexport const getFetch = (config) => {\n  let env = (config && config.env) || {};\n  const {fetch, Request, Response} = env;\n  const seeds = [\n    Request, Response, fetch\n  ];\n\n  let len = seeds.length, i = len,\n    seed, target, map = seedCache;\n\n  while (i--) {\n    seed = seeds[i];\n    target = map.get(seed);\n\n    target === undefined && map.set(seed, target = (i ? new Map() : factory(env)))\n\n    map = target;\n  }\n\n  return target;\n};\n\nconst adapter = getFetch();\n\nexport default adapter;\n","'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n *\n * @returns {string} The combined URL\n */\nexport default function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/?\\/$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n}\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const avalancheFuji = /*#__PURE__*/ defineChain({\n  id: 43_113,\n  name: 'Avalanche Fuji',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'Avalanche Fuji',\n    symbol: 'AVAX',\n  },\n  rpcUrls: {\n    default: { http: ['https://api.avax-test.network/ext/bc/C/rpc'] },\n  },\n  blockExplorers: {\n    default: {\n      name: 'SnowTrace',\n      url: 'https://testnet.snowtrace.io',\n      apiUrl: 'https://api-testnet.snowtrace.io',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xca11bde05977b3631167028862be2a173976ca11',\n      blockCreated: 7096959,\n    },\n  },\n  testnet: true,\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const songbird = /*#__PURE__*/ defineChain({\n  id: 19,\n  name: 'Songbird Canary-Network',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'Songbird',\n    symbol: 'SGB',\n  },\n  rpcUrls: {\n    default: { http: ['https://songbird-api.flare.network/ext/C/rpc'] },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Songbird Explorer',\n      url: 'https://songbird-explorer.flare.network',\n      apiUrl: 'https://songbird-explorer.flare.network/api',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 13382504,\n    },\n  },\n})\n","import type { Decoder, ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SolanaError,\n} from '@solana/errors';\n\nimport type { Account, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\n\n/**\n * Transforms an {@link EncodedAccount} into an {@link Account} (or a {@link MaybeEncodedAccount}\n * into a {@link MaybeAccount}) by decoding the account data using the provided {@link Decoder}\n * instance.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The type of this account's data.\n *\n * @example\n * ```ts\n * type MyAccountData = { name: string; age: number };\n *\n * const myAccount: EncodedAccount<'1234..5678'>;\n * const myDecoder: Decoder<MyAccountData> = getStructDecoder([\n *     ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *     ['age', getU32Decoder()],\n * ]);\n *\n * const myDecodedAccount = decodeAccount(myAccount, myDecoder);\n * myDecodedAccount satisfies Account<MyAccountData, '1234..5678'>;\n * ```\n */\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): MaybeAccount<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    try {\n        if ('exists' in encodedAccount && !encodedAccount.exists) {\n            return encodedAccount;\n        }\n        return Object.freeze({ ...encodedAccount, data: decoder.decode(encodedAccount.data) });\n    } catch {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT, {\n            address: encodedAccount.address,\n        });\n    }\n}\n\nfunction accountExists<TData extends object>(account: Account<TData> | MaybeAccount<TData>): account is Account<TData> {\n    return !('exists' in account) || ('exists' in account && account.exists);\n}\n\n/**\n * Asserts that an account stores decoded data, ie. not a `Uint8Array`.\n *\n * Note that it does not check the shape of the data matches the decoded type, only that it is not a\n * `Uint8Array`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The type of this account's data.\n *\n * @example\n * ```ts\n * type MyAccountData = { name: string; age: number };\n *\n * const myAccount: Account<MyAccountData | Uint8Array, '1234..5678'>;\n * assertAccountDecoded(myAccount);\n *\n * // now the account data can be used as MyAccountData\n * account.data satisfies MyAccountData;\n * ```\n *\n * This is particularly useful for narrowing the result of fetching a JSON parsed account.\n *\n * ```ts\n * const account: MaybeAccount<MockData | Uint8Array> = await fetchJsonParsedAccount<MockData>(\n *     rpc,\n *     '1234..5678' as Address,\n * );\n *\n * assertAccountDecoded(account);\n * // now we have a MaybeAccount<MockData>\n * account satisfies MaybeAccount<MockData>;\n * ```\n */\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is MaybeAccount<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress> | MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    if (accountExists(account) && account.data instanceof Uint8Array) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT, {\n            address: account.address,\n        });\n    }\n}\n\n/**\n * Asserts that all input accounts store decoded data, ie. not a `Uint8Array`.\n *\n * As with {@link assertAccountDecoded} it does not check the shape of the data matches the decoded\n * type, only that it is not a `Uint8Array`.\n *\n * @example\n * ```ts\n * type MyAccountData = { name: string; age: number };\n *\n * const myAccounts: Account<MyAccountData | Uint8Array, Address>[];\n * assertAccountsDecoded(myAccounts);\n *\n * // now the account data can be used as MyAccountData\n * for (const a of account) {\n *     account.data satisfies MyAccountData;\n * }\n * ```\n */\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: Account<ReadonlyUint8Array | TData, TAddress>[],\n): asserts accounts is Account<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: MaybeAccount<ReadonlyUint8Array | TData, TAddress>[],\n): asserts accounts is MaybeAccount<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: (Account<ReadonlyUint8Array | TData, TAddress> | MaybeAccount<ReadonlyUint8Array | TData, TAddress>)[],\n): asserts accounts is (Account<TData, TAddress> | MaybeAccount<TData, TAddress>)[] {\n    const encoded = accounts.filter(a => accountExists(a) && a.data instanceof Uint8Array);\n    if (encoded.length > 0) {\n        const encodedAddresses = encoded.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED, {\n            addresses: encodedAddresses,\n        });\n    }\n}\n","/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  const len = lst.length;\n  let Ah = new Uint32Array(len);\n  let Al = new Uint32Array(len);\n  for (let i = 0; i < len; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n","import { chainConfig } from '../../op-stack/chainConfig.js'\nimport { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const dchainTestnet = /*#__PURE__*/ defineChain({\n  ...chainConfig,\n  id: 2713017997578000,\n  name: 'Dchain Testnet',\n  nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: [\n        'https://dchaintestnet-2713017997578000-1.jsonrpc.testnet.sagarpc.io',\n      ],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Dchain Explorer',\n      url: 'https://dchaintestnet-2713017997578000-1.testnet.sagaexplorer.io',\n      apiUrl:\n        'https://api-dchaintestnet-2713017997578000-1.testnet.sagaexplorer.io/api',\n    },\n  },\n  contracts: {\n    ...chainConfig.contracts,\n  },\n})\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/sign/base-account/utils/presentAddOwnerDialog.ts","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/ui/Dialog/Dialog.tsx","import utils from './../utils.js';\nimport settle from './../core/settle.js';\nimport transitionalDefaults from '../defaults/transitional.js';\nimport AxiosError from '../core/AxiosError.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport parseProtocol from '../helpers/parseProtocol.js';\nimport platform from '../platform/index.js';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport {progressEventReducer} from '../helpers/progressEventReducer.js';\nimport resolveConfig from \"../helpers/resolveConfig.js\";\n\nconst isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';\n\nexport default isXHRAdapterSupported && function (config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    const _config = resolveConfig(config);\n    let requestData = _config.data;\n    const requestHeaders = AxiosHeaders.from(_config.headers).normalize();\n    let {responseType, onUploadProgress, onDownloadProgress} = _config;\n    let onCanceled;\n    let uploadThrottled, downloadThrottled;\n    let flushUpload, flushDownload;\n\n    function done() {\n      flushUpload && flushUpload(); // flush events\n      flushDownload && flushDownload(); // flush events\n\n      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);\n\n      _config.signal && _config.signal.removeEventListener('abort', onCanceled);\n    }\n\n    let request = new XMLHttpRequest();\n\n    request.open(_config.method.toUpperCase(), _config.url, true);\n\n    // Set the request timeout in MS\n    request.timeout = _config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      const responseHeaders = AxiosHeaders.from(\n        'getAllResponseHeaders' in request && request.getAllResponseHeaders()\n      );\n      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?\n        request.responseText : request.response;\n      const response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config,\n        request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n  request.onerror = function handleError(event) {\n       // Browsers deliver a ProgressEvent in XHR onerror\n       // (message may be empty; when present, surface it)\n       // See https://developer.mozilla.org/docs/Web/API/XMLHttpRequest/error_event\n       const msg = event && event.message ? event.message : 'Network Error';\n       const err = new AxiosError(msg, AxiosError.ERR_NETWORK, config, request);\n       // attach the underlying event for consumers who want details\n       err.event = event || null;\n       reject(err);\n       request = null;\n    };\n    \n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';\n      const transitional = _config.transitional || transitionalDefaults;\n      if (_config.timeoutErrorMessage) {\n        timeoutErrorMessage = _config.timeoutErrorMessage;\n      }\n      reject(new AxiosError(\n        timeoutErrorMessage,\n        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n        config,\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Remove Content-Type if data is undefined\n    requestData === undefined && requestHeaders.setContentType(null);\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {\n        request.setRequestHeader(key, val);\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(_config.withCredentials)) {\n      request.withCredentials = !!_config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = _config.responseType;\n    }\n\n    // Handle progress if needed\n    if (onDownloadProgress) {\n      ([downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true));\n      request.addEventListener('progress', downloadThrottled);\n    }\n\n    // Not all browsers support upload events\n    if (onUploadProgress && request.upload) {\n      ([uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress));\n\n      request.upload.addEventListener('progress', uploadThrottled);\n\n      request.upload.addEventListener('loadend', flushUpload);\n    }\n\n    if (_config.cancelToken || _config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = cancel => {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);\n        request.abort();\n        request = null;\n      };\n\n      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);\n      if (_config.signal) {\n        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    const protocol = parseProtocol(_config.url);\n\n    if (protocol && platform.protocols.indexOf(protocol) === -1) {\n      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));\n      return;\n    }\n\n\n    // Send the request\n    request.send(requestData || null);\n  });\n}\n","import { chainConfig } from '../../linea/chainConfig.js'\nimport { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const statusSepolia = /*#__PURE__*/ defineChain({\n  ...chainConfig,\n  id: 1_660_990_954,\n  name: 'Status Network Sepolia',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'Ether',\n    symbol: 'ETH',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://public.sepolia.rpc.status.network'],\n      webSocket: ['wss://public.sepolia.rpc.status.network/ws'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Blockscout',\n      url: 'https://sepoliascan.status.network',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xca11bde05977b3631167028862be2a173976ca11',\n      blockCreated: 1_578_364,\n    },\n  },\n  testnet: true,\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const zenchainTestnet = /*#__PURE__*/ defineChain({\n  id: 8408,\n  name: 'ZenChain Testnet',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'ZTC',\n    symbol: 'ZTC',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://zenchain-testnet.api.onfinality.io/public'],\n      webSocket: ['wss://zenchain-testnet.api.onfinality.io/public-ws'],\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 230019,\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Zentrace',\n      url: 'https://zentrace.io',\n    },\n  },\n  testnet: true,\n})\n","import { SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME, SolanaError } from '@solana/errors';\nimport { type Blockhash, isBlockhash } from '@solana/rpc-types';\n\nimport { ExcludeTransactionMessageLifetime, TransactionMessageWithLifetime } from './lifetime';\nimport { BaseTransactionMessage } from './transaction-message';\n\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network. The transaction message will continue to be eligible to land\n * until the network considers the `blockhash` to be expired.\n *\n * This can happen when the network proceeds past the `lastValidBlockHeight` for which the blockhash\n * is considered valid, or when the network switches to a fork where that blockhash is not present.\n */\ntype BlockhashLifetimeConstraint = Readonly<{\n    /**\n     * A recent blockhash observed by the transaction proposer.\n     *\n     * The transaction message will be considered eligible to land until the network determines this\n     * blockhash to be too old, or has switched to a fork where it is not present.\n     */\n    blockhash: Blockhash;\n    /**\n     * This is the block height beyond which the network will consider the blockhash to be too old\n     * to make a transaction message eligible to land.\n     */\n    lastValidBlockHeight: bigint;\n}>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the age of the blockhash it\n * includes.\n *\n * Such a transaction can only be landed on the network if the current block height of the network\n * is less than or equal to the value of\n * `TransactionMessageWithBlockhashLifetime['lifetimeConstraint']['lastValidBlockHeight']`.\n */\nexport interface TransactionMessageWithBlockhashLifetime {\n    readonly lifetimeConstraint: BlockhashLifetimeConstraint;\n}\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithBlockhashLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * if (isTransactionMessageWithBlockhashLifetime(message)) {\n *     // At this point, `message` has been refined to a `TransactionMessageWithBlockhashLifetime`.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsValid(blockhashIsValid);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a blockhash-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionMessageWithBlockhashLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n): transactionMessage is BaseTransactionMessage & TransactionMessageWithBlockhashLifetime {\n    return (\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.blockhash === 'string' &&\n        typeof transactionMessage.lifetimeConstraint.lastValidBlockHeight === 'bigint' &&\n        isBlockhash(transactionMessage.lifetimeConstraint.blockhash)\n    );\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * blockhash-based lifetime, from an untrusted network API or user input. Use this function to\n * assert that such a transaction message actually has a blockhash-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithBlockhashLifetime`.\n *     assertIsTransactionMessageWithBlockhashLifetime(message);\n *     // At this point, `message` is a `TransactionMessageWithBlockhashLifetime` that can be used\n *     // with the RPC.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n * } catch (e) {\n *     // `message` turned out not to have a blockhash-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionMessageWithBlockhashLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n): asserts transactionMessage is BaseTransactionMessage & TransactionMessageWithBlockhashLifetime {\n    if (!isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n    }\n}\n\n/**\n * Given a blockhash and the last block height at which that blockhash is considered usable to land\n * transactions, this method will return a new transaction message having the same type as the one\n * supplied plus the `TransactionMessageWithBlockhashLifetime` type.\n *\n * @example\n * ```ts\n * import { setTransactionMessageLifetimeUsingBlockhash } from '@solana/transaction-messages';\n *\n * const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n * const txMessageWithBlockhashLifetime = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, txMessage);\n * ```\n */\nexport function setTransactionMessageLifetimeUsingBlockhash<\n    TTransactionMessage extends BaseTransactionMessage & Partial<TransactionMessageWithLifetime>,\n>(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transactionMessage: TTransactionMessage,\n): ExcludeTransactionMessageLifetime<TTransactionMessage> & TransactionMessageWithBlockhashLifetime {\n    type ReturnType = ExcludeTransactionMessageLifetime<TTransactionMessage> & TransactionMessageWithBlockhashLifetime;\n\n    if (\n        'lifetimeConstraint' in transactionMessage &&\n        transactionMessage.lifetimeConstraint &&\n        'blockhash' in transactionMessage.lifetimeConstraint &&\n        transactionMessage.lifetimeConstraint.blockhash === blockhashLifetimeConstraint.blockhash &&\n        transactionMessage.lifetimeConstraint.lastValidBlockHeight === blockhashLifetimeConstraint.lastValidBlockHeight\n    ) {\n        return transactionMessage as ReturnType;\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        lifetimeConstraint: Object.freeze(blockhashLifetimeConstraint),\n    }) as ReturnType;\n}\n","// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\nexport function execTyped<type>(regex: RegExp, string: string) {\n  const match = regex.exec(string)\n  return match?.groups as type | undefined\n}\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n\nexport const isTupleRegex = /^\\(.+?\\).*?$/\n","/**\n * @module Hash\n */\n\nimport { subtle } from \"uncrypto\";\n\n/**\n * Auth-specific hash function using uncrypto for Edge runtime compatibility.\n * Computes SHA-256 hash of the given data.\n *\n * @param data - The data to hash\n * @returns Promise that resolves to the hex-encoded hash\n */\nexport const authHash = async (data: Buffer): Promise<string> => {\n  const hashBuffer = await subtle.digest(\"SHA-256\", data);\n  return Buffer.from(hashBuffer).toString(\"hex\");\n};\n","import type { ChainConfig, ChainEstimateFeesPerGasFn } from '../types/chain.js'\nimport { estimateGas } from './actions/estimateGas.js'\n\nexport const chainConfig = {\n  fees: {\n    estimateFeesPerGas,\n    async maxPriorityFeePerGas({ block, client, request }) {\n      const response = await estimateFeesPerGas({\n        block,\n        client,\n        multiply: (x) => x,\n        request,\n        type: 'eip1559',\n      })\n      // Returning `null` will trigger the base `estimateMaxPriorityFeePerGas` to perform\n      // fallback mechanisms to estimate priority fee.\n      if (!response?.maxPriorityFeePerGas) return null\n      return response.maxPriorityFeePerGas\n    },\n  },\n} as const satisfies ChainConfig\n\n///////////////////////////////////////////////////////////////////////////\n// Internal\n///////////////////////////////////////////////////////////////////////////\n\nasync function estimateFeesPerGas({\n  client,\n  multiply,\n  request,\n  type,\n}: Parameters<ChainEstimateFeesPerGasFn>[0]): ReturnType<ChainEstimateFeesPerGasFn> {\n  try {\n    const response = await estimateGas(client, {\n      ...request,\n      account: request?.account!,\n    })\n    const { priorityFeePerGas: maxPriorityFeePerGas } = response\n\n    const baseFeePerGas = multiply(BigInt(response.baseFeePerGas))\n    const maxFeePerGas = baseFeePerGas + maxPriorityFeePerGas\n\n    if (type === 'legacy') return { gasPrice: maxFeePerGas }\n    return {\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    }\n  } catch {\n    // Returning `null` will trigger the base `estimateFeesPerGas` to perform\n    // fallback mechanisms to estimate fees.\n    return null\n  }\n}\n","import { isValidNetworkForAccount } from \"./types.js\";\n\nimport type {\n  TransferExecutionStrategy,\n  SmartAccountTransferOptions,\n  TransferOptions,\n} from \"./types.js\";\nimport type { EvmAccount, EvmSmartAccount } from \"../../../accounts/evm/types.js\";\nimport type { CdpOpenApiClientType } from \"../../../openapi-client/index.js\";\nimport type { Address } from \"../../../types/misc.js\";\nimport type { TransactionResult } from \"../sendTransaction.js\";\nimport type { SendUserOperationReturnType } from \"../sendUserOperation.js\";\n\n/**\n * Transfer an amount of a token from an account to another account.\n *\n * @param apiClient - The client to use to send the transaction.\n * @param from - The account to send the transaction from.\n * @param transferArgs - The options for the transfer.\n * @param transferStrategy - The strategy to use to execute the transfer.\n * @returns The result of the transfer.\n */\nexport async function transfer<T extends EvmAccount | EvmSmartAccount>(\n  apiClient: CdpOpenApiClientType,\n  from: T,\n  transferArgs: T extends EvmSmartAccount ? SmartAccountTransferOptions : TransferOptions,\n  transferStrategy: TransferExecutionStrategy<T>,\n): Promise<T extends EvmSmartAccount ? SendUserOperationReturnType : TransactionResult> {\n  if (!isValidNetworkForAccount(transferArgs.network, from)) {\n    throw new Error(\n      `Network \"${transferArgs.network}\" is not supported for the given account type.`,\n    );\n  }\n\n  const to =\n    typeof transferArgs.to === \"string\" ? transferArgs.to : (transferArgs.to.address as Address);\n\n  const transfer = {\n    apiClient,\n    from,\n    to,\n    value: transferArgs.amount,\n    token: transferArgs.token,\n    network: transferArgs.network,\n    paymasterUrl: \"paymasterUrl\" in transferArgs ? transferArgs.paymasterUrl : undefined,\n  };\n\n  return transferStrategy.executeTransfer(transfer);\n}\n","import type { Client } from '../clients/createClient.js'\nimport type {\n  Address,\n  ChainEstimateFeesPerGasFnParameters,\n  ChainFees,\n  Hex,\n} from '../index.js'\nimport type { formatters } from './formatters.js'\n\nexport const fees: ChainFees<typeof formatters> = {\n  /*\n   * Estimates the fees per gas for a transaction.\n\n   * If the transaction is to be paid in a token (feeCurrency is present) then the fees \n   * are estimated in the value of the token. Otherwise falls back to the default\n   * estimation by returning null.\n   * \n   * @param params fee estimation function parameters\n   */\n  estimateFeesPerGas: async (\n    params: ChainEstimateFeesPerGasFnParameters<typeof formatters>,\n  ) => {\n    if (!params.request?.feeCurrency) return null\n\n    const [gasPrice, maxPriorityFeePerGas] = await Promise.all([\n      estimateFeePerGasInFeeCurrency(params.client, params.request.feeCurrency),\n      estimateMaxPriorityFeePerGasInFeeCurrency(\n        params.client,\n        params.request.feeCurrency,\n      ),\n    ])\n\n    // eth_gasPrice for cel2 returns baseFeePerGas + maxPriorityFeePerGas\n    const maxFeePerGas =\n      params.multiply(gasPrice - maxPriorityFeePerGas) + maxPriorityFeePerGas\n\n    return {\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    }\n  },\n}\n\ntype RequestGasPriceInFeeCurrencyParams = {\n  Method: 'eth_gasPrice'\n  Parameters: [Address]\n  ReturnType: Hex\n}\n\n/*\n * Estimate the fee per gas in the value of the fee token\n\n *\n * @param client - Client to use\n * @param feeCurrency -  Address of a whitelisted fee token\n * @returns The fee per gas in wei in the value of the  fee token\n *\n */\nasync function estimateFeePerGasInFeeCurrency(\n  client: Client,\n  feeCurrency: Address,\n) {\n  const fee = await client.request<RequestGasPriceInFeeCurrencyParams>({\n    method: 'eth_gasPrice',\n    params: [feeCurrency],\n  })\n  return BigInt(fee)\n}\n\ntype RequestMaxGasPriceInFeeCurrencyParams = {\n  Method: 'eth_maxPriorityFeePerGas'\n  Parameters: [Address]\n  ReturnType: Hex\n}\n\n/*\n * Estimate the max priority fee per gas in the value of the fee token\n\n *\n * @param client - Client to use\n * @param feeCurrency -  Address of a whitelisted fee token\n * @returns The fee per gas in wei in the value of the  fee token\n *\n */\nasync function estimateMaxPriorityFeePerGasInFeeCurrency(\n  client: Client,\n  feeCurrency: Address,\n) {\n  const feesPerGas =\n    await client.request<RequestMaxGasPriceInFeeCurrencyParams>({\n      method: 'eth_maxPriorityFeePerGas',\n      params: [feeCurrency],\n    })\n  return BigInt(feesPerGas)\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/kms/crypto-key/index.ts","import { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Concatenates an array of `Uint8Array`s into a single `Uint8Array`.\n * Reuses the original byte array when applicable.\n *\n * @param byteArrays - The array of byte arrays to concatenate.\n *\n * @example\n * ```ts\n * const bytes1 = new Uint8Array([0x01, 0x02]);\n * const bytes2 = new Uint8Array([]);\n * const bytes3 = new Uint8Array([0x03, 0x04]);\n * const bytes = mergeBytes([bytes1, bytes2, bytes3]);\n * //    ^ [0x01, 0x02, 0x03, 0x04]\n * ```\n */\nexport const mergeBytes = (byteArrays: Uint8Array[]): Uint8Array => {\n    const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n\n    const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach(arr => {\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\n\n/**\n * Pads a `Uint8Array` with zeroes to the specified length.\n * If the array is longer than the specified length, it is returned as-is.\n *\n * @param bytes - The byte array to pad.\n * @param length - The desired length of the byte array.\n *\n * @example\n * Adds zeroes to the end of the byte array to reach the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const paddedBytes = padBytes(bytes, 4);\n * //    ^ [0x01, 0x02, 0x00, 0x00]\n * ```\n *\n * @example\n * Returns the original byte array if it is already at the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const paddedBytes = padBytes(bytes, 2);\n * // bytes === paddedBytes\n * ```\n */\nexport function padBytes(bytes: Uint8Array, length: number): Uint8Array;\nexport function padBytes(bytes: ReadonlyUint8Array, length: number): ReadonlyUint8Array;\nexport function padBytes(bytes: ReadonlyUint8Array, length: number): ReadonlyUint8Array {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n}\n\n/**\n * Fixes a `Uint8Array` to the specified length.\n * If the array is longer than the specified length, it is truncated.\n * If the array is shorter than the specified length, it is padded with zeroes.\n *\n * @param bytes - The byte array to truncate or pad.\n * @param length - The desired length of the byte array.\n *\n * @example\n * Truncates the byte array to the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const fixedBytes = fixBytes(bytes, 2);\n * //    ^ [0x01, 0x02]\n * ```\n *\n * @example\n * Adds zeroes to the end of the byte array to reach the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const fixedBytes = fixBytes(bytes, 4);\n * //    ^ [0x01, 0x02, 0x00, 0x00]\n * ```\n *\n * @example\n * Returns the original byte array if it is already at the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const fixedBytes = fixBytes(bytes, 2);\n * // bytes === fixedBytes\n * ```\n */\nexport const fixBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array =>\n    padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\n\n/**\n * Returns true if and only if the provided `data` byte array contains\n * the provided `bytes` byte array at the specified `offset`.\n *\n * @param data - The byte sequence to search for.\n * @param bytes - The byte array in which to search for `data`.\n * @param offset - The position in `bytes` where the search begins.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const data = new Uint8Array([0x02, 0x03]);\n * containsBytes(bytes, data, 1); // true\n * containsBytes(bytes, data, 2); // false\n * ```\n */\nexport function containsBytes(\n    data: ReadonlyUint8Array | Uint8Array,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset: number,\n): boolean {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i) => b === slice[i]);\n}\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const iotaTestnet = /*#__PURE__*/ defineChain({\n  id: 1075,\n  name: 'IOTA EVM Testnet',\n  network: 'iotaevm-testnet',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'IOTA',\n    symbol: 'IOTA',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://json-rpc.evm.testnet.iotaledger.net'],\n      webSocket: ['wss://ws.json-rpc.evm.testnet.iotaledger.net'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Explorer',\n      url: 'https://explorer.evm.testnet.iotaledger.net',\n      apiUrl: 'https://explorer.evm.testnet.iotaledger.net/api',\n    },\n  },\n  testnet: true,\n})\n","import type { Abi, Address } from 'abitype'\nimport { BaseError } from '../../../errors/base.js'\nimport {\n  ContractFunctionExecutionError,\n  ContractFunctionRevertedError,\n  ContractFunctionZeroDataError,\n} from '../../../errors/contract.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Call } from '../../../types/calls.js'\nimport type { Hex } from '../../../types/misc.js'\nimport { decodeErrorResult } from '../../../utils/abi/decodeErrorResult.js'\nimport type { GetContractErrorReturnType } from '../../../utils/errors/getContractError.js'\nimport { ExecutionRevertedError } from '../../errors/bundler.js'\nimport {\n  UserOperationExecutionError,\n  type UserOperationExecutionErrorType,\n} from '../../errors/userOperation.js'\nimport type { UserOperation } from '../../types/userOperation.js'\nimport {\n  type GetBundlerErrorParameters,\n  getBundlerError,\n} from './getBundlerError.js'\n\ntype GetNodeErrorReturnType = ErrorType\n\nexport type GetUserOperationErrorParameters = UserOperation & {\n  calls?: readonly unknown[] | undefined\n  docsPath?: string | undefined\n}\n\nexport type GetUserOperationErrorReturnType<cause = ErrorType> = Omit<\n  UserOperationExecutionErrorType,\n  'cause'\n> & { cause: cause | GetNodeErrorReturnType }\n\nexport type GetUserOperationErrorErrorType = ErrorType\n\nexport function getUserOperationError<err extends ErrorType<string>>(\n  err: err,\n  { calls, docsPath, ...args }: GetUserOperationErrorParameters,\n): GetUserOperationErrorReturnType<err> {\n  const cause = (() => {\n    const cause = getBundlerError(\n      err as {} as BaseError,\n      args as GetBundlerErrorParameters,\n    )\n    if (calls && cause instanceof ExecutionRevertedError) {\n      const revertData = getRevertData(cause)\n      const contractCalls = calls?.filter(\n        (call: any) => call.abi,\n      ) as readonly Call[]\n      if (revertData && contractCalls.length > 0)\n        return getContractError({ calls: contractCalls, revertData })\n    }\n    return cause\n  })()\n  return new UserOperationExecutionError(cause, {\n    docsPath,\n    ...args,\n  }) as GetUserOperationErrorReturnType<err>\n}\n\n/////////////////////////////////////////////////////////////////////////////////\n\nfunction getRevertData(error: BaseError) {\n  let revertData: Hex | undefined\n  error.walk((e) => {\n    const error = e as any\n    if (\n      typeof error.data === 'string' ||\n      typeof error.data?.revertData === 'string' ||\n      (!(error instanceof BaseError) && typeof error.message === 'string')\n    ) {\n      const match = (\n        error.data?.revertData ||\n        error.data ||\n        error.message\n      ).match?.(/(0x[A-Za-z0-9]*)/)\n      if (match) {\n        revertData = match[1]\n        return true\n      }\n    }\n    return false\n  })\n  return revertData\n}\n\nfunction getContractError(parameters: {\n  calls: readonly Call[]\n  revertData: Hex\n}) {\n  const { calls, revertData } = parameters\n\n  const { abi, functionName, args, to } = (() => {\n    const contractCalls = calls?.filter((call) =>\n      Boolean(call.abi),\n    ) as readonly Call[]\n\n    if (contractCalls.length === 1) return contractCalls[0]\n\n    const compatContractCalls = contractCalls.filter((call) => {\n      try {\n        return Boolean(\n          decodeErrorResult({\n            abi: call.abi,\n            data: revertData,\n          }),\n        )\n      } catch {\n        return false\n      }\n    })\n    if (compatContractCalls.length === 1) return compatContractCalls[0]\n\n    return {\n      abi: [],\n      functionName: contractCalls.reduce(\n        (acc, call) => `${acc ? `${acc} | ` : ''}${call.functionName}`,\n        '',\n      ),\n      args: undefined,\n      to: undefined,\n    }\n  })() as {\n    abi: Abi\n    functionName: string\n    args: unknown[]\n    to: Address\n  }\n\n  const cause = (() => {\n    if (revertData === '0x')\n      return new ContractFunctionZeroDataError({ functionName })\n    return new ContractFunctionRevertedError({\n      abi,\n      data: revertData,\n      functionName,\n    })\n  })()\n  return new ContractFunctionExecutionError(cause as BaseError, {\n    abi,\n    args,\n    contractAddress: to,\n    functionName,\n  }) as GetContractErrorReturnType\n}\n","import {\n  type GetChainIdReturnType,\n  getChainId,\n} from '../../../actions/public/getChainId.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { SmartAccount } from '../../accounts/types.js'\nimport {\n  type EstimateUserOperationGasParameters,\n  type EstimateUserOperationGasReturnType,\n  estimateUserOperationGas,\n} from '../../actions/bundler/estimateUserOperationGas.js'\nimport {\n  type GetSupportedEntryPointsReturnType,\n  getSupportedEntryPoints,\n} from '../../actions/bundler/getSupportedEntryPoints.js'\nimport {\n  type GetUserOperationParameters,\n  type GetUserOperationReturnType,\n  getUserOperation,\n} from '../../actions/bundler/getUserOperation.js'\nimport {\n  type GetUserOperationReceiptParameters,\n  type GetUserOperationReceiptReturnType,\n  getUserOperationReceipt,\n} from '../../actions/bundler/getUserOperationReceipt.js'\nimport {\n  type PrepareUserOperationParameters,\n  type PrepareUserOperationRequest,\n  type PrepareUserOperationReturnType,\n  prepareUserOperation,\n} from '../../actions/bundler/prepareUserOperation.js'\nimport {\n  type SendUserOperationParameters,\n  type SendUserOperationReturnType,\n  sendUserOperation,\n} from '../../actions/bundler/sendUserOperation.js'\nimport {\n  type WaitForUserOperationReceiptParameters,\n  type WaitForUserOperationReceiptReturnType,\n  waitForUserOperationReceipt,\n} from '../../actions/bundler/waitForUserOperationReceipt.js'\n\nexport type BundlerActions<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n> = {\n  /**\n   * Returns an estimate of gas values necessary to execute the User Operation.\n   *\n   * - Docs: https://viem.sh/actions/bundler/estimateUserOperationGas\n   *\n   * @param client - Client to use\n   * @param parameters - {@link EstimateUserOperationGasParameters}\n   * @returns The gas estimate (in wei). {@link EstimateUserOperationGasReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http, parseEther } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { toSmartAccount } from 'viem/accounts'\n   *\n   * const account = await toSmartAccount({ ... })\n   *\n   * const bundlerClient = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const values = await bundlerClient.estimateUserOperationGas({\n   *   account,\n   *   calls: [{ to: '0x...', value: parseEther('1') }],\n   * })\n   */\n  estimateUserOperationGas: <\n    const calls extends readonly unknown[],\n    accountOverride extends SmartAccount | undefined = undefined,\n  >(\n    parameters: EstimateUserOperationGasParameters<\n      account,\n      accountOverride,\n      calls\n    >,\n  ) => Promise<EstimateUserOperationGasReturnType<account, accountOverride>>\n  /**\n   * Returns the chain ID associated with the bundler.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getChainId\n   * - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid)\n   *\n   * @returns The current chain ID. {@link GetChainIdReturnType}\n   *\n   * @example\n   * import { http } from 'viem'\n   * import { createBundlerClient, mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const chainId = await client.getChainId()\n   * // 1\n   */\n  getChainId: () => Promise<GetChainIdReturnType>\n  /**\n   * Returns the EntryPoints that the bundler supports.\n   *\n   * - Docs: https://viem.sh/actions/bundler/getSupportedEntryPoints\n   *\n   * @param client - Client to use\n   * @param parameters - {@link GetSupportedEntryPointsParameters}\n   * @returns Supported Entry Points. {@link GetSupportedEntryPointsReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http, parseEther } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const bundlerClient = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const addresses = await bundlerClient.getSupportedEntryPoints()\n   */\n  getSupportedEntryPoints: () => Promise<GetSupportedEntryPointsReturnType>\n  /**\n   * Returns the information about a User Operation given a hash.\n   *\n   * - Docs: https://viem.sh/docs/actions/bundler/getUserOperation\n   *\n   * @param client - Client to use\n   * @param parameters - {@link GetUserOperationParameters}\n   * @returns The receipt. {@link GetUserOperationReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const receipt = await client.getUserOperation({\n   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n   * })\n   */\n  getUserOperation: (\n    parameters: GetUserOperationParameters,\n  ) => Promise<GetUserOperationReturnType>\n  /**\n   * Returns the User Operation Receipt given a User Operation hash.\n   *\n   * - Docs: https://viem.sh/docs/actions/bundler/getUserOperationReceipt\n   *\n   * @param client - Client to use\n   * @param parameters - {@link GetUserOperationReceiptParameters}\n   * @returns The receipt. {@link GetUserOperationReceiptReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const receipt = await client.getUserOperationReceipt({\n   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n   * })\n   */\n  getUserOperationReceipt: (\n    parameters: GetUserOperationReceiptParameters,\n  ) => Promise<GetUserOperationReceiptReturnType>\n  /**\n   * Prepares a User Operation and fills in missing properties.\n   *\n   * - Docs: https://viem.sh/actions/bundler/prepareUserOperation\n   *\n   * @param args - {@link PrepareUserOperationParameters}\n   * @returns The User Operation. {@link PrepareUserOperationReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { toSmartAccount } from 'viem/accounts'\n   *\n   * const account = await toSmartAccount({ ... })\n   *\n   * const client = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const request = await client.prepareUserOperation({\n   *   account,\n   *   calls: [{ to: '0x...', value: parseEther('1') }],\n   * })\n   */\n  prepareUserOperation: <\n    const calls extends readonly unknown[],\n    const request extends PrepareUserOperationRequest<\n      account,\n      accountOverride,\n      calls\n    >,\n    accountOverride extends SmartAccount | undefined = undefined,\n  >(\n    parameters: PrepareUserOperationParameters<\n      account,\n      accountOverride,\n      calls,\n      request\n    >,\n  ) => Promise<\n    PrepareUserOperationReturnType<account, accountOverride, calls, request>\n  >\n  /**\n   * Broadcasts a User Operation to the Bundler.\n   *\n   * - Docs: https://viem.sh/actions/bundler/sendUserOperation\n   *\n   * @param client - Client to use\n   * @param parameters - {@link SendUserOperationParameters}\n   * @returns The User Operation hash. {@link SendUserOperationReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http, parseEther } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { toSmartAccount } from 'viem/accounts'\n   *\n   * const account = toSmartAccount({ ... })\n   *\n   * const bundlerClient = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const values = await bundlerClient.sendUserOperation({\n   *   account,\n   *   calls: [{ to: '0x...', value: parseEther('1') }],\n   * })\n   */\n  sendUserOperation: <\n    const calls extends readonly unknown[],\n    accountOverride extends SmartAccount | undefined = undefined,\n  >(\n    parameters: SendUserOperationParameters<account, accountOverride, calls>,\n  ) => Promise<SendUserOperationReturnType>\n  /**\n   * Waits for the User Operation to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the User Operation receipt.\n   *\n   * - Docs: https://viem.sh/docs/actions/bundler/waitForUserOperationReceipt\n   *\n   * @param client - Client to use\n   * @param parameters - {@link WaitForUserOperationReceiptParameters}\n   * @returns The receipt. {@link WaitForUserOperationReceiptReturnType}\n   *\n   * @example\n   * import { createBundlerClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createBundlerClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const receipt = await client.waitForUserOperationReceipt({\n   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n   * })\n   */\n  waitForUserOperationReceipt: (\n    parameters: WaitForUserOperationReceiptParameters,\n  ) => Promise<WaitForUserOperationReceiptReturnType>\n}\n\nexport function bundlerActions<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n>(client: Client<transport, chain, account>): BundlerActions<account> {\n  return {\n    estimateUserOperationGas: (parameters) =>\n      estimateUserOperationGas(client, parameters),\n    getChainId: () => getChainId(client),\n    getSupportedEntryPoints: () => getSupportedEntryPoints(client),\n    getUserOperation: (parameters) => getUserOperation(client, parameters),\n    getUserOperationReceipt: (parameters) =>\n      getUserOperationReceipt(client, parameters),\n    prepareUserOperation: (parameters) =>\n      prepareUserOperation(client, parameters),\n    sendUserOperation: (parameters) => sendUserOperation(client, parameters),\n    waitForUserOperationReceipt: (parameters) =>\n      waitForUserOperationReceipt(client, parameters),\n  }\n}\n","import { secp256k1 } from '@noble/curves/secp256k1'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex, Signature } from '../../types/misc.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\n\nexport type ParseSignatureErrorType = NumberToHexErrorType | ErrorType\n\n/**\n * @description Parses a hex formatted signature into a structured signature.\n *\n * @param signatureHex Signature in hex format.\n * @returns The structured signature.\n *\n * @example\n * parseSignature('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // { r: '0x...', s: '0x...', v: 28n }\n */\nexport function parseSignature(signatureHex: Hex) {\n  const { r, s } = secp256k1.Signature.fromCompact(signatureHex.slice(2, 130))\n  const yParityOrV = Number(`0x${signatureHex.slice(130)}`)\n  const [v, yParity] = (() => {\n    if (yParityOrV === 0 || yParityOrV === 1) return [undefined, yParityOrV]\n    if (yParityOrV === 27) return [BigInt(yParityOrV), 0]\n    if (yParityOrV === 28) return [BigInt(yParityOrV), 1]\n    throw new Error('Invalid yParityOrV value')\n  })()\n\n  if (typeof v !== 'undefined')\n    return {\n      r: numberToHex(r, { size: 32 }),\n      s: numberToHex(s, { size: 32 }),\n      v,\n      yParity,\n    } satisfies Signature\n  return {\n    r: numberToHex(r, { size: 32 }),\n    s: numberToHex(s, { size: 32 }),\n    yParity,\n  } satisfies Signature\n}\n","/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.ts';\n// prettier-ignore\nimport {\n  abytes, aexists, anumber, aoutput,\n  clean, createHasher, createXOFer, Hash,\n  swap32IfBE,\n  toBytes, u32,\n  type CHash, type CHashXO, type HashXOF, type Input\n} from './utils.ts';\n\n// No __PURE__ annotations in sha3 header:\n// EVERYTHING is in fact used on every export.\n// Various per round constants calculations\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nconst SHA3_PI: number[] = [];\nconst SHA3_ROTL: number[] = [];\nconst _SHA3_IOTA: bigint[] = [];\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  [x, y] = [y, (2 * x + 3 * y) % 5];\n  SHA3_PI.push(2 * (5 * y + x));\n  // Rotational\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n  // Iota\n  let t = _0n;\n  for (let j = 0; j < 7; j++) {\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n    if (R & _2n) t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n  }\n  _SHA3_IOTA.push(t);\n}\nconst IOTAS = split(_SHA3_IOTA, true);\nconst SHA3_IOTA_H = IOTAS[0];\nconst SHA3_IOTA_L = IOTAS[1];\n\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h: number, l: number, s: number) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h: number, l: number, s: number) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\nexport function keccakP(s: Uint32Array, rounds: number = 24): void {\n  const B = new Uint32Array(5 * 2);\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n  for (let round = 24 - rounds; round < 24; round++) {\n    // Theta \n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n    for (let x = 0; x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n      for (let y = 0; y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    }\n    // Rho () and Pi ()\n    let curH = s[2];\n    let curL = s[3];\n    for (let t = 0; t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    }\n    // Chi ()\n    for (let y = 0; y < 50; y += 10) {\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    }\n    // Iota ()\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n  clean(B);\n}\n\n/** Keccak sponge function. */\nexport class Keccak extends Hash<Keccak> implements HashXOF<Keccak> {\n  protected state: Uint8Array;\n  protected pos = 0;\n  protected posOut = 0;\n  protected finished = false;\n  protected state32: Uint32Array;\n  protected destroyed = false;\n\n  public blockLen: number;\n  public suffix: number;\n  public outputLen: number;\n  protected enableXOF = false;\n  protected rounds: number;\n\n  // NOTE: we accept arguments in bytes instead of bits here.\n  constructor(\n    blockLen: number,\n    suffix: number,\n    outputLen: number,\n    enableXOF = false,\n    rounds: number = 24\n  ) {\n    super();\n    this.blockLen = blockLen;\n    this.suffix = suffix;\n    this.outputLen = outputLen;\n    this.enableXOF = enableXOF;\n    this.rounds = rounds;\n    // Can be passed from user as dkLen\n    anumber(outputLen);\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n    // 0 < blockLen < 200\n    if (!(0 < blockLen && blockLen < 200))\n      throw new Error('only keccak-f1600 function is supported');\n    this.state = new Uint8Array(200);\n    this.state32 = u32(this.state);\n  }\n  clone(): Keccak {\n    return this._cloneInto();\n  }\n  protected keccak(): void {\n    swap32IfBE(this.state32);\n    keccakP(this.state32, this.rounds);\n    swap32IfBE(this.state32);\n    this.posOut = 0;\n    this.pos = 0;\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const { blockLen, state } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\n      if (this.pos === blockLen) this.keccak();\n    }\n    return this;\n  }\n  protected finish(): void {\n    if (this.finished) return;\n    this.finished = true;\n    const { state, suffix, pos, blockLen } = this;\n    // Do the padding\n    state[pos] ^= suffix;\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n    state[blockLen - 1] ^= 0x80;\n    this.keccak();\n  }\n  protected writeInto(out: Uint8Array): Uint8Array {\n    aexists(this, false);\n    abytes(out);\n    this.finish();\n    const bufferOut = this.state;\n    const { blockLen } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.keccak();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    anumber(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array): Uint8Array {\n    aoutput(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest(): Uint8Array {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.state);\n  }\n  _cloneInto(to?: Keccak): Keccak {\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\n    to.state32.set(this.state32);\n    to.pos = this.pos;\n    to.posOut = this.posOut;\n    to.finished = this.finished;\n    to.rounds = rounds;\n    // Suffix can change in cSHAKE\n    to.suffix = suffix;\n    to.outputLen = outputLen;\n    to.enableXOF = enableXOF;\n    to.destroyed = this.destroyed;\n    return to;\n  }\n}\n\nconst gen = (suffix: number, blockLen: number, outputLen: number) =>\n  createHasher(() => new Keccak(blockLen, suffix, outputLen));\n\n/** SHA3-224 hash function. */\nexport const sha3_224: CHash = /* @__PURE__ */ (() => gen(0x06, 144, 224 / 8))();\n/** SHA3-256 hash function. Different from keccak-256. */\nexport const sha3_256: CHash = /* @__PURE__ */ (() => gen(0x06, 136, 256 / 8))();\n/** SHA3-384 hash function. */\nexport const sha3_384: CHash = /* @__PURE__ */ (() => gen(0x06, 104, 384 / 8))();\n/** SHA3-512 hash function. */\nexport const sha3_512: CHash = /* @__PURE__ */ (() => gen(0x06, 72, 512 / 8))();\n\n/** keccak-224 hash function. */\nexport const keccak_224: CHash = /* @__PURE__ */ (() => gen(0x01, 144, 224 / 8))();\n/** keccak-256 hash function. Different from SHA3-256. */\nexport const keccak_256: CHash = /* @__PURE__ */ (() => gen(0x01, 136, 256 / 8))();\n/** keccak-384 hash function. */\nexport const keccak_384: CHash = /* @__PURE__ */ (() => gen(0x01, 104, 384 / 8))();\n/** keccak-512 hash function. */\nexport const keccak_512: CHash = /* @__PURE__ */ (() => gen(0x01, 72, 512 / 8))();\n\nexport type ShakeOpts = { dkLen?: number };\n\nconst genShake = (suffix: number, blockLen: number, outputLen: number) =>\n  createXOFer<HashXOF<Keccak>, ShakeOpts>(\n    (opts: ShakeOpts = {}) =>\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)\n  );\n\n/** SHAKE128 XOF with 128-bit security. */\nexport const shake128: CHashXO = /* @__PURE__ */ (() => genShake(0x1f, 168, 128 / 8))();\n/** SHAKE256 XOF with 256-bit security. */\nexport const shake256: CHashXO = /* @__PURE__ */ (() => genShake(0x1f, 136, 256 / 8))();\n","import type { Abi, Address, TypedData } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type GetChainIdReturnType,\n  getChainId,\n} from '../../actions/public/getChainId.js'\nimport {\n  type AddChainParameters,\n  addChain,\n} from '../../actions/wallet/addChain.js'\nimport {\n  type DeployContractParameters,\n  type DeployContractReturnType,\n  deployContract,\n} from '../../actions/wallet/deployContract.js'\nimport {\n  type GetAddressesReturnType,\n  getAddresses,\n} from '../../actions/wallet/getAddresses.js'\nimport {\n  type GetCallsStatusParameters,\n  type GetCallsStatusReturnType,\n  getCallsStatus,\n} from '../../actions/wallet/getCallsStatus.js'\nimport {\n  type GetCapabilitiesParameters,\n  type GetCapabilitiesReturnType,\n  getCapabilities,\n} from '../../actions/wallet/getCapabilities.js'\nimport {\n  type GetPermissionsReturnType,\n  getPermissions,\n} from '../../actions/wallet/getPermissions.js'\nimport {\n  type PrepareAuthorizationParameters,\n  type PrepareAuthorizationReturnType,\n  prepareAuthorization,\n} from '../../actions/wallet/prepareAuthorization.js'\nimport {\n  type PrepareTransactionRequestParameters,\n  type PrepareTransactionRequestRequest,\n  type PrepareTransactionRequestReturnType,\n  prepareTransactionRequest,\n} from '../../actions/wallet/prepareTransactionRequest.js'\nimport {\n  type RequestAddressesReturnType,\n  requestAddresses,\n} from '../../actions/wallet/requestAddresses.js'\nimport {\n  type RequestPermissionsParameters,\n  type RequestPermissionsReturnType,\n  requestPermissions,\n} from '../../actions/wallet/requestPermissions.js'\nimport {\n  type SendCallsParameters,\n  type SendCallsReturnType,\n  sendCalls,\n} from '../../actions/wallet/sendCalls.js'\nimport {\n  type SendCallsSyncParameters,\n  type SendCallsSyncReturnType,\n  sendCallsSync,\n} from '../../actions/wallet/sendCallsSync.js'\nimport {\n  type SendRawTransactionParameters,\n  type SendRawTransactionReturnType,\n  sendRawTransaction,\n} from '../../actions/wallet/sendRawTransaction.js'\nimport {\n  type SendRawTransactionSyncParameters,\n  type SendRawTransactionSyncReturnType,\n  sendRawTransactionSync,\n} from '../../actions/wallet/sendRawTransactionSync.js'\nimport {\n  type SendTransactionParameters,\n  type SendTransactionRequest,\n  type SendTransactionReturnType,\n  sendTransaction,\n} from '../../actions/wallet/sendTransaction.js'\nimport {\n  type SendTransactionSyncParameters,\n  type SendTransactionSyncRequest,\n  type SendTransactionSyncReturnType,\n  sendTransactionSync,\n} from '../../actions/wallet/sendTransactionSync.js'\nimport {\n  type ShowCallsStatusParameters,\n  type ShowCallsStatusReturnType,\n  showCallsStatus,\n} from '../../actions/wallet/showCallsStatus.js'\nimport {\n  type SignAuthorizationParameters,\n  type SignAuthorizationReturnType,\n  signAuthorization,\n} from '../../actions/wallet/signAuthorization.js'\nimport {\n  type SignMessageParameters,\n  type SignMessageReturnType,\n  signMessage,\n} from '../../actions/wallet/signMessage.js'\nimport {\n  type SignTransactionParameters,\n  type SignTransactionRequest,\n  type SignTransactionReturnType,\n  signTransaction,\n} from '../../actions/wallet/signTransaction.js'\nimport {\n  type SignTypedDataParameters,\n  type SignTypedDataReturnType,\n  signTypedData,\n} from '../../actions/wallet/signTypedData.js'\nimport {\n  type SwitchChainParameters,\n  switchChain,\n} from '../../actions/wallet/switchChain.js'\nimport {\n  type WaitForCallsStatusParameters,\n  type WaitForCallsStatusReturnType,\n  waitForCallsStatus,\n} from '../../actions/wallet/waitForCallsStatus.js'\nimport {\n  type WatchAssetParameters,\n  type WatchAssetReturnType,\n  watchAsset,\n} from '../../actions/wallet/watchAsset.js'\nimport {\n  type WriteContractParameters,\n  type WriteContractReturnType,\n  writeContract,\n} from '../../actions/wallet/writeContract.js'\nimport {\n  type WriteContractSyncParameters,\n  type WriteContractSyncReturnType,\n  writeContractSync,\n} from '../../actions/wallet/writeContractSync.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from '../../types/contract.js'\nimport type { Client } from '../createClient.js'\nimport type { Transport } from '../transports/createTransport.js'\n\nexport type WalletActions<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n> = {\n  /**\n   * Adds an EVM chain to the wallet.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/addChain\n   * - JSON-RPC Methods: [`eth_addEthereumChain`](https://eips.ethereum.org/EIPS/eip-3085)\n   *\n   * @param args - {@link AddChainParameters}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { optimism } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   transport: custom(window.ethereum),\n   * })\n   * await client.addChain({ chain: optimism })\n   */\n  addChain: (args: AddChainParameters) => Promise<void>\n  /**\n   * Deploys a contract to the network, given bytecode and constructor arguments.\n   *\n   * - Docs: https://viem.sh/docs/contract/deployContract\n   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_deploying-contracts\n   *\n   * @param args - {@link DeployContractParameters}\n   * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link DeployContractReturnType}\n   *\n   * @example\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x'),\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const hash = await client.deployContract({\n   *   abi: [],\n   *   account: '0x,\n   *   bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',\n   * })\n   */\n  deployContract: <\n    const abi extends Abi | readonly unknown[],\n    chainOverride extends Chain | undefined,\n  >(\n    args: DeployContractParameters<abi, chain, account, chainOverride>,\n  ) => Promise<DeployContractReturnType>\n  /**\n   * Returns a list of account addresses owned by the wallet or client.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/getAddresses\n   * - JSON-RPC Methods: [`eth_accounts`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_accounts)\n   *\n   * @returns List of account addresses owned by the wallet or client. {@link GetAddressesReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const accounts = await client.getAddresses()\n   */\n  getAddresses: () => Promise<GetAddressesReturnType>\n  /**\n   * Returns the status of a call batch that was sent via `sendCalls`.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/getCallsStatus\n   * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n   *\n   * @param client - Client to use\n   * @returns Status of the calls. {@link GetCallsStatusReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   *\n   * const { receipts, status } = await client.getCallsStatus({ id: '0xdeadbeef' })\n   */\n  getCallsStatus: (\n    parameters: GetCallsStatusParameters,\n  ) => Promise<GetCallsStatusReturnType>\n  /**\n   * Extract capabilities that a connected wallet supports (e.g. paymasters, session keys, etc).\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/getCapabilities\n   * - JSON-RPC Methods: [`wallet_getCapabilities`](https://eips.ethereum.org/EIPS/eip-5792)\n   *\n   * @param client - Client to use\n   * @returns The wallet's capabilities. {@link GetCapabilitiesReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   *\n   * const capabilities = await client.getCapabilities({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   * })\n   */\n  getCapabilities: <chainId extends number | undefined>(\n    parameters?: GetCapabilitiesParameters<chainId>,\n  ) => Promise<GetCapabilitiesReturnType<chainId>>\n  /**\n   * Returns the chain ID associated with the current network.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getChainId\n   * - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid)\n   *\n   * @returns The current chain ID. {@link GetChainIdReturnType}\n   *\n   * @example\n   * import { createWalletClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const chainId = await client.getChainId()\n   * // 1\n   */\n  getChainId: () => Promise<GetChainIdReturnType>\n  /**\n   * Gets the wallets current permissions.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/getPermissions\n   * - JSON-RPC Methods: [`wallet_getPermissions`](https://eips.ethereum.org/EIPS/eip-2255)\n   *\n   * @returns The wallet permissions. {@link GetPermissionsReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const permissions = await client.getPermissions()\n   */\n  getPermissions: () => Promise<GetPermissionsReturnType>\n  /**\n   * Prepares an [EIP-7702 Authorization](https://eips.ethereum.org/EIPS/eip-7702) object for signing.\n   * This Action will fill the required fields of the Authorization object if they are not provided (e.g. `nonce` and `chainId`).\n   *\n   * With the prepared Authorization object, you can use [`signAuthorization`](https://viem.sh/docs/eip7702/signAuthorization) to sign over the Authorization object.\n   *\n   * @param client - Client to use\n   * @param parameters - {@link PrepareAuthorizationParameters}\n   * @returns The prepared Authorization object. {@link PrepareAuthorizationReturnType}\n   *\n   * @example\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const authorization = await client.prepareAuthorization({\n   *   account: privateKeyToAccount('0x..'),\n   *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   * })\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x'),\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const authorization = await client.prepareAuthorization({\n   *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   * })\n   */\n  prepareAuthorization: (\n    parameters: PrepareAuthorizationParameters<account>,\n  ) => Promise<PrepareAuthorizationReturnType>\n  /**\n   * Prepares a transaction request for signing.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest\n   *\n   * @param args - {@link PrepareTransactionRequestParameters}\n   * @returns The transaction request. {@link PrepareTransactionRequestReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const request = await client.prepareTransactionRequest({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   to: '0x0000000000000000000000000000000000000000',\n   *   value: 1n,\n   * })\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x'),\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const request = await client.prepareTransactionRequest({\n   *   to: '0x0000000000000000000000000000000000000000',\n   *   value: 1n,\n   * })\n   */\n  prepareTransactionRequest: <\n    const request extends PrepareTransactionRequestRequest<\n      chain,\n      chainOverride\n    >,\n    chainOverride extends Chain | undefined = undefined,\n    accountOverride extends Account | Address | undefined = undefined,\n  >(\n    args: PrepareTransactionRequestParameters<\n      chain,\n      account,\n      chainOverride,\n      accountOverride,\n      request\n    >,\n  ) => Promise<\n    PrepareTransactionRequestReturnType<\n      chain,\n      account,\n      chainOverride,\n      accountOverride,\n      request\n    >\n  >\n  /**\n   * Requests a list of accounts managed by a wallet.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/requestAddresses\n   * - JSON-RPC Methods: [`eth_requestAccounts`](https://eips.ethereum.org/EIPS/eip-1102)\n   *\n   * Sends a request to the wallet, asking for permission to access the user's accounts. After the user accepts the request, it will return a list of accounts (addresses).\n   *\n   * This API can be useful for dapps that need to access the user's accounts in order to execute transactions or interact with smart contracts.\n   *\n   * @returns List of accounts managed by a wallet {@link RequestAddressesReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const accounts = await client.requestAddresses()\n   */\n  requestAddresses: () => Promise<RequestAddressesReturnType>\n  /**\n   * Requests permissions for a wallet.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/requestPermissions\n   * - JSON-RPC Methods: [`wallet_requestPermissions`](https://eips.ethereum.org/EIPS/eip-2255)\n   *\n   * @param args - {@link RequestPermissionsParameters}\n   * @returns The wallet permissions. {@link RequestPermissionsReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const permissions = await client.requestPermissions({\n   *   eth_accounts: {}\n   * })\n   */\n  requestPermissions: (\n    args: RequestPermissionsParameters,\n  ) => Promise<RequestPermissionsReturnType>\n  /**\n   * Requests the connected wallet to send a batch of calls.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/sendCalls\n   * - JSON-RPC Methods: [`wallet_sendCalls`](https://eips.ethereum.org/EIPS/eip-5792)\n   *\n   * @param client - Client to use\n   * @returns Transaction identifier. {@link SendCallsReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   *\n   * const id = await client.sendCalls({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   calls: [\n   *     {\n   *       data: '0xdeadbeef',\n   *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *     },\n   *     {\n   *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *       value: 69420n,\n   *     },\n   *   ],\n   * })\n   */\n  sendCalls: <\n    const calls extends readonly unknown[],\n    chainOverride extends Chain | undefined = undefined,\n  >(\n    parameters: SendCallsParameters<chain, account, chainOverride, calls>,\n  ) => Promise<SendCallsReturnType>\n  /**\n   * Requests the connected wallet to send a batch of calls, and waits for the calls to be included in a block.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/sendCallsSync\n   * - JSON-RPC Methods: [`wallet_sendCalls`](https://eips.ethereum.org/EIPS/eip-5792)\n   *\n   * @param client - Client to use\n   * @returns Calls status. {@link SendCallsSyncReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   *\n   * const status = await client.sendCallsSync({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   calls: [\n   *     {\n   *       data: '0xdeadbeef',\n   *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *     },\n   *     {\n   *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *       value: 69420n,\n   *     },\n   *   ],\n   * })\n   */\n  sendCallsSync: <\n    const calls extends readonly unknown[],\n    chainOverride extends Chain | undefined = undefined,\n  >(\n    parameters: SendCallsSyncParameters<chain, account, chainOverride, calls>,\n  ) => Promise<SendCallsSyncReturnType>\n  /**\n   * Sends a **signed** transaction to the network\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/sendRawTransaction\n   * - JSON-RPC Method: [`eth_sendRawTransaction`](https://ethereum.github.io/execution-apis/api-documentation/)\n   *\n   * @param client - Client to use\n   * @param parameters - {@link SendRawTransactionParameters}\n   * @returns The transaction hash. {@link SendRawTransactionReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { sendRawTransaction } from 'viem/wallet'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   *\n   * const hash = await client.sendRawTransaction({\n   *   serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33'\n   * })\n   */\n  sendRawTransaction: (\n    args: SendRawTransactionParameters,\n  ) => Promise<SendRawTransactionReturnType>\n  /**\n   * Sends a **signed** transaction to the network synchronously,\n   * and waits for the transaction to be included in a block.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/sendRawTransactionSync\n   * - JSON-RPC Method: [`eth_sendRawTransactionSync`](https://eips.ethereum.org/EIPS/eip-7966)\n   *\n   * @param client - Client to use\n   * @param parameters - {@link SendRawTransactionSyncParameters}\n   * @returns The transaction receipt. {@link SendRawTransactionSyncReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { sendRawTransactionSync } from 'viem/wallet'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   *\n   * const receipt = await client.sendRawTransactionSync({\n   *   serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33'\n   * })\n   */\n  sendRawTransactionSync: (\n    args: SendRawTransactionSyncParameters,\n  ) => Promise<SendRawTransactionSyncReturnType<chain>>\n  /**\n   * Creates, signs, and sends a new transaction to the network.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/sendTransaction\n   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions\n   * - JSON-RPC Methods:\n   *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)\n   *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)\n   *\n   * @param args - {@link SendTransactionParameters}\n   * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link SendTransactionReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const hash = await client.sendTransaction({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *   value: 1000000000000000000n,\n   * })\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x'),\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const hash = await client.sendTransaction({\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *   value: 1000000000000000000n,\n   * })\n   */\n  sendTransaction: <\n    const request extends SendTransactionRequest<chain, chainOverride>,\n    chainOverride extends Chain | undefined = undefined,\n  >(\n    args: SendTransactionParameters<chain, account, chainOverride, request>,\n  ) => Promise<SendTransactionReturnType>\n  /**\n   * Creates, signs, and sends a new transaction to the network synchronously.\n   * Returns the transaction receipt.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/sendTransactionSync\n   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions\n   * - JSON-RPC Methods:\n   *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)\n   *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)\n   *\n   * @param args - {@link SendTransactionParameters}\n   * @returns The transaction receipt. {@link SendTransactionReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const receipt = await client.sendTransactionSync({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *   value: 1000000000000000000n,\n   * })\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x'),\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const receipt = await client.sendTransactionSync({\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *   value: 1000000000000000000n,\n   * })\n   */\n  sendTransactionSync: <\n    const request extends SendTransactionSyncRequest<chain, chainOverride>,\n    chainOverride extends Chain | undefined = undefined,\n  >(\n    args: SendTransactionSyncParameters<chain, account, chainOverride, request>,\n  ) => Promise<SendTransactionSyncReturnType>\n  /**\n   * Requests for the wallet to show information about a call batch\n   * that was sent via `sendCalls`.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/showCallsStatus\n   * - JSON-RPC Methods: [`wallet_showCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n   *\n   * @param client - Client to use\n   * @returns Displays status of the calls in wallet. {@link ShowCallsStatusReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   *\n   * await client.showCallsStatus({ id: '0xdeadbeef' })\n   */\n  showCallsStatus: (\n    parameters: ShowCallsStatusParameters,\n  ) => Promise<ShowCallsStatusReturnType>\n  /**\n   * Signs an [EIP-7702 Authorization](https://eips.ethereum.org/EIPS/eip-7702) object.\n   *\n   * With the calculated signature, you can:\n   * - use [`verifyAuthorization`](https://viem.sh/docs/eip7702/verifyAuthorization) to verify the signed Authorization object,\n   * - use [`recoverAuthorizationAddress`](https://viem.sh/docs/eip7702/recoverAuthorizationAddress) to recover the signing address from the signed Authorization object.\n   *\n   * @param client - Client to use\n   * @param parameters - {@link SignAuthorizationParameters}\n   * @returns The signed Authorization object. {@link SignAuthorizationReturnType}\n   *\n   * @example\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const signature = await client.signAuthorization({\n   *   account: privateKeyToAccount('0x..'),\n   *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   * })\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x'),\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   *\n   * const signature = await client.signAuthorization({\n   *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   * })\n   */\n  signAuthorization: (\n    parameters: SignAuthorizationParameters<account>,\n  ) => Promise<SignAuthorizationReturnType>\n  /**\n   * Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))`.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/signMessage\n   * - JSON-RPC Methods:\n   *   - JSON-RPC Accounts: [`personal_sign`](https://docs.metamask.io/guide/signing-data#personal-sign)\n   *   - Local Accounts: Signs locally. No JSON-RPC request.\n   *\n   * With the calculated signature, you can:\n   * - use [`verifyMessage`](https://viem.sh/docs/utilities/verifyMessage) to verify the signature,\n   * - use [`recoverMessageAddress`](https://viem.sh/docs/utilities/recoverMessageAddress) to recover the signing address from a signature.\n   *\n   * @param args - {@link SignMessageParameters}\n   * @returns The signed message. {@link SignMessageReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const signature = await client.signMessage({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   message: 'hello world',\n   * })\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x'),\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const signature = await client.signMessage({\n   *   message: 'hello world',\n   * })\n   */\n  signMessage: (\n    args: SignMessageParameters<account>,\n  ) => Promise<SignMessageReturnType>\n  /**\n   * Signs a transaction.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/signTransaction\n   * - JSON-RPC Methods:\n   *   - JSON-RPC Accounts: [`eth_signTransaction`](https://ethereum.github.io/execution-apis/api-documentation/)\n   *   - Local Accounts: Signs locally. No JSON-RPC request.\n   *\n   * @param args - {@link SignTransactionParameters}\n   * @returns The signed message. {@link SignTransactionReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const request = await client.prepareTransactionRequest({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   to: '0x0000000000000000000000000000000000000000',\n   *   value: 1n,\n   * })\n   * const signature = await client.signTransaction(request)\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x'),\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const request = await client.prepareTransactionRequest({\n   *   to: '0x0000000000000000000000000000000000000000',\n   *   value: 1n,\n   * })\n   * const signature = await client.signTransaction(request)\n   */\n  signTransaction: <\n    chainOverride extends Chain | undefined,\n    const request extends SignTransactionRequest<\n      chain,\n      chainOverride\n    > = SignTransactionRequest<chain, chainOverride>,\n  >(\n    args: SignTransactionParameters<chain, account, chainOverride, request>,\n  ) => Promise<SignTransactionReturnType<request>>\n  /**\n   * Signs typed data and calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))`.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/signTypedData\n   * - JSON-RPC Methods:\n   *   - JSON-RPC Accounts: [`eth_signTypedData_v4`](https://docs.metamask.io/guide/signing-data#signtypeddata-v4)\n   *   - Local Accounts: Signs locally. No JSON-RPC request.\n   *\n   * @param client - Client to use\n   * @param args - {@link SignTypedDataParameters}\n   * @returns The signed data. {@link SignTypedDataReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const signature = await client.signTypedData({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   domain: {\n   *     name: 'Ether Mail',\n   *     version: '1',\n   *     chainId: 1,\n   *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n   *   },\n   *   types: {\n   *     Person: [\n   *       { name: 'name', type: 'string' },\n   *       { name: 'wallet', type: 'address' },\n   *     ],\n   *     Mail: [\n   *       { name: 'from', type: 'Person' },\n   *       { name: 'to', type: 'Person' },\n   *       { name: 'contents', type: 'string' },\n   *     ],\n   *   },\n   *   primaryType: 'Mail',\n   *   message: {\n   *     from: {\n   *       name: 'Cow',\n   *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n   *     },\n   *     to: {\n   *       name: 'Bob',\n   *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n   *     },\n   *     contents: 'Hello, Bob!',\n   *   },\n   * })\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x'),\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const signature = await client.signTypedData({\n   *   domain: {\n   *     name: 'Ether Mail',\n   *     version: '1',\n   *     chainId: 1,\n   *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n   *   },\n   *   types: {\n   *     Person: [\n   *       { name: 'name', type: 'string' },\n   *       { name: 'wallet', type: 'address' },\n   *     ],\n   *     Mail: [\n   *       { name: 'from', type: 'Person' },\n   *       { name: 'to', type: 'Person' },\n   *       { name: 'contents', type: 'string' },\n   *     ],\n   *   },\n   *   primaryType: 'Mail',\n   *   message: {\n   *     from: {\n   *       name: 'Cow',\n   *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n   *     },\n   *     to: {\n   *       name: 'Bob',\n   *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n   *     },\n   *     contents: 'Hello, Bob!',\n   *   },\n   * })\n   */\n  signTypedData: <\n    const typedData extends TypedData | { [key: string]: unknown },\n    primaryType extends string,\n  >(\n    args: SignTypedDataParameters<typedData, primaryType, account>,\n  ) => Promise<SignTypedDataReturnType>\n  /**\n   * Switch the target chain in a wallet.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/switchChain\n   * - JSON-RPC Methods: [`eth_switchEthereumChain`](https://eips.ethereum.org/EIPS/eip-3326)\n   *\n   * @param args - {@link SwitchChainParameters}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet, optimism } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * await client.switchChain({ id: optimism.id })\n   */\n  switchChain: (args: SwitchChainParameters) => Promise<void>\n  /**\n   * Waits for the status & receipts of a call bundle that was sent via `sendCalls`.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/waitForCallsStatus\n   * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n   *\n   * @param client - Client to use\n   * @param parameters - {@link WaitForCallsStatusParameters}\n   * @returns Status & receipts of the call bundle. {@link WaitForCallsStatusReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   *\n   * const { receipts, status } = await waitForCallsStatus(client, { id: '0xdeadbeef' })\n   */\n  waitForCallsStatus: (\n    parameters: WaitForCallsStatusParameters,\n  ) => Promise<WaitForCallsStatusReturnType>\n  /**\n   * Adds an EVM chain to the wallet.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/watchAsset\n   * - JSON-RPC Methods: [`eth_switchEthereumChain`](https://eips.ethereum.org/EIPS/eip-747)\n   *\n   * @param args - {@link WatchAssetParameters}\n   * @returns Boolean indicating if the token was successfully added. {@link WatchAssetReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const success = await client.watchAsset({\n   *   type: 'ERC20',\n   *   options: {\n   *     address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n   *     decimals: 18,\n   *     symbol: 'WETH',\n   *   },\n   * })\n   */\n  watchAsset: (args: WatchAssetParameters) => Promise<WatchAssetReturnType>\n  /**\n   * Executes a write function on a contract.\n   *\n   * - Docs: https://viem.sh/docs/contract/writeContract\n   * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts\n   *\n   * A \"write\" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms) is needed to be broadcast in order to change the state.\n   *\n   * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n   *\n   * __Warning: The `write` internally sends a transaction  it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract#usage) before you execute it.__\n   *\n   * @param args - {@link WriteContractParameters}\n   * @returns A [Transaction Hash](https://viem.sh/docs/glossary/terms#hash). {@link WriteContractReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom, parseAbi } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const hash = await client.writeContract({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n   *   functionName: 'mint',\n   *   args: [69420],\n   * })\n   *\n   * @example\n   * // With Validation\n   * import { createWalletClient, custom, parseAbi } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const { request } = await client.simulateContract({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n   *   functionName: 'mint',\n   *   args: [69420],\n   * }\n   * const hash = await client.writeContract(request)\n   */\n  writeContract: <\n    const abi extends Abi | readonly unknown[],\n    functionName extends ContractFunctionName<abi, 'payable' | 'nonpayable'>,\n    args extends ContractFunctionArgs<\n      abi,\n      'payable' | 'nonpayable',\n      functionName\n    >,\n    chainOverride extends Chain | undefined = undefined,\n  >(\n    args: WriteContractParameters<\n      abi,\n      functionName,\n      args,\n      chain,\n      account,\n      chainOverride\n    >,\n  ) => Promise<WriteContractReturnType>\n  /**\n   * Executes a write function on a contract synchronously.\n   * Returns the transaction receipt.\n   *\n   * - Docs: https://viem.sh/docs/contract/writeContract\n   *\n   * A \"write\" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms) is needed to be broadcast in order to change the state.\n   *\n   * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n   *\n   * __Warning: The `write` internally sends a transaction  it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract#usage) before you execute it.__\n   *\n   * @param args - {@link WriteContractSyncParameters}\n   * @returns A [Transaction Receipt](https://viem.sh/docs/glossary/terms#receipt). {@link WriteContractSyncReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom, parseAbi } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const receipt = await client.writeContractSync({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n   *   functionName: 'mint',\n   *   args: [69420],\n   * })\n   */\n  writeContractSync: <\n    const abi extends Abi | readonly unknown[],\n    functionName extends ContractFunctionName<abi, 'payable' | 'nonpayable'>,\n    args extends ContractFunctionArgs<\n      abi,\n      'payable' | 'nonpayable',\n      functionName\n    >,\n    chainOverride extends Chain | undefined = undefined,\n  >(\n    args: WriteContractSyncParameters<\n      abi,\n      functionName,\n      args,\n      chain,\n      account,\n      chainOverride\n    >,\n  ) => Promise<WriteContractSyncReturnType>\n}\n\nexport function walletActions<\n  transport extends Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n>(client: Client<transport, chain, account>): WalletActions<chain, account> {\n  return {\n    addChain: (args) => addChain(client, args),\n    deployContract: (args) => deployContract(client, args),\n    getAddresses: () => getAddresses(client),\n    getCallsStatus: (args) => getCallsStatus(client, args),\n    getCapabilities: (args) => getCapabilities(client, args),\n    getChainId: () => getChainId(client),\n    getPermissions: () => getPermissions(client),\n    prepareAuthorization: (args) => prepareAuthorization(client, args),\n    prepareTransactionRequest: (args) =>\n      prepareTransactionRequest(client as any, args as any) as any,\n    requestAddresses: () => requestAddresses(client),\n    requestPermissions: (args) => requestPermissions(client, args),\n    sendCalls: (args) => sendCalls(client, args),\n    sendCallsSync: (args) => sendCallsSync(client, args),\n    sendRawTransaction: (args) => sendRawTransaction(client, args),\n    sendRawTransactionSync: (args) => sendRawTransactionSync(client, args),\n    sendTransaction: (args) => sendTransaction(client, args),\n    sendTransactionSync: (args) => sendTransactionSync(client, args),\n    showCallsStatus: (args) => showCallsStatus(client, args),\n    signAuthorization: (args) => signAuthorization(client, args),\n    signMessage: (args) => signMessage(client, args),\n    signTransaction: (args) => signTransaction(client, args),\n    signTypedData: (args) => signTypedData(client, args),\n    switchChain: (args) => switchChain(client, args),\n    waitForCallsStatus: (args) => waitForCallsStatus(client, args),\n    watchAsset: (args) => watchAsset(client, args),\n    writeContract: (args) => writeContract(client, args as any),\n    writeContractSync: (args) => writeContractSync(client, args as any),\n  }\n}\n","import { Address, assertIsAddress, getAddressDecoder, getAddressEncoder, isAddress } from '@solana/addresses';\nimport { combineCodec, createEncoder, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\nexport type Blockhash = Brand<EncodedString<string, 'base58'>, 'Blockhash'>;\n\n/**\n * A type guard that returns `true` if the input string conforms to the {@link Blockhash} type, and\n * refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isBlockhash } from '@solana/rpc-types';\n *\n * if (isBlockhash(blockhash)) {\n *     // At this point, `blockhash` has been refined to a\n *     // `Blockhash` that can be used with the RPC.\n *     const { value: isValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsFresh(isValid);\n * } else {\n *     setError(`${blockhash} is not a blockhash`);\n * }\n * ```\n */\nexport function isBlockhash(putativeBlockhash: string): putativeBlockhash is Blockhash {\n    return isAddress(putativeBlockhash);\n}\n\n/**\n * From time to time you might acquire a string, that you expect to validate as a blockhash, from an\n * untrusted network API or user input. Use this function to assert that such an arbitrary string is\n * a base58-encoded blockhash.\n *\n * @example\n * ```ts\n * import { assertIsBlockhash } from '@solana/rpc-types';\n *\n * // Imagine a function that determines whether a blockhash is fresh when a user submits a form.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const blockhash: string = blockhashInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `blockhash` to `Blockhash`.\n *         assertIsBlockhash(blockhash);\n *         // At this point, `blockhash` is a `Blockhash` that can be used with the RPC.\n *         const { value: isValid } = await rpc.isBlockhashValid(blockhash).send();\n *     } catch (e) {\n *         // `blockhash` turned out not to be a base58-encoded blockhash\n *     }\n * }\n * ```\n */\nexport function assertIsBlockhash(putativeBlockhash: string): asserts putativeBlockhash is Blockhash {\n    try {\n        assertIsAddress(putativeBlockhash);\n    } catch (error) {\n        if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE)) {\n            throw new SolanaError(SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE, error.context);\n        }\n        if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH)) {\n            throw new SolanaError(SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH, error.context);\n        }\n        throw error;\n    }\n}\n\n/**\n * Combines _asserting_ that a string is a blockhash with _coercing_ it to the {@link Blockhash}\n * type. It's most useful with untrusted input.\n *\n * @example\n * ```ts\n * import { blockhash } from '@solana/rpc-types';\n *\n * const { value: isValid } = await rpc.isBlockhashValid(blockhash(blockhashFromUserInput)).send();\n * ```\n *\n * > [!TIP]\n * > When starting from a known-good blockhash as a string, it's more efficient to typecast it\n * rather than to use the {@link blockhash} helper, because the helper unconditionally performs\n * validation on its input.\n * >\n * > ```ts\n * > import { Blockhash } from '@solana/rpc-types';\n * >\n * > const blockhash = 'ABmPH5KDXX99u6woqFS5vfBGSNyKG42SzpvBMWWqAy48' as Blockhash;\n * > ```\n */\nexport function blockhash(putativeBlockhash: string): Blockhash {\n    assertIsBlockhash(putativeBlockhash);\n    return putativeBlockhash;\n}\n\n/**\n * Returns an encoder that you can use to encode a base58-encoded blockhash to a byte array.\n *\n * @example\n * ```ts\n * import { getBlockhashEncoder } from '@solana/rpc-types';\n *\n * const blockhash = 'ABmPH5KDXX99u6woqFS5vfBGSNyKG42SzpvBMWWqAy48' as Blockhash;\n * const blockhashEncoder = getBlockhashEncoder();\n * const blockhashBytes = blockhashEncoder.encode(blockhash);\n * // Uint8Array(32) [\n * //   136, 123,  44, 249,  43,  19,  60,  14,\n * //   144,  16, 168, 241, 121, 111,  70, 232,\n * //   186,  26, 140, 202, 213,  64, 231,  82,\n * //   179,  66, 103, 237,  52, 117, 217,  93\n * // ]\n * ```\n */\nexport function getBlockhashEncoder(): FixedSizeEncoder<Blockhash, 32> {\n    const addressEncoder = getAddressEncoder();\n    return createEncoder({\n        fixedSize: 32,\n        write: (value: string, bytes, offset) => {\n            assertIsBlockhash(value);\n            return addressEncoder.write(value as string as Address, bytes, offset);\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to convert an array of 32 bytes representing a blockhash to\n * the base58-encoded representation of that blockhash.\n *\n * @example\n * ```ts\n * import { getBlockhashDecoder } from '@solana/rpc-types';\n *\n * const blockhashBytes = new Uint8Array([\n *     136, 123,  44, 249,  43,  19,  60,  14,\n *     144,  16, 168, 241, 121, 111,  70, 232,\n *     186,  26, 140, 202, 213,  64, 231,  82,\n *     179,  66, 103, 237,  52, 117, 217,  93\n * ]);\n * const blockhashDecoder = getBlockhashDecoder();\n * const blockhash = blockhashDecoder.decode(blockhashBytes); // ABmPH5KDXX99u6woqFS5vfBGSNyKG42SzpvBMWWqAy48\n * ```\n */\nexport function getBlockhashDecoder(): FixedSizeDecoder<Blockhash, 32> {\n    return getAddressDecoder() as FixedSizeDecoder<string, 32> as FixedSizeDecoder<Blockhash, 32>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a base-58 encoded blockhash.\n *\n * @see {@link getBlockhashDecoder}\n * @see {@link getBlockhashEncoder}\n */\nexport function getBlockhashCodec(): FixedSizeCodec<Blockhash, Blockhash, 32> {\n    return combineCodec(getBlockhashEncoder(), getBlockhashDecoder());\n}\n\nexport function getBlockhashComparator(): (x: string, y: string) => number {\n    return new Intl.Collator('en', {\n        caseFirst: 'lower',\n        ignorePunctuation: false,\n        localeMatcher: 'best fit',\n        numeric: false,\n        sensitivity: 'variant',\n        usage: 'sort',\n    }).compare;\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, SolanaError } from '@solana/errors';\n\nimport { MessageSigner } from './message-signer';\nimport { TransactionSigner } from './transaction-signer';\n\n/**\n * Removes all duplicated {@link MessageSigner | MessageSigners} and\n * {@link TransactionSigner | TransactionSigners} from a provided array\n * by comparing their {@link Address | addresses}.\n *\n * @internal\n */\nexport function deduplicateSigners<TSigner extends MessageSigner | TransactionSigner>(\n    signers: readonly TSigner[],\n): readonly TSigner[] {\n    const deduplicated: Record<Address, TSigner> = {};\n    signers.forEach(signer => {\n        if (!deduplicated[signer.address]) {\n            deduplicated[signer.address] = signer;\n        } else if (deduplicated[signer.address] !== signer) {\n            throw new SolanaError(SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, {\n                address: signer.address,\n            });\n        }\n    });\n    return Object.values(deduplicated);\n}\n","/**\n * @module Client\n */\n\nimport { constants, publicEncrypt } from \"crypto\";\n\nimport { type Address, getTypesForEIP712Domain } from \"viem\";\n\nimport {\n  CreateServerAccountOptions,\n  CreateSmartAccountOptions,\n  CreateSwapQuoteOptions,\n  CreateSwapQuoteResult,\n  EvmClientInterface,\n  ExportServerAccountOptions,\n  GetOrCreateServerAccountOptions,\n  GetOrCreateSmartAccountOptions,\n  GetServerAccountOptions,\n  GetSmartAccountOptions,\n  GetSwapPriceOptions,\n  GetSwapPriceResult,\n  GetUserOperationOptions,\n  ImportServerAccountOptions,\n  ListServerAccountResult,\n  ListServerAccountsOptions,\n  ListSmartAccountResult,\n  ListSmartAccountsOptions,\n  PrepareAndSendUserOperationOptions,\n  PrepareUserOperationOptions,\n  ServerAccount,\n  SignatureResult,\n  SignHashOptions,\n  SignMessageOptions,\n  SignTransactionOptions,\n  SignTypedDataOptions,\n  SmartAccount,\n  SwapUnavailableResult,\n  UpdateEvmAccountOptions,\n  UpdateEvmSmartAccountOptions,\n  UserOperation,\n  WaitForUserOperationOptions,\n} from \"./evm.types.js\";\nimport { toEvmServerAccount } from \"../../accounts/evm/toEvmServerAccount.js\";\nimport { toEvmSmartAccount } from \"../../accounts/evm/toEvmSmartAccount.js\";\nimport { getUserOperation } from \"../../actions/evm/getUserOperation.js\";\nimport {\n  listSpendPermissions,\n  ListSpendPermissionsResult,\n} from \"../../actions/evm/listSpendPermissions.js\";\nimport {\n  listTokenBalances,\n  ListTokenBalancesOptions,\n  ListTokenBalancesResult,\n} from \"../../actions/evm/listTokenBalances.js\";\nimport {\n  requestFaucet,\n  RequestFaucetOptions,\n  RequestFaucetResult,\n} from \"../../actions/evm/requestFaucet.js\";\nimport { sendTransaction } from \"../../actions/evm/sendTransaction.js\";\nimport {\n  PrepareAndSendUserOperationReturnType,\n  sendUserOperation,\n  SendUserOperationOptions,\n  SendUserOperationReturnType,\n} from \"../../actions/evm/sendUserOperation.js\";\nimport { resolveSpendPermission } from \"../../actions/evm/spend-permissions/resolveSpendPermission.js\";\nimport { createSwapQuote } from \"../../actions/evm/swap/createSwapQuote.js\";\nimport { getSwapPrice } from \"../../actions/evm/swap/getSwapPrice.js\";\nimport {\n  waitForUserOperation,\n  WaitForUserOperationReturnType,\n} from \"../../actions/evm/waitForUserOperation.js\";\nimport { Analytics } from \"../../analytics.js\";\nimport { ImportAccountPublicRSAKey } from \"../../constants.js\";\nimport { UserInputValidationError } from \"../../errors.js\";\nimport { APIError } from \"../../openapi-client/errors.js\";\nimport {\n  CdpOpenApiClient,\n  EvmUserOperationStatus,\n  EIP712Message as OpenAPIEIP712Message,\n} from \"../../openapi-client/index.js\";\nimport { SPEND_PERMISSION_MANAGER_ADDRESS } from \"../../spend-permissions/constants.js\";\nimport { Hex } from \"../../types/misc.js\";\nimport { decryptWithPrivateKey, generateExportEncryptionKeyPair } from \"../../utils/export.js\";\n\nimport type {\n  SendTransactionOptions,\n  TransactionResult,\n} from \"../../actions/evm/sendTransaction.js\";\nimport type {\n  CreateSpendPermissionOptions,\n  ListSpendPermissionsOptions,\n  RevokeSpendPermissionOptions,\n} from \"../../spend-permissions/types.js\";\n\n/**\n * The namespace containing all EVM methods.\n */\nexport class EvmClient implements EvmClientInterface {\n  /**\n   * Creates a new CDP EVM account.\n   *\n   * @param {CreateServerAccountOptions} [options] - Optional parameters for creating the account.\n   * @param {string} [options.name] - A name for the account to create.\n   * @param {string} [options.idempotencyKey] - An idempotency key.\n   *\n   * @returns A promise that resolves to the newly created account.\n   *\n   * @example **Without arguments**\n   *          ```ts\n   *          const account = await cdp.evm.createAccount();\n   *          ```\n   *\n   * @example **With a name**\n   *          ```ts\n   *          const account = await cdp.evm.createAccount({ name: \"MyAccount\" });\n   *          ```\n   *\n   * @example **With an idempotency key**\n   *          ```ts\n   *          const idempotencyKey = uuidv4();\n   *\n   *          // First call\n   *          await cdp.evm.createAccount({\n   *            idempotencyKey,\n   *          });\n   *\n   *          // Second call with the same idempotency key will return the same account\n   *          await cdp.evm.createAccount({\n   *            idempotencyKey,\n   *          });\n   *          ```\n   */\n  async createAccount(options: CreateServerAccountOptions = {}): Promise<ServerAccount> {\n    Analytics.trackAction({\n      action: \"create_account\",\n      accountType: \"evm_server\",\n    });\n\n    return this._createAccountInternal(options);\n  }\n\n  /**\n   * Imports a CDP EVM account from an external source.\n   *\n   * @param {ImportServerAccountOptions} options - Parameters for importing the account.\n   * @param {string} options.privateKey - The private key of the account to import.\n   * @param {string} [options.name] - A name for the account to import.\n   * @param {string} [options.idempotencyKey] - An idempotency key.\n   *\n   * @returns A promise that resolves to the imported account.\n   *\n   * @example **Without arguments**\n   *          ```ts\n   *          const account = await cdp.evm.importAccount({\n   *            privateKey: \"0x123456\"\n   *          });\n   *          ```\n   *\n   * @example **With a name**\n   *          ```ts\n   *          const account = await cdp.evm.importAccount({\n   *            privateKey: \"0x123456\",\n   *            name: \"MyAccount\"\n   *          });\n   *          ```\n   *\n   * @example **With an idempotency key**\n   *          ```ts\n   *          const idempotencyKey = uuidv4();\n   *\n   *          // First call\n   *          await cdp.evm.importAccount({\n   *            privateKey: \"0x123456\",\n   *            idempotencyKey,\n   *          });\n   *\n   *          // Second call with the same idempotency key will return the same account\n   *          await cdp.evm.importAccount({\n   *            privateKey: \"0x123456\"\n   *            idempotencyKey,\n   *          });\n   *          ```\n   */\n  async importAccount(options: ImportServerAccountOptions): Promise<ServerAccount> {\n    Analytics.trackAction({\n      action: \"import_account\",\n      accountType: \"evm_server\",\n    });\n\n    const encryptionPublicKey = options.encryptionPublicKey || ImportAccountPublicRSAKey;\n\n    const privateKeyHex = options.privateKey.startsWith(\"0x\")\n      ? options.privateKey.slice(2)\n      : options.privateKey;\n\n    if (!/^[0-9a-fA-F]+$/.test(privateKeyHex)) {\n      throw new UserInputValidationError(\"Private key must be a valid hexadecimal string\");\n    }\n\n    try {\n      const privateKeyBytes = Buffer.from(privateKeyHex, \"hex\");\n\n      const encryptedPrivateKey = publicEncrypt(\n        {\n          key: encryptionPublicKey,\n          padding: constants.RSA_PKCS1_OAEP_PADDING,\n          oaepHash: \"sha256\",\n        },\n        privateKeyBytes,\n      );\n\n      const openApiAccount = await CdpOpenApiClient.importEvmAccount(\n        {\n          name: options.name,\n          encryptedPrivateKey: encryptedPrivateKey.toString(\"base64\"),\n        },\n        options.idempotencyKey,\n      );\n\n      const account = toEvmServerAccount(CdpOpenApiClient, {\n        account: openApiAccount,\n      });\n\n      Analytics.wrapObjectMethodsWithErrorTracking(account);\n\n      return account;\n    } catch (error) {\n      if (error instanceof APIError) {\n        throw error;\n      }\n      throw new Error(`Failed to import account: ${String(error)}`);\n    }\n  }\n\n  /**\n   * Exports a CDP EVM account's private key.\n   * It is important to store the private key in a secure place after it's exported.\n   *\n   * @param {ExportServerAccountOptions} options - Parameters for exporting the account.\n   * @param {string} [options.address] - The address of the account to export.\n   * @param {string} [options.name] - The name of the account to export.\n   * @param {string} [options.idempotencyKey] - An idempotency key.\n   *\n   * @returns A promise that resolves to the exported accounts 32-byte private key as a hex string, without the \"0x\" prefix.\n   *\n   * @example **With an address**\n   * ```ts\n   * const privateKey = await cdp.evm.exportAccount({\n   *   address: \"0x1234567890123456789012345678901234567890\",\n   * });\n   * ```\n   *\n   * @example **With a name**\n   * ```ts\n   * const privateKey = await cdp.evm.exportAccount({\n   *   name: \"MyAccount\",\n   * });\n   * ```\n   */\n  async exportAccount(options: ExportServerAccountOptions): Promise<string> {\n    Analytics.trackAction({\n      action: \"export_account\",\n      accountType: \"evm_server\",\n    });\n\n    const { publicKey, privateKey } = await generateExportEncryptionKeyPair();\n\n    const { encryptedPrivateKey } = await (async () => {\n      if (options.address) {\n        return CdpOpenApiClient.exportEvmAccount(\n          options.address,\n          {\n            exportEncryptionKey: publicKey,\n          },\n          options.idempotencyKey,\n        );\n      }\n\n      if (options.name) {\n        return CdpOpenApiClient.exportEvmAccountByName(\n          options.name,\n          {\n            exportEncryptionKey: publicKey,\n          },\n          options.idempotencyKey,\n        );\n      }\n\n      throw new UserInputValidationError(\"Either address or name must be provided\");\n    })();\n\n    return decryptWithPrivateKey(privateKey, encryptedPrivateKey);\n  }\n\n  /**\n   * Creates a new CDP EVM smart account.\n   *\n   * @param {CreateSmartAccountOptions} options - Parameters for creating the smart account.\n   * @param {Account} options.owner - The owner of the smart account.\n   * The owner can be any Ethereum account with signing capabilities,\n   * such as a CDP EVM account or a Viem LocalAccount.\n   * @param {string} [options.idempotencyKey] - An idempotency key.\n   *\n   * @returns A promise that resolves to the newly created smart account.\n   *\n   * @example **With a CDP EVM Account as the owner**\n   *          ```ts\n   *          const account = await cdp.evm.createAccount();\n   *          const smartAccount = await cdp.evm.createSmartAccount({\n   *            owner: account,\n   *          });\n   *          ```\n   *\n   * @example **With a Viem LocalAccount as the owner**\n   *          ```ts\n   *          // See https://viem.sh/docs/accounts/local/privateKeyToAccount\n   *          const privateKey = generatePrivateKey();\n   *          const account = privateKeyToAccount(privateKey);\n   *          const smartAccount = await client.evm.createSmartAccount({\n   *            owner: account,\n   *          });\n   *          ```\n   *\n   * @example **With an idempotency key**\n   *          ```ts\n   *          const idempotencyKey = uuidv4();\n   *\n   *          // First call\n   *          await cdp.evm.createSmartAccount({\n   *            owner: account,\n   *            idempotencyKey,\n   *          });\n   *\n   *          // Second call with the same idempotency key will return the same smart account\n   *          await cdp.evm.createSmartAccount({\n   *            owner: account,\n   *            idempotencyKey,\n   *          ```\n   */\n  async createSmartAccount(options: CreateSmartAccountOptions): Promise<SmartAccount> {\n    Analytics.trackAction({\n      action: \"create_smart_account\",\n      accountType: \"evm_smart\",\n    });\n\n    return this._createSmartAccountInternal(options);\n  }\n\n  /**\n   * Creates a spend permission for a smart account.\n   *\n   * @param {CreateSpendPermissionOptions} options - Parameters for creating the spend permission.\n   * @param {SpendPermission} options.spendPermission - The spend permission to create.\n   * @param {string} [options.idempotencyKey] - The idempotency key to use for the spend permission.\n   *\n   * @returns A promise that resolves to the spend permission.\n   *\n   * @example\n   * ```ts\n   * const userOperation = await cdp.evm.createSpendPermission({\n   *   spendPermission,\n   *   network: \"base-sepolia\",\n   * });\n   * ```\n   */\n  async createSpendPermission(options: CreateSpendPermissionOptions): Promise<UserOperation> {\n    Analytics.trackAction({\n      action: \"create_spend_permission\",\n    });\n\n    const resolvedSpendPermission = resolveSpendPermission(\n      options.spendPermission,\n      options.network,\n    );\n\n    const userOperation = await CdpOpenApiClient.createSpendPermission(\n      resolvedSpendPermission.account,\n      {\n        spender: resolvedSpendPermission.spender,\n        token: resolvedSpendPermission.token,\n        allowance: resolvedSpendPermission.allowance.toString(),\n        period: resolvedSpendPermission.period.toString(),\n        start: resolvedSpendPermission.start.toString(),\n        end: resolvedSpendPermission.end.toString(),\n        salt: resolvedSpendPermission.salt.toString(),\n        extraData: resolvedSpendPermission.extraData,\n        network: options.network,\n        paymasterUrl: options.paymasterUrl,\n      },\n      options.idempotencyKey,\n    );\n\n    return {\n      network: userOperation.network,\n      userOpHash: userOperation.userOpHash as Hex,\n      status: userOperation.status,\n      calls: userOperation.calls.map(call => ({\n        to: call.to as Address,\n        value: BigInt(call.value),\n        data: call.data as Hex,\n      })),\n    };\n  }\n\n  /**\n   * Revokes a spend permission for a smart account.\n   *\n   * @param {RevokeSpendPermissionOptions} options - Parameters for revoking the spend permission.\n   * @param {string} options.address - The address of the smart account.\n   * @param {string} options.permissionHash - The hash of the spend permission to revoke.\n   * @param {string} options.network - The network of the spend permission.\n   * @param {string} [options.paymasterUrl] - The paymaster URL of the spend permission.\n   *\n   * @returns A promise that resolves to the user operation.\n   *\n   * @example\n   * ```ts\n   * const userOperation = await cdp.evm.revokeSpendPermission({\n   *   address: \"0x1234567890123456789012345678901234567890\",\n   *   permissionHash: \"0x1234567890123456789012345678901234567890123456789012345678901234\",\n   *   network: \"base-sepolia\",\n   * });\n   * ```\n   */\n  async revokeSpendPermission(options: RevokeSpendPermissionOptions): Promise<UserOperation> {\n    Analytics.trackAction({\n      action: \"revoke_spend_permission\",\n    });\n\n    const userOperation = await CdpOpenApiClient.revokeSpendPermission(\n      options.address,\n      {\n        network: options.network,\n        permissionHash: options.permissionHash,\n        paymasterUrl: options.paymasterUrl,\n      },\n      options.idempotencyKey,\n    );\n\n    return {\n      network: userOperation.network,\n      userOpHash: userOperation.userOpHash as Hex,\n      status: userOperation.status,\n      calls: userOperation.calls.map(call => ({\n        to: call.to as Address,\n        value: BigInt(call.value),\n        data: call.data as Hex,\n      })),\n    };\n  }\n\n  /**\n   * Gets a CDP EVM account.\n   *\n   * @param {GetServerAccountOptions} options - Parameters for getting the account.\n   * Either `address` or `name` must be provided.\n   * If both are provided, lookup will be done by `address` and `name` will be ignored.\n   * @param {string} [options.address] - The address of the account to get.\n   * @param {string} [options.name] - The name of the account to get.\n   *\n   * @returns A promise that resolves to the account.\n   *\n   * @example **Get an account by address**\n   *          ```ts\n   *          const account = await cdp.evm.getAccount({\n   *            address: \"0x1234567890123456789012345678901234567890\",\n   *          });\n   *          ```\n   *\n   * @example **Get an account by name**\n   *          ```ts\n   *          const account = await cdp.evm.getAccount({\n   *            name: \"MyAccount\",\n   *          });\n   *          ```\n   */\n  async getAccount(options: GetServerAccountOptions): Promise<ServerAccount> {\n    Analytics.trackAction({\n      action: \"get_account\",\n      accountType: \"evm_server\",\n    });\n\n    return this._getAccountInternal(options);\n  }\n\n  /**\n   * Gets a CDP EVM smart account.\n   *\n   * @param {GetSmartAccountOptions} options - Parameters for getting the smart account.\n   * Either `address` or `name` must be provided.\n   * If both are provided, lookup will be done by `address` and `name` will be ignored.\n   * @param {string} [options.address] - The address of the smart account to get.\n   * @param {string} [options.name] - The name of the smart account to get.\n   * @param {Account} options.owner - The owner of the smart account.\n   * You must pass the signing-capable owner of the smart account so that the returned smart account\n   * can be functional.\n   *\n   * @returns A promise that resolves to the smart account.\n   *\n   * @example\n   * ```ts\n   * const smartAccount = await cdp.evm.getSmartAccount({\n   *   address: \"0x1234567890123456789012345678901234567890\",\n   *   owner: account,\n   * });\n   * ```\n   */\n  async getSmartAccount(options: GetSmartAccountOptions): Promise<SmartAccount> {\n    Analytics.trackAction({\n      action: \"get_smart_account\",\n    });\n\n    return this._getSmartAccountInternal(options);\n  }\n\n  /**\n   * Gets a CDP EVM account, or creates one if it doesn't exist.\n   *\n   * @param {GetOrCreateServerAccountOptions} options - Parameters for getting or creating the account.\n   * @param {string} [options.name] - The name of the account to get or create.\n   *\n   * @returns A promise that resolves to the account.\n   *\n   * @example\n   * ```ts\n   * const account = await cdp.evm.getOrCreateAccount({\n   *   name: \"MyAccount\",\n   * });\n   * ```\n   */\n  async getOrCreateAccount(options: GetOrCreateServerAccountOptions): Promise<ServerAccount> {\n    Analytics.trackAction({\n      action: \"get_or_create_account\",\n      accountType: \"evm_server\",\n    });\n\n    try {\n      const account = await this._getAccountInternal(options);\n      return account;\n    } catch (error) {\n      // If it failed because the account doesn't exist, create it\n      const doesAccountNotExist = error instanceof APIError && error.statusCode === 404;\n      if (doesAccountNotExist) {\n        try {\n          const account = await this._createAccountInternal(options);\n          return account;\n        } catch (error) {\n          // If it failed because the account already exists, get the existing account\n          const doesAccountAlreadyExist = error instanceof APIError && error.statusCode === 409;\n          if (doesAccountAlreadyExist) {\n            const account = await this._getAccountInternal(options);\n            return account;\n          }\n          throw error;\n        }\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Gets a CDP EVM smart account, or creates one if it doesn't exist.\n   * This method first attempts to retrieve an existing smart account with the given parameters.\n   * If no account exists, it creates a new one with the specified owner.\n   *\n   * @param {GetOrCreateSmartAccountOptions} options - Configuration options for getting or creating the smart account.\n   * @param {string} [options.name] - The name of the smart account to get or create.\n   * @param {Account} options.owner - The owner of the smart account.\n   *\n   * @returns {Promise<SmartAccount>} A promise that resolves to the retrieved or newly created smart account.\n   *\n   * @example\n   * ```ts\n   * const smartAccount = await cdp.evm.getOrCreateSmartAccount({\n   *   name: \"MySmartAccount\",\n   *   owner: account,\n   * });\n   * ```\n   */\n  async getOrCreateSmartAccount(options: GetOrCreateSmartAccountOptions): Promise<SmartAccount> {\n    Analytics.trackAction({\n      action: \"get_or_create_smart_account\",\n      accountType: \"evm_smart\",\n    });\n\n    try {\n      const account = await this._getSmartAccountInternal(options);\n      return account;\n    } catch (error) {\n      // If it failed because the account doesn't exist, create it\n      const doesAccountNotExist = error instanceof APIError && error.statusCode === 404;\n      if (doesAccountNotExist) {\n        try {\n          const account = await this._createSmartAccountInternal(options);\n          return account;\n        } catch (error) {\n          // If it failed because the account already exists, get the existing account\n          const doesAccountAlreadyExist = error instanceof APIError && error.statusCode === 409;\n          if (doesAccountAlreadyExist) {\n            const account = await this._getSmartAccountInternal(options);\n            return account;\n          }\n          throw error;\n        }\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Gets the price for a swap between two tokens on an EVM network.\n   *\n   * @param {GetSwapPriceOptions} options - The options for getting a swap price.\n   *\n   * @returns {Promise<GetSwapPriceResult | SwapUnavailableResult>} A promise that resolves to the swap price result or a response indicating that liquidity is unavailable.\n   *\n   * @example\n   * ```typescript\n   * const price = await cdp.evm.getSwapPrice({\n   *   network: \"ethereum-mainnet\",\n   *   toToken: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\", // USDC\n   *   fromToken: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\", // WETH\n   *   fromAmount: BigInt(\"1000000000000000000\"), // 1 WETH\n   *   taker: \"0x1234567890123456789012345678901234567890\"\n   * });\n   * ```\n   */\n  async getSwapPrice(\n    options: GetSwapPriceOptions,\n  ): Promise<GetSwapPriceResult | SwapUnavailableResult> {\n    Analytics.trackAction({\n      action: \"get_swap_price\",\n      properties: {\n        network: options.network,\n      },\n    });\n\n    return getSwapPrice(CdpOpenApiClient, options);\n  }\n\n  /**\n   * Creates a quote for a swap between two tokens on an EVM network.\n   *\n   * @param {CreateSwapQuoteOptions} options - The options for creating a swap quote.\n   *\n   * @returns {Promise<CreateSwapQuoteResult | SwapUnavailableResult>} A promise that resolves to the swap quote result or a response indicating that liquidity is unavailable.\n   *\n   * @example\n   * ```typescript\n   * const swapQuote = await cdp.evm.createSwapQuote({\n   *   network: \"ethereum\",\n   *   toToken: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\", // USDC\n   *   fromToken: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\", // WETH\n   *   fromAmount: BigInt(\"1000000000000000000\"), // 1 WETH\n   *   taker: \"0x1234567890123456789012345678901234567890\"\n   * });\n   * ```\n   */\n  async createSwapQuote(\n    options: CreateSwapQuoteOptions,\n  ): Promise<CreateSwapQuoteResult | SwapUnavailableResult> {\n    Analytics.trackAction({\n      action: \"create_swap_quote\",\n      properties: {\n        network: options.network,\n      },\n    });\n\n    return createSwapQuote(CdpOpenApiClient, options);\n  }\n\n  /**\n   * Gets a user operation for a smart account by user operation hash.\n   *\n   * @param {GetUserOperationOptions} options - Parameters for getting the user operation.\n   * @param {SmartAccount} options.smartAccount - The smart account signing the user operation.\n   * @param {string} options.userOpHash - The user operation hash.\n   *\n   * @returns A promise that resolves to the user operation.\n   *\n   * @example\n   * ```ts\n   * const userOp = await cdp.evm.getUserOperation({\n   *   smartAccount,\n   *   userOpHash: \"0x1234567890123456789012345678901234567890123456789012345678901234\",\n   * });\n   * ```\n   */\n  async getUserOperation(options: GetUserOperationOptions): Promise<UserOperation> {\n    Analytics.trackAction({\n      action: \"get_user_operation\",\n    });\n\n    return getUserOperation(CdpOpenApiClient, options);\n  }\n\n  /**\n   * Lists CDP EVM accounts.\n   *\n   * @param {ListServerAccountsOptions} [options] - Optional parameters for listing the accounts.\n   * @param {number} [options.pageSize] - The number of accounts to return.\n   * @param {string} [options.pageToken] - The page token to begin listing from.\n   * This is obtained by previous calls to this method.\n   *\n   * @returns A promise that resolves to an array of accounts, and a token to paginate through the accounts.\n   *\n   * @example\n   * ```ts\n   * const accounts = await cdp.evm.listAccounts();\n   * ```\n   *\n   * @example **With pagination**\n   *          ```ts\n   *          let page = await cdp.evm.listAccounts();\n   *\n   *          while (page.nextPageToken) {\n   *            page = await cdp.evm.listAccounts({ pageToken: page.nextPageToken });\n   *          }\n   *          ```\n   */\n  async listAccounts(options: ListServerAccountsOptions = {}): Promise<ListServerAccountResult> {\n    Analytics.trackAction({\n      action: \"list_accounts\",\n      accountType: \"evm_server\",\n    });\n\n    const ethAccounts = await CdpOpenApiClient.listEvmAccounts({\n      pageSize: options.pageSize,\n      pageToken: options.pageToken,\n    });\n\n    return {\n      accounts: ethAccounts.accounts.map(account => {\n        const evmAccount = toEvmServerAccount(CdpOpenApiClient, {\n          account,\n        });\n\n        Analytics.wrapObjectMethodsWithErrorTracking(evmAccount);\n\n        return evmAccount;\n      }),\n      nextPageToken: ethAccounts.nextPageToken,\n    };\n  }\n\n  /**\n   * Lists CDP EVM token balances.\n   *\n   * @param {ListTokenBalancesOptions} options - Parameters for listing the token balances.\n   * @param {number} [options.pageSize] - The number of token balances to return.\n   * @param {string} [options.pageToken] - The page token to begin listing from.\n   * This is obtained by previous calls to this method.\n   *\n   * @returns A promise that resolves to an array of token balances, and a token to paginate through the token balances.\n   *\n   * @example\n   * ```ts\n   * const tokenBalances = await cdp.evm.listTokenBalances({\n   *   address: \"0x1234567890123456789012345678901234567890\",\n   *   network: \"base-sepolia\",\n   * });\n   * ```\n   *\n   * @example\n   * **With pagination**\n   * ```ts\n   * let page = await cdp.evm.listTokenBalances({\n   *   address: \"0x1234567890123456789012345678901234567890\",\n   *   network: \"base-sepolia\",\n   * });\n   *\n   * while (page.nextPageToken) {\n   *   page = await cdp.evm.listTokenBalances({\n   *     address: \"0x1234567890123456789012345678901234567890\",\n   *     network: \"base-sepolia\",\n   *     pageToken: page.nextPageToken,\n   *   });\n   * }\n   */\n  async listTokenBalances(options: ListTokenBalancesOptions): Promise<ListTokenBalancesResult> {\n    Analytics.trackAction({\n      action: \"list_token_balances\",\n      properties: {\n        network: options.network,\n      },\n    });\n\n    return listTokenBalances(CdpOpenApiClient, options);\n  }\n\n  /**\n   * Lists CDP EVM smart accounts.\n   *\n   * @param {ListSmartAccountsOptions} options - Parameters for listing the smart accounts.\n   * @param {number} [options.pageSize] - The number of smart accounts to return.\n   * @param {string} [options.pageToken] - The page token to begin listing from.\n   * This is obtained by previous calls to this method.\n   *\n   * @returns A promise that resolves to an array of smart accounts, and a token to paginate through the smart accounts.\n   *\n   * @example\n   * ```ts\n   * const smartAccounts = await cdp.evm.listSmartAccounts();\n   * ```\n   *\n   * @example **With pagination**\n   *          ```ts\n   *          let page = await cdp.evm.listSmartAccounts();\n   *\n   *          while (page.nextPageToken) {\n   *            page = await cdp.evm.listSmartAccounts({ pageToken: page.nextPageToken });\n   *          }\n   *          ```\n   */\n  async listSmartAccounts(options: ListSmartAccountsOptions = {}): Promise<ListSmartAccountResult> {\n    Analytics.trackAction({\n      action: \"list_smart_accounts\",\n    });\n\n    const smartAccounts = await CdpOpenApiClient.listEvmSmartAccounts({\n      pageSize: options.pageSize,\n      pageToken: options.pageToken,\n    });\n\n    return {\n      accounts: smartAccounts.accounts.map(account => ({\n        address: account.address as Address,\n        owners: [account.owners[0] as Address],\n        type: \"evm-smart\",\n        policies: account.policies,\n      })),\n      nextPageToken: smartAccounts.nextPageToken,\n    };\n  }\n\n  /**\n   * Lists the spend permissions for a smart account.\n   *\n   * @param {ListSpendPermissionsOptions} options - Parameters for listing the spend permissions.\n   * @param {string} options.address - The address of the smart account.\n   * @param {number} [options.pageSize] - The number of spend permissions to return.\n   * @param {string} [options.pageToken] - The page token to return the next page of spend permissions.\n   *\n   * @returns A promise that resolves to the spend permissions.\n   */\n  async listSpendPermissions(\n    options: ListSpendPermissionsOptions,\n  ): Promise<ListSpendPermissionsResult> {\n    Analytics.trackAction({\n      action: \"list_spend_permissions\",\n    });\n\n    return listSpendPermissions(CdpOpenApiClient, options);\n  }\n\n  /**\n   * Prepares a user operation for a smart account.\n   *\n   * @param {PrepareUserOperationOptions} options - Parameters for preparing the user operation.\n   * @param {SmartAccount} options.smartAccount - The smart account signing the user operation.\n   * @param {string} options.network - The network to prepare the user operation for.\n   * @param {EvmCall[]} options.calls - The calls to include in the user operation.\n   * @param {string} [options.paymasterUrl] - The optional paymaster URL to use for the user operation.\n   *\n   * @returns A promise that resolves to the user operation hash.\n   *\n   * @example\n   * ```ts\n   * const userOp = await cdp.evm.prepareUserOperation({\n   *   smartAccount,\n   *   network: \"base-sepolia\",\n   *   calls: [\n   *     {\n   *       to: \"0x1234567890123456789012345678901234567890\",\n   *       value: parseEther(\"0.000001\"),\n   *       data: \"0x\",\n   *     },\n   *   ],\n   * });\n   * ```\n   */\n  async prepareUserOperation(options: PrepareUserOperationOptions): Promise<UserOperation> {\n    Analytics.trackAction({\n      action: \"prepare_user_operation\",\n      properties: {\n        network: options.network,\n      },\n    });\n\n    const userOp = await CdpOpenApiClient.prepareUserOperation(options.smartAccount.address, {\n      network: options.network,\n      calls: options.calls.map(call => ({\n        to: call.to as Address,\n        value: call.value.toString(),\n        data: call.data as Hex,\n        overrideGasLimit: call.overrideGasLimit,\n      })),\n      paymasterUrl: options.paymasterUrl,\n    });\n\n    return {\n      network: userOp.network,\n      userOpHash: userOp.userOpHash as Hex,\n      status: userOp.status,\n      calls: userOp.calls.map(call => ({\n        to: call.to as Address,\n        value: BigInt(call.value),\n        data: call.data as Hex,\n      })),\n    };\n  }\n\n  /**\n   * Prepares and sends a user operation for a smart account.\n   *\n   * @param {PrepareAndSendUserOperationOptions} options - Parameters for preparing and sending the user operation.\n   * @param {SmartAccount} options.smartAccount - The smart account signing the user operation.\n   * @param {string} options.network - The network to prepare and send the user operation on.\n   * @param {EvmCall[]} options.calls - The calls to include in the user operation.\n   * @param {string} [options.paymasterUrl] - The optional paymaster URL to use for the user operation.\n   *\n   * @returns A promise that resolves to the smart account address, user operation hash, and status of the user operation.\n   *\n   * @example\n   * ```ts\n   * const { userOpHash } = await cdp.evm.prepareAndSendUserOperation({\n   *   smartAccount,\n   *   network: \"base-sepolia\",\n   *   calls: [\n   *     {\n   *       to: \"0x1234567890123456789012345678901234567890\",\n   *       value: parseEther(\"0.000001\"),\n   *       data: \"0x\",\n   *     },\n   *   ],\n   * });\n   * ```\n   */\n  async prepareAndSendUserOperation(\n    options: PrepareAndSendUserOperationOptions,\n  ): Promise<PrepareAndSendUserOperationReturnType> {\n    Analytics.trackAction({\n      action: \"prepare_and_send_user_operation\",\n      properties: {\n        network: options.network,\n      },\n    });\n\n    const userOp = await CdpOpenApiClient.prepareAndSendUserOperation(\n      options.smartAccount.address,\n      {\n        network: options.network,\n        calls: options.calls.map(call => ({\n          to: call.to as Address,\n          value: call.value.toString(),\n          data: call.data as Hex,\n        })),\n        paymasterUrl: options.paymasterUrl,\n      },\n      options.idempotencyKey,\n    );\n\n    return {\n      smartAccountAddress: options.smartAccount.address as Address,\n      userOpHash: userOp.userOpHash as Hex,\n      status: userOp.status as typeof EvmUserOperationStatus.broadcast,\n    };\n  }\n\n  /**\n   * Requests funds from an EVM faucet.\n   *\n   * @param {RequestFaucetOptions} options - Parameters for requesting funds from the EVM faucet.\n   * @param {string} options.address - The address to request funds for.\n   * @param {string} options.network - The network to request funds from.\n   * @param {string} options.token - The token to request funds for.\n   * @param {string} [options.idempotencyKey] - An idempotency key.\n   *\n   * @returns A promise that resolves to the transaction hash.\n   *\n   * @example\n   * ```ts\n   * const result = await cdp.evm.requestFaucet({\n   *   address: \"0x1234567890123456789012345678901234567890\",\n   *   network: \"base-sepolia\",\n   *   token: \"eth\",\n   * });\n   * ```\n   */\n  async requestFaucet(options: RequestFaucetOptions): Promise<RequestFaucetResult> {\n    Analytics.trackAction({\n      action: \"request_faucet\",\n      properties: {\n        network: options.network,\n      },\n    });\n\n    return requestFaucet(CdpOpenApiClient, options);\n  }\n\n  /**\n   * Signs an EVM transaction and sends it to the specified network using the Coinbase API.\n   * This method handles nonce management and gas estimation automatically.\n   *\n   * @param {SendTransactionOptions} options - Configuration options for sending the transaction.\n   * @returns A promise that resolves to the transaction hash.\n   *\n   * @example\n   * **Sending an RLP-encoded transaction**\n   * ```ts\n   * import { parseEther, serializeTransaction } from \"viem\";\n   * import { baseSepolia } from \"viem/chains\";\n   *\n   * const { transactionHash } = await cdp.evm.sendTransaction({\n   *   address: account.address,\n   *   transaction: serializeTransaction({\n   *     to: \"0x4252e0c9A3da5A2700e7d91cb50aEf522D0C6Fe8\",\n   *     value: parseEther(\"0.000001\"),\n   *     chainId: baseSepolia.id,\n   *     // Fields below are optional, CDP API will populate them if omitted.\n   *     // nonce\n   *     // maxPriorityFeePerGas\n   *     // maxFeePerGas\n   *     // gas\n   *   }),\n   *   network: \"base-sepolia\",\n   * });\n   * ```\n   * @example\n   * **Sending an EIP-1559 transaction request object**\n   * ```ts\n   * const { transactionHash } = await cdp.evm.sendTransaction({\n   *   address: account.address,\n   *   transaction: {\n   *     to: \"0x4252e0c9A3da5A2700e7d91cb50aEf522D0C6Fe8\",\n   *     value: parseEther(\"0.000001\"),\n   *     // Fields below are optional, CDP API will populate them if omitted.\n   *     // nonce\n   *     // maxPriorityFeePerGas\n   *     // maxFeePerGas\n   *     // gas\n   *   },\n   *   network: \"base-sepolia\",\n   * });\n   * ```\n   */\n  async sendTransaction(options: SendTransactionOptions): Promise<TransactionResult> {\n    Analytics.trackAction({\n      action: \"send_transaction\",\n      properties: {\n        network: options.network,\n      },\n    });\n\n    return sendTransaction(CdpOpenApiClient, options);\n  }\n\n  /**\n   * Sends a user operation.\n   *\n   * @param {SendUserOperationOptions} options - Parameters for sending the user operation.\n   * @param {SmartAccount} options.smartAccount - The smart account sending the user operation.\n   * @param {string} options.network - The network to send the user operation on.\n   * @param {EvmCall[]} options.calls - The calls to include in the user operation.\n   * @param {string} [options.paymasterUrl] - The optional paymaster URL to use for the user operation.\n   * @param {string} [options.idempotencyKey] - An idempotency key.\n   *\n   * @returns A promise that resolves to an object containing the smart account address,\n   * the user operation hash, and the status of the user operation.\n   *\n   * @example\n   * ```ts\n   * const userOp = await cdp.evm.sendUserOperation({\n   *   smartAccount,\n   *   network: \"base-sepolia\",\n   *   calls: [\n   *     {\n   *       to: \"0x1234567890123456789012345678901234567890\",\n   *       value: parseEther(\"0.000001\"),\n   *       data: \"0x\",\n   *     },\n   *   ],\n   * });\n   * ```\n   */\n  async sendUserOperation(\n    options: SendUserOperationOptions<unknown[]>,\n  ): Promise<SendUserOperationReturnType> {\n    Analytics.trackAction({\n      action: \"send_user_operation\",\n      properties: {\n        network: options.network,\n      },\n    });\n\n    return sendUserOperation(CdpOpenApiClient, {\n      smartAccount: options.smartAccount,\n      network: options.network,\n      calls: options.calls,\n      paymasterUrl: options.paymasterUrl,\n      idempotencyKey: options.idempotencyKey,\n    });\n  }\n\n  /**\n   * Signs an EVM hash.\n   *\n   * @param {SignHashOptions} options - Parameters for signing the hash.\n   * @param {string} options.address - The address to sign the hash for.\n   * @param {string} options.hash - The hash to sign.\n   * @param {string} [options.idempotencyKey] - An idempotency key.\n   *\n   * @returns A promise that resolves to the signature.\n   *\n   * @example\n   * ```ts\n   * // Create a new EVM server account to sign with\n   * const ethAccount = await cdp.createEvmServerAccount({});\n   *\n   * const signature = await cdp.evm.signHash({\n   *   address: ethAccount.address,\n   *   hash: \"0x1234567890123456789012345678901234567890123456789012345678901234\",\n   * });\n   * ```\n   */\n  async signHash(options: SignHashOptions): Promise<SignatureResult> {\n    Analytics.trackAction({\n      action: \"sign_hash\",\n    });\n\n    const signature = await CdpOpenApiClient.signEvmHash(\n      options.address,\n      {\n        hash: options.hash,\n      },\n      options.idempotencyKey,\n    );\n\n    return {\n      signature: signature.signature as Hex,\n    };\n  }\n\n  /**\n   * Signs an EIP-191 message.\n   *\n   * @param {SignMessageOptions} options - Parameters for signing the message.\n   * @param {string} options.address - The address to sign the message for.\n   * @param {string} options.message - The message to sign.\n   * @param {string} [options.idempotencyKey] - An idempotency key.\n   *\n   * @returns A promise that resolves to the signature.\n   *\n   * @example\n   * ```ts\n   * // Create a new EVM server account to sign with\n   * const ethAccount = await cdp.createEvmServerAccount({});\n   *\n   * const signature = await cdp.evm.signMessage({\n   *   address: ethAccount.address,\n   *   message: \"Hello, world!\",\n   * });\n   * ```\n   */\n  async signMessage(options: SignMessageOptions): Promise<SignatureResult> {\n    Analytics.trackAction({\n      action: \"sign_message\",\n    });\n\n    const signature = await CdpOpenApiClient.signEvmMessage(\n      options.address,\n      {\n        message: options.message,\n      },\n      options.idempotencyKey,\n    );\n\n    return {\n      signature: signature.signature as Hex,\n    };\n  }\n\n  /**\n   * Signs an EIP-712 message.\n   *\n   * @param {SignTypedDataOptions} options - Parameters for signing the EIP-712 message.\n   * @returns A promise that resolves to the signature.\n   *\n   * @example\n   * ```ts\n   * const signature = await cdp.evm.signTypedData({\n   *   address: account.address,\n   *   domain: {\n   *     name: \"Permit2\",\n   *     chainId: 1,\n   *     verifyingContract: \"0x000000000022D473030F116dDEE9F6B43aC78BA3\",\n   *   },\n   *   types: {\n   *     EIP712Domain: [\n   *       { name: \"name\", type: \"string\" },\n   *       { name: \"chainId\", type: \"uint256\" },\n   *       { name: \"verifyingContract\", type: \"address\" },\n   *     ],\n   *     PermitTransferFrom: [\n   *       { name: \"permitted\", type: \"TokenPermissions\" },\n   *       { name: \"spender\", type: \"address\" },\n   *       { name: \"nonce\", type: \"uint256\" },\n   *       { name: \"deadline\", type: \"uint256\" },\n   *     ],\n   *     TokenPermissions: [\n   *       { name: \"token\", type: \"address\" },\n   *       { name: \"amount\", type: \"uint256\" },\n   *     ],\n   *   },\n   *   primaryType: \"PermitTransferFrom\",\n   *   message: {\n   *     permitted: {\n   *       token: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n   *       amount: \"1000000\",\n   *     },\n   *     spender: \"0xFfFfFfFFfFFfFFfFFfFFFFFffFFFffffFfFFFfFf\",\n   *     nonce: \"0\",\n   *     deadline: \"1717123200\",\n   *   },\n   * });\n   * ```\n   */\n  async signTypedData(options: SignTypedDataOptions): Promise<SignatureResult> {\n    Analytics.trackAction({\n      action: \"sign_typed_data\",\n    });\n\n    const { domain, message, primaryType } = options;\n    const types = {\n      EIP712Domain: getTypesForEIP712Domain({ domain }),\n      ...options.types,\n    };\n\n    const openApiMessage: OpenAPIEIP712Message = {\n      domain,\n      types,\n      primaryType,\n      message,\n    };\n\n    const signature = await CdpOpenApiClient.signEvmTypedData(\n      options.address,\n      openApiMessage,\n      options.idempotencyKey,\n    );\n\n    return {\n      signature: signature.signature as Hex,\n    };\n  }\n\n  /**\n   * Signs an EVM transaction.\n   *\n   * @param {SignTransactionOptions} options - Configuration options for signing the transaction.\n   * @returns A promise that resolves to the signature.\n   *\n   * @example\n   * ```ts\n   * import { parseEther, serializeTransaction } from \"viem\";\n   * import { baseSepolia } from \"viem/chains\";\n   *\n   * // Create a new EVM server account to sign with\n   * const ethAccount = await cdp.createEvmServerAccount({});\n   *\n   * const serializedTx = serializeTransaction(\n   *   {\n   *     chainId: baseSepolia.id,\n   *     data: \"0x\",\n   *     to: \"0x4252e0c9A3da5A2700e7d91cb50aEf522D0C6Fe8\",\n   *     type: \"eip1559\",\n   *     value: parseEther(\"0.000001\"),\n   *   },\n   * );\n   *\n   * const signature = await cdp.evm.signTransaction({\n   *   address: ethAccount.address,\n   *   transaction: serializedTx,\n   * });\n   * ```\n   */\n  async signTransaction(options: SignTransactionOptions): Promise<SignatureResult> {\n    Analytics.trackAction({\n      action: \"sign_transaction\",\n    });\n\n    const signature = await CdpOpenApiClient.signEvmTransaction(\n      options.address,\n      {\n        transaction: options.transaction,\n      },\n      options.idempotencyKey,\n    );\n\n    return {\n      signature: signature.signedTransaction as Hex,\n    };\n  }\n\n  /**\n   * Updates a CDP EVM account.\n   *\n   * @param {UpdateEvmAccountOptions} [options] - Optional parameters for creating the account.\n   * @param {string} options.address - The address of the account to update\n   * @param {UpdateEvmAccountBody} options.update - An object containing account fields to update.\n   * @param {string} [options.update.name] - The new name for the account.\n   * @param {string} [options.update.accountPolicy] - The ID of a Policy to apply to the account.\n   * @param {string} [options.idempotencyKey] - An idempotency key.\n   *\n   * @returns A promise that resolves to the updated account.\n   *\n   * @example **With a name**\n   *          ```ts\n   *          const account = await cdp.evm.updateAccount({ address: \"0x...\", update: { name: \"New Name\" } });\n   *          ```\n   *\n   * @example **With an account policy**\n   *          ```ts\n   *          const account = await cdp.evm.updateAccount({ address: \"0x...\", update: { accountPolicy: \"73bcaeeb-d7af-4615-b064-42b5fe83a31e\" } });\n   *          ```\n   *\n   * @example **With an idempotency key**\n   *          ```ts\n   *          const idempotencyKey = uuidv4();\n   *\n   *          // First call\n   *          await cdp.evm.updateAccount({\n   *            address: \"0x...\",\n   *            update: { accountPolicy: \"73bcaeeb-d7af-4615-b064-42b5fe83a31e\" },\n   *            idempotencyKey,\n   *          });\n   *\n   *          // Second call with the same idempotency key will not update\n   *          await cdp.evm.updateAccount({\n   *            address: '0x...',\n   *            update: { name: \"\" },\n   *            idempotencyKey,\n   *          });\n   *          ```\n   */\n  async updateAccount(options: UpdateEvmAccountOptions): Promise<ServerAccount> {\n    Analytics.trackAction({\n      action: \"update_account\",\n    });\n\n    const openApiAccount = await CdpOpenApiClient.updateEvmAccount(\n      options.address,\n      options.update,\n      options.idempotencyKey,\n    );\n\n    const account = toEvmServerAccount(CdpOpenApiClient, {\n      account: openApiAccount,\n    });\n\n    Analytics.wrapObjectMethodsWithErrorTracking(account);\n\n    return account;\n  }\n\n  /**\n   * Updates a CDP EVM smart account.\n   *\n   * @param {UpdateEvmSmartAccountOptions} [options] - Optional parameters for updating the account.\n   * @param {string} options.address - The address of the account to update\n   * @param {UpdateEvmSmartAccount} options.update - An object containing account fields to update.\n   * @param {string} options.owner - The owner of the account.\n   * @param {string} [options.update.name] - The new name for the account.\n   * @param {string} [options.idempotencyKey] - An idempotency key.\n   *\n   * @returns A promise that resolves to the updated account.\n   */\n  async updateSmartAccount(options: UpdateEvmSmartAccountOptions): Promise<SmartAccount> {\n    Analytics.trackAction({\n      action: \"update_smart_account\",\n    });\n\n    const openApiSmartAccount = await CdpOpenApiClient.updateEvmSmartAccount(\n      options.address,\n      options.update,\n      options.idempotencyKey,\n    );\n\n    const smartAccount = toEvmSmartAccount(CdpOpenApiClient, {\n      smartAccount: openApiSmartAccount,\n      owner: options.owner,\n    });\n\n    Analytics.wrapObjectMethodsWithErrorTracking(smartAccount);\n\n    return smartAccount;\n  }\n\n  /**\n   * Waits for a user operation to complete or fail.\n   *\n   * @param {WaitForUserOperationOptions} options - Parameters for waiting for the user operation.\n   * @param {string} options.smartAccountAddress - The address of the smart account.\n   * @param {string} options.userOpHash - The user operation hash.\n   * @param {WaitOptions} [options.waitOptions] - Optional parameters for the wait operation.\n   *\n   * @returns A promise that resolves to the transaction receipt.\n   *\n   * @example\n   * ```ts\n   * // Send a user operation and get the user operation hash\n   * const { userOpHash } = await cdp.evm.sendUserOperation({\n   *   smartAccount,\n   *   network: \"base-sepolia\",\n   *   calls: [\n   *     {\n   *       to: \"0x0000000000000000000000000000000000000000\",\n   *       value: parseEther(\"0.000001\"),\n   *       data: \"0x\",\n   *     },\n   *   ],\n   * });\n   *\n   * // Wait for the user operation to complete or fail\n   * const result = await cdp.evm.waitForUserOperation({\n   *   smartAccountAddress: smartAccount.address,\n   *   userOpHash: userOp.userOpHash,\n   * });\n   * ```\n   */\n  async waitForUserOperation(\n    options: WaitForUserOperationOptions,\n  ): Promise<WaitForUserOperationReturnType> {\n    Analytics.trackAction({\n      action: \"wait_for_user_operation\",\n    });\n\n    return waitForUserOperation(CdpOpenApiClient, {\n      ...options,\n    });\n  }\n\n  /**\n   * Internal method to create an account without tracking analytics.\n   * Used internally by composite operations to avoid double-counting.\n   *\n   * @param {CreateServerAccountOptions} options - Parameters for creating the account.\n   * @returns {Promise<ServerAccount>} A promise that resolves to the newly created account.\n   */\n  private async _createAccountInternal(\n    options: CreateServerAccountOptions = {},\n  ): Promise<ServerAccount> {\n    const openApiAccount = await CdpOpenApiClient.createEvmAccount(\n      {\n        name: options.name,\n        accountPolicy: options.accountPolicy,\n      },\n      options.idempotencyKey,\n    );\n\n    const account = toEvmServerAccount(CdpOpenApiClient, {\n      account: openApiAccount,\n    });\n\n    Analytics.wrapObjectMethodsWithErrorTracking(account);\n\n    return account;\n  }\n\n  /**\n   * Internal method to get an account without tracking analytics.\n   * Used internally by composite operations to avoid double-counting.\n   *\n   * @param {GetServerAccountOptions} options - Parameters for getting the account.\n   * @returns {Promise<ServerAccount>} A promise that resolves to the account.\n   */\n  private async _getAccountInternal(options: GetServerAccountOptions): Promise<ServerAccount> {\n    const openApiAccount = await (() => {\n      if (options.address) {\n        return CdpOpenApiClient.getEvmAccount(options.address);\n      }\n\n      if (options.name) {\n        return CdpOpenApiClient.getEvmAccountByName(options.name);\n      }\n\n      throw new UserInputValidationError(\"Either address or name must be provided\");\n    })();\n\n    const account = toEvmServerAccount(CdpOpenApiClient, {\n      account: openApiAccount,\n    });\n\n    Analytics.wrapObjectMethodsWithErrorTracking(account);\n\n    return account;\n  }\n\n  /**\n   * Internal method to create a smart account without tracking analytics.\n   * Used internally by composite operations to avoid double-counting.\n   *\n   * @param {CreateSmartAccountOptions} options - Parameters for creating the smart account.\n   * @returns {Promise<SmartAccount>} A promise that resolves to the newly created smart account.\n   */\n  private async _createSmartAccountInternal(\n    options: CreateSmartAccountOptions,\n  ): Promise<SmartAccount> {\n    const owners = [options.owner.address];\n\n    if (options.enableSpendPermissions) {\n      owners.push(SPEND_PERMISSION_MANAGER_ADDRESS);\n    }\n\n    const openApiSmartAccount = await CdpOpenApiClient.createEvmSmartAccount(\n      {\n        owners: owners,\n        name: options.name,\n      },\n      options.idempotencyKey,\n    );\n\n    const smartAccount = toEvmSmartAccount(CdpOpenApiClient, {\n      smartAccount: openApiSmartAccount,\n      owner: options.owner,\n    });\n\n    Analytics.wrapObjectMethodsWithErrorTracking(smartAccount);\n\n    return smartAccount;\n  }\n\n  /**\n   * Internal method to get a smart account without tracking analytics.\n   * Used internally by composite operations to avoid double-counting.\n   *\n   * @param {GetSmartAccountOptions} options - Parameters for getting the smart account.\n   * @returns {Promise<SmartAccount>} A promise that resolves to the smart account.\n   */\n  private async _getSmartAccountInternal(options: GetSmartAccountOptions): Promise<SmartAccount> {\n    const openApiSmartAccount = await (async () => {\n      if (options.address) {\n        return CdpOpenApiClient.getEvmSmartAccount(options.address);\n      } else if (options.name) {\n        return CdpOpenApiClient.getEvmSmartAccountByName(options.name);\n      }\n      throw new UserInputValidationError(\"Either address or name must be provided\");\n    })();\n\n    if (!openApiSmartAccount.owners.includes(options.owner.address)) {\n      throw new UserInputValidationError(\n        `Owner mismatch: The provided owner address is not an owner of the smart account. Please use a valid owner for this smart account.\n\nSmart Account Address: ${openApiSmartAccount.address}\nSmart Account Owners: ${openApiSmartAccount.owners.join(\", \")}\nProvided Owner Address: ${options.owner.address}\\n`,\n      );\n    }\n\n    const smartAccount = toEvmSmartAccount(CdpOpenApiClient, {\n      smartAccount: openApiSmartAccount,\n      owner: options.owner,\n    });\n\n    Analytics.wrapObjectMethodsWithErrorTracking(smartAccount);\n\n    return smartAccount;\n  }\n}\n","import type { OneOf, Pretty } from './types.js'\nimport { version } from './version.js'\n\ntype BaseErrorArgs = Pretty<\n  {\n    docsPath?: string | undefined\n    metaMessages?: string[] | undefined\n  } & OneOf<{ details?: string | undefined } | { cause?: BaseError | Error }>\n>\n\nexport class BaseError extends Error {\n  details: string\n  docsPath?: string | undefined\n  metaMessages?: string[] | undefined\n  shortMessage: string\n\n  override name = 'AbiTypeError'\n\n  constructor(shortMessage: string, args: BaseErrorArgs = {}) {\n    const details =\n      args.cause instanceof BaseError\n        ? args.cause.details\n        : args.cause?.message\n          ? args.cause.message\n          : args.details!\n    const docsPath =\n      args.cause instanceof BaseError\n        ? args.cause.docsPath || args.docsPath\n        : args.docsPath\n    const message = [\n      shortMessage || 'An error occurred.',\n      '',\n      ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n      ...(docsPath ? [`Docs: https://abitype.dev${docsPath}`] : []),\n      ...(details ? [`Details: ${details}`] : []),\n      `Version: abitype@${version}`,\n    ].join('\\n')\n\n    super(message)\n\n    if (args.cause) this.cause = args.cause\n    this.details = details\n    this.docsPath = docsPath\n    this.metaMessages = args.metaMessages\n    this.shortMessage = shortMessage\n  }\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/core/telemetry/events/scw-sub-account.ts","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/** Asserts something is hash */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** @deprecated */\nexport const byteSwapIfBE: typeof swap8IfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = string | Uint8Array;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Hash interface. */\nexport type IHash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** For runtime check if class implements interface */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  abstract clone(): T;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash function */\nexport type CHash = ReturnType<typeof createHasher>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof createOptHasher>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof createXOFer>;\n\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function createOptHasher<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function createXOFer<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\nexport const wrapConstructor: typeof createHasher = createHasher;\nexport const wrapConstructorWithOpts: typeof createOptHasher = createOptHasher;\nexport const wrapXOFConstructorWithOpts: typeof createXOFer = createXOFer;\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return Uint8Array.from(crypto.randomBytes(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/core/telemetry/events/subscription.ts","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/util/validatePreferences.ts","/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Converts bigint values in an object to strings for safe serialization\n *\n * @param obj - The object to convert\n * @returns A new object with bigint values converted to strings\n */\nexport const convertBigIntsToStrings = (obj: any): any => {\n  if (typeof obj === \"bigint\") {\n    return obj.toString();\n  }\n  if (Array.isArray(obj)) {\n    return obj.map(convertBigIntsToStrings);\n  }\n  if (obj && typeof obj === \"object\") {\n    return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, convertBigIntsToStrings(v)]));\n  }\n  return obj;\n};\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/core/type/util.ts","/**\n * @module Client\n */\n\nimport { constants, publicEncrypt } from \"crypto\";\n\nimport bs58 from \"bs58\";\n\nimport {\n  CreateAccountOptions,\n  ExportAccountOptions,\n  GetAccountOptions,\n  GetOrCreateAccountOptions,\n  ImportAccountOptions,\n  ListAccountsOptions,\n  ListAccountsResult,\n  ListTokenBalancesOptions,\n  ListTokenBalancesResult,\n  RequestFaucetOptions,\n  SendTransactionOptions,\n  SignatureResult,\n  SignMessageOptions,\n  SignTransactionOptions,\n  SolanaClientInterface,\n  UpdateSolanaAccountOptions,\n} from \"./solana.types.js\";\nimport { toSolanaAccount } from \"../../accounts/solana/toSolanaAccount.js\";\nimport { SolanaAccount } from \"../../accounts/solana/types.js\";\nimport { requestFaucet } from \"../../actions/solana/requestFaucet.js\";\nimport {\n  sendTransaction,\n  type SendTransactionResult,\n} from \"../../actions/solana/sendTransaction.js\";\nimport { signMessage } from \"../../actions/solana/signMessage.js\";\nimport {\n  signTransaction,\n  type SignTransactionResult,\n} from \"../../actions/solana/signTransaction.js\";\nimport { Analytics } from \"../../analytics.js\";\nimport { ImportAccountPublicRSAKey } from \"../../constants.js\";\nimport { UserInputValidationError } from \"../../errors.js\";\nimport { APIError } from \"../../openapi-client/errors.js\";\nimport { CdpOpenApiClient } from \"../../openapi-client/index.js\";\nimport {\n  decryptWithPrivateKey,\n  formatSolanaPrivateKey,\n  generateExportEncryptionKeyPair,\n} from \"../../utils/export.js\";\n\n/**\n * The namespace containing all Solana methods.\n */\nexport class SolanaClient implements SolanaClientInterface {\n  /**\n   * Creates a new Solana account.\n   *\n   * @param {CreateAccountOptions} options - Parameters for creating the Solana account.\n   * @param {string} [options.name] - The name of the account.\n   * @param {string} [options.idempotencyKey] - An idempotency key.\n   *\n   * @returns A promise that resolves to the newly created account.\n   *\n   * @example **Without arguments**\n   *          ```ts\n   *          const account = await cdp.solana.createAccount();\n   *          ```\n   *\n   * @example **With a name**\n   *          ```ts\n   *          const account = await cdp.solana.createAccount({ name: \"MyAccount\" });\n   *          ```\n   *\n   * @example **With an idempotency key**\n   *          ```ts\n   *          const idempotencyKey = uuidv4();\n   *\n   *          // First call\n   *          await cdp.solana.createAccount({ idempotencyKey });\n   *\n   *          // Second call with the same idempotency key will return the same account\n   *          await cdp.solana.createAccount({ idempotencyKey });\n   *          ```\n   */\n  async createAccount(options: CreateAccountOptions = {}): Promise<SolanaAccount> {\n    Analytics.trackAction({\n      action: \"create_account\",\n      accountType: \"solana\",\n    });\n\n    return this._createAccountInternal(options);\n  }\n\n  /**\n   * Exports a CDP Solana account's private key.\n   * It is important to store the private key in a secure place after it's exported.\n   *\n   * @param {ExportAccountOptions} options - Parameters for exporting the Solana account.\n   * @param {string} [options.address] - The address of the account.\n   * @param {string} [options.name] - The name of the account.\n   *\n   * @returns A promise that resolves to the exported account's full 64-byte private key as a base58 encoded string.\n   *\n   * @example **With an address**\n   * ```ts\n   * const privateKey = await cdp.solana.exportAccount({\n   *   address: \"1234567890123456789012345678901234567890\",\n   * });\n   * ```\n   *\n   * @example **With a name**\n   * ```ts\n   * const privateKey = await cdp.solana.exportAccount({\n   *   name: \"MyAccount\",\n   * });\n   * ```\n   */\n  async exportAccount(options: ExportAccountOptions): Promise<string> {\n    Analytics.trackAction({\n      action: \"export_account\",\n      accountType: \"solana\",\n    });\n\n    const { publicKey, privateKey } = await generateExportEncryptionKeyPair();\n\n    const { encryptedPrivateKey } = await (async () => {\n      if (options.address) {\n        return CdpOpenApiClient.exportSolanaAccount(\n          options.address,\n          {\n            exportEncryptionKey: publicKey,\n          },\n          options.idempotencyKey,\n        );\n      }\n\n      if (options.name) {\n        return CdpOpenApiClient.exportSolanaAccountByName(\n          options.name,\n          {\n            exportEncryptionKey: publicKey,\n          },\n          options.idempotencyKey,\n        );\n      }\n\n      throw new UserInputValidationError(\"Either address or name must be provided\");\n    })();\n\n    const decryptedPrivateKey = decryptWithPrivateKey(privateKey, encryptedPrivateKey);\n    return formatSolanaPrivateKey(decryptedPrivateKey);\n  }\n\n  /**\n   * Imports a Solana account using a private key.\n   * The private key will be encrypted before being stored securely.\n   *\n   * @param {ImportAccountOptions} options - Parameters for importing the Solana account.\n   * @param {string} options.privateKey - The private key to import (32 or 64 bytes). Can be a base58 encoded string or raw bytes.\n   * @param {string} [options.name] - The name of the account.\n   * @param {string} [options.encryptionPublicKey] - The RSA public key for encrypting the private key.\n   * @param {string} [options.idempotencyKey] - An idempotency key.\n   *\n   * @returns A promise that resolves to the imported account.\n   *\n   * @example **Import with private key only**\n   *          ```ts\n   *          const account = await cdp.solana.importAccount({\n   *            privateKey: \"3Kzjw8qSxx8bQkV7EHrVFWYiPyNLbBVxtVe1Q5h2zKZY8DdcuT2dKxyz9kU5vQrP\",\n   *          });\n   *          ```\n   *\n   * @example **Import with name**\n   *          ```ts\n   *          const account = await cdp.solana.importAccount({\n   *            privateKey: \"3Kzjw8qSxx8bQkV7EHrVFWYiPyNLbBVxtVe1Q5h2zKZY8DdcuT2dKxyz9kU5vQrP\",\n   *            name: \"ImportedAccount\",\n   *          });\n   *          ```\n   *\n   * @example **Import with idempotency key**\n   *          ```ts\n   *          const idempotencyKey = uuidv4();\n   *\n   *          const account = await cdp.solana.importAccount({\n   *            privateKey: \"3Kzjw8qSxx8bQkV7EHrVFWYiPyNLbBVxtVe1Q5h2zKZY8DdcuT2dKxyz9kU5vQrP\",\n   *            name: \"ImportedAccount\",\n   *            idempotencyKey,\n   *          });\n   *          ```\n   */\n  async importAccount(options: ImportAccountOptions): Promise<SolanaAccount> {\n    Analytics.trackAction({\n      action: \"import_account\",\n      accountType: \"solana\",\n    });\n\n    let privateKeyBytes: Uint8Array = new Uint8Array();\n\n    if (typeof options.privateKey === \"string\") {\n      privateKeyBytes = bs58.decode(options.privateKey);\n    } else {\n      privateKeyBytes = options.privateKey;\n    }\n\n    if (privateKeyBytes.length !== 32 && privateKeyBytes.length !== 64) {\n      throw new UserInputValidationError(\"Invalid private key length\");\n    }\n\n    if (privateKeyBytes.length === 64) {\n      privateKeyBytes = privateKeyBytes.subarray(0, 32);\n    }\n\n    const encryptionPublicKey = options.encryptionPublicKey || ImportAccountPublicRSAKey;\n\n    const encryptedPrivateKey = publicEncrypt(\n      {\n        key: encryptionPublicKey,\n        padding: constants.RSA_PKCS1_OAEP_PADDING,\n        oaepHash: \"sha256\",\n      },\n      privateKeyBytes,\n    );\n\n    const openApiAccount = await CdpOpenApiClient.importSolanaAccount(\n      {\n        encryptedPrivateKey: encryptedPrivateKey.toString(\"base64\"),\n        name: options.name,\n      },\n      options.idempotencyKey,\n    );\n\n    const account = toSolanaAccount(CdpOpenApiClient, {\n      account: openApiAccount,\n    });\n\n    Analytics.wrapObjectMethodsWithErrorTracking(account);\n\n    return account;\n  }\n\n  /**\n   * Gets a Solana account by its address.\n   *\n   * @param {GetAccountOptions} options - Parameters for getting the Solana account.\n   * Either `address` or `name` must be provided.\n   * If both are provided, lookup will be done by `address` and `name` will be ignored.\n   * @param {string} [options.address] - The address of the account.\n   * @param {string} [options.name] - The name of the account.\n   *\n   * @returns A promise that resolves to the account.\n   *\n   * @example **Get an account by address**\n   *          ```ts\n   *          const account = await cdp.solana.getAccount({\n   *            address: \"1234567890123456789012345678901234567890\",\n   *          });\n   *          ```\n   *\n   * @example **Get an account by name**\n   *          ```ts\n   *          const account = await cdp.solana.getAccount({\n   *            name: \"MyAccount\",\n   *          });\n   *          ```\n   */\n  async getAccount(options: GetAccountOptions): Promise<SolanaAccount> {\n    Analytics.trackAction({\n      action: \"get_account\",\n      accountType: \"solana\",\n    });\n\n    return this._getAccountInternal(options);\n  }\n\n  /**\n   * Gets a Solana account by its address.\n   *\n   * @param {GetOrCreateAccountOptions} options - Parameters for getting or creating the Solana account.\n   * @param {string} options.name - The name of the account.\n   *\n   * @returns A promise that resolves to the account.\n   *\n   * @example\n   * ```ts\n   * const account = await cdp.solana.getOrCreateAccount({\n   *   name: \"MyAccount\",\n   * });\n   * ```\n   */\n  async getOrCreateAccount(options: GetOrCreateAccountOptions): Promise<SolanaAccount> {\n    Analytics.trackAction({\n      action: \"get_or_create_account\",\n      accountType: \"solana\",\n    });\n\n    try {\n      const account = await this._getAccountInternal(options);\n      return account;\n    } catch (error) {\n      // If it failed because the account doesn't exist, create it\n      const doesAccountNotExist = error instanceof APIError && error.statusCode === 404;\n      if (doesAccountNotExist) {\n        try {\n          const account = await this._createAccountInternal(options);\n          return account;\n        } catch (error) {\n          // If it failed because the account already exists, get the existing account\n          const doesAccountAlreadyExist = error instanceof APIError && error.statusCode === 409;\n          if (doesAccountAlreadyExist) {\n            const account = await this._getAccountInternal(options);\n            return account;\n          }\n          throw error;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Lists all Solana accounts.\n   *\n   * @param {ListAccountsOptions} options - Parameters for listing the Solana accounts.\n   * @param {number} [options.pageSize] - The number of accounts to return.\n   * @param {string} [options.pageToken] - The page token to begin listing from.\n   * This is obtained by previous calls to this method.\n   *\n   * @returns A promise that resolves to an array of Solana account instances.\n   *\n   * @example **Without arguments**\n   *          ```ts\n   *          const accounts = await cdp.solana.listAccounts();\n   *          ```\n   *\n   * @example **With pagination**\n   *          ```ts\n   *          let page = await cdp.solana.listAccounts();\n   *\n   *          while (page.nextPageToken) {\n   *            page = await cdp.solana.listAccounts({ pageToken: page.nextPageToken });\n   *          }\n   *\n   *          page.accounts.forEach(account => console.log(account));\n   *          ```\n   * }\n   * ```\n   */\n  async listAccounts(options: ListAccountsOptions = {}): Promise<ListAccountsResult> {\n    Analytics.trackAction({\n      action: \"list_accounts\",\n      accountType: \"solana\",\n    });\n\n    const solAccounts = await CdpOpenApiClient.listSolanaAccounts({\n      pageSize: options.pageSize,\n      pageToken: options.pageToken,\n    });\n\n    return {\n      accounts: solAccounts.accounts.map(account => {\n        const solanaAccount = toSolanaAccount(CdpOpenApiClient, {\n          account,\n        });\n\n        Analytics.wrapObjectMethodsWithErrorTracking(solanaAccount);\n\n        return solanaAccount;\n      }),\n      nextPageToken: solAccounts.nextPageToken,\n    };\n  }\n\n  /**\n   * Requests funds from a Solana faucet.\n   *\n   * @param {RequestFaucetOptions} options - Parameters for requesting funds from the Solana faucet.\n   * @param {string} options.address - The address to request funds for.\n   * @param {string} options.token - The token to request funds for.\n   * @param {string} [options.idempotencyKey] - An idempotency key.\n   *\n   * @returns A promise that resolves to the transaction signature.\n   *\n   * @example\n   *          ```ts\n   *          const signature = await cdp.solana.requestFaucet({\n   *            address: \"1234567890123456789012345678901234567890\",\n   *            token: \"sol\",\n   *          });\n   *          ```\n   */\n  async requestFaucet(options: RequestFaucetOptions): Promise<SignatureResult> {\n    Analytics.trackAction({\n      action: \"request_faucet\",\n      accountType: \"solana\",\n    });\n\n    return requestFaucet(CdpOpenApiClient, options);\n  }\n\n  /**\n   * Signs a message.\n   *\n   * @param {SignMessageOptions} options - Parameters for signing the message.\n   * @param {string} options.address - The address to sign the message for.\n   * @param {string} options.message - The message to sign.\n   * @param {string} [options.idempotencyKey] - An idempotency key.\n   *\n   * @returns A promise that resolves to the signature.\n   *\n   * @example\n   * ```ts\n   * // Create a Solana account\n   * const account = await cdp.solana.createAccount();\n   *\n   * // When you want to sign a message, you can do so by address\n   * const signature = await cdp.solana.signMessage({\n   *   address: account.address,\n   *   message: \"Hello, world!\",\n   * });\n   * ```\n   */\n  async signMessage(options: SignMessageOptions): Promise<SignatureResult> {\n    Analytics.trackAction({\n      action: \"sign_message\",\n      accountType: \"solana\",\n    });\n\n    return signMessage(CdpOpenApiClient, options);\n  }\n\n  /**\n   * Signs a transaction.\n   *\n   * @param {SignTransactionOptions} options - Parameters for signing the transaction.\n   * @param {string} options.address - The address to sign the transaction for.\n   * @param {string} options.transaction - The transaction to sign.\n   * @param {string} [options.idempotencyKey] - An idempotency key.\n   *\n   * @returns A promise that resolves to the signature.\n   *\n   * @example\n   * ```ts\n   * // Create a Solana account\n   * const account = await cdp.solana.createAccount();\n   *\n   * // Add your transaction instructions here\n   * const transaction = new Transaction()\n   *\n   * // Make sure to set requireAllSignatures to false, since signing will be done through the API\n   * const serializedTransaction = transaction.serialize({\n   *   requireAllSignatures: false,\n   * });\n   *\n   * // Base64 encode the serialized transaction\n   * const transaction = Buffer.from(serializedTransaction).toString(\"base64\");\n   *\n   * // When you want to sign a transaction, you can do so by address and base64 encoded transaction\n   * const signature = await cdp.solana.signTransaction({\n   *   address: account.address,\n   *   transaction,\n   * });\n   * ```\n   */\n  async signTransaction(options: SignTransactionOptions): Promise<SignTransactionResult> {\n    Analytics.trackAction({\n      action: \"sign_transaction\",\n      accountType: \"solana\",\n    });\n\n    return signTransaction(CdpOpenApiClient, options);\n  }\n\n  /**\n   * Updates a CDP Solana account.\n   *\n   * @param {UpdateSolanaAccountOptions} [options] - Optional parameters for creating the account.\n   * @param {string} options.address - The address of the account to update\n   * @param {UpdateSolanaAccountBody} options.update - An object containing account fields to update.\n   * @param {string} [options.update.name] - The new name for the account.\n   * @param {string} [options.update.accountPolicy] - The ID of a Policy to apply to the account.\n   * @param {string} [options.idempotencyKey] - An idempotency key.\n   *\n   * @returns A promise that resolves to the updated account.\n   *\n   * @example **With a name**\n   *          ```ts\n   *          const account = await cdp.sol.updateAccount({ address: \"...\", update: { name: \"New Name\" } });\n   *          ```\n   *\n   * @example **With an account policy**\n   *          ```ts\n   *          const account = await cdp.sol.updateAccount({ address: \"...\", update: { accountPolicy: \"73bcaeeb-d7af-4615-b064-42b5fe83a31e\" } });\n   *          ```\n   *\n   * @example **With an idempotency key**\n   *          ```ts\n   *          const idempotencyKey = uuidv4();\n   *\n   *          // First call\n   *          await cdp.sol.updateAccount({\n   *            address: \"0x...\",\n   *            update: { accountPolicy: \"73bcaeeb-d7af-4615-b064-42b5fe83a31e\" },\n   *            idempotencyKey,\n   *          });\n   *\n   *          // Second call with the same idempotency key will not update\n   *          await cdp.sol.updateAccount({\n   *            address: '0x...',\n   *            update: { name: \"\" },\n   *            idempotencyKey,\n   *          });\n   *          ```\n   */\n  async updateAccount(options: UpdateSolanaAccountOptions): Promise<SolanaAccount> {\n    Analytics.trackAction({\n      action: \"update_account\",\n      accountType: \"solana\",\n    });\n\n    const openApiAccount = await CdpOpenApiClient.updateSolanaAccount(\n      options.address,\n      options.update,\n      options.idempotencyKey,\n    );\n\n    const account = toSolanaAccount(CdpOpenApiClient, {\n      account: openApiAccount,\n    });\n\n    Analytics.wrapObjectMethodsWithErrorTracking(account);\n\n    return account;\n  }\n\n  /**\n   * Sends a Solana transaction using the Coinbase API.\n   *\n   * @param {SendTransactionOptions} options - Parameters for sending the Solana transaction.\n   * @param {string} options.network - The network to send the transaction to.\n   * @param {string} options.transaction - The base64 encoded transaction to send.\n   * @param {string} [options.idempotencyKey] - An idempotency key.\n   *\n   * @returns A promise that resolves to the transaction result.\n   *\n   * @example\n   * ```ts\n   * const signature = await cdp.solana.sendTransaction({\n   *   network: \"solana-devnet\",\n   *   transaction: \"...\",\n   * });\n   * ```\n   */\n  async sendTransaction(options: SendTransactionOptions): Promise<SendTransactionResult> {\n    Analytics.trackAction({\n      action: \"send_transaction\",\n      accountType: \"solana\",\n      properties: {\n        network: options.network,\n      },\n    });\n\n    return sendTransaction(CdpOpenApiClient, options);\n  }\n\n  /**\n   * Lists the token balances for a Solana account.\n   *\n   * @param {ListTokenBalancesOptions} options - Parameters for listing the Solana token balances.\n   * @param {string} options.address - The address of the account to list token balances for.\n   * @param {string} [options.network] - The network to list token balances for. Defaults to \"solana\".\n   * @param {number} [options.pageSize] - The number of token balances to return.\n   * @param {string} [options.pageToken] - The page token to begin listing from.\n   * This is obtained by previous calls to this method.\n   *\n   * @returns A promise that resolves to an array of Solana token balance instances.\n   *\n   * @example\n   * ```ts\n   * const balances = await cdp.solana.listTokenBalances({ address: \"...\", network: \"solana-devnet\" });\n   * ```\n   */\n  async listTokenBalances(options: ListTokenBalancesOptions): Promise<ListTokenBalancesResult> {\n    Analytics.trackAction({\n      action: \"list_token_balances\",\n      accountType: \"solana\",\n      properties: {\n        network: options.network,\n      },\n    });\n\n    const tokenBalances = await CdpOpenApiClient.listSolanaTokenBalances(\n      options.network || \"solana\",\n      options.address,\n      {\n        pageSize: options.pageSize,\n        pageToken: options.pageToken,\n      },\n    );\n\n    return {\n      balances: tokenBalances.balances.map(balance => {\n        return {\n          amount: {\n            amount: BigInt(balance.amount.amount),\n            decimals: balance.amount.decimals,\n          },\n          token: {\n            mintAddress: balance.token.mintAddress,\n            name: balance.token.name,\n            symbol: balance.token.symbol,\n          },\n        };\n      }),\n      nextPageToken: tokenBalances.nextPageToken,\n    };\n  }\n\n  /**\n   * Internal method to create a Solana account without tracking analytics.\n   * Used internally by composite operations to avoid double-counting.\n   *\n   * @param {CreateAccountOptions} options - Parameters for creating the account.\n   * @returns {Promise<SolanaAccount>} A promise that resolves to the newly created account.\n   */\n  private async _createAccountInternal(options: CreateAccountOptions = {}): Promise<SolanaAccount> {\n    const openApiAccount = await CdpOpenApiClient.createSolanaAccount(\n      {\n        name: options.name,\n        accountPolicy: options.accountPolicy,\n      },\n      options.idempotencyKey,\n    );\n\n    const account = toSolanaAccount(CdpOpenApiClient, {\n      account: openApiAccount,\n    });\n\n    Analytics.wrapObjectMethodsWithErrorTracking(account);\n\n    return account;\n  }\n\n  /**\n   * Internal method to get a Solana account without tracking analytics.\n   * Used internally by composite operations to avoid double-counting.\n   *\n   * @param {GetAccountOptions} options - Parameters for getting the account.\n   * @returns {Promise<SolanaAccount>} A promise that resolves to the account.\n   */\n  private async _getAccountInternal(options: GetAccountOptions): Promise<SolanaAccount> {\n    const openApiAccount = await (() => {\n      if (options.address) {\n        return CdpOpenApiClient.getSolanaAccount(options.address);\n      }\n\n      if (options.name) {\n        return CdpOpenApiClient.getSolanaAccountByName(options.name);\n      }\n\n      throw new UserInputValidationError(\"Either address or name must be provided\");\n    })();\n\n    const account = toSolanaAccount(CdpOpenApiClient, {\n      account: openApiAccount,\n    });\n\n    Analytics.wrapObjectMethodsWithErrorTracking(account);\n\n    return account;\n  }\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/util/cipher.ts","/**\n * @module Errors\n */\n\n/**\n * A class of errors for capturing stack traces.\n */\nclass BaseError extends Error {\n  /**\n   * Base error constructor.\n   *\n   * @param message - The message to display.\n   */\n  constructor(message: string) {\n    super(message);\n    this.name = this.constructor.name;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\n/**\n * An error for invalid API key format.\n */\nexport class InvalidAPIKeyFormatError extends BaseError {\n  /**\n   * Invalid API key format error constructor.\n   *\n   * @param message - The message to display.\n   */\n  constructor(message: string) {\n    super(\"Invalid API key format: \" + message);\n  }\n}\n\n/**\n * An error for invalid Wallet Secret format.\n */\nexport class InvalidWalletSecretFormatError extends BaseError {\n  /**\n   * Invalid Wallet Secret format error constructor.\n   *\n   * @param message - The message to display.\n   */\n  constructor(message: string) {\n    super(\"Invalid Wallet Secret format: \" + message);\n  }\n}\n\n/**\n * An error for an undefined Wallet Secret.\n */\nexport class UndefinedWalletSecretError extends BaseError {\n  /**\n   * Undefined Wallet Secret error constructor.\n   *\n   * @param message - The message to display.\n   */\n  constructor(message: string) {\n    super(\"Undefined Wallet Secret: \" + message);\n  }\n}\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const metisSepolia = /*#__PURE__*/ defineChain({\n  id: 59902,\n  name: 'Metis Sepolia',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'Test Metis',\n    symbol: 'tMETIS',\n  },\n  rpcUrls: {\n    default: {\n      http: [\n        'https://sepolia.metisdevops.link',\n        'https://metis-sepolia-rpc.publicnode.com',\n        'https://metis-sepolia.gateway.tenderly.co',\n      ],\n      webSocket: ['wss://metis-sepolia-rpc.publicnode.com'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Metis Sepolia Explorer',\n      url: 'https://sepolia-explorer.metisdevops.link',\n      apiUrl: 'https://sepolia-explorer.metisdevops.link/api-docs',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 224185,\n    },\n  },\n})\n","import { isFixedSize } from '@solana/codecs-core';\n\n/**\n * Functionally, this type helper is equivalent to the identity type  i.e. `type Identity<T> = T`.\n * However, wrapping generic object mappings in this type significantly reduces the number\n * of instantiation expressions processed, which increases TypeScript performance and\n * prevents \"Type instantiation is excessively deep and possibly infinite\" errors.\n *\n * This works because TypeScript doesn't create a new level of nesting when encountering conditional generic types.\n * @see https://github.com/microsoft/TypeScript/issues/34933\n * @see https://github.com/kysely-org/kysely/pull/483\n */\nexport type DrainOuterGeneric<T> = [T] extends [unknown] ? T : never;\n\nexport function maxCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce(\n        (all, size) => (all === null || size === null ? null : Math.max(all, size)),\n        0 as number | null,\n    );\n}\n\nexport function sumCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce((all, size) => (all === null || size === null ? null : all + size), 0 as number | null);\n}\n\nexport function getFixedSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : null;\n}\n\nexport function getMaxSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : (codec.maxSize ?? null);\n}\n","export const SPEND_PERMISSION_MANAGER_ADDRESS = \"0xf85210B21cC50302F477BA56686d2019dC9b67Ad\";\n\nexport const SPEND_PERMISSION_MANAGER_ABI = [\n  {\n    inputs: [\n      {\n        internalType: \"contract PublicERC6492Validator\",\n        name: \"publicERC6492Validator\",\n        type: \"address\",\n      },\n      { internalType: \"address\", name: \"magicSpend\", type: \"address\" },\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\",\n  },\n  {\n    inputs: [\n      { internalType: \"uint48\", name: \"currentTimestamp\", type: \"uint48\" },\n      { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n    ],\n    name: \"AfterSpendPermissionEnd\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      { internalType: \"uint48\", name: \"currentTimestamp\", type: \"uint48\" },\n      { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n    ],\n    name: \"BeforeSpendPermissionStart\",\n    type: \"error\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"token\", type: \"address\" }],\n    name: \"ERC721TokenNotSupported\",\n    type: \"error\",\n  },\n  { inputs: [], name: \"EmptySpendPermissionBatch\", type: \"error\" },\n  {\n    inputs: [\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"allowance\", type: \"uint256\" },\n    ],\n    name: \"ExceededSpendPermission\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          { internalType: \"uint160\", name: \"spend\", type: \"uint160\" },\n        ],\n        internalType: \"struct SpendPermissionManager.PeriodSpend\",\n        name: \"actualLastUpdatedPeriod\",\n        type: \"tuple\",\n      },\n      {\n        components: [\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          { internalType: \"uint160\", name: \"spend\", type: \"uint160\" },\n        ],\n        internalType: \"struct SpendPermissionManager.PeriodSpend\",\n        name: \"expectedLastUpdatedPeriod\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"InvalidLastUpdatedPeriod\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"sender\", type: \"address\" },\n      { internalType: \"address\", name: \"expected\", type: \"address\" },\n    ],\n    name: \"InvalidSender\",\n    type: \"error\",\n  },\n  { inputs: [], name: \"InvalidSignature\", type: \"error\" },\n  {\n    inputs: [\n      { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n      { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n    ],\n    name: \"InvalidStartEnd\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      { internalType: \"uint128\", name: \"noncePostfix\", type: \"uint128\" },\n      { internalType: \"uint128\", name: \"permissionHashPostfix\", type: \"uint128\" },\n    ],\n    name: \"InvalidWithdrawRequestNonce\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"firstAccount\", type: \"address\" },\n      { internalType: \"address\", name: \"secondAccount\", type: \"address\" },\n    ],\n    name: \"MismatchedAccounts\",\n    type: \"error\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"token\", type: \"address\" }],\n    name: \"SafeERC20FailedOperation\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"spendToken\", type: \"address\" },\n      { internalType: \"address\", name: \"withdrawAsset\", type: \"address\" },\n    ],\n    name: \"SpendTokenWithdrawAssetMismatch\",\n    type: \"error\",\n  },\n  {\n    inputs: [{ internalType: \"uint256\", name: \"value\", type: \"uint256\" }],\n    name: \"SpendValueOverflow\",\n    type: \"error\",\n  },\n  {\n    inputs: [\n      { internalType: \"uint256\", name: \"spendValue\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"withdrawAmount\", type: \"uint256\" },\n    ],\n    name: \"SpendValueWithdrawAmountMismatch\",\n    type: \"error\",\n  },\n  { inputs: [], name: \"UnauthorizedSpendPermission\", type: \"error\" },\n  {\n    inputs: [\n      { internalType: \"uint256\", name: \"received\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"expected\", type: \"uint256\" },\n    ],\n    name: \"UnexpectedReceiveAmount\",\n    type: \"error\",\n  },\n  { inputs: [], name: \"ZeroAllowance\", type: \"error\" },\n  { inputs: [], name: \"ZeroPeriod\", type: \"error\" },\n  { inputs: [], name: \"ZeroSpender\", type: \"error\" },\n  { inputs: [], name: \"ZeroToken\", type: \"error\" },\n  { inputs: [], name: \"ZeroValue\", type: \"error\" },\n  {\n    anonymous: false,\n    inputs: [\n      { indexed: true, internalType: \"bytes32\", name: \"hash\", type: \"bytes32\" },\n      {\n        components: [\n          { internalType: \"address\", name: \"account\", type: \"address\" },\n          { internalType: \"address\", name: \"spender\", type: \"address\" },\n          { internalType: \"address\", name: \"token\", type: \"address\" },\n          { internalType: \"uint160\", name: \"allowance\", type: \"uint160\" },\n          { internalType: \"uint48\", name: \"period\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          { internalType: \"uint256\", name: \"salt\", type: \"uint256\" },\n          { internalType: \"bytes\", name: \"extraData\", type: \"bytes\" },\n        ],\n        indexed: false,\n        internalType: \"struct SpendPermissionManager.SpendPermission\",\n        name: \"spendPermission\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"SpendPermissionApproved\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      { indexed: true, internalType: \"bytes32\", name: \"hash\", type: \"bytes32\" },\n      {\n        components: [\n          { internalType: \"address\", name: \"account\", type: \"address\" },\n          { internalType: \"address\", name: \"spender\", type: \"address\" },\n          { internalType: \"address\", name: \"token\", type: \"address\" },\n          { internalType: \"uint160\", name: \"allowance\", type: \"uint160\" },\n          { internalType: \"uint48\", name: \"period\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          { internalType: \"uint256\", name: \"salt\", type: \"uint256\" },\n          { internalType: \"bytes\", name: \"extraData\", type: \"bytes\" },\n        ],\n        indexed: false,\n        internalType: \"struct SpendPermissionManager.SpendPermission\",\n        name: \"spendPermission\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"SpendPermissionRevoked\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      { indexed: true, internalType: \"bytes32\", name: \"hash\", type: \"bytes32\" },\n      { indexed: true, internalType: \"address\", name: \"account\", type: \"address\" },\n      { indexed: true, internalType: \"address\", name: \"spender\", type: \"address\" },\n      { indexed: false, internalType: \"address\", name: \"token\", type: \"address\" },\n      {\n        components: [\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          { internalType: \"uint160\", name: \"spend\", type: \"uint160\" },\n        ],\n        indexed: false,\n        internalType: \"struct SpendPermissionManager.PeriodSpend\",\n        name: \"periodSpend\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"SpendPermissionUsed\",\n    type: \"event\",\n  },\n  {\n    inputs: [],\n    name: \"MAGIC_SPEND\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"NATIVE_TOKEN\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"PERMISSION_DETAILS_TYPEHASH\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"PUBLIC_ERC6492_VALIDATOR\",\n    outputs: [{ internalType: \"contract PublicERC6492Validator\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"SPEND_PERMISSION_BATCH_TYPEHASH\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"SPEND_PERMISSION_TYPEHASH\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"account\", type: \"address\" },\n          { internalType: \"address\", name: \"spender\", type: \"address\" },\n          { internalType: \"address\", name: \"token\", type: \"address\" },\n          { internalType: \"uint160\", name: \"allowance\", type: \"uint160\" },\n          { internalType: \"uint48\", name: \"period\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          { internalType: \"uint256\", name: \"salt\", type: \"uint256\" },\n          { internalType: \"bytes\", name: \"extraData\", type: \"bytes\" },\n        ],\n        internalType: \"struct SpendPermissionManager.SpendPermission\",\n        name: \"spendPermission\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"approve\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"account\", type: \"address\" },\n          { internalType: \"uint48\", name: \"period\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          {\n            components: [\n              { internalType: \"address\", name: \"spender\", type: \"address\" },\n              { internalType: \"address\", name: \"token\", type: \"address\" },\n              { internalType: \"uint160\", name: \"allowance\", type: \"uint160\" },\n              { internalType: \"uint256\", name: \"salt\", type: \"uint256\" },\n              { internalType: \"bytes\", name: \"extraData\", type: \"bytes\" },\n            ],\n            internalType: \"struct SpendPermissionManager.PermissionDetails[]\",\n            name: \"permissions\",\n            type: \"tuple[]\",\n          },\n        ],\n        internalType: \"struct SpendPermissionManager.SpendPermissionBatch\",\n        name: \"spendPermissionBatch\",\n        type: \"tuple\",\n      },\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" },\n    ],\n    name: \"approveBatchWithSignature\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"account\", type: \"address\" },\n          { internalType: \"address\", name: \"spender\", type: \"address\" },\n          { internalType: \"address\", name: \"token\", type: \"address\" },\n          { internalType: \"uint160\", name: \"allowance\", type: \"uint160\" },\n          { internalType: \"uint48\", name: \"period\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          { internalType: \"uint256\", name: \"salt\", type: \"uint256\" },\n          { internalType: \"bytes\", name: \"extraData\", type: \"bytes\" },\n        ],\n        internalType: \"struct SpendPermissionManager.SpendPermission\",\n        name: \"permissionToApprove\",\n        type: \"tuple\",\n      },\n      {\n        components: [\n          { internalType: \"address\", name: \"account\", type: \"address\" },\n          { internalType: \"address\", name: \"spender\", type: \"address\" },\n          { internalType: \"address\", name: \"token\", type: \"address\" },\n          { internalType: \"uint160\", name: \"allowance\", type: \"uint160\" },\n          { internalType: \"uint48\", name: \"period\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          { internalType: \"uint256\", name: \"salt\", type: \"uint256\" },\n          { internalType: \"bytes\", name: \"extraData\", type: \"bytes\" },\n        ],\n        internalType: \"struct SpendPermissionManager.SpendPermission\",\n        name: \"permissionToRevoke\",\n        type: \"tuple\",\n      },\n      {\n        components: [\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          { internalType: \"uint160\", name: \"spend\", type: \"uint160\" },\n        ],\n        internalType: \"struct SpendPermissionManager.PeriodSpend\",\n        name: \"expectedLastUpdatedPeriod\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"approveWithRevoke\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"account\", type: \"address\" },\n          { internalType: \"address\", name: \"spender\", type: \"address\" },\n          { internalType: \"address\", name: \"token\", type: \"address\" },\n          { internalType: \"uint160\", name: \"allowance\", type: \"uint160\" },\n          { internalType: \"uint48\", name: \"period\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          { internalType: \"uint256\", name: \"salt\", type: \"uint256\" },\n          { internalType: \"bytes\", name: \"extraData\", type: \"bytes\" },\n        ],\n        internalType: \"struct SpendPermissionManager.SpendPermission\",\n        name: \"spendPermission\",\n        type: \"tuple\",\n      },\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" },\n    ],\n    name: \"approveWithSignature\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"eip712Domain\",\n    outputs: [\n      { internalType: \"bytes1\", name: \"fields\", type: \"bytes1\" },\n      { internalType: \"string\", name: \"name\", type: \"string\" },\n      { internalType: \"string\", name: \"version\", type: \"string\" },\n      { internalType: \"uint256\", name: \"chainId\", type: \"uint256\" },\n      { internalType: \"address\", name: \"verifyingContract\", type: \"address\" },\n      { internalType: \"bytes32\", name: \"salt\", type: \"bytes32\" },\n      { internalType: \"uint256[]\", name: \"extensions\", type: \"uint256[]\" },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"account\", type: \"address\" },\n          { internalType: \"uint48\", name: \"period\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          {\n            components: [\n              { internalType: \"address\", name: \"spender\", type: \"address\" },\n              { internalType: \"address\", name: \"token\", type: \"address\" },\n              { internalType: \"uint160\", name: \"allowance\", type: \"uint160\" },\n              { internalType: \"uint256\", name: \"salt\", type: \"uint256\" },\n              { internalType: \"bytes\", name: \"extraData\", type: \"bytes\" },\n            ],\n            internalType: \"struct SpendPermissionManager.PermissionDetails[]\",\n            name: \"permissions\",\n            type: \"tuple[]\",\n          },\n        ],\n        internalType: \"struct SpendPermissionManager.SpendPermissionBatch\",\n        name: \"spendPermissionBatch\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"getBatchHash\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"account\", type: \"address\" },\n          { internalType: \"address\", name: \"spender\", type: \"address\" },\n          { internalType: \"address\", name: \"token\", type: \"address\" },\n          { internalType: \"uint160\", name: \"allowance\", type: \"uint160\" },\n          { internalType: \"uint48\", name: \"period\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          { internalType: \"uint256\", name: \"salt\", type: \"uint256\" },\n          { internalType: \"bytes\", name: \"extraData\", type: \"bytes\" },\n        ],\n        internalType: \"struct SpendPermissionManager.SpendPermission\",\n        name: \"spendPermission\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"getCurrentPeriod\",\n    outputs: [\n      {\n        components: [\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          { internalType: \"uint160\", name: \"spend\", type: \"uint160\" },\n        ],\n        internalType: \"struct SpendPermissionManager.PeriodSpend\",\n        name: \"\",\n        type: \"tuple\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"account\", type: \"address\" },\n          { internalType: \"address\", name: \"spender\", type: \"address\" },\n          { internalType: \"address\", name: \"token\", type: \"address\" },\n          { internalType: \"uint160\", name: \"allowance\", type: \"uint160\" },\n          { internalType: \"uint48\", name: \"period\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          { internalType: \"uint256\", name: \"salt\", type: \"uint256\" },\n          { internalType: \"bytes\", name: \"extraData\", type: \"bytes\" },\n        ],\n        internalType: \"struct SpendPermissionManager.SpendPermission\",\n        name: \"spendPermission\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"getHash\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"account\", type: \"address\" },\n          { internalType: \"address\", name: \"spender\", type: \"address\" },\n          { internalType: \"address\", name: \"token\", type: \"address\" },\n          { internalType: \"uint160\", name: \"allowance\", type: \"uint160\" },\n          { internalType: \"uint48\", name: \"period\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          { internalType: \"uint256\", name: \"salt\", type: \"uint256\" },\n          { internalType: \"bytes\", name: \"extraData\", type: \"bytes\" },\n        ],\n        internalType: \"struct SpendPermissionManager.SpendPermission\",\n        name: \"spendPermission\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"getLastUpdatedPeriod\",\n    outputs: [\n      {\n        components: [\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          { internalType: \"uint160\", name: \"spend\", type: \"uint160\" },\n        ],\n        internalType: \"struct SpendPermissionManager.PeriodSpend\",\n        name: \"\",\n        type: \"tuple\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"account\", type: \"address\" },\n          { internalType: \"address\", name: \"spender\", type: \"address\" },\n          { internalType: \"address\", name: \"token\", type: \"address\" },\n          { internalType: \"uint160\", name: \"allowance\", type: \"uint160\" },\n          { internalType: \"uint48\", name: \"period\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          { internalType: \"uint256\", name: \"salt\", type: \"uint256\" },\n          { internalType: \"bytes\", name: \"extraData\", type: \"bytes\" },\n        ],\n        internalType: \"struct SpendPermissionManager.SpendPermission\",\n        name: \"spendPermission\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"isApproved\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"account\", type: \"address\" },\n          { internalType: \"address\", name: \"spender\", type: \"address\" },\n          { internalType: \"address\", name: \"token\", type: \"address\" },\n          { internalType: \"uint160\", name: \"allowance\", type: \"uint160\" },\n          { internalType: \"uint48\", name: \"period\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          { internalType: \"uint256\", name: \"salt\", type: \"uint256\" },\n          { internalType: \"bytes\", name: \"extraData\", type: \"bytes\" },\n        ],\n        internalType: \"struct SpendPermissionManager.SpendPermission\",\n        name: \"spendPermission\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"isRevoked\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"account\", type: \"address\" },\n          { internalType: \"address\", name: \"spender\", type: \"address\" },\n          { internalType: \"address\", name: \"token\", type: \"address\" },\n          { internalType: \"uint160\", name: \"allowance\", type: \"uint160\" },\n          { internalType: \"uint48\", name: \"period\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          { internalType: \"uint256\", name: \"salt\", type: \"uint256\" },\n          { internalType: \"bytes\", name: \"extraData\", type: \"bytes\" },\n        ],\n        internalType: \"struct SpendPermissionManager.SpendPermission\",\n        name: \"spendPermission\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"isValid\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"account\", type: \"address\" },\n          { internalType: \"address\", name: \"spender\", type: \"address\" },\n          { internalType: \"address\", name: \"token\", type: \"address\" },\n          { internalType: \"uint160\", name: \"allowance\", type: \"uint160\" },\n          { internalType: \"uint48\", name: \"period\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          { internalType: \"uint256\", name: \"salt\", type: \"uint256\" },\n          { internalType: \"bytes\", name: \"extraData\", type: \"bytes\" },\n        ],\n        internalType: \"struct SpendPermissionManager.SpendPermission\",\n        name: \"spendPermission\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"revoke\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"account\", type: \"address\" },\n          { internalType: \"address\", name: \"spender\", type: \"address\" },\n          { internalType: \"address\", name: \"token\", type: \"address\" },\n          { internalType: \"uint160\", name: \"allowance\", type: \"uint160\" },\n          { internalType: \"uint48\", name: \"period\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          { internalType: \"uint256\", name: \"salt\", type: \"uint256\" },\n          { internalType: \"bytes\", name: \"extraData\", type: \"bytes\" },\n        ],\n        internalType: \"struct SpendPermissionManager.SpendPermission\",\n        name: \"spendPermission\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"revokeAsSpender\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"account\", type: \"address\" },\n          { internalType: \"address\", name: \"spender\", type: \"address\" },\n          { internalType: \"address\", name: \"token\", type: \"address\" },\n          { internalType: \"uint160\", name: \"allowance\", type: \"uint160\" },\n          { internalType: \"uint48\", name: \"period\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          { internalType: \"uint256\", name: \"salt\", type: \"uint256\" },\n          { internalType: \"bytes\", name: \"extraData\", type: \"bytes\" },\n        ],\n        internalType: \"struct SpendPermissionManager.SpendPermission\",\n        name: \"spendPermission\",\n        type: \"tuple\",\n      },\n      { internalType: \"uint160\", name: \"value\", type: \"uint160\" },\n    ],\n    name: \"spend\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: \"address\", name: \"account\", type: \"address\" },\n          { internalType: \"address\", name: \"spender\", type: \"address\" },\n          { internalType: \"address\", name: \"token\", type: \"address\" },\n          { internalType: \"uint160\", name: \"allowance\", type: \"uint160\" },\n          { internalType: \"uint48\", name: \"period\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"start\", type: \"uint48\" },\n          { internalType: \"uint48\", name: \"end\", type: \"uint48\" },\n          { internalType: \"uint256\", name: \"salt\", type: \"uint256\" },\n          { internalType: \"bytes\", name: \"extraData\", type: \"bytes\" },\n        ],\n        internalType: \"struct SpendPermissionManager.SpendPermission\",\n        name: \"spendPermission\",\n        type: \"tuple\",\n      },\n      { internalType: \"uint160\", name: \"value\", type: \"uint160\" },\n      {\n        components: [\n          { internalType: \"bytes\", name: \"signature\", type: \"bytes\" },\n          { internalType: \"address\", name: \"asset\", type: \"address\" },\n          { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n          { internalType: \"uint256\", name: \"nonce\", type: \"uint256\" },\n          { internalType: \"uint48\", name: \"expiry\", type: \"uint48\" },\n        ],\n        internalType: \"struct MagicSpend.WithdrawRequest\",\n        name: \"withdrawRequest\",\n        type: \"tuple\",\n      },\n    ],\n    name: \"spendWithWithdraw\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  { stateMutability: \"payable\", type: \"receive\" },\n] as const;\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const merlinErigonTestnet = /*#__PURE__*/ defineChain({\n  id: 4203,\n  name: 'Merlin Erigon Testnet',\n  nativeCurrency: {\n    name: 'BTC',\n    symbol: 'BTC',\n    decimals: 18,\n  },\n  rpcUrls: {\n    default: { http: ['https://testnet-erigon-rpc.merlinchain.io'] },\n  },\n  blockExplorers: {\n    default: {\n      name: 'blockscout',\n      url: 'https://testnet-erigon-scan.merlinchain.io',\n      apiUrl: 'https://testnet-erigon-scan.merlinchain.io/api',\n    },\n  },\n  testnet: true,\n})\n","/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from './_md.ts';\nimport * as u64 from './_u64.ts';\nimport { type CHash, clean, createHasher, rotr } from './utils.ts';\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected A: number = SHA256_IV[0] | 0;\n  protected B: number = SHA256_IV[1] | 0;\n  protected C: number = SHA256_IV[2] | 0;\n  protected D: number = SHA256_IV[3] | 0;\n  protected E: number = SHA256_IV[4] | 0;\n  protected F: number = SHA256_IV[5] | 0;\n  protected G: number = SHA256_IV[6] | 0;\n  protected H: number = SHA256_IV[7] | 0;\n\n  constructor(outputLen: number = 32) {\n    super(64, outputLen, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean(): void {\n    clean(SHA256_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\nexport class SHA224 extends SHA256 {\n  protected A: number = SHA224_IV[0] | 0;\n  protected B: number = SHA224_IV[1] | 0;\n  protected C: number = SHA224_IV[2] | 0;\n  protected D: number = SHA224_IV[3] | 0;\n  protected E: number = SHA224_IV[4] | 0;\n  protected F: number = SHA224_IV[5] | 0;\n  protected G: number = SHA224_IV[6] | 0;\n  protected H: number = SHA224_IV[7] | 0;\n  constructor() {\n    super(28);\n  }\n}\n\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n\nexport class SHA512 extends HashMD<SHA512> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  // h -- high 32 bits, l -- low 32 bits\n  protected Ah: number = SHA512_IV[0] | 0;\n  protected Al: number = SHA512_IV[1] | 0;\n  protected Bh: number = SHA512_IV[2] | 0;\n  protected Bl: number = SHA512_IV[3] | 0;\n  protected Ch: number = SHA512_IV[4] | 0;\n  protected Cl: number = SHA512_IV[5] | 0;\n  protected Dh: number = SHA512_IV[6] | 0;\n  protected Dl: number = SHA512_IV[7] | 0;\n  protected Eh: number = SHA512_IV[8] | 0;\n  protected El: number = SHA512_IV[9] | 0;\n  protected Fh: number = SHA512_IV[10] | 0;\n  protected Fl: number = SHA512_IV[11] | 0;\n  protected Gh: number = SHA512_IV[12] | 0;\n  protected Gl: number = SHA512_IV[13] | 0;\n  protected Hh: number = SHA512_IV[14] | 0;\n  protected Hl: number = SHA512_IV[15] | 0;\n\n  constructor(outputLen: number = 64) {\n    super(128, outputLen, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ): void {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean(): void {\n    clean(SHA512_W_H, SHA512_W_L);\n  }\n  destroy(): void {\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\nexport class SHA384 extends SHA512 {\n  protected Ah: number = SHA384_IV[0] | 0;\n  protected Al: number = SHA384_IV[1] | 0;\n  protected Bh: number = SHA384_IV[2] | 0;\n  protected Bl: number = SHA384_IV[3] | 0;\n  protected Ch: number = SHA384_IV[4] | 0;\n  protected Cl: number = SHA384_IV[5] | 0;\n  protected Dh: number = SHA384_IV[6] | 0;\n  protected Dl: number = SHA384_IV[7] | 0;\n  protected Eh: number = SHA384_IV[8] | 0;\n  protected El: number = SHA384_IV[9] | 0;\n  protected Fh: number = SHA384_IV[10] | 0;\n  protected Fl: number = SHA384_IV[11] | 0;\n  protected Gh: number = SHA384_IV[12] | 0;\n  protected Gl: number = SHA384_IV[13] | 0;\n  protected Hh: number = SHA384_IV[14] | 0;\n  protected Hl: number = SHA384_IV[15] | 0;\n\n  constructor() {\n    super(48);\n  }\n}\n\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n  0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n  0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n  0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n  0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\n\nexport class SHA512_224 extends SHA512 {\n  protected Ah: number = T224_IV[0] | 0;\n  protected Al: number = T224_IV[1] | 0;\n  protected Bh: number = T224_IV[2] | 0;\n  protected Bl: number = T224_IV[3] | 0;\n  protected Ch: number = T224_IV[4] | 0;\n  protected Cl: number = T224_IV[5] | 0;\n  protected Dh: number = T224_IV[6] | 0;\n  protected Dl: number = T224_IV[7] | 0;\n  protected Eh: number = T224_IV[8] | 0;\n  protected El: number = T224_IV[9] | 0;\n  protected Fh: number = T224_IV[10] | 0;\n  protected Fl: number = T224_IV[11] | 0;\n  protected Gh: number = T224_IV[12] | 0;\n  protected Gl: number = T224_IV[13] | 0;\n  protected Hh: number = T224_IV[14] | 0;\n  protected Hl: number = T224_IV[15] | 0;\n\n  constructor() {\n    super(28);\n  }\n}\n\nexport class SHA512_256 extends SHA512 {\n  protected Ah: number = T256_IV[0] | 0;\n  protected Al: number = T256_IV[1] | 0;\n  protected Bh: number = T256_IV[2] | 0;\n  protected Bl: number = T256_IV[3] | 0;\n  protected Ch: number = T256_IV[4] | 0;\n  protected Cl: number = T256_IV[5] | 0;\n  protected Dh: number = T256_IV[6] | 0;\n  protected Dl: number = T256_IV[7] | 0;\n  protected Eh: number = T256_IV[8] | 0;\n  protected El: number = T256_IV[9] | 0;\n  protected Fh: number = T256_IV[10] | 0;\n  protected Fl: number = T256_IV[11] | 0;\n  protected Gh: number = T256_IV[12] | 0;\n  protected Gl: number = T256_IV[13] | 0;\n  protected Hh: number = T256_IV[14] | 0;\n  protected Hl: number = T256_IV[15] | 0;\n\n  constructor() {\n    super(32);\n  }\n}\n\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexport const sha256: CHash = /* @__PURE__ */ createHasher(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224: CHash = /* @__PURE__ */ createHasher(() => new SHA224());\n\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512: CHash = /* @__PURE__ */ createHasher(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384: CHash = /* @__PURE__ */ createHasher(() => new SHA384());\n\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256: CHash = /* @__PURE__ */ createHasher(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224: CHash = /* @__PURE__ */ createHasher(() => new SHA512_224());\n","import type { Address } from 'abitype'\nimport { erc6492MagicBytes } from '../../constants/bytes.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { encodeAbiParameters } from '../abi/encodeAbiParameters.js'\nimport { concatHex } from '../data/concat.js'\nimport { hexToBytes } from '../encoding/toBytes.js'\n\ntype To = 'bytes' | 'hex'\n\nexport type SerializeErc6492SignatureParameters<to extends To = 'hex'> = {\n  /** The ERC-4337 Account Factory address to use for counterfactual verification. */\n  address: Address\n  /** Calldata to pass to deploy account (if not deployed) for counterfactual verification. */\n  data: Hex\n  /** The original signature. */\n  signature: Hex\n  to?: to | To | undefined\n}\n\nexport type SerializeErc6492SignatureReturnType<to extends To = 'hex'> =\n  | (to extends 'hex' ? Hex : never)\n  | (to extends 'bytes' ? ByteArray : never)\n\nexport type SerializeErc6492SignatureErrorType = ErrorType\n\n/**\n * @description Serializes a ERC-6492 flavoured signature into hex format.\n *\n * @param signature ERC-6492 signature in object format.\n * @returns ERC-6492 signature in hex format.\n *\n * @example\n * serializeSignature({ address: '0x...', data: '0x...', signature: '0x...' })\n * // '0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492'\n */\nexport function serializeErc6492Signature<to extends To = 'hex'>(\n  parameters: SerializeErc6492SignatureParameters<to>,\n): SerializeErc6492SignatureReturnType<to> {\n  const { address, data, signature, to = 'hex' } = parameters\n  const signature_ = concatHex([\n    encodeAbiParameters(\n      [{ type: 'address' }, { type: 'bytes' }, { type: 'bytes' }],\n      [address, data, signature],\n    ),\n    erc6492MagicBytes,\n  ])\n\n  if (to === 'hex') return signature_ as SerializeErc6492SignatureReturnType<to>\n  return hexToBytes(signature_) as SerializeErc6492SignatureReturnType<to>\n}\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const filecoinCalibration = /*#__PURE__*/ defineChain({\n  id: 314_159,\n  name: 'Filecoin Calibration',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'testnet filecoin',\n    symbol: 'tFIL',\n  },\n  rpcUrls: {\n    default: { http: ['https://api.calibration.node.glif.io/rpc/v1'] },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Filscan',\n      url: 'https://calibration.filscan.io',\n    },\n  },\n  testnet: true,\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const defichainEvmTestnet = /*#__PURE__*/ defineChain({\n  id: 1131,\n  network: 'defichain-evm-testnet',\n  name: 'DeFiChain EVM Testnet',\n  nativeCurrency: {\n    name: 'DeFiChain',\n    symbol: 'DFI',\n    decimals: 18,\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://eth.testnet.ocean.jellyfishsdk.com'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'DeFiScan',\n      url: 'https://meta.defiscan.live/?network=TestNet',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 156462,\n    },\n  },\n  testnet: true,\n})\n","export * from \"./generated/coinbaseDeveloperPlatformAPIs.schemas.js\";\nexport * from \"./generated/evm-accounts/evm-accounts.js\";\nexport * from \"./generated/evm-smart-accounts/evm-smart-accounts.js\";\nexport * from \"./generated/evm-swaps/evm-swaps.js\";\nexport * from \"./generated/evm-token-balances/evm-token-balances.js\";\nexport * from \"./generated/solana-accounts/solana-accounts.js\";\nexport * from \"./generated/solana-token-balances/solana-token-balances.js\";\nexport * from \"./generated/faucets/faucets.js\";\nexport * from \"./generated/policy-engine/policy-engine.js\";\nexport * from \"./generated/onramp/onramp.js\";\nexport * from \"./generated/onchain-data/onchain-data.js\";\nexport * from \"./generated/end-user-accounts/end-user-accounts.js\";\nexport * from \"./generated/x402-facilitator/x402-facilitator.js\";\nexport * from \"./generated/sql-api-alpha/sql-api-alpha.js\";\n\nimport { configure } from \"./cdpApiClient.js\";\nimport * as endUserAccounts from \"./generated/end-user-accounts/end-user-accounts.js\";\nimport * as evm from \"./generated/evm-accounts/evm-accounts.js\";\nimport * as evmSmartAccounts from \"./generated/evm-smart-accounts/evm-smart-accounts.js\";\nimport * as evmSwaps from \"./generated/evm-swaps/evm-swaps.js\";\nimport * as evmTokenBalances from \"./generated/evm-token-balances/evm-token-balances.js\";\nimport * as faucets from \"./generated/faucets/faucets.js\";\nimport * as onchainData from \"./generated/onchain-data/onchain-data.js\";\nimport * as policies from \"./generated/policy-engine/policy-engine.js\";\nimport * as solana from \"./generated/solana-accounts/solana-accounts.js\";\nimport * as solanaTokenBalances from \"./generated/solana-token-balances/solana-token-balances.js\";\n\nexport const CdpOpenApiClient = {\n  ...evm,\n  ...evmSmartAccounts,\n  ...evmSwaps,\n  ...evmTokenBalances,\n  ...solana,\n  ...solanaTokenBalances,\n  ...faucets,\n  ...onchainData,\n  ...policies,\n  ...endUserAccounts,\n  configure,\n};\n\nexport const OpenApiEvmMethods = {\n  ...evm,\n  ...evmSmartAccounts,\n  ...evmSwaps,\n  ...evmTokenBalances,\n  requestEvmFaucet: faucets.requestEvmFaucet,\n};\n\nexport const OpenApiSolanaMethods = {\n  ...solana,\n  requestSolanaFaucet: faucets.requestSolanaFaucet,\n};\n\nexport const OpenApiPoliciesMethods = {\n  ...policies,\n};\n\nexport type CdpOpenApiClientType = typeof CdpOpenApiClient;\n","import { createHash } from \"crypto\";\n\n/**\n * Deterministically generates a UUIDv4 from a given input string.\n * This is necessary when we need to generate downstream idempotency keys for operations that have multiple calls.\n *\n * @param input - The input string to derive from\n * @param salt - Optional salt to append to the input (defaults to \"salt\")\n * @returns A UUIDv4 formatted string\n */\nexport function createDeterministicUuidV4(input: string, salt = \"salt\"): string {\n  const hash = createHash(\"sha256\")\n    .update(input + \"-\" + salt)\n    .digest(\"hex\");\n  // Format as UUIDv4: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n  return [\n    hash.slice(0, 8),\n    hash.slice(8, 12),\n    \"4\" + hash.slice(13, 16), // Version 4\n    ((parseInt(hash.slice(16, 17), 16) & 0x3) | 0x8).toString(16) + hash.slice(17, 20), // Variant bits\n    hash.slice(20, 32),\n  ].join(\"-\");\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const luksoTestnet = /*#__PURE__*/ defineChain({\n  id: 4201,\n  name: 'LUKSO Testnet',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'LUKSO Testnet',\n    symbol: 'LYXt',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://rpc.testnet.lukso.network'],\n      webSocket: ['wss://ws-rpc.testnet.lukso.network'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'LUKSO Testnet Explorer',\n      url: 'https://explorer.execution.testnet.lukso.network',\n      apiUrl: 'https://api.explorer.execution.testnet.lukso.network/api',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 605348,\n    },\n  },\n  testnet: true,\n})\n","// TODO(v3): Rename to `toLocalAccount` + add `source` property to define source (privateKey, mnemonic, hdKey, etc).\n\nimport type { Address } from 'abitype'\n\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../errors/address.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport {\n  type IsAddressErrorType,\n  isAddress,\n} from '../utils/address/isAddress.js'\nimport type {\n  AccountSource,\n  CustomSource,\n  JsonRpcAccount,\n  LocalAccount,\n} from './types.js'\n\ntype GetAccountReturnType<accountSource extends AccountSource> =\n  | (accountSource extends Address ? JsonRpcAccount : never)\n  | (accountSource extends CustomSource ? LocalAccount : never)\n\nexport type ToAccountErrorType =\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\n/**\n * @description Creates an Account from a custom signing implementation.\n *\n * @returns A Local Account.\n */\nexport function toAccount<accountSource extends AccountSource>(\n  source: accountSource,\n): GetAccountReturnType<accountSource> {\n  if (typeof source === 'string') {\n    if (!isAddress(source, { strict: false }))\n      throw new InvalidAddressError({ address: source })\n    return {\n      address: source,\n      type: 'json-rpc',\n    } as GetAccountReturnType<accountSource>\n  }\n\n  if (!isAddress(source.address, { strict: false }))\n    throw new InvalidAddressError({ address: source.address })\n  return {\n    address: source.address,\n    nonceManager: source.nonceManager,\n    sign: source.sign,\n    signAuthorization: source.signAuthorization,\n    signMessage: source.signMessage,\n    signTransaction: source.signTransaction,\n    signTypedData: source.signTypedData,\n    source: 'custom',\n    type: 'local',\n  } as GetAccountReturnType<accountSource>\n}\n","import { getErc20Address } from \"../actions/evm/transfer/utils.js\";\nimport { UserInputValidationError } from \"../errors.js\";\n\nimport type { Network } from \"../actions/evm/transfer/types.js\";\nimport type { SpendPermissionNetwork } from \"../openapi-client/index.js\";\nimport type { Address } from \"../types/misc.js\";\n\n/**\n * Resolve the address of a token for a given network.\n *\n * @param token - The token symbol or contract address.\n * @param network - The network to get the address for.\n *\n * @returns The address of the token.\n */\nexport function resolveTokenAddress(\n  token: \"eth\" | \"usdc\" | Address,\n  network: SpendPermissionNetwork,\n): Address {\n  if (token === \"eth\") {\n    return \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\";\n  }\n\n  if (token === \"usdc\" && (network === \"base\" || network === \"base-sepolia\")) {\n    return getErc20Address(token, network as Network);\n  }\n\n  if (token === \"usdc\") {\n    throw new UserInputValidationError(\n      `Automatic token address lookup for ${token} is not supported on ${network}. Please provide the token address manually.`,\n    );\n  }\n\n  return token;\n}\n","/**\n * This package contains types that describe the [methods](https://solana.com/docs/rpc/http) of the\n * Solana JSON RPC API, and utilities for creating a {@link RpcApi} implementation with sensible\n * defaults. It can be used standalone, but it is also exported as part of Kit\n * [`@solana/kit`](https://github.com/anza-xyz/kit/tree/main/packages/kit).\n *\n * @example\n * Each RPC method is described in terms of a TypeScript type of the following form:\n *\n * ```ts\n * type ExampleApi = {\n *     getSomething(address: Address): Something;\n * };\n * ```\n *\n * A {@link RpcApi} that implements `ExampleApi` will ultimately expose its defined methods on any\n * {@link Rpc} that uses it.\n *\n * ```ts\n * const rpc: Rpc<ExampleApi> = createExampleRpc(/* ... *\\/);\n * const something: Something = await rpc.getSomething(address('95DpK3y3GF7U8s1k4EvZ7xqyeCkhsHeZaE97iZpHUGMN')).send();\n * ```\n *\n * @packageDocumentation\n */\nimport { createJsonRpcApi, RpcApi } from '@solana/rpc-spec';\nimport {\n    AllowedNumericKeypaths,\n    getDefaultRequestTransformerForSolanaRpc,\n    getDefaultResponseTransformerForSolanaRpc,\n    innerInstructionsConfigs,\n    jsonParsedAccountsConfigs,\n    jsonParsedTokenAccountsConfigs,\n    KEYPATH_WILDCARD,\n    messageConfig,\n    RequestTransformerConfig,\n} from '@solana/rpc-transformers';\n\nimport { GetAccountInfoApi } from './getAccountInfo';\nimport { GetBalanceApi } from './getBalance';\nimport { GetBlockApi } from './getBlock';\nimport { GetBlockCommitmentApi } from './getBlockCommitment';\nimport { GetBlockHeightApi } from './getBlockHeight';\nimport { GetBlockProductionApi } from './getBlockProduction';\nimport { GetBlocksApi } from './getBlocks';\nimport { GetBlocksWithLimitApi } from './getBlocksWithLimit';\nimport { GetBlockTimeApi } from './getBlockTime';\nimport { GetClusterNodesApi } from './getClusterNodes';\nimport { GetEpochInfoApi } from './getEpochInfo';\nimport { GetEpochScheduleApi } from './getEpochSchedule';\nimport { GetFeeForMessageApi } from './getFeeForMessage';\nimport { GetFirstAvailableBlockApi } from './getFirstAvailableBlock';\nimport { GetGenesisHashApi } from './getGenesisHash';\nimport { GetHealthApi } from './getHealth';\nimport { GetHighestSnapshotSlotApi } from './getHighestSnapshotSlot';\nimport { GetIdentityApi } from './getIdentity';\nimport { GetInflationGovernorApi } from './getInflationGovernor';\nimport { GetInflationRateApi } from './getInflationRate';\nimport { GetInflationRewardApi } from './getInflationReward';\nimport { GetLargestAccountsApi } from './getLargestAccounts';\nimport { GetLatestBlockhashApi } from './getLatestBlockhash';\nimport { GetLeaderScheduleApi } from './getLeaderSchedule';\nimport { GetMaxRetransmitSlotApi } from './getMaxRetransmitSlot';\nimport { GetMaxShredInsertSlotApi } from './getMaxShredInsertSlot';\nimport { GetMinimumBalanceForRentExemptionApi } from './getMinimumBalanceForRentExemption';\nimport { GetMultipleAccountsApi } from './getMultipleAccounts';\nimport { GetProgramAccountsApi } from './getProgramAccounts';\nimport { GetRecentPerformanceSamplesApi } from './getRecentPerformanceSamples';\nimport { GetRecentPrioritizationFeesApi } from './getRecentPrioritizationFees';\nimport { GetSignaturesForAddressApi } from './getSignaturesForAddress';\nimport { GetSignatureStatusesApi } from './getSignatureStatuses';\nimport { GetSlotApi } from './getSlot';\nimport { GetSlotLeaderApi } from './getSlotLeader';\nimport { GetSlotLeadersApi } from './getSlotLeaders';\nimport { GetStakeMinimumDelegationApi } from './getStakeMinimumDelegation';\nimport { GetSupplyApi } from './getSupply';\nimport { GetTokenAccountBalanceApi } from './getTokenAccountBalance';\nimport { GetTokenAccountsByDelegateApi } from './getTokenAccountsByDelegate';\nimport { GetTokenAccountsByOwnerApi } from './getTokenAccountsByOwner';\nimport { GetTokenLargestAccountsApi } from './getTokenLargestAccounts';\nimport { GetTokenSupplyApi } from './getTokenSupply';\nimport { GetTransactionApi } from './getTransaction';\nimport { GetTransactionCountApi } from './getTransactionCount';\nimport { GetVersionApi } from './getVersion';\nimport { GetVoteAccountsApi } from './getVoteAccounts';\nimport { IsBlockhashValidApi } from './isBlockhashValid';\nimport { MinimumLedgerSlotApi } from './minimumLedgerSlot';\nimport { RequestAirdropApi } from './requestAirdrop';\nimport { SendTransactionApi } from './sendTransaction';\nimport { SimulateTransactionApi } from './simulateTransaction';\n\ntype SolanaRpcApiForAllClusters = GetAccountInfoApi &\n    GetBalanceApi &\n    GetBlockApi &\n    GetBlockCommitmentApi &\n    GetBlockHeightApi &\n    GetBlockProductionApi &\n    GetBlocksApi &\n    GetBlocksWithLimitApi &\n    GetBlockTimeApi &\n    GetClusterNodesApi &\n    GetEpochInfoApi &\n    GetEpochScheduleApi &\n    GetFeeForMessageApi &\n    GetFirstAvailableBlockApi &\n    GetGenesisHashApi &\n    GetHealthApi &\n    GetHighestSnapshotSlotApi &\n    GetIdentityApi &\n    GetInflationGovernorApi &\n    GetInflationRateApi &\n    GetInflationRewardApi &\n    GetLargestAccountsApi &\n    GetLatestBlockhashApi &\n    GetLeaderScheduleApi &\n    GetMaxRetransmitSlotApi &\n    GetMaxShredInsertSlotApi &\n    GetMinimumBalanceForRentExemptionApi &\n    GetMultipleAccountsApi &\n    GetProgramAccountsApi &\n    GetRecentPerformanceSamplesApi &\n    GetRecentPrioritizationFeesApi &\n    GetSignaturesForAddressApi &\n    GetSignatureStatusesApi &\n    GetSlotApi &\n    GetSlotLeaderApi &\n    GetSlotLeadersApi &\n    GetStakeMinimumDelegationApi &\n    GetSupplyApi &\n    GetTokenAccountBalanceApi &\n    GetTokenAccountsByDelegateApi &\n    GetTokenAccountsByOwnerApi &\n    GetTokenLargestAccountsApi &\n    GetTokenSupplyApi &\n    GetTransactionApi &\n    GetTransactionCountApi &\n    GetVersionApi &\n    GetVoteAccountsApi &\n    IsBlockhashValidApi &\n    MinimumLedgerSlotApi &\n    SendTransactionApi &\n    SimulateTransactionApi;\ntype SolanaRpcApiForTestClusters = RequestAirdropApi & SolanaRpcApiForAllClusters;\n/**\n * Represents the RPC methods available on test clusters.\n *\n * For instance, the test clusters support the {@link RequestAirdropApi} while mainnet does not.\n */\nexport type SolanaRpcApi = SolanaRpcApiForTestClusters;\n/**\n * Represents the RPC methods available on the devnet cluster.\n *\n * For instance, the devnet cluster supports the {@link RequestAirdropApi} while mainnet does not.\n */\nexport type SolanaRpcApiDevnet = SolanaRpcApiForTestClusters;\n/**\n * Represents the RPC methods available on the testnet cluster.\n *\n * For instance, the testnet cluster supports the {@link RequestAirdropApi} while mainnet does not.\n */\nexport type SolanaRpcApiTestnet = SolanaRpcApiForTestClusters;\n/**\n * Represents the RPC methods available on the mainnet cluster.\n *\n * For instance, the mainnet cluster does not support the {@link RequestAirdropApi} whereas test\n * clusters do.\n */\nexport type SolanaRpcApiMainnet = SolanaRpcApiForAllClusters;\n\nexport type {\n    GetAccountInfoApi,\n    GetBalanceApi,\n    GetBlockApi,\n    GetBlockCommitmentApi,\n    GetBlockHeightApi,\n    GetBlockProductionApi,\n    GetBlocksApi,\n    GetBlocksWithLimitApi,\n    GetBlockTimeApi,\n    GetClusterNodesApi,\n    GetEpochInfoApi,\n    GetEpochScheduleApi,\n    GetFeeForMessageApi,\n    GetFirstAvailableBlockApi,\n    GetGenesisHashApi,\n    GetHealthApi,\n    GetHighestSnapshotSlotApi,\n    GetIdentityApi,\n    GetInflationGovernorApi,\n    GetInflationRateApi,\n    GetInflationRewardApi,\n    GetLargestAccountsApi,\n    GetLatestBlockhashApi,\n    GetLeaderScheduleApi,\n    GetMaxRetransmitSlotApi,\n    GetMaxShredInsertSlotApi,\n    GetMinimumBalanceForRentExemptionApi,\n    GetMultipleAccountsApi,\n    GetProgramAccountsApi,\n    GetRecentPerformanceSamplesApi,\n    GetRecentPrioritizationFeesApi,\n    GetSignaturesForAddressApi,\n    GetSignatureStatusesApi,\n    GetSlotApi,\n    GetSlotLeaderApi,\n    GetSlotLeadersApi,\n    GetStakeMinimumDelegationApi,\n    GetSupplyApi,\n    GetTokenAccountBalanceApi,\n    GetTokenAccountsByDelegateApi,\n    GetTokenAccountsByOwnerApi,\n    GetTokenLargestAccountsApi,\n    GetTokenSupplyApi,\n    GetTransactionApi,\n    GetTransactionCountApi,\n    GetVersionApi,\n    GetVoteAccountsApi,\n    IsBlockhashValidApi,\n    MinimumLedgerSlotApi,\n    RequestAirdropApi,\n    SendTransactionApi,\n    SimulateTransactionApi,\n};\n\ntype Config = RequestTransformerConfig;\n\n/**\n * Creates a {@link RpcApi} implementation of the Solana JSON RPC API with some default behaviours.\n *\n * The default behaviours include:\n * - A transform that converts `bigint` inputs to `number` for compatibility with version 1.0 of the\n *   Solana JSON RPC.\n * - A transform that calls the config's {@link Config.onIntegerOverflow | onIntegerOverflow}\n *   handler whenever a `bigint` input would overflow a JavaScript IEEE 754 number. See\n *   [this](https://github.com/solana-labs/solana-web3.js/issues/1116) GitHub issue for more\n *   information.\n * - A transform that applies a default commitment wherever not specified\n */\nexport function createSolanaRpcApi<\n    // eslint-disable-next-line @typescript-eslint/no-duplicate-type-constituents\n    TRpcMethods extends SolanaRpcApi | SolanaRpcApiDevnet | SolanaRpcApiMainnet | SolanaRpcApiTestnet = SolanaRpcApi,\n>(config?: Config): RpcApi<TRpcMethods> {\n    return createJsonRpcApi<TRpcMethods>({\n        requestTransformer: getDefaultRequestTransformerForSolanaRpc(config),\n        responseTransformer: getDefaultResponseTransformerForSolanaRpc({\n            allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n        }),\n    });\n}\n\nlet memoizedKeypaths: AllowedNumericKeypaths<RpcApi<SolanaRpcApi>>;\n\n/**\n * These are keypaths at the end of which you will find a numeric value that should *not* be upcast\n * to a `bigint`. These are values that are legitimately defined as `u8` or `usize` on the backend.\n */\nfunction getAllowedNumericKeypaths(): AllowedNumericKeypaths<RpcApi<SolanaRpcApi>> {\n    if (!memoizedKeypaths) {\n        memoizedKeypaths = {\n            getAccountInfo: jsonParsedAccountsConfigs.map(c => ['value', ...c]),\n            getBlock: [\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'preTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'preTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'postTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'postTokenBalances',\n                    KEYPATH_WILDCARD,\n                    'uiTokenAmount',\n                    'decimals',\n                ],\n                ['transactions', KEYPATH_WILDCARD, 'meta', 'rewards', KEYPATH_WILDCARD, 'commission'],\n                ...innerInstructionsConfigs.map(c => [\n                    'transactions',\n                    KEYPATH_WILDCARD,\n                    'meta',\n                    'innerInstructions',\n                    KEYPATH_WILDCARD,\n                    ...c,\n                ]),\n                ...messageConfig.map(c => ['transactions', KEYPATH_WILDCARD, 'transaction', 'message', ...c] as const),\n                ['rewards', KEYPATH_WILDCARD, 'commission'],\n            ],\n            getClusterNodes: [\n                [KEYPATH_WILDCARD, 'featureSet'],\n                [KEYPATH_WILDCARD, 'shredVersion'],\n            ],\n            getInflationGovernor: [['initial'], ['foundation'], ['foundationTerm'], ['taper'], ['terminal']],\n            getInflationRate: [['foundation'], ['total'], ['validator']],\n            getInflationReward: [[KEYPATH_WILDCARD, 'commission']],\n            getMultipleAccounts: jsonParsedAccountsConfigs.map(c => ['value', KEYPATH_WILDCARD, ...c]),\n            getProgramAccounts: jsonParsedAccountsConfigs.flatMap(c => [\n                ['value', KEYPATH_WILDCARD, 'account', ...c],\n                [KEYPATH_WILDCARD, 'account', ...c],\n            ]),\n            getRecentPerformanceSamples: [[KEYPATH_WILDCARD, 'samplePeriodSecs']],\n            getTokenAccountBalance: [\n                ['value', 'decimals'],\n                ['value', 'uiAmount'],\n            ],\n            getTokenAccountsByDelegate: jsonParsedTokenAccountsConfigs.map(c => [\n                'value',\n                KEYPATH_WILDCARD,\n                'account',\n                ...c,\n            ]),\n            getTokenAccountsByOwner: jsonParsedTokenAccountsConfigs.map(c => [\n                'value',\n                KEYPATH_WILDCARD,\n                'account',\n                ...c,\n            ]),\n            getTokenLargestAccounts: [\n                ['value', KEYPATH_WILDCARD, 'decimals'],\n                ['value', KEYPATH_WILDCARD, 'uiAmount'],\n            ],\n            getTokenSupply: [\n                ['value', 'decimals'],\n                ['value', 'uiAmount'],\n            ],\n            getTransaction: [\n                ['meta', 'preTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                ['meta', 'preTokenBalances', KEYPATH_WILDCARD, 'uiTokenAmount', 'decimals'],\n                ['meta', 'postTokenBalances', KEYPATH_WILDCARD, 'accountIndex'],\n                ['meta', 'postTokenBalances', KEYPATH_WILDCARD, 'uiTokenAmount', 'decimals'],\n                ['meta', 'rewards', KEYPATH_WILDCARD, 'commission'],\n                ...innerInstructionsConfigs.map(c => ['meta', 'innerInstructions', KEYPATH_WILDCARD, ...c]),\n                ...messageConfig.map(c => ['transaction', 'message', ...c] as const),\n            ],\n            getVersion: [['feature-set']],\n            getVoteAccounts: [\n                ['current', KEYPATH_WILDCARD, 'commission'],\n                ['delinquent', KEYPATH_WILDCARD, 'commission'],\n            ],\n            simulateTransaction: [\n                ['value', 'loadedAccountsDataSize'],\n                ...jsonParsedAccountsConfigs.map(c => ['value', 'accounts', KEYPATH_WILDCARD, ...c]),\n                ...innerInstructionsConfigs.map(c => ['value', 'innerInstructions', KEYPATH_WILDCARD, ...c]),\n            ],\n        };\n    }\n    return memoizedKeypaths;\n}\n","import type { Address } from 'abitype'\n\nimport { getTransactionCount } from '../actions/public/getTransactionCount.js'\nimport type { Client } from '../clients/createClient.js'\nimport type { MaybePromise } from '../types/utils.js'\nimport { LruMap } from './lru.js'\n\nexport type CreateNonceManagerParameters = {\n  source: NonceManagerSource\n}\n\ntype FunctionParameters = {\n  address: Address\n  chainId: number\n}\n\nexport type NonceManager = {\n  /** Get and increment a nonce. */\n  consume: (\n    parameters: FunctionParameters & { client: Client },\n  ) => Promise<number>\n  /** Increment a nonce. */\n  increment: (chainId: FunctionParameters) => void\n  /** Get a nonce. */\n  get: (chainId: FunctionParameters & { client: Client }) => Promise<number>\n  /** Reset a nonce. */\n  reset: (chainId: FunctionParameters) => void\n}\n\n/**\n * Creates a nonce manager for auto-incrementing transaction nonces.\n *\n * - Docs: https://viem.sh/docs/accounts/createNonceManager\n *\n * @example\n * ```ts\n * const nonceManager = createNonceManager({\n *   source: jsonRpc(),\n * })\n * ```\n */\nexport function createNonceManager(\n  parameters: CreateNonceManagerParameters,\n): NonceManager {\n  const { source } = parameters\n\n  const deltaMap = new Map()\n  const nonceMap = new LruMap<number>(8192)\n  const promiseMap = new Map<string, Promise<number>>()\n\n  const getKey = ({ address, chainId }: FunctionParameters) =>\n    `${address}.${chainId}`\n\n  return {\n    async consume({ address, chainId, client }) {\n      const key = getKey({ address, chainId })\n      const promise = this.get({ address, chainId, client })\n\n      this.increment({ address, chainId })\n      const nonce = await promise\n\n      await source.set({ address, chainId }, nonce)\n      nonceMap.set(key, nonce)\n\n      return nonce\n    },\n    async increment({ address, chainId }) {\n      const key = getKey({ address, chainId })\n      const delta = deltaMap.get(key) ?? 0\n      deltaMap.set(key, delta + 1)\n    },\n    async get({ address, chainId, client }) {\n      const key = getKey({ address, chainId })\n\n      let promise = promiseMap.get(key)\n      if (!promise) {\n        promise = (async () => {\n          try {\n            const nonce = await source.get({ address, chainId, client })\n            const previousNonce = nonceMap.get(key) ?? 0\n            if (previousNonce > 0 && nonce <= previousNonce)\n              return previousNonce + 1\n            nonceMap.delete(key)\n            return nonce\n          } finally {\n            this.reset({ address, chainId })\n          }\n        })()\n        promiseMap.set(key, promise)\n      }\n\n      const delta = deltaMap.get(key) ?? 0\n      return delta + (await promise)\n    },\n    reset({ address, chainId }) {\n      const key = getKey({ address, chainId })\n      deltaMap.delete(key)\n      promiseMap.delete(key)\n    },\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////\n// Sources\n\nexport type NonceManagerSource = {\n  /** Get a nonce. */\n  get(parameters: FunctionParameters & { client: Client }): MaybePromise<number>\n  /** Set a nonce. */\n  set(parameters: FunctionParameters, nonce: number): MaybePromise<void>\n}\n\n/** JSON-RPC source for a nonce manager. */\nexport function jsonRpc(): NonceManagerSource {\n  return {\n    async get(parameters) {\n      const { address, client } = parameters\n      return getTransactionCount(client, {\n        address,\n        blockTag: 'pending',\n      })\n    },\n    set() {},\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////\n// Default\n\n/** Default Nonce Manager with a JSON-RPC source. */\nexport const nonceManager = /*#__PURE__*/ createNonceManager({\n  source: jsonRpc(),\n})\n","import { GetUserOperationOptions, UserOperation } from \"../../client/evm/evm.types.js\";\nimport { CdpOpenApiClientType } from \"../../openapi-client/index.js\";\nimport { Address, Hex } from \"../../types/misc.js\";\n\n/**\n * Gets a user operation for a smart account by user operation hash.\n *\n * @param {CdpOpenApiClientType} client - The client to use to get the user operation.\n * @param {GetUserOperationOptions} options - Parameters for getting the user operation.\n * @param {SmartAccount} options.smartAccount - The smart account signing the user operation.\n * @param {string} options.userOpHash - The user operation hash.\n *\n * @returns A promise that resolves to the user operation.\n *\n * @example\n * ```ts\n * const userOp = await getUserOperation(client, {\n *   smartAccount,\n *   userOpHash: \"0x1234567890123456789012345678901234567890123456789012345678901234\",\n * });\n * ```\n */\nexport async function getUserOperation(\n  client: CdpOpenApiClientType,\n  options: GetUserOperationOptions,\n): Promise<UserOperation> {\n  const address =\n    typeof options.smartAccount === \"string\" ? options.smartAccount : options.smartAccount.address;\n\n  const userOp = await client.getUserOperation(address, options.userOpHash);\n\n  return {\n    calls: userOp.calls.map(call => ({\n      to: call.to as Address,\n      value: BigInt(call.value),\n      data: call.data as Hex,\n    })),\n    network: userOp.network,\n    status: userOp.status,\n    transactionHash: userOp.transactionHash as Hex | undefined,\n    userOpHash: userOp.userOpHash as Hex,\n    receipts: userOp.receipts,\n  };\n}\n","import { InvalidAddressError } from '../../errors/address.js'\nimport { BaseError } from '../../errors/base.js'\nimport { InvalidChainIdError } from '../../errors/chain.js'\nimport type { ExactPartial } from '../../types/utils.js'\nimport { isAddress } from '../../utils/address/isAddress.js'\nimport { InvalidEip712TransactionError } from '../errors/transaction.js'\nimport type {\n  ZksyncTransactionSerializable,\n  ZksyncTransactionSerializableEIP712,\n} from '../types/transaction.js'\nimport { isEIP712Transaction } from './isEip712Transaction.js'\n\nexport function assertEip712Transaction(\n  transaction: ExactPartial<ZksyncTransactionSerializable>,\n) {\n  const { chainId, to, from, paymaster, paymasterInput } =\n    transaction as ZksyncTransactionSerializableEIP712\n\n  if (!isEIP712Transaction(transaction))\n    throw new InvalidEip712TransactionError()\n  if (!chainId || chainId <= 0) throw new InvalidChainIdError({ chainId })\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (from && !isAddress(from)) throw new InvalidAddressError({ address: from })\n  if (paymaster && !isAddress(paymaster))\n    throw new InvalidAddressError({ address: paymaster })\n  if (paymaster && !paymasterInput) {\n    throw new BaseError(\n      '`paymasterInput` must be provided when `paymaster` is defined',\n    )\n  }\n  if (!paymaster && paymasterInput) {\n    throw new BaseError(\n      '`paymaster` must be provided when `paymasterInput` is defined',\n    )\n  }\n}\n","import { z } from \"zod\";\n\n/**\n * Enum for Action types\n */\nexport const ActionEnum = z.enum([\"reject\", \"accept\"]);\n/**\n * Type representing the possible policy actions.\n * Determines whether matching the rule will cause a request to be accepted or rejected.\n */\nexport type Action = z.infer<typeof ActionEnum>;\n\n/**\n * Enum for SolAddressOperator values\n */\nexport const SolAddressOperatorEnum = z.enum([\"in\", \"not in\"]);\n/**\n * Type representing the operators that can be used for Solana address comparisons.\n * These operators determine how transaction addresses are evaluated against a list.\n */\nexport type SolAddressOperator = z.infer<typeof SolAddressOperatorEnum>;\n\n/**\n * Enum for SolValueOperator values\n */\nexport const SolValueOperatorEnum = z.enum([\">\", \">=\", \"<\", \"<=\", \"==\"]);\n/**\n * Type representing the operators that can be used for SOL value comparisons.\n * These operators determine how transaction SOL values are compared against thresholds.\n */\nexport type SolValueOperator = z.infer<typeof SolValueOperatorEnum>;\n\n/**\n * Enum for SplAddressOperator values\n */\nexport const SplAddressOperatorEnum = z.enum([\"in\", \"not in\"]);\n/**\n * Type representing the operators that can be used for SPL address comparisons.\n * These operators determine how SPL token transfer recipient addresses are evaluated against a list.\n */\nexport type SplAddressOperator = z.infer<typeof SplAddressOperatorEnum>;\n\n/**\n * Enum for SplValueOperator values\n */\nexport const SplValueOperatorEnum = z.enum([\">\", \">=\", \"<\", \"<=\", \"==\"]);\n/**\n * Type representing the operators that can be used for SPL token value comparisons.\n * These operators determine how SPL token values are compared against thresholds.\n */\nexport type SplValueOperator = z.infer<typeof SplValueOperatorEnum>;\n\n/**\n * Enum for MintAddressOperator values\n */\nexport const MintAddressOperatorEnum = z.enum([\"in\", \"not in\"]);\n/**\n * Type representing the operators that can be used for mint address comparisons.\n * These operators determine how token mint addresses are evaluated against a list.\n */\nexport type MintAddressOperator = z.infer<typeof MintAddressOperatorEnum>;\n\n/**\n * Enum for ProgramIdOperator values\n */\nexport const ProgramIdOperatorEnum = z.enum([\"in\", \"not in\"]);\n/**\n * Type representing the operators that can be used for program ID comparisons.\n * These operators determine how transaction program IDs are evaluated against a list.\n */\nexport type ProgramIdOperator = z.infer<typeof ProgramIdOperatorEnum>;\n\n/**\n * Enum for SolNetworkOperator values\n */\nexport const SolNetworkOperatorEnum = z.enum([\"in\", \"not in\"]);\n/**\n * Type representing the operators that can be used for Solana network comparisons.\n * These operators determine how transaction networks are evaluated against a list.\n */\nexport type SolNetworkOperator = z.infer<typeof SolNetworkOperatorEnum>;\n\n/**\n * Enum for supported Solana networks\n */\nexport const SolNetworkEnum = z.enum([\"solana-devnet\", \"solana\"]);\n/**\n * Type representing the supported Solana networks.\n */\nexport type SolNetwork = z.infer<typeof SolNetworkEnum>;\n\n/**\n * Enum for KnownIdlType values\n */\nexport const KnownIdlTypeEnum = z.enum([\"SystemProgram\", \"TokenProgram\", \"AssociatedTokenProgram\"]);\n/**\n * Type representing known Solana programs that have established IDL specifications.\n * These programs can be referenced directly by name in policy rules.\n */\nexport type KnownIdlType = z.infer<typeof KnownIdlTypeEnum>;\n\n/**\n * Schema for IDL specifications following Anchor's IDL format v0.30+\n */\nexport const IdlSchema = z\n  .object({\n    /** The program address */\n    address: z.string(),\n    /** Array of instruction specifications */\n    instructions: z.array(z.any()),\n  })\n  .passthrough();\nexport type Idl = z.infer<typeof IdlSchema>;\n\n/**\n * Enum for SolDataParameterOperator values\n */\nexport const SolDataParameterOperatorEnum = z.enum([\">\", \">=\", \"<\", \"<=\", \"==\"]);\n/**\n * Type representing the operators that can be used for Solana data parameter comparisons.\n */\nexport type SolDataParameterOperator = z.infer<typeof SolDataParameterOperatorEnum>;\n\n/**\n * Enum for SolDataParameterListOperator values\n */\nexport const SolDataParameterListOperatorEnum = z.enum([\"in\", \"not in\"]);\n/**\n * Type representing the operators that can be used for Solana data parameter list comparisons.\n */\nexport type SolDataParameterListOperator = z.infer<typeof SolDataParameterListOperatorEnum>;\n\n/**\n * Schema for Solana data parameter conditions (single value)\n */\nexport const SolDataParameterConditionSchema = z.object({\n  /** The parameter name */\n  name: z.string(),\n  /** The operator to use for the comparison */\n  operator: SolDataParameterOperatorEnum,\n  /** The value to compare against */\n  value: z.string(),\n});\nexport type SolDataParameterCondition = z.infer<typeof SolDataParameterConditionSchema>;\n\n/**\n * Schema for Solana data parameter conditions (list values)\n */\nexport const SolDataParameterConditionListSchema = z.object({\n  /** The parameter name */\n  name: z.string(),\n  /** The operator to use for the comparison */\n  operator: SolDataParameterListOperatorEnum,\n  /** The values to compare against */\n  values: z.array(z.string()),\n});\nexport type SolDataParameterConditionList = z.infer<typeof SolDataParameterConditionListSchema>;\n\n/**\n * Schema for Solana data conditions\n */\nexport const SolDataConditionSchema = z.object({\n  /** The instruction name */\n  instruction: z.string(),\n  /** Parameter conditions for the instruction */\n  params: z\n    .array(z.union([SolDataParameterConditionSchema, SolDataParameterConditionListSchema]))\n    .optional(),\n});\nexport type SolDataCondition = z.infer<typeof SolDataConditionSchema>;\n\n/**\n * Schema for Solana address criterions\n */\nexport const SolAddressCriterionSchema = z.object({\n  /** The type of criterion, must be \"solAddress\" for Solana address-based rules. */\n  type: z.literal(\"solAddress\"),\n  /**\n   * Array of Solana addresses to compare against.\n   * Each address must be a valid Base58-encoded Solana address (32-44 characters).\n   */\n  addresses: z.array(z.string().regex(/^[1-9A-HJ-NP-Za-km-z]{32,44}$/)),\n  /**\n   * The operator to use for evaluating transaction addresses.\n   * \"in\" checks if an address is in the provided list.\n   * \"not in\" checks if an address is not in the provided list.\n   */\n  operator: SolAddressOperatorEnum,\n});\nexport type SolAddressCriterion = z.infer<typeof SolAddressCriterionSchema>;\n\n/**\n * Schema for SOL value criterions\n */\nexport const SolValueCriterionSchema = z.object({\n  /** The type of criterion, must be \"solValue\" for SOL value-based rules. */\n  type: z.literal(\"solValue\"),\n  /**\n   * The SOL value amount in lamports to compare against, as a string.\n   * Must contain only digits.\n   */\n  solValue: z.string().regex(/^[0-9]+$/),\n  /** The comparison operator to use for evaluating transaction SOL values against the threshold. */\n  operator: SolValueOperatorEnum,\n});\nexport type SolValueCriterion = z.infer<typeof SolValueCriterionSchema>;\n\n/**\n * Schema for SPL address criterions\n */\nexport const SplAddressCriterionSchema = z.object({\n  /** The type of criterion, must be \"splAddress\" for SPL address-based rules. */\n  type: z.literal(\"splAddress\"),\n  /**\n   * Array of Solana addresses to compare against for SPL token transfer recipients.\n   * Each address must be a valid Base58-encoded Solana address (32-44 characters).\n   */\n  addresses: z.array(z.string().regex(/^[1-9A-HJ-NP-Za-km-z]{32,44}$/)),\n  /**\n   * The operator to use for evaluating SPL token transfer recipient addresses.\n   * \"in\" checks if an address is in the provided list.\n   * \"not in\" checks if an address is not in the provided list.\n   */\n  operator: SplAddressOperatorEnum,\n});\nexport type SplAddressCriterion = z.infer<typeof SplAddressCriterionSchema>;\n\n/**\n * Schema for SPL value criterions\n */\nexport const SplValueCriterionSchema = z.object({\n  /** The type of criterion, must be \"splValue\" for SPL token value-based rules. */\n  type: z.literal(\"splValue\"),\n  /**\n   * The SPL token value amount to compare against, as a string.\n   * Must contain only digits.\n   */\n  splValue: z.string().regex(/^[0-9]+$/),\n  /** The comparison operator to use for evaluating SPL token values against the threshold. */\n  operator: SplValueOperatorEnum,\n});\nexport type SplValueCriterion = z.infer<typeof SplValueCriterionSchema>;\n\n/**\n * Schema for mint address criterions\n */\nexport const MintAddressCriterionSchema = z.object({\n  /** The type of criterion, must be \"mintAddress\" for token mint address-based rules. */\n  type: z.literal(\"mintAddress\"),\n  /**\n   * Array of Solana addresses to compare against for token mint addresses.\n   * Each address must be a valid Base58-encoded Solana address (32-44 characters).\n   */\n  addresses: z.array(z.string().regex(/^[1-9A-HJ-NP-Za-km-z]{32,44}$/)),\n  /**\n   * The operator to use for evaluating token mint addresses.\n   * \"in\" checks if an address is in the provided list.\n   * \"not in\" checks if an address is not in the provided list.\n   */\n  operator: MintAddressOperatorEnum,\n});\nexport type MintAddressCriterion = z.infer<typeof MintAddressCriterionSchema>;\n\n/**\n * Schema for Solana data criterions\n */\nexport const SolDataCriterionSchema = z.object({\n  /** The type of criterion, must be \"solData\" for Solana data-based rules. */\n  type: z.literal(\"solData\"),\n  /**\n   * List of IDL specifications. Can contain known program names (strings) or custom IDL objects.\n   */\n  idls: z.array(z.union([KnownIdlTypeEnum, IdlSchema])),\n  /**\n   * A list of conditions to apply against the transaction instruction.\n   * Only one condition must evaluate to true for this criterion to be met.\n   */\n  conditions: z.array(SolDataConditionSchema),\n});\nexport type SolDataCriterion = z.infer<typeof SolDataCriterionSchema>;\n\n/**\n * Schema for program ID criterions\n */\nexport const ProgramIdCriterionSchema = z.object({\n  /** The type of criterion, must be \"programId\" for program ID-based rules. */\n  type: z.literal(\"programId\"),\n  /**\n   * Array of Solana program IDs to compare against.\n   * Each program ID must be a valid Base58-encoded Solana address (32-44 characters).\n   */\n  programIds: z.array(z.string().regex(/^[1-9A-HJ-NP-Za-km-z]{32,44}$/)),\n  /**\n   * The operator to use for evaluating transaction program IDs.\n   * \"in\" checks if a program ID is in the provided list.\n   * \"not in\" checks if a program ID is not in the provided list.\n   */\n  operator: ProgramIdOperatorEnum,\n});\nexport type ProgramIdCriterion = z.infer<typeof ProgramIdCriterionSchema>;\n\n/**\n * Schema for Solana network criterions\n */\nexport const SolNetworkCriterionSchema = z.object({\n  /** The type of criterion, must be \"solNetwork\" for network-based rules. */\n  type: z.literal(\"solNetwork\"),\n  /**\n   * Array of Solana networks to compare against.\n   */\n  networks: z.array(SolNetworkEnum),\n  /**\n   * The operator to use for evaluating transaction network.\n   * \"in\" checks if the network is in the provided list.\n   * \"not in\" checks if the network is not in the provided list.\n   */\n  operator: SolNetworkOperatorEnum,\n});\nexport type SolNetworkCriterion = z.infer<typeof SolNetworkCriterionSchema>;\n\n/**\n * Schema for Solana message criterions\n */\nexport const SolMessageCriterionSchema = z.object({\n  /** The type of criterion, must be \"solMessage\" for message-based rules. */\n  type: z.literal(\"solMessage\"),\n  /**\n   * A regular expression pattern to match against the message.\n   */\n  match: z.string(),\n});\nexport type SolMessageCriterion = z.infer<typeof SolMessageCriterionSchema>;\n\n/**\n * Schema for criteria used in SignSolTransaction operations\n */\nexport const SignSolTransactionCriteriaSchema = z\n  .array(\n    z.discriminatedUnion(\"type\", [\n      SolAddressCriterionSchema,\n      SolValueCriterionSchema,\n      SplAddressCriterionSchema,\n      SplValueCriterionSchema,\n      MintAddressCriterionSchema,\n      SolDataCriterionSchema,\n      ProgramIdCriterionSchema,\n    ]),\n  )\n  .max(10)\n  .min(1);\n/**\n * Type representing a set of criteria for the signSolTransaction operation.\n * Can contain up to 10 individual criterion objects for Solana addresses, SOL values, SPL addresses, SPL values, mint addresses, Solana data, and program IDs.\n */\nexport type SignSolTransactionCriteria = z.infer<typeof SignSolTransactionCriteriaSchema>;\n\n/**\n * Schema for criteria used in SendSolTransaction operations\n */\nexport const SendSolTransactionCriteriaSchema = z\n  .array(\n    z.discriminatedUnion(\"type\", [\n      SolAddressCriterionSchema,\n      SolValueCriterionSchema,\n      SplAddressCriterionSchema,\n      SplValueCriterionSchema,\n      MintAddressCriterionSchema,\n      SolDataCriterionSchema,\n      ProgramIdCriterionSchema,\n      SolNetworkCriterionSchema,\n    ]),\n  )\n  .max(10)\n  .min(1);\n/**\n * Type representing a set of criteria for the sendSolTransaction operation.\n * Can contain up to 10 individual criterion objects for Solana addresses, SOL values, SPL addresses, SPL values, mint addresses, Solana data, program IDs, and network restrictions.\n */\nexport type SendSolTransactionCriteria = z.infer<typeof SendSolTransactionCriteriaSchema>;\n\n/**\n * Enum for Solana Operation types\n */\nexport const SolOperationEnum = z.enum([\n  \"signSolTransaction\",\n  \"sendSolTransaction\",\n  \"signSolMessage\",\n]);\n/**\n * Type representing the operations that can be governed by a policy.\n * Defines what Solana operations the policy applies to.\n */\nexport type SolOperation = z.infer<typeof SolOperationEnum>;\n\n/**\n * Type representing a 'signSolTransaction' policy rule that can accept or reject specific operations\n * based on a set of criteria.\n */\nexport const SignSolTransactionRuleSchema = z.object({\n  /**\n   * Determines whether matching the rule will cause a request to be rejected or accepted.\n   * \"accept\" will allow the transaction, \"reject\" will block it.\n   */\n  action: ActionEnum,\n  /**\n   * The operation to which this rule applies.\n   * Must be \"signSolTransaction\".\n   */\n  operation: z.literal(\"signSolTransaction\"),\n  /**\n   * The set of criteria that must be matched for this rule to apply.\n   * Must be compatible with the specified operation type.\n   */\n  criteria: SignSolTransactionCriteriaSchema,\n});\nexport type SignSolTransactionRule = z.infer<typeof SignSolTransactionRuleSchema>;\n\n/**\n * Type representing a 'sendSolTransaction' policy rule that can accept or reject specific operations\n * based on a set of criteria.\n */\nexport const SendSolTransactionRuleSchema = z.object({\n  /**\n   * Determines whether matching the rule will cause a request to be rejected or accepted.\n   * \"accept\" will allow the transaction, \"reject\" will block it.\n   */\n  action: ActionEnum,\n  /**\n   * The operation to which this rule applies.\n   * Must be \"sendSolTransaction\".\n   */\n  operation: z.literal(\"sendSolTransaction\"),\n  /**\n   * The set of criteria that must be matched for this rule to apply.\n   * Must be compatible with the specified operation type.\n   */\n  criteria: SendSolTransactionCriteriaSchema,\n});\nexport type SendSolTransactionRule = z.infer<typeof SendSolTransactionRuleSchema>;\n\n/**\n * Schema for criteria used in SignSolMessage operations\n */\nexport const SignSolMessageCriteriaSchema = z.array(SolMessageCriterionSchema).max(10).min(1);\n/**\n * Type representing a set of criteria for the signSolMessage operation.\n * Can contain up to 10 individual criterion objects for Solana message matching.\n */\nexport type SignSolMessageCriteria = z.infer<typeof SignSolMessageCriteriaSchema>;\n\n/**\n * Type representing a 'signSolMessage' policy rule that can accept or reject specific operations\n * based on a set of criteria.\n */\nexport const SignSolMessageRuleSchema = z.object({\n  /**\n   * Determines whether matching the rule will cause a request to be rejected or accepted.\n   * \"accept\" will allow the message signing, \"reject\" will block it.\n   */\n  action: ActionEnum,\n  /**\n   * The operation to which this rule applies.\n   * Must be \"signSolMessage\".\n   */\n  operation: z.literal(\"signSolMessage\"),\n  /**\n   * The set of criteria that must be matched for this rule to apply.\n   * Must be compatible with the specified operation type.\n   */\n  criteria: SignSolMessageCriteriaSchema,\n});\nexport type SignSolMessageRule = z.infer<typeof SignSolMessageRuleSchema>;\n","import {\n  GetSwapPriceOptions,\n  GetSwapPriceResult,\n  SwapUnavailableResult,\n} from \"../../../client/evm/evm.types.js\";\nimport { CdpOpenApiClientType, GetSwapPriceResponse } from \"../../../openapi-client/index.js\";\nimport { Address } from \"../../../types/misc.js\";\n\n/**\n * Gets the price for a swap between two tokens on an EVM network.\n *\n * @param {CdpOpenApiClientType} client - The client to use to get the swap price.\n * @param {GetSwapPriceOptions} options - The options for getting a swap price.\n *\n * @returns {Promise<GetSwapPriceResult | SwapUnavailableResult>} A promise that resolves to the swap price result or a response indicating that liquidity is unavailable.\n *\n * @example **Getting a swap price**\n * ```ts\n * const price = await getSwapPrice(client, {\n *   network: \"ethereum-mainnet\",\n *   toToken: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\", // USDC\n *   fromToken: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\", // WETH\n *   fromAmount: BigInt(\"1000000000000000000\"), // 1 WETH in wei\n *   taker: \"0x1234567890123456789012345678901234567890\",\n *   idempotencyKey: \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\" // Optional: for request deduplication\n * });\n * ```\n */\nexport async function getSwapPrice(\n  client: CdpOpenApiClientType,\n  options: GetSwapPriceOptions,\n): Promise<GetSwapPriceResult | SwapUnavailableResult> {\n  // Call the getEvmSwapPrice function directly with the client's configured API\n  const response = await client.getEvmSwapPrice(\n    {\n      network: options.network,\n      toToken: options.toToken,\n      fromToken: options.fromToken,\n      fromAmount: options.fromAmount.toString(),\n      taker: options.taker,\n      signerAddress: options.signerAddress,\n      gasPrice: options.gasPrice?.toString(),\n      slippageBps: options.slippageBps,\n    },\n    options.idempotencyKey,\n  );\n\n  // Check if liquidity is unavailable\n  if (!response.liquidityAvailable) {\n    // Return the SwapUnavailableResult\n    return {\n      liquidityAvailable: false,\n    };\n  }\n\n  // At this point we know it's a GetSwapPriceResponse with liquidityAvailable as true\n  const quoteResponse = response as GetSwapPriceResponse;\n  return {\n    blockNumber: BigInt(quoteResponse.blockNumber),\n    toAmount: BigInt(quoteResponse.toAmount),\n    toToken: quoteResponse.toToken as Address,\n    fees: {\n      gasFee: quoteResponse.fees.gasFee\n        ? {\n            amount: BigInt(quoteResponse.fees.gasFee.amount),\n            token: quoteResponse.fees.gasFee.token as Address,\n          }\n        : undefined,\n      protocolFee: quoteResponse.fees.protocolFee\n        ? {\n            amount: BigInt(quoteResponse.fees.protocolFee.amount),\n            token: quoteResponse.fees.protocolFee.token as Address,\n          }\n        : undefined,\n    },\n    issues: {\n      allowance: quoteResponse.issues.allowance\n        ? {\n            currentAllowance: BigInt(quoteResponse.issues.allowance.currentAllowance),\n            spender: quoteResponse.issues.allowance.spender as Address,\n          }\n        : undefined,\n      balance: quoteResponse.issues.balance\n        ? {\n            token: quoteResponse.issues.balance.token as Address,\n            currentBalance: BigInt(quoteResponse.issues.balance.currentBalance),\n            requiredBalance: BigInt(quoteResponse.issues.balance.requiredBalance),\n          }\n        : undefined,\n      simulationIncomplete: quoteResponse.issues.simulationIncomplete,\n    },\n    liquidityAvailable: true,\n    minToAmount: BigInt(quoteResponse.minToAmount),\n    fromAmount: BigInt(quoteResponse.fromAmount),\n    fromToken: quoteResponse.fromToken as Address,\n    gas: quoteResponse.gas ? BigInt(quoteResponse.gas) : undefined,\n    gasPrice: quoteResponse.gasPrice ? BigInt(quoteResponse.gasPrice) : undefined,\n  };\n}\n","import { version } from '../version.js'\n\n/** @internal */\nexport function getUrl(url: string) {\n  return url\n}\n\n/** @internal */\nexport function getVersion() {\n  return version\n}\n\n/** @internal */\nexport function prettyPrint(args: unknown) {\n  if (!args) return ''\n  const entries = Object.entries(args)\n    .map(([key, value]) => {\n      if (value === undefined || value === false) return null\n      return [key, value]\n    })\n    .filter(Boolean) as [string, string][]\n  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0)\n  return entries\n    .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n    .join('\\n')\n}\n","import md5 from \"md5\";\n\nimport { UserInputValidationError } from \"./errors.js\";\nimport { APIError, NetworkError } from \"./openapi-client/errors.js\";\nimport { version } from \"./version.js\";\n\n/**\n * The data in an error event\n */\ntype ErrorEventData = {\n  /**\n   * The API method where the error occurred, e.g. createAccount, getAccount\n   */\n  method: string;\n  /**\n   * The error message\n   */\n  message: string;\n  /**\n   * The error stack trace\n   */\n  stack?: string;\n  /**\n   * The name of the event. This should match the name in AEC\n   */\n  name: \"error\";\n};\n\n/**\n * The data in an action event\n */\ntype ActionEventData = {\n  /**\n   * The operation being performed, e.g. \"transfer\", \"swap\", \"fund\", \"requestFaucet\"\n   */\n  action: string;\n  /**\n   * The account type, e.g. \"evm-server\", \"evm-smart\", \"solana\"\n   */\n  accountType?: \"evm_server\" | \"evm_smart\" | \"solana\";\n  /**\n   * Additional properties specific to the action\n   */\n  properties?: Record<string, unknown>;\n  /**\n   * The name of the event\n   */\n  name: \"action\";\n};\n\ntype EventData = ErrorEventData | ActionEventData;\n\n// This is a public client id for the analytics service\nconst publicClientId = \"54f2ee2fb3d2b901a829940d70fbfc13\";\n\nexport const Analytics = {\n  identifier: \"\", // set in cdp.ts\n  wrapClassWithErrorTracking,\n  wrapObjectMethodsWithErrorTracking,\n  sendEvent,\n  trackAction,\n};\n\n/**\n * Sends an analytics event to the default endpoint\n *\n * @param event - The event data containing event-specific fields\n * @returns Promise that resolves when the event is sent\n */\nasync function sendEvent(event: EventData): Promise<void> {\n  if (event.name === \"error\" && process.env.DISABLE_CDP_ERROR_REPORTING === \"true\") {\n    return;\n  }\n\n  if (event.name !== \"error\" && process.env.DISABLE_CDP_USAGE_TRACKING === \"true\") {\n    return;\n  }\n\n  const timestamp = Date.now();\n\n  const enhancedEvent = {\n    user_id: Analytics.identifier,\n    event_type: event.name,\n    platform: \"server\",\n    timestamp,\n    event_properties: {\n      project_name: \"cdp-sdk\",\n      cdp_sdk_language: \"typescript\",\n      version,\n      ...event,\n    },\n  };\n\n  const events = [enhancedEvent];\n  const stringifiedEventData = JSON.stringify(events);\n  const uploadTime = timestamp.toString();\n\n  const checksum = md5(stringifiedEventData + uploadTime);\n\n  const analyticsServiceData = {\n    client: publicClientId,\n    e: stringifiedEventData,\n    checksum,\n  };\n\n  const apiEndpoint = \"https://cca-lite.coinbase.com\";\n  const eventPath = \"/amp\";\n  const eventEndPoint = `${apiEndpoint}${eventPath}`;\n\n  await fetch(eventEndPoint, {\n    method: \"POST\",\n    mode: \"no-cors\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(analyticsServiceData),\n  });\n}\n\n/**\n * Track an action being performed\n *\n * @param params - The parameters for tracking an action\n * @param params.action - The action being performed\n * @param params.accountType - The type of account\n * @param params.properties - Additional properties\n */\nfunction trackAction(params: {\n  action: string;\n  accountType?: \"evm_server\" | \"evm_smart\" | \"solana\";\n  properties?: Record<string, unknown>;\n}): void {\n  if (\n    params.properties?.network &&\n    typeof params.properties.network === \"string\" &&\n    params.properties.network.startsWith(\"http\")\n  ) {\n    const url = new URL(params.properties.network);\n    params.properties.customRpcHost = url.hostname;\n    params.properties.network = \"custom\";\n  }\n\n  sendEvent({\n    action: params.action,\n    accountType: params.accountType,\n    properties: params.properties,\n    name: \"action\",\n  }).catch(() => {\n    // ignore error\n  });\n}\n\n/**\n * Wraps all methods of a class with error tracking.\n *\n * @param ClassToWrap - The class whose prototype methods should be wrapped.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction wrapClassWithErrorTracking(ClassToWrap: any): void {\n  if (process.env.DISABLE_CDP_ERROR_REPORTING === \"true\") {\n    return;\n  }\n\n  const methods = Object.getOwnPropertyNames(ClassToWrap.prototype).filter(\n    name => name !== \"constructor\" && typeof ClassToWrap.prototype[name] === \"function\",\n  );\n\n  for (const method of methods) {\n    const originalMethod = ClassToWrap.prototype[method];\n    ClassToWrap.prototype[method] = async function (...args: unknown[]) {\n      try {\n        return await originalMethod.apply(this, args);\n      } catch (error) {\n        if (!shouldTrackError(error)) {\n          throw error;\n        }\n\n        const { message, stack } = error as Error;\n\n        sendEvent({\n          method,\n          message,\n          stack,\n          name: \"error\",\n        }).catch(() => {\n          // ignore error\n        });\n\n        throw error;\n      }\n    };\n  }\n}\n\n/**\n * Wraps all methods of an object with error tracking.\n *\n * @param object - The object whose methods should be wrapped.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction wrapObjectMethodsWithErrorTracking(object: any): void {\n  if (process.env.DISABLE_CDP_ERROR_REPORTING === \"true\") {\n    return;\n  }\n\n  const methods = Object.getOwnPropertyNames(object).filter(\n    name => name !== \"constructor\" && typeof object[name] === \"function\",\n  );\n\n  for (const method of methods) {\n    const originalMethod = object[method];\n    object[method] = async function (...args: unknown[]) {\n      try {\n        return await originalMethod.apply(this, args);\n      } catch (error) {\n        if (!shouldTrackError(error)) {\n          throw error;\n        }\n\n        const { message, stack } = error as Error;\n\n        sendEvent({\n          method,\n          message,\n          stack,\n          name: \"error\",\n        }).catch(() => {\n          // ignore error\n        });\n\n        throw error;\n      }\n    };\n  }\n}\n\n/**\n * Filters out non-errors and API errors\n *\n * @param error - The error to check.\n * @returns True if the error should be tracked, false otherwise.\n */\nfunction shouldTrackError(error: unknown): boolean {\n  if (!(error instanceof Error)) {\n    return false;\n  }\n\n  if (error instanceof UserInputValidationError) {\n    return false;\n  }\n\n  if (error instanceof NetworkError) {\n    return true;\n  }\n\n  if (error instanceof APIError && error.errorType !== \"unexpected_error\") {\n    return false;\n  }\n\n  return true;\n}\n","import { ERROR_DOCS_PAGE_URL } from \"../constants.js\";\nimport {\n  Error as OpenAPIError,\n  ErrorType as OpenAPIErrorType,\n} from \"./generated/coinbaseDeveloperPlatformAPIs.schemas.js\";\n\nexport type HttpErrorType =\n  | \"unexpected_error\"\n  | \"unauthorized\"\n  | \"not_found\"\n  | \"bad_gateway\"\n  | \"service_unavailable\"\n  | \"unknown\"\n  | \"network_timeout\"\n  | \"network_connection_failed\"\n  | \"network_ip_blocked\"\n  | \"network_dns_failure\";\n\n/**\n * Extended error codes that include both OpenAPI errors and network errors\n */\nexport type APIErrorType = OpenAPIErrorType | HttpErrorType;\n\n/**\n * Extended API error that encompasses both OpenAPI errors and other API-related errors\n */\nexport class APIError extends Error {\n  statusCode: number;\n  errorType: APIErrorType;\n  errorMessage: string;\n  correlationId?: string;\n  errorLink?: string;\n\n  /**\n   * Constructor for the APIError class\n   *\n   * @param statusCode - The HTTP status code\n   * @param errorType - The type of error\n   * @param errorMessage - The error message\n   * @param correlationId - The correlation ID\n   * @param errorLink - URL to documentation about this error\n   * @param cause - The cause of the error\n   */\n  constructor(\n    statusCode: number,\n    errorType: APIErrorType,\n    errorMessage: string,\n    correlationId?: string,\n    errorLink?: string,\n    cause?: Error | unknown,\n  ) {\n    super(errorMessage, { cause });\n    this.name = \"APIError\";\n    this.statusCode = statusCode;\n    this.errorType = errorType;\n    this.errorMessage = errorMessage;\n\n    // Only set correlationId if it's defined\n    if (correlationId !== undefined) {\n      this.correlationId = correlationId;\n    }\n\n    // Only set errorLink if it's defined\n    if (errorLink !== undefined) {\n      this.errorLink = errorLink;\n    }\n  }\n\n  /**\n   * Convert the error to a JSON object, excluding undefined properties\n   *\n   * @returns The error as a JSON object\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      statusCode: this.statusCode,\n      errorType: this.errorType,\n      errorMessage: this.errorMessage,\n      ...(this.correlationId && { correlationId: this.correlationId }),\n      ...(this.errorLink && { errorLink: this.errorLink }),\n    };\n  }\n}\n\n/**\n * Error thrown when an Axios request is made but no response is received\n */\nexport class UnknownApiError extends APIError {\n  /**\n   * Constructor for the UnknownApiError class\n   *\n   * @param errorType - The type of error\n   * @param errorMessage - The error message\n   * @param cause - The cause of the error\n   */\n  constructor(errorType: APIErrorType, errorMessage: string, cause?: Error) {\n    super(0, errorType, errorMessage, undefined, undefined, cause);\n    this.name = \"UnknownApiError\";\n  }\n}\n\n/**\n * Error thrown when an error is not known\n */\nexport class UnknownError extends Error {\n  /**\n   * Constructor for the UnknownError class\n   *\n   * @param message - The error message\n   * @param cause - The cause of the error\n   */\n  constructor(message: string, cause?: Error) {\n    super(message, { cause });\n    this.name = \"UnknownError\";\n  }\n}\n\n/**\n * Error thrown when a network-level failure occurs before reaching the CDP service\n * This includes gateway errors, IP blocklist rejections, DNS failures, etc.\n */\nexport class NetworkError extends APIError {\n  networkDetails?: {\n    code?: string;\n    message?: string;\n    retryable?: boolean;\n  };\n\n  /**\n   * Constructor for the NetworkError class\n   *\n   * @param errorType - The type of network error\n   * @param errorMessage - The error message\n   * @param networkDetails - Additional network error details\n   * @param networkDetails.code - The error code\n   * @param networkDetails.message - The error message\n   * @param networkDetails.retryable - Whether the error is retryable\n   * @param cause - The cause of the error\n   */\n  constructor(\n    errorType: HttpErrorType,\n    errorMessage: string,\n    networkDetails?: { code?: string; message?: string; retryable?: boolean },\n    cause?: Error | unknown,\n  ) {\n    super(\n      0, // Status code 0 indicates no response was received\n      errorType,\n      errorMessage,\n      undefined,\n      `${ERROR_DOCS_PAGE_URL}#network-errors`,\n      cause,\n    );\n    this.name = \"NetworkError\";\n    this.networkDetails = networkDetails;\n  }\n\n  /**\n   * Convert the error to a JSON object, including network details\n   *\n   * @returns The error as a JSON object\n   */\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      ...(this.networkDetails && { networkDetails: this.networkDetails }),\n    };\n  }\n}\n\n/**\n * Type guard to check if an object is an OpenAPIError\n *\n * @param obj - The object to check\n * @returns True if the object is an OpenAPIError\n */\nexport function isOpenAPIError(obj: unknown): obj is OpenAPIError {\n  return (\n    obj !== null &&\n    typeof obj === \"object\" &&\n    \"errorType\" in obj &&\n    typeof (obj as OpenAPIError).errorType === \"string\" &&\n    \"errorMessage\" in obj &&\n    typeof (obj as OpenAPIError).errorMessage === \"string\"\n  );\n}\n","import { serializeTransaction, TransactionRequestEIP1559 } from \"viem\";\n\nimport type {\n  CdpOpenApiClientType,\n  SendEvmTransactionBodyNetwork,\n} from \"../../openapi-client/index.js\";\nimport type { Address, Hex } from \"../../types/misc.js\";\n\n/**\n * Options for sending an EVM transaction.\n */\nexport interface SendTransactionOptions {\n  /** The address of the account. */\n  address: Address;\n  /**\n   * The transaction to send. The chainId is ignored in favor of the `network` field.\n   *\n   * This can be either:\n   * - An RLP-encoded transaction to sign and send, as a 0x-prefixed hex string, or\n   * - An EIP-1559 transaction request object.\n   */\n  transaction: Hex | TransactionRequestEIP1559;\n  /**\n   * The network to send the transaction to.\n   * The chainId in the `transaction` field is ignored in favor of this field.\n   */\n  network: SendEvmTransactionBodyNetwork;\n  /** The idempotency key. */\n  idempotencyKey?: string;\n}\n\n/**\n * Result of a transaction\n */\nexport interface TransactionResult {\n  /** The hash of the transaction. */\n  transactionHash: Hex;\n}\n\n/**\n * Sends an EVM transaction.\n *\n * @param apiClient - The API client.\n * @param options - The options for sending the transaction.\n *\n * @returns The result of the transaction.\n */\nexport async function sendTransaction(\n  apiClient: CdpOpenApiClientType,\n  options: SendTransactionOptions,\n): Promise<TransactionResult> {\n  const { address, network, idempotencyKey } = options;\n  let transaction = options.transaction;\n\n  if (typeof transaction !== \"string\") {\n    transaction = serializeTransaction({\n      ...transaction,\n      // chainId is ignored in favor of network\n      chainId: 1,\n      type: \"eip1559\",\n    });\n  }\n\n  const result = await apiClient.sendEvmTransaction(\n    address,\n    { transaction, network },\n    idempotencyKey,\n  );\n\n  return {\n    transactionHash: result.transactionHash as Hex,\n  };\n}\n","import { SignMessageOptions, SignatureResult } from \"../../client/solana/solana.types.js\";\nimport { CdpOpenApiClientType } from \"../../openapi-client/index.js\";\n\n/**\n * Sign a message.\n *\n * @param apiClient - The API client.\n * @param {SignMessageOptions} options - Parameters for signing the message.\n * @param {string} options.address - The address to sign the message for.\n * @param {string} options.message - The message to sign.\n * @param {string} [options.idempotencyKey] - An idempotency key.\n *\n * @returns A promise that resolves to the transaction signature.\n *\n * @example\n *          ```ts\n *          const signature = await signMessage(cdp.solana, {\n *            address: \"1234567890123456789012345678901234567890\",\n *            message: \"Hello, world!\",\n *          });\n *          ```\n */\nexport async function signMessage(\n  apiClient: CdpOpenApiClientType,\n  options: SignMessageOptions,\n): Promise<SignatureResult> {\n  const signature = await apiClient.signSolanaMessage(\n    options.address,\n    { message: options.message },\n    options.idempotencyKey,\n  );\n\n  return {\n    signature: signature.signature,\n  };\n}\n","import { RequestFaucetOptions, SignatureResult } from \"../../client/solana/solana.types.js\";\nimport { CdpOpenApiClientType } from \"../../openapi-client/index.js\";\n\n/**\n * Requests funds from a Solana faucet.\n *\n * @param apiClient - The API client.\n * @param {RequestFaucetOptions} options - Parameters for requesting funds from the Solana faucet.\n * @param {string} options.address - The address to request funds for.\n * @param {string} options.token - The token to request funds for.\n * @param {string} [options.idempotencyKey] - An idempotency key.\n *\n * @returns A promise that resolves to the transaction signature.\n *\n * @example\n *          ```ts\n *          const signature = await requestFaucet(cdp.solana, {\n *            address: \"1234567890123456789012345678901234567890\",\n *            token: \"sol\",\n *          });\n *          ```\n */\nexport async function requestFaucet(\n  apiClient: CdpOpenApiClientType,\n  options: RequestFaucetOptions,\n): Promise<SignatureResult> {\n  const signature = await apiClient.requestSolanaFaucet(\n    { address: options.address, token: options.token },\n    options.idempotencyKey,\n  );\n\n  return {\n    signature: signature.transactionSignature,\n  };\n}\n","/**\n * This project is a fork of [nickyout/fast-stable-stringify](https://github.com/nickyout/fast-stable-stringify)\n *\n * The most popular repository providing this feature is [substack's json-stable-stringify](https://www.npmjs.com/package/json-stable-stringify). The intent of this library is to provide a faster alternative for when performance is more important than features. It assumes you provide basic javascript values without circular references, and returns a non-indented string.\n *\n * Just like substack's, it:\n *\n * - handles all variations of all basic javascript values (number, string, boolean, array, object, null, Date, BigInt)\n * - handles undefined _and_ function in the same way as `JSON.stringify`\n * - **does not support ie8 (and below) with complete certainty**.\n *\n * Unlike substack's, it:\n *\n * - does not implement the 'replacer' or 'space' arguments of the JSON.stringify method\n * - does not check for circular references\n *\n * @example\n * ```js\n * import stringify from '@solana/fast-stable-stringify';\n * stringify({ d: 0, c: 1, a: 2, b: 3, e: 4 }); // '{\"a\":2,\"b\":3,\"c\":1,\"d\":0,\"e\":4}'\n * ```\n *\n * @packageDocumentation\n */\nconst objToString = Object.prototype.toString;\nconst objKeys =\n    Object.keys ||\n    function (obj) {\n        const keys = [];\n        for (const name in obj) {\n            keys.push(name);\n        }\n        return keys;\n    };\n\nfunction stringify(val: unknown, isArrayProp: boolean) {\n    let i, max, str, keys, key, propVal, toStr;\n    if (val === true) {\n        return 'true';\n    }\n    if (val === false) {\n        return 'false';\n    }\n    switch (typeof val) {\n        case 'object':\n            if (val === null) {\n                return null;\n            } else if ('toJSON' in val && typeof val.toJSON === 'function') {\n                return stringify(val.toJSON(), isArrayProp);\n            } else {\n                toStr = objToString.call(val);\n                if (toStr === '[object Array]') {\n                    str = '[';\n                    max = (val as unknown[]).length - 1;\n                    for (i = 0; i < max; i++) {\n                        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n                        str += stringify((val as unknown[])[i], true) + ',';\n                    }\n                    if (max > -1) {\n                        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n                        str += stringify((val as unknown[])[i], true);\n                    }\n                    return str + ']';\n                } else if (toStr === '[object Object]') {\n                    // only object is left\n                    keys = objKeys(val).sort();\n                    max = keys.length;\n                    str = '';\n                    i = 0;\n                    while (i < max) {\n                        key = keys[i];\n                        propVal = stringify((val as Record<typeof key, unknown>)[key], false);\n                        if (propVal !== undefined) {\n                            if (str) {\n                                str += ',';\n                            }\n                            // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n                            str += JSON.stringify(key) + ':' + propVal;\n                        }\n                        i++;\n                    }\n                    return '{' + str + '}';\n                } else {\n                    return JSON.stringify(val);\n                }\n            }\n        case 'function':\n        case 'undefined':\n            return isArrayProp ? null : undefined;\n        case 'bigint':\n            return `${val.toString()}n`;\n        case 'string':\n            return JSON.stringify(val);\n        default:\n            return isFinite(val as number) ? val : null;\n    }\n}\n\nexport default function (\n    val:\n        | Function // eslint-disable-line @typescript-eslint/no-unsafe-function-type\n        | undefined,\n): undefined;\nexport default function (val: unknown): string;\nexport default function (val: unknown): string | undefined {\n    const returnVal = stringify(val, false);\n    if (returnVal !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n        return '' + returnVal;\n    }\n}\n","import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\n\nexport type AddChainParameters = {\n  /** The chain to add to the wallet. */\n  chain: Chain\n}\n\nexport type AddChainErrorType =\n  | RequestErrorType\n  | NumberToHexErrorType\n  | ErrorType\n\n/**\n * Adds an EVM chain to the wallet.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/addChain\n * - JSON-RPC Methods: [`eth_addEthereumChain`](https://eips.ethereum.org/EIPS/eip-3085)\n *\n * @param client - Client to use\n * @param parameters - {@link AddChainParameters}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { optimism } from 'viem/chains'\n * import { addChain } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   transport: custom(window.ethereum),\n * })\n * await addChain(client, { chain: optimism })\n */\nexport async function addChain<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(client: Client<Transport, chain, account>, { chain }: AddChainParameters) {\n  const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain\n  await client.request(\n    {\n      method: 'wallet_addEthereumChain',\n      params: [\n        {\n          chainId: numberToHex(id),\n          chainName: name,\n          nativeCurrency,\n          rpcUrls: rpcUrls.default.http,\n          blockExplorerUrls: blockExplorers\n            ? Object.values(blockExplorers).map(({ url }) => url)\n            : undefined,\n        },\n      ],\n    },\n    { dedupe: true, retryCount: 0 },\n  )\n}\n","import { generateJwt } from \"../../auth/utils/jwt.js\";\nimport { config } from \"../../openapi-client/cdpApiClient.js\";\n\n/**\n * Get the base node RPC URL for a given network. Can also be used as a Paymaster URL\n *\n * @param network - The network identifier\n * @returns The base node RPC URL or undefined if the network is not supported\n */\nexport async function getBaseNodeRpcUrl(\n  network: \"base\" | \"base-sepolia\",\n): Promise<string | undefined> {\n  if (!config) {\n    return;\n  }\n\n  try {\n    const basePath = config.basePath?.replace(\"/platform\", \"\");\n\n    const jwt = await generateJwt({\n      apiKeyId: config.apiKeyId,\n      apiKeySecret: config.apiKeySecret,\n      requestMethod: \"GET\",\n      requestHost: basePath.replace(\"https://\", \"\"),\n      requestPath: \"/apikeys/v1/tokens/active\",\n    });\n\n    const response = await fetch(`${basePath}/apikeys/v1/tokens/active`, {\n      headers: {\n        Authorization: `Bearer ${jwt}`,\n        \"Content-Type\": \"application/json\",\n      },\n    });\n\n    const json = await response.json();\n    return `${basePath}/rpc/v1/${network}/${json.id}`;\n  } catch {\n    return;\n  }\n}\n","import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { WalletPermission } from '../../types/eip1193.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type GetPermissionsReturnType = WalletPermission[]\n\nexport type GetPermissionsErrorType = RequestErrorType | ErrorType\n\n/**\n * Gets the wallets current permissions.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/getPermissions\n * - JSON-RPC Methods: [`wallet_getPermissions`](https://eips.ethereum.org/EIPS/eip-2255)\n *\n * @param client - Client to use\n * @returns The wallet permissions. {@link GetPermissionsReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getPermissions } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const permissions = await getPermissions(client)\n */\nexport async function getPermissions<\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n>(client: Client<Transport, chain, account>) {\n  const permissions = await client.request(\n    { method: 'wallet_getPermissions' },\n    { dedupe: true },\n  )\n  return permissions\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, SolanaError } from '@solana/errors';\nimport { Transaction } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link TransactionModifyingSigner#modifyAndSignTransactions | modifyAndSignTransactions} method.\n *\n * @see {@link BaseTransactionSignerConfig}\n */\nexport type TransactionModifyingSignerConfig = BaseTransactionSignerConfig;\n\n/**\n * A signer interface that potentially modifies the provided {@link Transaction | Transactions}\n * before signing them.\n *\n * For instance, this enables wallets to inject additional instructions into the\n * transaction before signing them. For each transaction, instead of returning a\n * {@link SignatureDictionary}, its\n * {@link TransactionModifyingSigner#modifyAndSignTransactions | modifyAndSignTransactions} function\n * returns an updated {@link Transaction} with a potentially modified set of instructions and\n * signature dictionary.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: TransactionModifyingSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     modifyAndSignTransactions: async <T extends Transaction>(\n *         transactions: T[]\n *     ): Promise<T[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Sequential**. Contrary to partial signers, these cannot be executed in\n *   parallel as each call can modify the provided transactions.\n * - **First signers**. For a given transaction, a modifying signer must always\n *   be used before a partial signer as the former will likely modify the\n *   transaction and thus impact the outcome of the latter.\n * - **Potential conflicts**. If more than one modifying signer is provided,\n *   the second signer may invalidate the signature of the first one. However,\n *   modifying signers may decide not to modify a transaction based on the\n *   existence of signatures for that transaction.\n *\n * @see {@link isTransactionModifyingSigner}\n * @see {@link assertIsTransactionModifyingSigner}\n */\nexport type TransactionModifyingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    modifyAndSignTransactions<T extends Transaction>(\n        transactions: readonly T[],\n        config?: TransactionModifyingSignerConfig,\n    ): Promise<readonly T[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionModifyingSigner({ address, modifyAndSignTransactions: async () => {} }); // true\n * isTransactionModifyingSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionModifyingSigner}\n */\nexport function isTransactionModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionModifyingSigner<TAddress> {\n    return 'modifyAndSignTransactions' in value && typeof value.modifyAndSignTransactions === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionModifyingSigner({ address, modifyAndSignTransactions: async () => {} }); // void\n * assertIsTransactionModifyingSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionModifyingSigner}\n */\nexport function assertIsTransactionModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionModifyingSigner<TAddress> {\n    if (!isTransactionModifyingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","/**\n * Generated by orval v7.6.0 \n * Do not edit manually.\n * Coinbase Developer Platform APIs\n * The Coinbase Developer Platform APIs - leading the world's transition onchain.\n * OpenAPI spec version: 2.0.0\n */\n/**\n * The type of authentication information.\n */\nexport type EmailAuthenticationType =\n  (typeof EmailAuthenticationType)[keyof typeof EmailAuthenticationType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const EmailAuthenticationType = {\n  email: \"email\",\n} as const;\n\n/**\n * Information about an end user who authenticates using a one-time password sent to their email address.\n */\nexport interface EmailAuthentication {\n  /** The type of authentication information. */\n  type: EmailAuthenticationType;\n  /** The email address of the end user. */\n  email: string;\n}\n\n/**\n * The type of authentication information.\n */\nexport type SmsAuthenticationType =\n  (typeof SmsAuthenticationType)[keyof typeof SmsAuthenticationType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SmsAuthenticationType = {\n  sms: \"sms\",\n} as const;\n\n/**\n * Information about an end user who authenticates using a one-time password sent to their phone number via SMS.\n */\nexport interface SmsAuthentication {\n  /** The type of authentication information. */\n  type: SmsAuthenticationType;\n  /**\n   * The phone number of the end user in E.164 format.\n   * @pattern ^\\+[1-9]\\d{1,14}$\n   */\n  phoneNumber: string;\n}\n\n/**\n * The type of authentication information.\n */\nexport type DeveloperJWTAuthenticationType =\n  (typeof DeveloperJWTAuthenticationType)[keyof typeof DeveloperJWTAuthenticationType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const DeveloperJWTAuthenticationType = {\n  jwt: \"jwt\",\n} as const;\n\n/**\n * Information about an end user who authenticates using a JWT issued by the developer.\n */\nexport interface DeveloperJWTAuthentication {\n  /** The type of authentication information. */\n  type: DeveloperJWTAuthenticationType;\n  /** The key ID of the JWK used to sign the JWT. */\n  kid: string;\n  /** The unique identifier for the end user that is captured in the `sub` claim of the JWT. */\n  sub: string;\n}\n\n/**\n * Information about how the end user is authenticated.\n */\nexport type AuthenticationMethod =\n  | EmailAuthentication\n  | SmsAuthentication\n  | DeveloperJWTAuthentication;\n\n/**\n * The list of valid authentication methods linked to the end user.\n */\nexport type AuthenticationMethods = AuthenticationMethod[];\n\n/**\n * Information about the end user.\n */\nexport interface EndUser {\n  /**\n   * A stable, unique identifier for the end user. The `userId` must be unique across all end users in the developer's CDP Project. It must be between 1 and 100 characters long and can only contain alphanumeric characters and hyphens.\n   * @pattern ^[a-zA-Z0-9-]{1,100}$\n   */\n  userId: string;\n  authenticationMethods: AuthenticationMethods;\n  /** The list of EVM accounts associated with the end user. Currently, only one EVM account is supported per end user. */\n  evmAccounts: string[];\n  /** The list of EVM smart accounts associated with the end user. Currently, only one EVM smart account is supported per end user. */\n  evmSmartAccounts: string[];\n  /** The list of Solana accounts associated with the end user. Currently, only one Solana account is supported per end user. */\n  solanaAccounts: string[];\n}\n\nexport interface ListResponse {\n  /** The token for the next page of items, if any. */\n  nextPageToken?: string;\n}\n\n/**\n * The code that indicates the type of error that occurred. These error codes can be used to determine how to handle the error.\n */\nexport type ErrorType = (typeof ErrorType)[keyof typeof ErrorType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const ErrorType = {\n  already_exists: \"already_exists\",\n  bad_gateway: \"bad_gateway\",\n  faucet_limit_exceeded: \"faucet_limit_exceeded\",\n  forbidden: \"forbidden\",\n  idempotency_error: \"idempotency_error\",\n  internal_server_error: \"internal_server_error\",\n  invalid_request: \"invalid_request\",\n  invalid_sql_query: \"invalid_sql_query\",\n  invalid_signature: \"invalid_signature\",\n  malformed_transaction: \"malformed_transaction\",\n  not_found: \"not_found\",\n  payment_method_required: \"payment_method_required\",\n  rate_limit_exceeded: \"rate_limit_exceeded\",\n  request_canceled: \"request_canceled\",\n  service_unavailable: \"service_unavailable\",\n  timed_out: \"timed_out\",\n  unauthorized: \"unauthorized\",\n  policy_violation: \"policy_violation\",\n  policy_in_use: \"policy_in_use\",\n  account_limit_exceeded: \"account_limit_exceeded\",\n  network_not_tradable: \"network_not_tradable\",\n  guest_permission_denied: \"guest_permission_denied\",\n  guest_region_forbidden: \"guest_region_forbidden\",\n  guest_transaction_limit: \"guest_transaction_limit\",\n  guest_transaction_count: \"guest_transaction_count\",\n  phone_number_verification_expired: \"phone_number_verification_expired\",\n  document_verification_failed: \"document_verification_failed\",\n  recipient_allowlist_violation: \"recipient_allowlist_violation\",\n  recipient_allowlist_pending: \"recipient_allowlist_pending\",\n  travel_rules_recipient_violation: \"travel_rules_recipient_violation\",\n} as const;\n\n/**\n * An error response including the code for the type of error and a human-readable message describing the error.\n */\nexport interface Error {\n  errorType: ErrorType;\n  /** The error message. */\n  errorMessage: string;\n  /** A unique identifier for the request that generated the error. This can be used to help debug issues with the API. */\n  correlationId?: string;\n  /** A link to the corresponding error documentation. */\n  errorLink?: string;\n}\n\nexport interface EvmAccount {\n  /**\n   * The 0x-prefixed, checksum EVM address.\n   * @pattern ^0x[0-9a-fA-F]{40}$\n   */\n  address: string;\n  /**\n   * An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names are guaranteed to be unique across all EVM accounts in the developer's CDP Project.\n   * @pattern ^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\n   */\n  name?: string;\n  /** The list of policy IDs that apply to the account. This will include both the project-level policy and the account-level policy, if one exists. */\n  policies?: string[];\n  /** The UTC ISO 8601 timestamp at which the account was created. */\n  createdAt?: string;\n  /** The UTC ISO 8601 timestamp at which the account was last updated. */\n  updatedAt?: string;\n}\n\n/**\n * The domain of the EIP-712 typed data.\n */\nexport interface EIP712Domain {\n  /** The name of the DApp or protocol. */\n  name?: string;\n  /** The version of the DApp or protocol. */\n  version?: string;\n  /** The chain ID of the EVM network. */\n  chainId?: number;\n  /**\n   * The 0x-prefixed EVM address of the verifying smart contract.\n   * @pattern ^0x[a-fA-F0-9]{40}$\n   */\n  verifyingContract?: string;\n  /**\n   * The optional 32-byte 0x-prefixed hex salt for domain separation.\n   * @pattern ^0x[a-fA-F0-9]{64}$\n   */\n  salt?: string;\n}\n\n/**\n * A mapping of struct names to an array of type objects (name + type).\nEach key corresponds to a type name (e.g., \"`EIP712Domain`\", \"`PermitTransferFrom`\").\n\n */\nexport interface EIP712Types {\n  [key: string]: unknown;\n}\n\n/**\n * The message to sign. The structure of this message must match the `primaryType` struct in the `types` object.\n */\nexport type EIP712MessageMessage = { [key: string]: unknown };\n\n/**\n * The message to sign using EIP-712.\n */\nexport interface EIP712Message {\n  domain: EIP712Domain;\n  types: EIP712Types;\n  /** The primary type of the message. This is the name of the struct in the `types` object that is the root of the message. */\n  primaryType: string;\n  /** The message to sign. The structure of this message must match the `primaryType` struct in the `types` object. */\n  message: EIP712MessageMessage;\n}\n\nexport interface EvmSmartAccount {\n  /**\n   * The 0x-prefixed, checksum address of the Smart Account.\n   * @pattern ^0x[0-9a-fA-F]{40}$\n   */\n  address: string;\n  /** Today, only a single owner can be set for a Smart Account, but this is an array to allow having multiple owners in the future. The address is a 0x-prefixed, checksum address. */\n  owners: string[];\n  /**\n   * An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names are guaranteed to be unique across all Smart Accounts in the developer's CDP Project.\n   * @pattern ^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\n   */\n  name?: string;\n  /** The list of policy IDs that apply to the smart account. This will include both the project-level policy and the account-level policy, if one exists. */\n  policies?: string[];\n  /** The UTC ISO 8601 timestamp at which the account was created. */\n  createdAt?: string;\n  /** The UTC ISO 8601 timestamp at which the account was last updated. */\n  updatedAt?: string;\n}\n\n/**\n * The network the user operation is for.\n */\nexport type EvmUserOperationNetwork =\n  (typeof EvmUserOperationNetwork)[keyof typeof EvmUserOperationNetwork];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const EvmUserOperationNetwork = {\n  \"base-sepolia\": \"base-sepolia\",\n  base: \"base\",\n  arbitrum: \"arbitrum\",\n  optimism: \"optimism\",\n  zora: \"zora\",\n  polygon: \"polygon\",\n  bnb: \"bnb\",\n  avalanche: \"avalanche\",\n  ethereum: \"ethereum\",\n  \"ethereum-sepolia\": \"ethereum-sepolia\",\n} as const;\n\nexport interface EvmCall {\n  /**\n   * The address the call is directed to.\n   * @pattern ^0x[0-9a-fA-F]{40}$\n   */\n  to: string;\n  /** The amount of ETH to send with the call, in wei. */\n  value: string;\n  /**\n   * The call data to send. This is the hex-encoded data of the function call consisting of the method selector and the function arguments.\n   * @pattern ^0x[0-9a-fA-F]*$\n   */\n  data: string;\n  /** The override gas limit to use for the call instead of the bundler's estimated gas limit. */\n  overrideGasLimit?: string;\n}\n\n/**\n * The revert data if the user operation has reverted.\n */\nexport interface UserOperationReceiptRevert {\n  /**\n   * The 0x-prefixed raw hex string.\n   * @pattern ^0x[0-9a-fA-F]*$\n   */\n  data: string;\n  /** Human-readable revert reason if able to decode. */\n  message: string;\n}\n\n/**\n * The receipt that contains information about the execution of user operation.\n */\nexport interface UserOperationReceipt {\n  revert?: UserOperationReceiptRevert;\n  /**\n   * The hash of this transaction as 0x-prefixed string.\n   * @pattern ^0x[a-fA-F0-9]{64}$\n   */\n  transactionHash?: string;\n  /**\n   * The block hash of the block including the transaction as 0x-prefixed string.\n   * @pattern ^0x[0-9a-fA-F]{64}$|^$\n   */\n  blockHash?: string;\n  /** The block height (number) of the block including the transaction. */\n  blockNumber?: number;\n  /** The gas used for landing this user operation. */\n  gasUsed?: string;\n}\n\n/**\n * The status of the user operation.\n */\nexport type EvmUserOperationStatus =\n  (typeof EvmUserOperationStatus)[keyof typeof EvmUserOperationStatus];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const EvmUserOperationStatus = {\n  pending: \"pending\",\n  signed: \"signed\",\n  broadcast: \"broadcast\",\n  complete: \"complete\",\n  dropped: \"dropped\",\n  failed: \"failed\",\n} as const;\n\nexport interface EvmUserOperation {\n  network: EvmUserOperationNetwork;\n  /**\n   * The hash of the user operation. This is not the transaction hash, as a transaction consists of multiple user operations. The user operation hash is the hash of this particular user operation which gets signed by the owner of the Smart Account.\n   * @pattern ^0x[0-9a-fA-F]{64}$\n   */\n  userOpHash: string;\n  /** The list of calls in the user operation. */\n  calls: EvmCall[];\n  /** The status of the user operation. */\n  status: EvmUserOperationStatus;\n  /**\n   * The hash of the transaction that included this particular user operation. This gets set after the user operation is broadcasted and the transaction is included in a block.\n   * @pattern ^0x[0-9a-fA-F]{64}$|^$\n   */\n  transactionHash?: string;\n  /** The list of receipts associated with the user operation. */\n  receipts?: UserOperationReceipt[];\n}\n\n/**\n * The network the spend permission is on.\n */\nexport type SpendPermissionNetwork =\n  (typeof SpendPermissionNetwork)[keyof typeof SpendPermissionNetwork];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SpendPermissionNetwork = {\n  base: \"base\",\n  \"base-sepolia\": \"base-sepolia\",\n  ethereum: \"ethereum\",\n  \"ethereum-sepolia\": \"ethereum-sepolia\",\n  optimism: \"optimism\",\n  arbitrum: \"arbitrum\",\n  avalanche: \"avalanche\",\n  polygon: \"polygon\",\n} as const;\n\n/**\n * Request parameters for creating a Spend Permission.\n */\nexport interface CreateSpendPermissionRequest {\n  network: SpendPermissionNetwork;\n  /**\n   * Entity that can spend account's tokens. Can be either a Smart Account or an EOA.\n   * @pattern ^0x[a-fA-F0-9]{40}$\n   */\n  spender: string;\n  /**\n   * ERC-7528 native token address (e.g. \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\" for native ETH), or an  ERC-20 contract address.\n   * @pattern ^0x[a-fA-F0-9]{40}$\n   */\n  token: string;\n  /** Maximum allowed value to spend, in atomic units for the specified token, within each period. */\n  allowance: string;\n  /** Time duration for resetting used allowance on a recurring basis (seconds). */\n  period: string;\n  /** The start time for this spend permission, in Unix seconds. */\n  start: string;\n  /** The expiration time for this spend permission, in Unix seconds. */\n  end: string;\n  /** An arbitrary salt to differentiate unique spend permissions with otherwise identical data. */\n  salt?: string;\n  /** Arbitrary data to include in the permission. */\n  extraData?: string;\n  /** The paymaster URL of the spend permission. */\n  paymasterUrl?: string;\n}\n\n/**\n * The core spend permission.\n */\nexport interface SpendPermission {\n  /**\n   * Smart account this spend permission is valid for.\n   * @pattern ^0x[a-fA-F0-9]{40}$\n   */\n  account: string;\n  /**\n   * Entity that can spend account's tokens.\n   * @pattern ^0x[a-fA-F0-9]{40}$\n   */\n  spender: string;\n  /**\n   * Token address (ERC-7528 native token address or ERC-20 contract).\n   * @pattern ^0x[a-fA-F0-9]{40}$\n   */\n  token: string;\n  /** Maximum allowed value to spend, in atomic units for the specified token, within each period. */\n  allowance: string;\n  /** Time duration for resetting used allowance on a recurring basis (seconds). */\n  period: string;\n  /** The start time for this spend permission, in Unix seconds. */\n  start: string;\n  /** The expiration time for this spend permission, in Unix seconds. */\n  end: string;\n  /** An arbitrary salt to differentiate unique spend permissions with otherwise identical data. */\n  salt: string;\n  /** Arbitrary data to include in the permission. */\n  extraData: string;\n}\n\nexport interface SpendPermissionResponseObject {\n  permission: SpendPermission;\n  /** Unique hash identifier for this permission. */\n  permissionHash: string;\n  /** Whether this permission has been revoked. */\n  revoked: boolean;\n  /** The UTC ISO 8601 timestamp when the permission was revoked (if applicable). */\n  revokedAt?: string;\n  /** The UTC ISO 8601 timestamp when the permission was created. */\n  createdAt: string;\n  network: SpendPermissionNetwork;\n}\n\n/**\n * Request parameters for revoking a Spend Permission.\n */\nexport interface RevokeSpendPermissionRequest {\n  network: SpendPermissionNetwork;\n  /** The hash of the spend permission to revoke. */\n  permissionHash: string;\n  /** The paymaster URL of the spend permission. */\n  paymasterUrl?: string;\n}\n\n/**\n * The network on which to perform the swap.\n */\nexport type EvmSwapsNetwork = (typeof EvmSwapsNetwork)[keyof typeof EvmSwapsNetwork];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const EvmSwapsNetwork = {\n  base: \"base\",\n  ethereum: \"ethereum\",\n  arbitrum: \"arbitrum\",\n  optimism: \"optimism\",\n} as const;\n\n/**\n * The 0x-prefixed contract address of the token to receive.\n * @pattern ^0x[a-fA-F0-9]{40}$\n */\nexport type ToToken = string;\n\n/**\n * The 0x-prefixed contract address of the token to send.\n * @pattern ^0x[a-fA-F0-9]{40}$\n */\nexport type FromToken = string;\n\n/**\n * The amount of the `fromToken` to send in atomic units of the token. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.\n * @pattern ^\\d+$\n */\nexport type FromAmount = string;\n\n/**\n * The 0x-prefixed address that holds the `fromToken` balance and has the `Permit2` allowance set for the swap.\n * @pattern ^0x[a-fA-F0-9]{40}$\n */\nexport type Taker = string;\n\n/**\n * The 0x-prefixed Externally Owned Account (EOA) address that will sign the `Permit2` EIP-712 permit message. This is only needed if `taker` is a smart contract.\n * @pattern ^0x[a-fA-F0-9]{40}$\n */\nexport type SignerAddress = string;\n\n/**\n * The target gas price for the swap transaction, in Wei. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. If not provided, the API will use an estimate based on the current network conditions.\n * @pattern ^\\d+$\n */\nexport type GasPrice = string;\n\n/**\n * The maximum acceptable slippage of the `toToken` in basis points. If this parameter is set to 0, no slippage will be tolerated. If not provided, the default slippage tolerance is 100 bps (i.e., 1%).\n * @minimum 0\n * @maximum 10000\n */\nexport type SlippageBps = number;\n\nexport interface TokenFee {\n  /**\n   * The estimated amount of the fee in atomic units of the `token`. For example, `1000000000000000` if the fee is in ETH equates to 0.001 ETH, `10000` if the fee is in USDC equates to 0.01 USDC, etc.\n   * @pattern ^\\d+$\n   */\n  amount: string;\n  /**\n   * The contract address of the token that the fee is paid in. The address `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` is used for the native token of the network (e.g. ETH).\n   * @pattern ^0x[a-fA-F0-9]{40}$\n   */\n  token: string;\n}\n\n/**\n * The estimated gas fee for the swap.\n * @nullable\n */\nexport type CommonSwapResponseFeesGasFee = TokenFee | null;\n\n/**\n * The estimated protocol fee for the swap.\n * @nullable\n */\nexport type CommonSwapResponseFeesProtocolFee = TokenFee | null;\n\n/**\n * The estimated fees for the swap.\n */\nexport type CommonSwapResponseFees = {\n  /**\n   * The estimated gas fee for the swap.\n   * @nullable\n   */\n  gasFee: CommonSwapResponseFeesGasFee;\n  /**\n   * The estimated protocol fee for the swap.\n   * @nullable\n   */\n  protocolFee: CommonSwapResponseFeesProtocolFee;\n};\n\n/**\n * Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.\n * @nullable\n */\nexport type CommonSwapResponseIssuesAllowance = {\n  /**\n   * The current allowance of the `fromToken` by the `taker`.\n   * @pattern ^\\d+$\n   */\n  currentAllowance: string;\n  /**\n   * The 0x-prefixed address of to set the allowance on.\n   * @pattern ^0x[a-fA-F0-9]{40}$\n   */\n  spender: string;\n} | null;\n\n/**\n * Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.\n * @nullable\n */\nexport type CommonSwapResponseIssuesBalance = {\n  /**\n   * The 0x-prefixed contract address of the token.\n   * @pattern ^0x[a-fA-F0-9]{40}$\n   */\n  token: string;\n  /**\n   * The current balance of the `fromToken` by the `taker`.\n   * @pattern ^\\d+$\n   */\n  currentBalance: string;\n  /**\n   * The amount of the token that the `taker` must hold.\n   * @pattern ^\\d+$\n   */\n  requiredBalance: string;\n} | null;\n\n/**\n * An object containing potential issues discovered during validation that could prevent the swap from being executed successfully.\n */\nexport type CommonSwapResponseIssues = {\n  /**\n   * Details of the allowances that the taker must set in order to execute the swap successfully. Null if no allowance is required.\n   * @nullable\n   */\n  allowance: CommonSwapResponseIssuesAllowance;\n  /**\n   * Details of the balance of the `fromToken` that the `taker` must hold. Null if the `taker` has a sufficient balance.\n   * @nullable\n   */\n  balance: CommonSwapResponseIssuesBalance;\n  /** This is set to true when the transaction cannot be validated. This can happen when the taker has an insufficient balance of the `fromToken`. Note that this does not necessarily mean that the trade will revert. */\n  simulationIncomplete: boolean;\n};\n\nexport interface CommonSwapResponse {\n  /**\n   * The block number at which the liquidity conditions were examined.\n   * @pattern ^[1-9]\\d*$\n   */\n  blockNumber: string;\n  /**\n   * The amount of the `toToken` that will be received in atomic units of the `toToken`. For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc.\n   * @pattern ^(0|[1-9]\\d*)$\n   */\n  toAmount: string;\n  /**\n   * The 0x-prefixed contract address of the token that will be received.\n   * @pattern ^0x[a-fA-F0-9]{40}$\n   */\n  toToken: string;\n  /** The estimated fees for the swap. */\n  fees: CommonSwapResponseFees;\n  /** An object containing potential issues discovered during validation that could prevent the swap from being executed successfully. */\n  issues: CommonSwapResponseIssues;\n  /** Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false. */\n  liquidityAvailable: boolean;\n  /**\n   * The minimum amount of the `toToken` that must be received for the swap to succeed, in atomic units of the `toToken`.  For example, `1000000000000000000` when receiving ETH equates to 1 ETH, `1000000` when receiving USDC equates to 1 USDC, etc. This value is influenced by the `slippageBps` parameter.\n   * @pattern ^(0|[1-9]\\d*)$\n   */\n  minToAmount: string;\n  /**\n   * The amount of the `fromToken` that will be sent in this swap, in atomic units of the `fromToken`. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.\n   * @pattern ^(0|[1-9]\\d*)$\n   */\n  fromAmount: string;\n  /**\n   * The 0x-prefixed contract address of the token that will be sent.\n   * @pattern ^0x[a-fA-F0-9]{40}$\n   */\n  fromToken: string;\n}\n\nexport type GetSwapPriceResponseAllOf = {\n  /**\n   * The estimated gas limit that should be used to send the transaction to guarantee settlement.\n   * @nullable\n   * @pattern ^\\d+$\n   */\n  gas: string | null;\n  /**\n   * The gas price, in Wei, that should be used to send the transaction. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. The transaction should be sent with this gas price to guarantee settlement.\n   * @pattern ^\\d+$\n   */\n  gasPrice: string;\n};\n\nexport type GetSwapPriceResponse = CommonSwapResponse & GetSwapPriceResponseAllOf;\n\nexport interface SwapUnavailableResponse {\n  /** Whether sufficient liquidity is available to settle the swap. All other fields in the response will be empty if this is false. */\n  liquidityAvailable: boolean;\n}\n\n/**\n * A wrapper for the response of a swap price operation.\n */\nexport type GetSwapPriceResponseWrapper = GetSwapPriceResponse | SwapUnavailableResponse;\n\n/**\n * The approval object which contains the necessary fields to submit an approval for this transaction. Null if the `fromToken` is the native token or the transaction is a native token wrap / unwrap.\n * @nullable\n */\nexport type CreateSwapQuoteResponseAllOfPermit2 = {\n  /**\n   * The hash for the approval according to [EIP-712](https://eips.ethereum.org/EIPS/eip-712). Computing the hash of the `eip712` field should match the value of this field.\n   * @pattern ^0x[a-fA-F0-9]{64}$\n   */\n  hash: string;\n  eip712: EIP712Message;\n} | null;\n\n/**\n * The details of the transaction to be signed and submitted to execute the swap.\n */\nexport type CreateSwapQuoteResponseAllOfTransaction = {\n  /**\n   * The 0x-prefixed address of the contract to call.\n   * @pattern ^0x[a-fA-F0-9]{40}$\n   */\n  to: string;\n  /** The hex-encoded call data to send to the contract. */\n  data: string;\n  /**\n   * The estimated gas limit that should be used to send the transaction to guarantee settlement.\n   * @pattern ^\\d+$\n   */\n  gas: string;\n  /**\n   * The gas price, in Wei, that should be used to send the transaction. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. The transaction should be sent with this gas price to guarantee settlement.\n   * @pattern ^\\d+$\n   */\n  gasPrice: string;\n  /**\n   * The value of the transaction in Wei.\n   * @pattern ^\\d+$\n   */\n  value: string;\n};\n\nexport type CreateSwapQuoteResponseAllOf = {\n  /**\n   * The approval object which contains the necessary fields to submit an approval for this transaction. Null if the `fromToken` is the native token or the transaction is a native token wrap / unwrap.\n   * @nullable\n   */\n  permit2: CreateSwapQuoteResponseAllOfPermit2;\n  /** The details of the transaction to be signed and submitted to execute the swap. */\n  transaction: CreateSwapQuoteResponseAllOfTransaction;\n};\n\nexport type CreateSwapQuoteResponse = CreateSwapQuoteResponseAllOf & CommonSwapResponse;\n\n/**\n * A wrapper for the response of a swap quote operation.\n */\nexport type CreateSwapQuoteResponseWrapper = CreateSwapQuoteResponse | SwapUnavailableResponse;\n\n/**\n * The name of the supported EVM networks in human-readable format.\n */\nexport type ListEvmTokenBalancesNetwork =\n  (typeof ListEvmTokenBalancesNetwork)[keyof typeof ListEvmTokenBalancesNetwork];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const ListEvmTokenBalancesNetwork = {\n  base: \"base\",\n  \"base-sepolia\": \"base-sepolia\",\n  ethereum: \"ethereum\",\n} as const;\n\n/**\n * Amount of a given token.\n */\nexport interface TokenAmount {\n  /**\n   * The amount is denominated in the smallest indivisible unit of the token. For ETH, the smallest indivisible unit is Wei (10^-18 ETH). For ERC-20s, the smallest unit is the unit returned from `function totalSupply() public view returns (uint256)`.\n   * @pattern ^[0-9]+$\n   */\n  amount: string;\n  /** 'decimals' is the exponential value N that satisfies the equation `amount * 10^-N = standard_denomination`. The standard denomination is the most commonly used denomination for the token.\n- In the case of the native gas token, `decimals` is defined via convention. As an example, for ETH of Ethereum mainnet, the standard denomination is 10^-18 the smallest denomination (Wei). As such, for ETH on Ethereum mainnet, `decimals` is 18. - In the case of ERC-20 tokens, `decimals` is defined via configuration. `decimals` will be the number returned by `function decimals() public view returns (uint8)` on the underlying token contract.\nNot all tokens have a `decimals` field, as this function is [optional in the ERC-20 specification](https://eips.ethereum.org/EIPS/eip-20#decimals). This field will be left empty if the underlying token contract doesn't implement `decimals`.\nFurther, this endpoint will only populate this value for a small subset of whitelisted ERC-20 tokens at this time. We intend to improve coverage in the future. */\n  decimals: number;\n}\n\n/**\n * General information about a token. Includes the type, the network, and other identifying information.\n */\nexport interface Token {\n  network: ListEvmTokenBalancesNetwork;\n  /** The symbol of this token (ex: SOL, ETH, USDC).\nThe token symbol is not unique. It is possible for two different tokens to have the same symbol.\nFor native gas tokens, this symbol is defined via convention. As an example, for ETH on Ethereum mainnet, the symbol is \"ETH\". For ERC-20 tokens, this symbol is defined via configuration. `symbol` will be the string returned by `function symbol() public view returns (string)` on the underlying token contract.\nNot all tokens have a symbol, as this function is [optional in the ERC-20 specification](https://eips.ethereum.org/EIPS/eip-20#symbol). This field will only be populated when the token's underlying ERC-20 contract has a `symbol()` function.\nFurther, this endpoint will only populate this value for a small subset of whitelisted ERC-20 tokens at this time. We intend to improve coverage in the future. */\n  symbol?: string;\n  /** The name of this token (ex: \"Solana\", \"Ether\", \"USD Coin\").\nThe token name is not unique. It is possible for two different tokens to have the same name.\nFor native gas tokens, this name is defined via convention. As an example, for ETH on Ethereum mainnet, the name is \"Ether\". For ERC-20 tokens, this name is defined via configuration. `name` will be the string returned by `function name() public view returns (string)` on the underlying token contract.\nNot all tokens have a name, as this function is [optional in the ERC-20 specification](https://eips.ethereum.org/EIPS/eip-20#name). This field will only be populated when the token's underlying ERC-20 contract has a `name()` function.\nFurther, this endpoint will only populate this value for a small subset of whitelisted ERC-20 tokens at this time. We intend to improve coverage in the future. */\n  name?: string;\n  /**\n   * The contract address of the token.\nFor Ether, the contract address is `0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` per [EIP-7528](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7528.md). For ERC-20 tokens, this is the contract address where the token is deployed.\n   * @pattern ^0x[0-9a-fA-F]{40}$\n   */\n  contractAddress: string;\n}\n\nexport interface TokenBalance {\n  amount: TokenAmount;\n  token: Token;\n}\n\n/**\n * The type of criterion to use. This should be `ethValue`.\n */\nexport type EthValueCriterionType =\n  (typeof EthValueCriterionType)[keyof typeof EthValueCriterionType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const EthValueCriterionType = {\n  ethValue: \"ethValue\",\n} as const;\n\n/**\n * The operator to use for the comparison. The transaction's `value` field will be on the left-hand side of the operator, and the `ethValue` field will be on the right-hand side.\n */\nexport type EthValueCriterionOperator =\n  (typeof EthValueCriterionOperator)[keyof typeof EthValueCriterionOperator];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const EthValueCriterionOperator = {\n  \">\": \">\",\n  \">=\": \">=\",\n  \"<\": \"<\",\n  \"<=\": \"<=\",\n  \"==\": \"==\",\n} as const;\n\n/**\n * A schema for specifying a criterion for the `value` field of an EVM transaction.\n */\nexport interface EthValueCriterion {\n  /** The type of criterion to use. This should be `ethValue`. */\n  type: EthValueCriterionType;\n  /**\n   * The amount of ETH, in wei, that the transaction's `value` field should be compared to.\n   * @pattern ^[0-9]+$\n   */\n  ethValue: string;\n  /** The operator to use for the comparison. The transaction's `value` field will be on the left-hand side of the operator, and the `ethValue` field will be on the right-hand side. */\n  operator: EthValueCriterionOperator;\n}\n\n/**\n * The type of criterion to use. This should be `evmAddress`.\n */\nexport type EvmAddressCriterionType =\n  (typeof EvmAddressCriterionType)[keyof typeof EvmAddressCriterionType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const EvmAddressCriterionType = {\n  evmAddress: \"evmAddress\",\n} as const;\n\n/**\n * The operator to use for the comparison. The transaction's `to` field will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.\n */\nexport type EvmAddressCriterionOperator =\n  (typeof EvmAddressCriterionOperator)[keyof typeof EvmAddressCriterionOperator];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const EvmAddressCriterionOperator = {\n  in: \"in\",\n  not_in: \"not in\",\n} as const;\n\n/**\n * A schema for specifying a criterion for the `to` field of an EVM transaction.\n */\nexport interface EvmAddressCriterion {\n  /** The type of criterion to use. This should be `evmAddress`. */\n  type: EvmAddressCriterionType;\n  /** A list of 0x-prefixed EVM addresses that the transaction's `to` field should be compared to. There is a limit of 300 addresses per criterion. */\n  addresses: string[];\n  /** The operator to use for the comparison. The transaction's `to` field will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side. */\n  operator: EvmAddressCriterionOperator;\n}\n\n/**\n * A reference to an established EIP standard. When referencing a `KnownAbiType` within a policy rule configuring an `EvmDataCriterion`, criteria will only decode function data officially documented in the standard. For more information on supported token standards, see the links below.\n  - [erc20 - Token Standard](https://eips.ethereum.org/EIPS/eip-20).\n  - [erc721 - Non-Fungible Token Standard](https://eips.ethereum.org/EIPS/eip-721).\n  - [erc1155 - Multi Token Standard](https://eips.ethereum.org/EIPS/eip-1155).\n */\nexport type KnownAbiType = (typeof KnownAbiType)[keyof typeof KnownAbiType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const KnownAbiType = {\n  erc20: \"erc20\",\n  erc721: \"erc721\",\n  erc1155: \"erc1155\",\n} as const;\n\n/**\n * Parameter definition for ABI functions, errors, and constructors.\n */\nexport interface AbiParameter {\n  /** The name of the parameter. */\n  name?: string;\n  /** The canonical type of the parameter. */\n  type: string;\n  /** The internal Solidity type used by the compiler. */\n  internalType?: string;\n  /** Used for tuple types. */\n  components?: AbiParameter[];\n}\n\n/**\n * State mutability of a function in Solidity.\n */\nexport type AbiStateMutability = (typeof AbiStateMutability)[keyof typeof AbiStateMutability];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const AbiStateMutability = {\n  pure: \"pure\",\n  view: \"view\",\n  nonpayable: \"nonpayable\",\n  payable: \"payable\",\n} as const;\n\n/**\n * The type of the ABI item, must be `function`.\n */\nexport type AbiFunctionType = (typeof AbiFunctionType)[keyof typeof AbiFunctionType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const AbiFunctionType = {\n  function: \"function\",\n} as const;\n\n/**\n * ABI function type for contract functions.\n */\nexport interface AbiFunction {\n  /** The type of the ABI item, must be `function`. */\n  type: AbiFunctionType;\n  /** The name of the ABI function. */\n  name: string;\n  /** The list of ABI parameters used for this function. */\n  inputs: AbiParameter[];\n  /** The values returned by this function. */\n  outputs: AbiParameter[];\n  /** Deprecated. Use pure or view from stateMutability instead. */\n  constant?: boolean;\n  /** Deprecated. Use payable or nonpayable from `stateMutability` instead. */\n  payable?: boolean;\n  stateMutability: AbiStateMutability;\n  /** Deprecated. Vyper used to provide gas estimates. */\n  gas?: number;\n}\n\n/**\n * The type of the ABI item.\n */\nexport type AbiInputType = (typeof AbiInputType)[keyof typeof AbiInputType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const AbiInputType = {\n  constructor: \"constructor\",\n  error: \"error\",\n  event: \"event\",\n  fallback: \"fallback\",\n  receive: \"receive\",\n} as const;\n\n/**\n * Generic ABI item type encapsulating all other types besides `function`.\n */\nexport interface AbiInput {\n  /** The type of the ABI item. */\n  type: AbiInputType;\n  /** For additional information on the ABI JSON specification, see [the Solidity documentation](https://docs.soliditylang.org/en/latest/abi-spec.html#json). */\n  additionalProperties?: unknown;\n}\n\nexport type AbiItem = AbiFunction | AbiInput;\n\n/**\n * Contract ABI Specification following Solidity's external JSON interface format.\n */\nexport type Abi = AbiItem[];\n\n/**\n * The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.\n */\nexport type EvmDataParameterConditionOperator =\n  (typeof EvmDataParameterConditionOperator)[keyof typeof EvmDataParameterConditionOperator];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const EvmDataParameterConditionOperator = {\n  \">\": \">\",\n  \">=\": \">=\",\n  \"<\": \"<\",\n  \"<=\": \"<=\",\n  \"==\": \"==\",\n} as const;\n\nexport interface EvmDataParameterCondition {\n  /** The name of the parameter to check against a transaction's calldata. If name is unknown, or is not named, you may supply an array index, e.g., `0` for first parameter. */\n  name: string;\n  /** The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side. */\n  operator: EvmDataParameterConditionOperator;\n  /** A single value to compare the value resolved at `name` to. All values are encoded as strings. Refer to the table in the documentation for how values should be encoded, and which operators are supported for each type. */\n  value: string;\n}\n\n/**\n * The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `values` field will be on the right-hand side.\n */\nexport type EvmDataParameterConditionListOperator =\n  (typeof EvmDataParameterConditionListOperator)[keyof typeof EvmDataParameterConditionListOperator];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const EvmDataParameterConditionListOperator = {\n  in: \"in\",\n  not_in: \"not in\",\n} as const;\n\nexport interface EvmDataParameterConditionList {\n  /** The name of the parameter to check against a transaction's calldata. If name is unknown, or is not named, you may supply an array index, e.g., `0` for first parameter. */\n  name: string;\n  /** The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `values` field will be on the right-hand side. */\n  operator: EvmDataParameterConditionListOperator;\n  /** Values to compare against the resolved `name` value. All values are encoded as strings. Refer to the table in the documentation for how values should be encoded, and which operators are supported for each type. */\n  values: string[];\n}\n\n/**\n * A list of parameter conditions to apply against encoded arguments in the transaction's `data` field.\n */\nexport type EvmDataConditionParamsItem = EvmDataParameterCondition | EvmDataParameterConditionList;\n\n/**\n * A single condition to apply against the function and encoded arguments in the transaction's `data` field. Each `parameter` configuration must be successfully evaluated against the corresponding function argument in order for a policy to be accepted.\n */\nexport interface EvmDataCondition {\n  /** The name of a smart contract function being called. */\n  function: string;\n  /** An optional list of parameter conditions to apply against encoded arguments in the transaction's `data` field. */\n  params?: EvmDataConditionParamsItem[];\n}\n\n/**\n * The type of criterion to use. This should be `evmData`.\n */\nexport type EvmDataCriterionType = (typeof EvmDataCriterionType)[keyof typeof EvmDataCriterionType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const EvmDataCriterionType = {\n  evmData: \"evmData\",\n} as const;\n\n/**\n * The ABI of the smart contract being called. This can be a partial structure with only specific functions.\n */\nexport type EvmDataCriterionAbi = KnownAbiType | Abi;\n\n/**\n * A schema for specifying a criterion for the `data` field of an EVM transaction.\n */\nexport interface EvmDataCriterion {\n  /** The type of criterion to use. This should be `evmData`. */\n  type: EvmDataCriterionType;\n  /** The ABI of the smart contract being called. This can be a partial structure with only specific functions. */\n  abi: EvmDataCriterionAbi;\n  /** A list of conditions to apply against the function and encoded arguments in the transaction's `data` field. Each condition must be met in order for this policy to be accepted or rejected. */\n  conditions: EvmDataCondition[];\n}\n\n/**\n * The type of criterion to use. This should be `netUSDChange`.\n */\nexport type NetUSDChangeCriterionType =\n  (typeof NetUSDChangeCriterionType)[keyof typeof NetUSDChangeCriterionType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const NetUSDChangeCriterionType = {\n  netUSDChange: \"netUSDChange\",\n} as const;\n\n/**\n * The operator to use for the comparison. The total value of a transaction's asset transfer will be on the left-hand side of the operator, and the `changeCents` field will be on the right-hand side.\n */\nexport type NetUSDChangeCriterionOperator =\n  (typeof NetUSDChangeCriterionOperator)[keyof typeof NetUSDChangeCriterionOperator];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const NetUSDChangeCriterionOperator = {\n  \">\": \">\",\n  \">=\": \">=\",\n  \"<\": \"<\",\n  \"<=\": \"<=\",\n  \"==\": \"==\",\n} as const;\n\n/**\n * A schema for specifying a criterion for the USD denominated asset transfer or exposure for a transaction. This includes native transfers, as well as token transfers.\n */\nexport interface NetUSDChangeCriterion {\n  /** The type of criterion to use. This should be `netUSDChange`. */\n  type: NetUSDChangeCriterionType;\n  /** The amount of USD, in cents, that the total value of a transaction's asset transfer should be compared to. */\n  changeCents: number;\n  /** The operator to use for the comparison. The total value of a transaction's asset transfer will be on the left-hand side of the operator, and the `changeCents` field will be on the right-hand side. */\n  operator: NetUSDChangeCriterionOperator;\n}\n\nexport type SignEvmTransactionCriteriaItem =\n  | EthValueCriterion\n  | EvmAddressCriterion\n  | EvmDataCriterion\n  | NetUSDChangeCriterion;\n\n/**\n * A schema for specifying criteria for the SignEvmTransaction operation.\n */\nexport type SignEvmTransactionCriteria = SignEvmTransactionCriteriaItem[];\n\n/**\n * Whether matching the rule will cause the request to be rejected or accepted.\n */\nexport type SignEvmTransactionRuleAction =\n  (typeof SignEvmTransactionRuleAction)[keyof typeof SignEvmTransactionRuleAction];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SignEvmTransactionRuleAction = {\n  reject: \"reject\",\n  accept: \"accept\",\n} as const;\n\n/**\n * The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.\n */\nexport type SignEvmTransactionRuleOperation =\n  (typeof SignEvmTransactionRuleOperation)[keyof typeof SignEvmTransactionRuleOperation];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SignEvmTransactionRuleOperation = {\n  signEvmTransaction: \"signEvmTransaction\",\n} as const;\n\nexport interface SignEvmTransactionRule {\n  /** Whether matching the rule will cause the request to be rejected or accepted. */\n  action: SignEvmTransactionRuleAction;\n  /** The operation to which the rule applies. Every element of the `criteria` array must match the specified operation. */\n  operation: SignEvmTransactionRuleOperation;\n  criteria: SignEvmTransactionCriteria;\n}\n\n/**\n * The type of criterion to use. This should be `evmNetwork`.\n */\nexport type EvmNetworkCriterionType =\n  (typeof EvmNetworkCriterionType)[keyof typeof EvmNetworkCriterionType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const EvmNetworkCriterionType = {\n  evmNetwork: \"evmNetwork\",\n} as const;\n\n/**\n * The network the transaction is for.\n */\nexport type EvmNetworkCriterionNetworksItem =\n  (typeof EvmNetworkCriterionNetworksItem)[keyof typeof EvmNetworkCriterionNetworksItem];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const EvmNetworkCriterionNetworksItem = {\n  \"base-sepolia\": \"base-sepolia\",\n  base: \"base\",\n  ethereum: \"ethereum\",\n  \"ethereum-sepolia\": \"ethereum-sepolia\",\n  avalanche: \"avalanche\",\n  polygon: \"polygon\",\n  optimism: \"optimism\",\n  arbitrum: \"arbitrum\",\n  zora: \"zora\",\n  bnb: \"bnb\",\n} as const;\n\n/**\n * The operator to use for the comparison. The transaction's intended `network` will be on the left-hand side of the operator, and the `networks` field will be on the right-hand side.\n */\nexport type EvmNetworkCriterionOperator =\n  (typeof EvmNetworkCriterionOperator)[keyof typeof EvmNetworkCriterionOperator];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const EvmNetworkCriterionOperator = {\n  in: \"in\",\n  not_in: \"not in\",\n} as const;\n\n/**\n * A schema for specifying a criterion for the intended `network` of an EVM transaction.\n */\nexport interface EvmNetworkCriterion {\n  /** The type of criterion to use. This should be `evmNetwork`. */\n  type: EvmNetworkCriterionType;\n  /** A list of EVM network identifiers that the transaction's intended `network` should be compared to. */\n  networks: EvmNetworkCriterionNetworksItem[];\n  /** The operator to use for the comparison. The transaction's intended `network` will be on the left-hand side of the operator, and the `networks` field will be on the right-hand side. */\n  operator: EvmNetworkCriterionOperator;\n}\n\nexport type SendEvmTransactionCriteriaItem =\n  | EthValueCriterion\n  | EvmAddressCriterion\n  | EvmNetworkCriterion\n  | EvmDataCriterion\n  | NetUSDChangeCriterion;\n\n/**\n * A schema for specifying criteria for the SignEvmTransaction operation.\n */\nexport type SendEvmTransactionCriteria = SendEvmTransactionCriteriaItem[];\n\n/**\n * Whether matching the rule will cause the request to be rejected or accepted.\n */\nexport type SendEvmTransactionRuleAction =\n  (typeof SendEvmTransactionRuleAction)[keyof typeof SendEvmTransactionRuleAction];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SendEvmTransactionRuleAction = {\n  reject: \"reject\",\n  accept: \"accept\",\n} as const;\n\n/**\n * The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.\n */\nexport type SendEvmTransactionRuleOperation =\n  (typeof SendEvmTransactionRuleOperation)[keyof typeof SendEvmTransactionRuleOperation];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SendEvmTransactionRuleOperation = {\n  sendEvmTransaction: \"sendEvmTransaction\",\n} as const;\n\nexport interface SendEvmTransactionRule {\n  /** Whether matching the rule will cause the request to be rejected or accepted. */\n  action: SendEvmTransactionRuleAction;\n  /** The operation to which the rule applies. Every element of the `criteria` array must match the specified operation. */\n  operation: SendEvmTransactionRuleOperation;\n  criteria: SendEvmTransactionCriteria;\n}\n\n/**\n * The type of criterion to use. This should be `evmMessage`.\n */\nexport type EvmMessageCriterionType =\n  (typeof EvmMessageCriterionType)[keyof typeof EvmMessageCriterionType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const EvmMessageCriterionType = {\n  evmMessage: \"evmMessage\",\n} as const;\n\n/**\n * A schema for specifying a criterion for the message being signed.\n */\nexport interface EvmMessageCriterion {\n  /** The type of criterion to use. This should be `evmMessage`. */\n  type: EvmMessageCriterionType;\n  /** A regular expression the message is matched against. Accepts valid regular expression syntax described by [RE2](https://github.com/google/re2/wiki/Syntax). */\n  match: string;\n}\n\n/**\n * A schema for specifying the rejection criteria for the SignEvmMessage operation.\n */\nexport type SignEvmMessageCriteria = EvmMessageCriterion[];\n\n/**\n * Whether matching the rule will cause the request to be rejected or accepted.\n */\nexport type SignEvmMessageRuleAction =\n  (typeof SignEvmMessageRuleAction)[keyof typeof SignEvmMessageRuleAction];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SignEvmMessageRuleAction = {\n  reject: \"reject\",\n  accept: \"accept\",\n} as const;\n\n/**\n * The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.\n */\nexport type SignEvmMessageRuleOperation =\n  (typeof SignEvmMessageRuleOperation)[keyof typeof SignEvmMessageRuleOperation];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SignEvmMessageRuleOperation = {\n  signEvmMessage: \"signEvmMessage\",\n} as const;\n\nexport interface SignEvmMessageRule {\n  /** Whether matching the rule will cause the request to be rejected or accepted. */\n  action: SignEvmMessageRuleAction;\n  /** The operation to which the rule applies. Every element of the `criteria` array must match the specified operation. */\n  operation: SignEvmMessageRuleOperation;\n  criteria: SignEvmMessageCriteria;\n}\n\n/**\n * The operator to use for the comparison. The value located at the message's path will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.\n */\nexport type EvmTypedAddressConditionOperator =\n  (typeof EvmTypedAddressConditionOperator)[keyof typeof EvmTypedAddressConditionOperator];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const EvmTypedAddressConditionOperator = {\n  in: \"in\",\n  not_in: \"not in\",\n} as const;\n\n/**\n * A schema for specifying criterion for an address field of an EVM typed message. The address can be deeply nested within the typed data's message.\n */\nexport interface EvmTypedAddressCondition {\n  /** A list of 0x-prefixed EVM addresses that the value located at the message's path should be compared to. There is a limit of 300 addresses per criterion. */\n  addresses: string[];\n  /** The operator to use for the comparison. The value located at the message's path will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side. */\n  operator: EvmTypedAddressConditionOperator;\n  /** The path to the field to compare against this criterion. To reference deeply nested fields within the message, separate object keys by `.`, and access array values using `[index]`. If the field does not exist or is not an address, the operation will be rejected. */\n  path: string;\n}\n\n/**\n * The operator to use for the comparison. The value located at the message's path will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.\n */\nexport type EvmTypedNumericalConditionOperator =\n  (typeof EvmTypedNumericalConditionOperator)[keyof typeof EvmTypedNumericalConditionOperator];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const EvmTypedNumericalConditionOperator = {\n  \">\": \">\",\n  \">=\": \">=\",\n  \"<\": \"<\",\n  \"<=\": \"<=\",\n  \"==\": \"==\",\n} as const;\n\n/**\n * A schema for specifying criterion for a numerical field of an EVM typed message. The value can be deeply nested within the typed data's message.\n */\nexport interface EvmTypedNumericalCondition {\n  /**\n   * The amount that the value located at the message's path should be compared to.\n   * @pattern ^[0-9]+$\n   */\n  value: string;\n  /** The operator to use for the comparison. The value located at the message's path will be on the left-hand side of the operator, and the `value` field will be on the right-hand side. */\n  operator: EvmTypedNumericalConditionOperator;\n  /** The path to the field to compare against this criterion. To reference deeply nested fields within the message, separate object keys by `.`, and access array values using `[index]`. If the field does not exist or is not an address, the operation will be rejected. */\n  path: string;\n}\n\n/**\n * A schema for specifying criterion for a string field of an EVM typed message. The value can be deeply nested within the typed data's message.\n */\nexport interface EvmTypedStringCondition {\n  /** A regular expression the field is matched against. */\n  match: string;\n  /** The path to the field to compare against this criterion. To reference deeply nested fields within the message, separate object keys by `.`, and access array values using `[index]`. If the field does not exist or is not an address, the operation will be rejected. */\n  path: string;\n}\n\n/**\n * The type of criterion to use. This should be `evmTypedDataField`.\n */\nexport type SignEvmTypedDataFieldCriterionType =\n  (typeof SignEvmTypedDataFieldCriterionType)[keyof typeof SignEvmTypedDataFieldCriterionType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SignEvmTypedDataFieldCriterionType = {\n  evmTypedDataField: \"evmTypedDataField\",\n} as const;\n\nexport type SignEvmTypedDataFieldCriterionTypesTypesItem = {\n  /** The name of a key within an EIP-712 data structure. */\n  name?: string;\n  /** The Solidity type of a value within an EIP-712 data structure. */\n  type?: string;\n};\n\n/**\n * EIP-712 compliant map of model names to model definitions.\n */\nexport type SignEvmTypedDataFieldCriterionTypesTypes = {\n  [key: string]: SignEvmTypedDataFieldCriterionTypesTypesItem[];\n};\n\n/**\n * An object containing EIP-712 type definitions, as well as a primary type for the root message object.\n */\nexport type SignEvmTypedDataFieldCriterionTypes = {\n  /** EIP-712 compliant map of model names to model definitions. */\n  types: SignEvmTypedDataFieldCriterionTypesTypes;\n  /** The name of the root EIP-712 type. This value must be included in the `types` object. */\n  primaryType: string;\n};\n\nexport type SignEvmTypedDataFieldCriterionConditionsItem =\n  | EvmTypedAddressCondition\n  | EvmTypedNumericalCondition\n  | EvmTypedStringCondition;\n\nexport interface SignEvmTypedDataFieldCriterion {\n  /** The type of criterion to use. This should be `evmTypedDataField`. */\n  type: SignEvmTypedDataFieldCriterionType;\n  /** An object containing EIP-712 type definitions, as well as a primary type for the root message object. */\n  types: SignEvmTypedDataFieldCriterionTypes;\n  /** A list of conditions to check against the data being signed. Each condition must be met for the rule to take effect. */\n  conditions: SignEvmTypedDataFieldCriterionConditionsItem[];\n}\n\n/**\n * The type of criterion to use. This should be `evmTypedDataVerifyingContract`.\n */\nexport type SignEvmTypedDataVerifyingContractCriterionType =\n  (typeof SignEvmTypedDataVerifyingContractCriterionType)[keyof typeof SignEvmTypedDataVerifyingContractCriterionType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SignEvmTypedDataVerifyingContractCriterionType = {\n  evmTypedDataVerifyingContract: \"evmTypedDataVerifyingContract\",\n} as const;\n\n/**\n * The operator to use for the comparison. The domain's verifying contract will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.\n */\nexport type SignEvmTypedDataVerifyingContractCriterionOperator =\n  (typeof SignEvmTypedDataVerifyingContractCriterionOperator)[keyof typeof SignEvmTypedDataVerifyingContractCriterionOperator];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SignEvmTypedDataVerifyingContractCriterionOperator = {\n  in: \"in\",\n  not_in: \"not in\",\n} as const;\n\n/**\n * A schema for specifying criterion for a domain's verifying contract.\n */\nexport interface SignEvmTypedDataVerifyingContractCriterion {\n  /** The type of criterion to use. This should be `evmTypedDataVerifyingContract`. */\n  type: SignEvmTypedDataVerifyingContractCriterionType;\n  /** A list of 0x-prefixed EVM addresses that the domain's verifying contract should be compared to. There is a limit of 300 addresses per criterion. */\n  addresses: string[];\n  /** The operator to use for the comparison. The domain's verifying contract will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side. */\n  operator: SignEvmTypedDataVerifyingContractCriterionOperator;\n}\n\nexport type SignEvmTypedDataCriteriaItem =\n  | SignEvmTypedDataFieldCriterion\n  | SignEvmTypedDataVerifyingContractCriterion;\n\n/**\n * A schema for specifying criteria for the SignEvmTypedData operation.\n */\nexport type SignEvmTypedDataCriteria = SignEvmTypedDataCriteriaItem[];\n\n/**\n * Whether matching the rule will cause the request to be rejected or accepted.\n */\nexport type SignEvmTypedDataRuleAction =\n  (typeof SignEvmTypedDataRuleAction)[keyof typeof SignEvmTypedDataRuleAction];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SignEvmTypedDataRuleAction = {\n  reject: \"reject\",\n  accept: \"accept\",\n} as const;\n\n/**\n * The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.\n */\nexport type SignEvmTypedDataRuleOperation =\n  (typeof SignEvmTypedDataRuleOperation)[keyof typeof SignEvmTypedDataRuleOperation];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SignEvmTypedDataRuleOperation = {\n  signEvmTypedData: \"signEvmTypedData\",\n} as const;\n\nexport interface SignEvmTypedDataRule {\n  /** Whether matching the rule will cause the request to be rejected or accepted. */\n  action: SignEvmTypedDataRuleAction;\n  /** The operation to which the rule applies. Every element of the `criteria` array must match the specified operation. */\n  operation: SignEvmTypedDataRuleOperation;\n  criteria: SignEvmTypedDataCriteria;\n}\n\n/**\n * The type of criterion to use. This should be `solAddress`.\n */\nexport type SolAddressCriterionType =\n  (typeof SolAddressCriterionType)[keyof typeof SolAddressCriterionType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SolAddressCriterionType = {\n  solAddress: \"solAddress\",\n} as const;\n\n/**\n * The operator to use for the comparison. Each of the native transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.\n */\nexport type SolAddressCriterionOperator =\n  (typeof SolAddressCriterionOperator)[keyof typeof SolAddressCriterionOperator];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SolAddressCriterionOperator = {\n  in: \"in\",\n  not_in: \"not in\",\n} as const;\n\n/**\n * The criterion for the recipient addresses of a Solana transaction's native transfer instruction.\n */\nexport interface SolAddressCriterion {\n  /** The type of criterion to use. This should be `solAddress`. */\n  type: SolAddressCriterionType;\n  /** The Solana addresses that are compared to the list of native transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array. */\n  addresses: string[];\n  /** The operator to use for the comparison. Each of the native transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side. */\n  operator: SolAddressCriterionOperator;\n}\n\n/**\n * The type of criterion to use. This should be `solValue`.\n */\nexport type SolValueCriterionType =\n  (typeof SolValueCriterionType)[keyof typeof SolValueCriterionType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SolValueCriterionType = {\n  solValue: \"solValue\",\n} as const;\n\n/**\n * The operator to use for the comparison. The transaction instruction's `value` field will be on the left-hand side of the operator, and the `solValue` field will be on the right-hand side.\n */\nexport type SolValueCriterionOperator =\n  (typeof SolValueCriterionOperator)[keyof typeof SolValueCriterionOperator];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SolValueCriterionOperator = {\n  \">\": \">\",\n  \">=\": \">=\",\n  \"<\": \"<\",\n  \"<=\": \"<=\",\n  \"==\": \"==\",\n} as const;\n\n/**\n * The criterion for the SOL value in lamports of a native transfer instruction in a Solana transaction.\n */\nexport interface SolValueCriterion {\n  /** The type of criterion to use. This should be `solValue`. */\n  type: SolValueCriterionType;\n  /** The amount of SOL in lamports that the transaction instruction's `value` field should be compared to. */\n  solValue: string;\n  /** The operator to use for the comparison. The transaction instruction's `value` field will be on the left-hand side of the operator, and the `solValue` field will be on the right-hand side. */\n  operator: SolValueCriterionOperator;\n}\n\n/**\n * The type of criterion to use. This should be `splAddress`.\n */\nexport type SplAddressCriterionType =\n  (typeof SplAddressCriterionType)[keyof typeof SplAddressCriterionType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SplAddressCriterionType = {\n  splAddress: \"splAddress\",\n} as const;\n\n/**\n * The operator to use for the comparison. Each of the SPL token transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.\n */\nexport type SplAddressCriterionOperator =\n  (typeof SplAddressCriterionOperator)[keyof typeof SplAddressCriterionOperator];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SplAddressCriterionOperator = {\n  in: \"in\",\n  not_in: \"not in\",\n} as const;\n\n/**\n * The criterion for the recipient addresses of a Solana transaction's SPL token transfer instructions.\n */\nexport interface SplAddressCriterion {\n  /** The type of criterion to use. This should be `splAddress`. */\n  type: SplAddressCriterionType;\n  /** The Solana addresses that are compared to the list of SPL token transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array. */\n  addresses: string[];\n  /** The operator to use for the comparison. Each of the SPL token transfer recipient addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side. */\n  operator: SplAddressCriterionOperator;\n}\n\n/**\n * The type of criterion to use. This should be `splValue`.\n */\nexport type SplValueCriterionType =\n  (typeof SplValueCriterionType)[keyof typeof SplValueCriterionType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SplValueCriterionType = {\n  splValue: \"splValue\",\n} as const;\n\n/**\n * The operator to use for the comparison. The transaction instruction's `value` field will be on the left-hand side of the operator, and the `splValue` field will be on the right-hand side.\n */\nexport type SplValueCriterionOperator =\n  (typeof SplValueCriterionOperator)[keyof typeof SplValueCriterionOperator];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SplValueCriterionOperator = {\n  \">\": \">\",\n  \">=\": \">=\",\n  \"<\": \"<\",\n  \"<=\": \"<=\",\n  \"==\": \"==\",\n} as const;\n\n/**\n * The criterion for the SPL token value of a SPL token transfer instruction in a Solana transaction.\n */\nexport interface SplValueCriterion {\n  /** The type of criterion to use. This should be `splValue`. */\n  type: SplValueCriterionType;\n  /** The amount of the SPL token that the transaction instruction's `value` field should be compared to. */\n  splValue: string;\n  /** The operator to use for the comparison. The transaction instruction's `value` field will be on the left-hand side of the operator, and the `splValue` field will be on the right-hand side. */\n  operator: SplValueCriterionOperator;\n}\n\n/**\n * The type of criterion to use. This should be `mintAddress`.\n */\nexport type MintAddressCriterionType =\n  (typeof MintAddressCriterionType)[keyof typeof MintAddressCriterionType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const MintAddressCriterionType = {\n  mintAddress: \"mintAddress\",\n} as const;\n\n/**\n * The operator to use for the comparison. Each of the token mint addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side.\n */\nexport type MintAddressCriterionOperator =\n  (typeof MintAddressCriterionOperator)[keyof typeof MintAddressCriterionOperator];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const MintAddressCriterionOperator = {\n  in: \"in\",\n  not_in: \"not in\",\n} as const;\n\n/**\n * The criterion for the token mint addresses of a Solana transaction's SPL token transfer instructions.\n */\nexport interface MintAddressCriterion {\n  /** The type of criterion to use. This should be `mintAddress`. */\n  type: MintAddressCriterionType;\n  /** The Solana addresses that are compared to the list of token mint addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array. */\n  addresses: string[];\n  /** The operator to use for the comparison. Each of the token mint addresses in the transaction's `accountKeys` (for legacy transactions) or `staticAccountKeys` (for V0 transactions) array will be on the left-hand side of the operator, and the `addresses` field will be on the right-hand side. */\n  operator: MintAddressCriterionOperator;\n}\n\n/**\n * A reference to an established Solana program. When referencing a `KnownIdlType` within a policy rule configuring an `SolDataCriterion`, criteria will decode instruction data as documented in the programs. For more information on supported programs, see the links below.\n  - [SystemProgram](https://docs.rs/solana-program/latest/solana_program/system_instruction/enum.SystemInstruction.html).\n  - [TokenProgram](https://docs.rs/spl-token/latest/spl_token/instruction/enum.TokenInstruction.html).\n  - [AssociatedTokenProgram](https://docs.rs/spl-associated-token-account/latest/spl_associated_token_account/instruction/index.html).\n */\nexport type KnownIdlType = (typeof KnownIdlType)[keyof typeof KnownIdlType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const KnownIdlType = {\n  SystemProgram: \"SystemProgram\",\n  TokenProgram: \"TokenProgram\",\n  AssociatedTokenProgram: \"AssociatedTokenProgram\",\n} as const;\n\nexport type IdlInstructionsItemArgsItem = {\n  /** The argument name. */\n  name: string;\n  /** The argument type. */\n  type: string;\n};\n\nexport type IdlInstructionsItemAccountsItem = {\n  /** The account name. */\n  name: string;\n  /** Whether the account is writable. */\n  writable?: boolean;\n  /** Whether the account must be a signer. */\n  signer?: boolean;\n};\n\nexport type IdlInstructionsItem = {\n  /** The instruction name. */\n  name: string;\n  /**\n   * Array of 8 numbers representing the instruction discriminator.\n   * @minItems 8\n   * @maxItems 8\n   */\n  discriminator: number[];\n  /** List of instruction arguments. */\n  args: IdlInstructionsItemArgsItem[];\n  /** Optional list of accounts required by the instruction. */\n  accounts?: IdlInstructionsItemAccountsItem[];\n};\n\n/**\n * Optional metadata about the IDL.\n */\nexport type IdlMetadata = {\n  /** The program name. */\n  name?: string;\n  /** The program version. */\n  version?: string;\n  /** The IDL specification version. */\n  spec?: string;\n};\n\nexport type IdlTypesItem = { [key: string]: unknown };\n\n/**\n * IDL Specification following Anchor's IDL format v0.30+.\n */\nexport interface Idl {\n  /** The program address. */\n  address: string;\n  /** List of program instructions. */\n  instructions: IdlInstructionsItem[];\n  /** Optional metadata about the IDL. */\n  metadata?: IdlMetadata;\n  /** Optional type definitions for custom data structures used in the program. */\n  types?: IdlTypesItem[];\n}\n\n/**\n * The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.\n */\nexport type SolDataParameterConditionOperator =\n  (typeof SolDataParameterConditionOperator)[keyof typeof SolDataParameterConditionOperator];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SolDataParameterConditionOperator = {\n  \">\": \">\",\n  \">=\": \">=\",\n  \"<\": \"<\",\n  \"<=\": \"<=\",\n  \"==\": \"==\",\n} as const;\n\n/**\n * A single parameter condition to apply against a specific instruction's parameters.\n */\nexport interface SolDataParameterCondition {\n  /** The parameter name. */\n  name: string;\n  /** The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side. */\n  operator: SolDataParameterConditionOperator;\n  /** The value to compare against. */\n  value: string;\n}\n\n/**\n * The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side.\n */\nexport type SolDataParameterConditionListOperator =\n  (typeof SolDataParameterConditionListOperator)[keyof typeof SolDataParameterConditionListOperator];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SolDataParameterConditionListOperator = {\n  in: \"in\",\n  not_in: \"not in\",\n} as const;\n\n/**\n * A single parameter condition to apply against a specific instruction's parameters.\n */\nexport interface SolDataParameterConditionList {\n  /** The parameter name. */\n  name: string;\n  /** The operator to use for the comparison. The value resolved at the `name` will be on the left-hand side of the operator, and the `value` field will be on the right-hand side. */\n  operator: SolDataParameterConditionListOperator;\n  /** The values to compare against. */\n  values: string[];\n}\n\n/**\n * A list of parameter conditions to apply against a specific instruction's data.\n */\nexport type SolDataConditionParamsItem = SolDataParameterCondition | SolDataParameterConditionList;\n\n/**\n * A single condition to apply against a specific instruction type and its parameters.\n */\nexport interface SolDataCondition {\n  /** The instruction name. */\n  instruction: string;\n  /** Parameter conditions for the instruction. */\n  params?: SolDataConditionParamsItem[];\n}\n\n/**\n * The type of criterion to use. This should be `solData`.\n */\nexport type SolDataCriterionType = (typeof SolDataCriterionType)[keyof typeof SolDataCriterionType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SolDataCriterionType = {\n  solData: \"solData\",\n} as const;\n\nexport type SolDataCriterionIdlsItem = KnownIdlType | Idl;\n\n/**\n * A schema for specifying criterion for instruction data in a Solana transaction.\n */\nexport interface SolDataCriterion {\n  /** The type of criterion to use. This should be `solData`. */\n  type: SolDataCriterionType;\n  /** List of IDL specifications. Can contain known program names (strings) or custom IDL objects. */\n  idls: SolDataCriterionIdlsItem[];\n  /** A list of conditions to apply against the transaction instruction. Only one condition must evaluate to true for this criterion to be met. */\n  conditions: SolDataCondition[];\n}\n\n/**\n * The type of criterion to use. This should be `programId`.\n */\nexport type ProgramIdCriterionType =\n  (typeof ProgramIdCriterionType)[keyof typeof ProgramIdCriterionType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const ProgramIdCriterionType = {\n  programId: \"programId\",\n} as const;\n\n/**\n * The operator to use for the comparison. Each of the program IDs in the transaction's instructions will be on the left-hand side of the operator, and the `programIds` field will be on the right-hand side.\n */\nexport type ProgramIdCriterionOperator =\n  (typeof ProgramIdCriterionOperator)[keyof typeof ProgramIdCriterionOperator];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const ProgramIdCriterionOperator = {\n  in: \"in\",\n  not_in: \"not in\",\n} as const;\n\n/**\n * The criterion for the program IDs of a Solana transaction's instructions.\n */\nexport interface ProgramIdCriterion {\n  /** The type of criterion to use. This should be `programId`. */\n  type: ProgramIdCriterionType;\n  /** The Solana program IDs that are compared to the list of program IDs in the transaction's instructions. */\n  programIds: string[];\n  /** The operator to use for the comparison. Each of the program IDs in the transaction's instructions will be on the left-hand side of the operator, and the `programIds` field will be on the right-hand side. */\n  operator: ProgramIdCriterionOperator;\n}\n\nexport type SignSolTransactionCriteriaItem =\n  | SolAddressCriterion\n  | SolValueCriterion\n  | SplAddressCriterion\n  | SplValueCriterion\n  | MintAddressCriterion\n  | SolDataCriterion\n  | ProgramIdCriterion;\n\n/**\n * A schema for specifying criteria for the SignSolTransaction operation.\n */\nexport type SignSolTransactionCriteria = SignSolTransactionCriteriaItem[];\n\n/**\n * Whether matching the rule will cause the request to be rejected or accepted.\n */\nexport type SignSolTransactionRuleAction =\n  (typeof SignSolTransactionRuleAction)[keyof typeof SignSolTransactionRuleAction];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SignSolTransactionRuleAction = {\n  reject: \"reject\",\n  accept: \"accept\",\n} as const;\n\n/**\n * The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.\n */\nexport type SignSolTransactionRuleOperation =\n  (typeof SignSolTransactionRuleOperation)[keyof typeof SignSolTransactionRuleOperation];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SignSolTransactionRuleOperation = {\n  signSolTransaction: \"signSolTransaction\",\n} as const;\n\nexport interface SignSolTransactionRule {\n  /** Whether matching the rule will cause the request to be rejected or accepted. */\n  action: SignSolTransactionRuleAction;\n  /** The operation to which the rule applies. Every element of the `criteria` array must match the specified operation. */\n  operation: SignSolTransactionRuleOperation;\n  criteria: SignSolTransactionCriteria;\n}\n\n/**\n * The type of criterion to use. This should be `solNetwork`.\n */\nexport type SolNetworkCriterionType =\n  (typeof SolNetworkCriterionType)[keyof typeof SolNetworkCriterionType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SolNetworkCriterionType = {\n  solNetwork: \"solNetwork\",\n} as const;\n\n/**\n * The Solana network the transaction is for.\n */\nexport type SolNetworkCriterionNetworksItem =\n  (typeof SolNetworkCriterionNetworksItem)[keyof typeof SolNetworkCriterionNetworksItem];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SolNetworkCriterionNetworksItem = {\n  \"solana-devnet\": \"solana-devnet\",\n  solana: \"solana\",\n} as const;\n\n/**\n * The operator to use for the comparison. The transaction's intended network will be on the left-hand side of the operator, and the `networks` field will be on the right-hand side.\n */\nexport type SolNetworkCriterionOperator =\n  (typeof SolNetworkCriterionOperator)[keyof typeof SolNetworkCriterionOperator];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SolNetworkCriterionOperator = {\n  in: \"in\",\n  not_in: \"not in\",\n} as const;\n\n/**\n * The criterion for the Solana network of a transaction.\n */\nexport interface SolNetworkCriterion {\n  /** The type of criterion to use. This should be `solNetwork`. */\n  type: SolNetworkCriterionType;\n  /** The Solana networks that the transaction's intended network should be compared to. */\n  networks: SolNetworkCriterionNetworksItem[];\n  /** The operator to use for the comparison. The transaction's intended network will be on the left-hand side of the operator, and the `networks` field will be on the right-hand side. */\n  operator: SolNetworkCriterionOperator;\n}\n\nexport type SendSolTransactionCriteriaItem =\n  | SolAddressCriterion\n  | SolValueCriterion\n  | SplAddressCriterion\n  | SplValueCriterion\n  | MintAddressCriterion\n  | SolDataCriterion\n  | ProgramIdCriterion\n  | SolNetworkCriterion;\n\n/**\n * A schema for specifying criteria for the SendSolTransaction operation.\n */\nexport type SendSolTransactionCriteria = SendSolTransactionCriteriaItem[];\n\n/**\n * Whether matching the rule will cause the request to be rejected or accepted.\n */\nexport type SendSolTransactionRuleAction =\n  (typeof SendSolTransactionRuleAction)[keyof typeof SendSolTransactionRuleAction];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SendSolTransactionRuleAction = {\n  reject: \"reject\",\n  accept: \"accept\",\n} as const;\n\n/**\n * The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.\n */\nexport type SendSolTransactionRuleOperation =\n  (typeof SendSolTransactionRuleOperation)[keyof typeof SendSolTransactionRuleOperation];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SendSolTransactionRuleOperation = {\n  sendSolTransaction: \"sendSolTransaction\",\n} as const;\n\nexport interface SendSolTransactionRule {\n  /** Whether matching the rule will cause the request to be rejected or accepted. */\n  action: SendSolTransactionRuleAction;\n  /** The operation to which the rule applies. Every element of the `criteria` array must match the specified operation. */\n  operation: SendSolTransactionRuleOperation;\n  criteria: SendSolTransactionCriteria;\n}\n\n/**\n * The type of criterion to use. This should be `solMessage`.\n */\nexport type SolMessageCriterionType =\n  (typeof SolMessageCriterionType)[keyof typeof SolMessageCriterionType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SolMessageCriterionType = {\n  solMessage: \"solMessage\",\n} as const;\n\n/**\n * The criterion for the message of a Solana transaction.\n */\nexport interface SolMessageCriterion {\n  /** The type of criterion to use. This should be `solMessage`. */\n  type: SolMessageCriterionType;\n  /** A regular expression the field is matched against. */\n  match: string;\n}\n\n/**\n * A schema for specifying criteria for the SignSolMessage operation.\n */\nexport type SignSolMessageCriteria = SolMessageCriterion[];\n\n/**\n * Whether matching the rule will cause the request to be rejected or accepted.\n */\nexport type SignSolMessageRuleAction =\n  (typeof SignSolMessageRuleAction)[keyof typeof SignSolMessageRuleAction];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SignSolMessageRuleAction = {\n  reject: \"reject\",\n  accept: \"accept\",\n} as const;\n\n/**\n * The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.\n */\nexport type SignSolMessageRuleOperation =\n  (typeof SignSolMessageRuleOperation)[keyof typeof SignSolMessageRuleOperation];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SignSolMessageRuleOperation = {\n  signSolMessage: \"signSolMessage\",\n} as const;\n\nexport interface SignSolMessageRule {\n  /** Whether matching the rule will cause the request to be rejected or accepted. */\n  action: SignSolMessageRuleAction;\n  /** The operation to which the rule applies. Every element of the `criteria` array must match the specified operation. */\n  operation: SignSolMessageRuleOperation;\n  criteria: SignSolMessageCriteria;\n}\n\n/**\n * Whether any attempts to sign a hash will be accepted or rejected. This rule does not accept any criteria.\n */\nexport type SignEvmHashRuleAction =\n  (typeof SignEvmHashRuleAction)[keyof typeof SignEvmHashRuleAction];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SignEvmHashRuleAction = {\n  reject: \"reject\",\n  accept: \"accept\",\n} as const;\n\n/**\n * The operation to which the rule applies.\n */\nexport type SignEvmHashRuleOperation =\n  (typeof SignEvmHashRuleOperation)[keyof typeof SignEvmHashRuleOperation];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SignEvmHashRuleOperation = {\n  signEvmHash: \"signEvmHash\",\n} as const;\n\nexport interface SignEvmHashRule {\n  /** Whether any attempts to sign a hash will be accepted or rejected. This rule does not accept any criteria. */\n  action: SignEvmHashRuleAction;\n  /** The operation to which the rule applies. */\n  operation: SignEvmHashRuleOperation;\n}\n\nexport type PrepareUserOperationCriteriaItem =\n  | EthValueCriterion\n  | EvmAddressCriterion\n  | EvmNetworkCriterion\n  | EvmDataCriterion\n  | NetUSDChangeCriterion;\n\n/**\n * A schema for specifying criteria for the PrepareUserOperation operation.\n */\nexport type PrepareUserOperationCriteria = PrepareUserOperationCriteriaItem[];\n\n/**\n * Whether matching the rule will cause the request to be rejected or accepted.\n */\nexport type PrepareUserOperationRuleAction =\n  (typeof PrepareUserOperationRuleAction)[keyof typeof PrepareUserOperationRuleAction];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const PrepareUserOperationRuleAction = {\n  reject: \"reject\",\n  accept: \"accept\",\n} as const;\n\n/**\n * The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.\n */\nexport type PrepareUserOperationRuleOperation =\n  (typeof PrepareUserOperationRuleOperation)[keyof typeof PrepareUserOperationRuleOperation];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const PrepareUserOperationRuleOperation = {\n  prepareUserOperation: \"prepareUserOperation\",\n} as const;\n\nexport interface PrepareUserOperationRule {\n  /** Whether matching the rule will cause the request to be rejected or accepted. */\n  action: PrepareUserOperationRuleAction;\n  /** The operation to which the rule applies. Every element of the `criteria` array must match the specified operation. */\n  operation: PrepareUserOperationRuleOperation;\n  criteria: PrepareUserOperationCriteria;\n}\n\nexport type SendUserOperationCriteriaItem =\n  | EthValueCriterion\n  | EvmAddressCriterion\n  | EvmDataCriterion\n  | NetUSDChangeCriterion;\n\n/**\n * A schema for specifying criteria for the SendUserOperation operation.\n */\nexport type SendUserOperationCriteria = SendUserOperationCriteriaItem[];\n\n/**\n * Whether matching the rule will cause the request to be rejected or accepted.\n */\nexport type SendUserOperationRuleAction =\n  (typeof SendUserOperationRuleAction)[keyof typeof SendUserOperationRuleAction];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SendUserOperationRuleAction = {\n  reject: \"reject\",\n  accept: \"accept\",\n} as const;\n\n/**\n * The operation to which the rule applies. Every element of the `criteria` array must match the specified operation.\n */\nexport type SendUserOperationRuleOperation =\n  (typeof SendUserOperationRuleOperation)[keyof typeof SendUserOperationRuleOperation];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SendUserOperationRuleOperation = {\n  sendUserOperation: \"sendUserOperation\",\n} as const;\n\nexport interface SendUserOperationRule {\n  /** Whether matching the rule will cause the request to be rejected or accepted. */\n  action: SendUserOperationRuleAction;\n  /** The operation to which the rule applies. Every element of the `criteria` array must match the specified operation. */\n  operation: SendUserOperationRuleOperation;\n  criteria: SendUserOperationCriteria;\n}\n\n/**\n * A rule that limits the behavior of an account.\n */\nexport type Rule =\n  | SignEvmTransactionRule\n  | SendEvmTransactionRule\n  | SignEvmMessageRule\n  | SignEvmTypedDataRule\n  | SignSolTransactionRule\n  | SendSolTransactionRule\n  | SignSolMessageRule\n  | SignEvmHashRule\n  | PrepareUserOperationRule\n  | SendUserOperationRule;\n\n/**\n * The scope of the policy. Only one project-level policy can exist at any time.\n */\nexport type PolicyScope = (typeof PolicyScope)[keyof typeof PolicyScope];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const PolicyScope = {\n  project: \"project\",\n  account: \"account\",\n} as const;\n\nexport interface Policy {\n  /**\n   * The unique identifier for the policy.\n   * @pattern ^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\n   */\n  id: string;\n  /**\n   * An optional human-readable description of the policy.\nPolicy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.\n   * @pattern ^[A-Za-z0-9 ,.]{1,50}$\n   */\n  description?: string;\n  /** The scope of the policy. Only one project-level policy can exist at any time. */\n  scope: PolicyScope;\n  /** A list of rules that comprise the policy. */\n  rules: Rule[];\n  /** The ISO 8601 timestamp at which the Policy was created. */\n  createdAt: string;\n  /** The ISO 8601 timestamp at which the Policy was last updated. */\n  updatedAt: string;\n}\n\nexport interface SolanaAccount {\n  /**\n   * The base58 encoded Solana address.\n   * @pattern ^[1-9A-HJ-NP-Za-km-z]{32,44}$\n   */\n  address: string;\n  /**\n   * An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names are guaranteed to be unique across all Solana accounts in the developer's CDP Project.\n   * @pattern ^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\n   */\n  name?: string;\n  /** The list of policy IDs that apply to the account. This will include both the project-level policy and the account-level policy, if one exists. */\n  policies?: string[];\n  /** The ISO 8601 UTC timestamp at which the account was created. */\n  createdAt?: string;\n  /** The ISO 8601 UTC timestamp at which the account was last updated. */\n  updatedAt?: string;\n}\n\n/**\n * The name of the supported Solana networks in human-readable format.\n */\nexport type ListSolanaTokenBalancesNetwork =\n  (typeof ListSolanaTokenBalancesNetwork)[keyof typeof ListSolanaTokenBalancesNetwork];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const ListSolanaTokenBalancesNetwork = {\n  solana: \"solana\",\n  \"solana-devnet\": \"solana-devnet\",\n} as const;\n\n/**\n * Amount of a given Solana token.\n */\nexport interface SolanaTokenAmount {\n  /**\n   * The amount is denominated in the smallest indivisible unit of the token. For SOL, the smallest indivisible unit is lamports (10^-9 SOL). For SPL tokens, the smallest unit is defined by the token's decimals configuration.\n   * @pattern ^[0-9]+$\n   */\n  amount: string;\n  /** 'decimals' is the exponential value N that satisfies the equation `amount * 10^-N = standard_denomination`. The standard denomination is the most commonly used denomination for the token.\n- For native SOL, `decimals` is 9 (1 SOL = 10^9 lamports). - For SPL tokens, `decimals` is defined in the token's mint configuration. */\n  decimals: number;\n}\n\n/**\n * General information about a Solana token. Includes the mint address, and other identifying information.\n */\nexport interface SolanaToken {\n  /** The symbol of this token (ex: SOL, USDC, RAY).\nThe token symbol is not unique. It is possible for two different tokens to have the same symbol.\nFor the native SOL token, this symbol is \"SOL\". For SPL tokens, this symbol is defined in the token's metadata.\nNot all tokens have a symbol. This field will only be populated when the token has metadata available. */\n  symbol?: string;\n  /** The name of this token (ex: \"Solana\", \"USD Coin\", \"Raydium\").\nThe token name is not unique. It is possible for two different tokens to have the same name.\nFor the native SOL token, this name is \"Solana\". For SPL tokens, this name is defined in the token's metadata.\nNot all tokens have a name. This field will only be populated when the token has metadata available. */\n  name?: string;\n  /**\n   * The mint address of the token.\nFor native SOL, the mint address is `So11111111111111111111111111111111111111111`. For SPL tokens, this is the mint address where the token is defined.\n   * @pattern ^[1-9A-HJ-NP-Za-km-z]{32,44}$\n   */\n  mintAddress: string;\n}\n\nexport interface SolanaTokenBalance {\n  amount: SolanaTokenAmount;\n  token: SolanaToken;\n}\n\n/**\n * Request to execute a SQL query against indexed blockchain data.\n */\nexport interface OnchainDataQuery {\n  /**\n   * SQL query to execute against the indexed blockchain data.\n   * @minLength 1\n   * @maxLength 50000\n   */\n  sql: string;\n}\n\n/**\n * Row data with column names as keys.\n */\nexport type OnchainDataResultResultItem = { [key: string]: unknown };\n\n/**\n * Column data type (ClickHouse types).\n */\nexport type OnchainDataResultSchemaColumnsItemType =\n  (typeof OnchainDataResultSchemaColumnsItemType)[keyof typeof OnchainDataResultSchemaColumnsItemType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const OnchainDataResultSchemaColumnsItemType = {\n  String: \"String\",\n  UInt8: \"UInt8\",\n  UInt16: \"UInt16\",\n  UInt32: \"UInt32\",\n  UInt64: \"UInt64\",\n  UInt128: \"UInt128\",\n  UInt256: \"UInt256\",\n  Int8: \"Int8\",\n  Int16: \"Int16\",\n  Int32: \"Int32\",\n  Int64: \"Int64\",\n  Int128: \"Int128\",\n  Int256: \"Int256\",\n  Float32: \"Float32\",\n  Float64: \"Float64\",\n  Bool: \"Bool\",\n  Date: \"Date\",\n  DateTime: \"DateTime\",\n  DateTime64: \"DateTime64\",\n  UUID: \"UUID\",\n} as const;\n\nexport type OnchainDataResultSchemaColumnsItem = {\n  /** Column name. */\n  name?: string;\n  /** Column data type (ClickHouse types). */\n  type?: OnchainDataResultSchemaColumnsItemType;\n};\n\n/**\n * Schema information for the query result. This is a derived schema from the query result, so types may not match the underlying table.\n\n */\nexport type OnchainDataResultSchema = {\n  /** Column definitions. */\n  columns?: OnchainDataResultSchemaColumnsItem[];\n};\n\n/**\n * Metadata about query execution.\n */\nexport type OnchainDataResultMetadata = {\n  /** Whether the result was served from cache. */\n  cached?: boolean;\n  /** Query execution time in milliseconds. */\n  executionTimeMs?: number;\n  /** Number of rows returned. */\n  rowCount?: number;\n};\n\n/**\n * Result of executing a SQL query.\n */\nexport interface OnchainDataResult {\n  /** Query result as an array of objects representing rows. */\n  result?: OnchainDataResultResultItem[];\n  /** Schema information for the query result. This is a derived schema from the query result, so types may not match the underlying table.\n   */\n  schema?: OnchainDataResultSchema;\n  /** Metadata about query execution. */\n  metadata?: OnchainDataResultMetadata;\n}\n\n/**\n * Response containing token addresses that an account has received.\n */\nexport interface AccountTokenAddressesResponse {\n  /** The account address that was queried. */\n  accountAddress?: string;\n  /** List of token contract addresses that the account has received. */\n  tokenAddresses?: string[];\n  /**\n   * Total number of unique token addresses discovered.\n   * @minimum 0\n   */\n  totalCount?: number;\n}\n\n/**\n * The version of the x402 protocol.\n */\nexport type X402Version = (typeof X402Version)[keyof typeof X402Version];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const X402Version = {\n  NUMBER_1: 1,\n} as const;\n\n/**\n * The authorization data for the ERC-3009 authorization message.\n */\nexport type X402ExactEvmPayloadAuthorization = {\n  /**\n   * The 0x-prefixed, checksum EVM address of the sender of the payment.\n   * @pattern ^0x[0-9a-fA-F]{40}$\n   */\n  from: string;\n  /**\n   * The 0x-prefixed, checksum EVM address of the recipient of the payment.\n   * @pattern ^0x[0-9a-fA-F]{40}$\n   */\n  to: string;\n  /** The value of the payment, in atomic units of the payment asset. */\n  value: string;\n  /** The unix timestamp after which the payment is valid. */\n  validAfter: string;\n  /** The unix timestamp before which the payment is valid. */\n  validBefore: string;\n  /** The hex-encoded nonce of the payment. */\n  nonce: string;\n};\n\n/**\n * The x402 protocol exact scheme payload for EVM networks. The scheme is implemented using ERC-3009. For more details, please see [EVM Exact Scheme Details](https://github.com/coinbase/x402/blob/main/specs/schemes/exact/scheme_exact_evm.md).\n */\nexport interface X402ExactEvmPayload {\n  /** The EIP-712 hex-encoded signature of the ERC-3009 authorization message. */\n  signature: string;\n  /** The authorization data for the ERC-3009 authorization message. */\n  authorization: X402ExactEvmPayloadAuthorization;\n}\n\n/**\n * The x402 protocol exact scheme payload for Solana networks. For more details, please see [Solana Exact Scheme Details](https://github.com/coinbase/x402/blob/main/specs/schemes/exact/scheme_exact_svm.md).\n */\nexport interface X402ExactSolanaPayload {\n  /** The base64-encoded Solana transaction. */\n  transaction: string;\n}\n\n/**\n * The scheme of the payment protocol to use. Currently, the only supported scheme is `exact`.\n */\nexport type X402PaymentPayloadScheme =\n  (typeof X402PaymentPayloadScheme)[keyof typeof X402PaymentPayloadScheme];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const X402PaymentPayloadScheme = {\n  exact: \"exact\",\n} as const;\n\n/**\n * The network of the blockchain to send payment on.\n */\nexport type X402PaymentPayloadNetwork =\n  (typeof X402PaymentPayloadNetwork)[keyof typeof X402PaymentPayloadNetwork];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const X402PaymentPayloadNetwork = {\n  \"base-sepolia\": \"base-sepolia\",\n  base: \"base\",\n  \"solana-devnet\": \"solana-devnet\",\n  solana: \"solana\",\n} as const;\n\n/**\n * The payload of the payment depending on the x402Version, scheme, and network.\n */\nexport type X402PaymentPayloadPayload = X402ExactEvmPayload | X402ExactSolanaPayload;\n\n/**\n * The x402 protocol payment payload that the client attaches to x402-paid API requests to the resource server in the X-PAYMENT header.\n */\nexport interface X402PaymentPayload {\n  x402Version: X402Version;\n  /** The scheme of the payment protocol to use. Currently, the only supported scheme is `exact`. */\n  scheme: X402PaymentPayloadScheme;\n  /** The network of the blockchain to send payment on. */\n  network: X402PaymentPayloadNetwork;\n  /** The payload of the payment depending on the x402Version, scheme, and network. */\n  payload: X402PaymentPayloadPayload;\n}\n\n/**\n * The scheme of the payment protocol to use. Currently, the only supported scheme is `exact`.\n */\nexport type X402PaymentRequirementsScheme =\n  (typeof X402PaymentRequirementsScheme)[keyof typeof X402PaymentRequirementsScheme];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const X402PaymentRequirementsScheme = {\n  exact: \"exact\",\n} as const;\n\n/**\n * The network of the blockchain to send payment on.\n */\nexport type X402PaymentRequirementsNetwork =\n  (typeof X402PaymentRequirementsNetwork)[keyof typeof X402PaymentRequirementsNetwork];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const X402PaymentRequirementsNetwork = {\n  \"base-sepolia\": \"base-sepolia\",\n  base: \"base\",\n  \"solana-devnet\": \"solana-devnet\",\n  solana: \"solana\",\n} as const;\n\n/**\n * The optional JSON schema describing the resource output.\n */\nexport type X402PaymentRequirementsOutputSchema = { [key: string]: unknown };\n\n/**\n * The optional additional scheme-specific payment info.\n */\nexport type X402PaymentRequirementsExtra = { [key: string]: unknown };\n\n/**\n * The x402 protocol payment requirements that the resource server expects the client's payment payload to meet.\n */\nexport interface X402PaymentRequirements {\n  /** The scheme of the payment protocol to use. Currently, the only supported scheme is `exact`. */\n  scheme: X402PaymentRequirementsScheme;\n  /** The network of the blockchain to send payment on. */\n  network: X402PaymentRequirementsNetwork;\n  /** The maximum amount required to pay for the resource in atomic units of the payment asset. */\n  maxAmountRequired: string;\n  /** The URL of the resource to pay for. */\n  resource: string;\n  /** The description of the resource. */\n  description: string;\n  /** The MIME type of the resource response. */\n  mimeType: string;\n  /** The optional JSON schema describing the resource output. */\n  outputSchema?: X402PaymentRequirementsOutputSchema;\n  /**\n   * The destination to pay value to.\n\nFor EVM networks, payTo will be a 0x-prefixed, checksum EVM address.\n\nFor Solana-based networks, payTo will be a base58-encoded Solana address.\n   * @pattern ^0x[a-fA-F0-9]{40}|[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\n   */\n  payTo: string;\n  /** The maximum time in seconds for the resource server to respond. */\n  maxTimeoutSeconds: number;\n  /**\n   * The asset to pay with.\n\nFor EVM networks, the asset will be a 0x-prefixed, checksum EVM address.\n\nFor Solana-based networks, the asset will be a base58-encoded Solana address.\n   * @pattern ^0x[a-fA-F0-9]{40}|[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\n   */\n  asset: string;\n  /** The optional additional scheme-specific payment info. */\n  extra?: X402PaymentRequirementsExtra;\n}\n\n/**\n * The reason the payment is invalid on the x402 protocol.\n */\nexport type X402VerifyInvalidReason =\n  (typeof X402VerifyInvalidReason)[keyof typeof X402VerifyInvalidReason];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const X402VerifyInvalidReason = {\n  insufficient_funds: \"insufficient_funds\",\n  invalid_scheme: \"invalid_scheme\",\n  invalid_network: \"invalid_network\",\n  invalid_x402_version: \"invalid_x402_version\",\n  invalid_payment_requirements: \"invalid_payment_requirements\",\n  invalid_payload: \"invalid_payload\",\n  invalid_exact_evm_payload_authorization_value: \"invalid_exact_evm_payload_authorization_value\",\n  invalid_exact_evm_payload_authorization_valid_after:\n    \"invalid_exact_evm_payload_authorization_valid_after\",\n  invalid_exact_evm_payload_authorization_valid_before:\n    \"invalid_exact_evm_payload_authorization_valid_before\",\n  invalid_exact_evm_payload_authorization_typed_data_message:\n    \"invalid_exact_evm_payload_authorization_typed_data_message\",\n  invalid_exact_evm_payload_authorization_from_address_kyt:\n    \"invalid_exact_evm_payload_authorization_from_address_kyt\",\n  invalid_exact_evm_payload_authorization_to_address_kyt:\n    \"invalid_exact_evm_payload_authorization_to_address_kyt\",\n  invalid_exact_evm_payload_signature: \"invalid_exact_evm_payload_signature\",\n  invalid_exact_evm_payload_signature_address: \"invalid_exact_evm_payload_signature_address\",\n  invalid_exact_svm_payload_transaction: \"invalid_exact_svm_payload_transaction\",\n  invalid_exact_svm_payload_transaction_amount_mismatch:\n    \"invalid_exact_svm_payload_transaction_amount_mismatch\",\n  invalid_exact_svm_payload_transaction_create_ata_instruction:\n    \"invalid_exact_svm_payload_transaction_create_ata_instruction\",\n  invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_payee:\n    \"invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_payee\",\n  invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_asset:\n    \"invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_asset\",\n  invalid_exact_svm_payload_transaction_instructions:\n    \"invalid_exact_svm_payload_transaction_instructions\",\n  invalid_exact_svm_payload_transaction_instructions_length:\n    \"invalid_exact_svm_payload_transaction_instructions_length\",\n  invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction:\n    \"invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction\",\n  invalid_exact_svm_payload_transaction_instructions_compute_price_instruction:\n    \"invalid_exact_svm_payload_transaction_instructions_compute_price_instruction\",\n  invalid_exact_svm_payload_transaction_instructions_compute_price_instruction_too_high:\n    \"invalid_exact_svm_payload_transaction_instructions_compute_price_instruction_too_high\",\n  invalid_exact_svm_payload_transaction_instruction_not_spl_token_transfer_checked:\n    \"invalid_exact_svm_payload_transaction_instruction_not_spl_token_transfer_checked\",\n  invalid_exact_svm_payload_transaction_instruction_not_token_2022_transfer_checked:\n    \"invalid_exact_svm_payload_transaction_instruction_not_token_2022_transfer_checked\",\n  invalid_exact_svm_payload_transaction_not_a_transfer_instruction:\n    \"invalid_exact_svm_payload_transaction_not_a_transfer_instruction\",\n  invalid_exact_svm_payload_transaction_cannot_derive_receiver_ata:\n    \"invalid_exact_svm_payload_transaction_cannot_derive_receiver_ata\",\n  invalid_exact_svm_payload_transaction_receiver_ata_not_found:\n    \"invalid_exact_svm_payload_transaction_receiver_ata_not_found\",\n  invalid_exact_svm_payload_transaction_sender_ata_not_found:\n    \"invalid_exact_svm_payload_transaction_sender_ata_not_found\",\n  invalid_exact_svm_payload_transaction_simulation_failed:\n    \"invalid_exact_svm_payload_transaction_simulation_failed\",\n  invalid_exact_svm_payload_transaction_transfer_to_incorrect_ata:\n    \"invalid_exact_svm_payload_transaction_transfer_to_incorrect_ata\",\n} as const;\n\n/**\n * The reason the payment settlement errored on the x402 protocol.\n */\nexport type X402SettleErrorReason =\n  (typeof X402SettleErrorReason)[keyof typeof X402SettleErrorReason];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const X402SettleErrorReason = {\n  insufficient_funds: \"insufficient_funds\",\n  invalid_scheme: \"invalid_scheme\",\n  invalid_network: \"invalid_network\",\n  invalid_x402_version: \"invalid_x402_version\",\n  invalid_payment_requirements: \"invalid_payment_requirements\",\n  invalid_payload: \"invalid_payload\",\n  invalid_exact_evm_payload_authorization_value: \"invalid_exact_evm_payload_authorization_value\",\n  invalid_exact_evm_payload_authorization_valid_after:\n    \"invalid_exact_evm_payload_authorization_valid_after\",\n  invalid_exact_evm_payload_authorization_valid_before:\n    \"invalid_exact_evm_payload_authorization_valid_before\",\n  invalid_exact_evm_payload_authorization_typed_data_message:\n    \"invalid_exact_evm_payload_authorization_typed_data_message\",\n  invalid_exact_evm_payload_authorization_from_address_kyt:\n    \"invalid_exact_evm_payload_authorization_from_address_kyt\",\n  invalid_exact_evm_payload_authorization_to_address_kyt:\n    \"invalid_exact_evm_payload_authorization_to_address_kyt\",\n  invalid_exact_evm_payload_signature_address: \"invalid_exact_evm_payload_signature_address\",\n  settle_exact_svm_block_height_exceeded: \"settle_exact_svm_block_height_exceeded\",\n  settle_exact_svm_transaction_confirmation_timed_out:\n    \"settle_exact_svm_transaction_confirmation_timed_out\",\n} as const;\n\n/**\n * The scheme of the payment protocol.\n */\nexport type X402SupportedPaymentKindScheme =\n  (typeof X402SupportedPaymentKindScheme)[keyof typeof X402SupportedPaymentKindScheme];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const X402SupportedPaymentKindScheme = {\n  exact: \"exact\",\n} as const;\n\n/**\n * The network of the blockchain.\n */\nexport type X402SupportedPaymentKindNetwork =\n  (typeof X402SupportedPaymentKindNetwork)[keyof typeof X402SupportedPaymentKindNetwork];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const X402SupportedPaymentKindNetwork = {\n  \"base-sepolia\": \"base-sepolia\",\n  base: \"base\",\n  \"solana-devnet\": \"solana-devnet\",\n  solana: \"solana\",\n} as const;\n\n/**\n * The optional additional scheme-specific payment info.\n */\nexport type X402SupportedPaymentKindExtra = { [key: string]: unknown };\n\n/**\n * The supported payment kind for the x402 protocol. A kind is comprised of a scheme and a network, which together uniquely identify a way to move money on the x402 protocol. For more details, please see [x402 Schemes](https://github.com/coinbase/x402?tab=readme-ov-file#schemes).\n */\nexport interface X402SupportedPaymentKind {\n  x402Version: X402Version;\n  /** The scheme of the payment protocol. */\n  scheme: X402SupportedPaymentKindScheme;\n  /** The network of the blockchain. */\n  network: X402SupportedPaymentKindNetwork;\n  /** The optional additional scheme-specific payment info. */\n  extra?: X402SupportedPaymentKindExtra;\n}\n\n/**\n * The type of payment method to be used to complete an onramp order.\n */\nexport type OnrampOrderPaymentMethodTypeId =\n  (typeof OnrampOrderPaymentMethodTypeId)[keyof typeof OnrampOrderPaymentMethodTypeId];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const OnrampOrderPaymentMethodTypeId = {\n  GUEST_CHECKOUT_APPLE_PAY: \"GUEST_CHECKOUT_APPLE_PAY\",\n} as const;\n\n/**\n * The type of fee.\n */\nexport type OnrampOrderFeeType = (typeof OnrampOrderFeeType)[keyof typeof OnrampOrderFeeType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const OnrampOrderFeeType = {\n  FEE_TYPE_NETWORK: \"FEE_TYPE_NETWORK\",\n  FEE_TYPE_EXCHANGE: \"FEE_TYPE_EXCHANGE\",\n} as const;\n\n/**\n * A fee associated with an order.\n */\nexport interface OnrampOrderFee {\n  /** The type of fee. */\n  type: OnrampOrderFeeType;\n  /** The amount of the fee. */\n  amount: string;\n  /** The currency of the fee. */\n  currency: string;\n}\n\n/**\n * The status of an onramp order.\n */\nexport type OnrampOrderStatus = (typeof OnrampOrderStatus)[keyof typeof OnrampOrderStatus];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const OnrampOrderStatus = {\n  ONRAMP_ORDER_STATUS_PENDING_AUTH: \"ONRAMP_ORDER_STATUS_PENDING_AUTH\",\n  ONRAMP_ORDER_STATUS_PENDING_PAYMENT: \"ONRAMP_ORDER_STATUS_PENDING_PAYMENT\",\n  ONRAMP_ORDER_STATUS_PROCESSING: \"ONRAMP_ORDER_STATUS_PROCESSING\",\n  ONRAMP_ORDER_STATUS_COMPLETED: \"ONRAMP_ORDER_STATUS_COMPLETED\",\n  ONRAMP_ORDER_STATUS_FAILED: \"ONRAMP_ORDER_STATUS_FAILED\",\n} as const;\n\n/**\n * An Onramp order.\n */\nexport interface OnrampOrder {\n  /** The ID of the onramp order. */\n  orderId: string;\n  /** The total amount of fiat to be paid, inclusive of any fees. */\n  paymentTotal: string;\n  /** The amount of fiat to be converted to crypto. */\n  paymentSubtotal: string;\n  /** The fiat currency to be converted to crypto. */\n  paymentCurrency: string;\n  paymentMethod: OnrampOrderPaymentMethodTypeId;\n  /** The amount of crypto to be purchased. */\n  purchaseAmount: string;\n  /** The crypto currency to be purchased. */\n  purchaseCurrency: string;\n  /** The fees associated with the order. */\n  fees: OnrampOrderFee[];\n  /** The exchange rate used to convert fiat to crypto i.e. the crypto value of one fiat. */\n  exchangeRate: string;\n  /** The destination address to send the crypto to. */\n  destinationAddress: string;\n  /** The network to send the crypto on. */\n  destinationNetwork: string;\n  status: OnrampOrderStatus;\n  /** The transaction hash of the order (only available once crypto has been sent). */\n  txHash?: string;\n  /** The date and time the order was created. */\n  createdAt: string;\n  /** The date and time the order was last updated. */\n  updatedAt: string;\n  /** The partner user reference ID. */\n  partnerUserRef?: string;\n}\n\n/**\n * The type of payment link.\n */\nexport type OnrampPaymentLinkType =\n  (typeof OnrampPaymentLinkType)[keyof typeof OnrampPaymentLinkType];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const OnrampPaymentLinkType = {\n  PAYMENT_LINK_TYPE_APPLE_PAY_BUTTON: \"PAYMENT_LINK_TYPE_APPLE_PAY_BUTTON\",\n} as const;\n\n/**\n * A payment link to pay for an order.\n\nPlease refer to the [Onramp docs](https://docs.cdp.coinbase.com/onramp-&-offramp/onramp-apis/onramp-overview) for details on how to integrate with the different payment link types.\n */\nexport interface OnrampPaymentLink {\n  /** The URL to the hosted widget the user should be redirected to. For certain payment link types you can append your  own redirect_url query parameter to this URL to ensure the user is redirected back to your app after the widget completes. */\n  url: string;\n  paymentLinkType: OnrampPaymentLinkType;\n}\n\n/**\n * The type of payment method used to generate the onramp quote.\n */\nexport type OnrampQuotePaymentMethodTypeId =\n  (typeof OnrampQuotePaymentMethodTypeId)[keyof typeof OnrampQuotePaymentMethodTypeId];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const OnrampQuotePaymentMethodTypeId = {\n  CARD: \"CARD\",\n  ACH: \"ACH\",\n  APPLE_PAY: \"APPLE_PAY\",\n  PAYPAL: \"PAYPAL\",\n  FIAT_WALLET: \"FIAT_WALLET\",\n  CRYPTO_WALLET: \"CRYPTO_WALLET\",\n} as const;\n\n/**\n * An onramp session containing a ready-to-use onramp URL.\n */\nexport interface OnrampSession {\n  /** Ready-to-use onramp URL. */\n  onrampUrl: string;\n}\n\n/**\n * Quote information with pricing details for the crypto purchase.\n */\nexport interface OnrampQuote {\n  /** The total amount of fiat to be paid, inclusive of any fees. */\n  paymentTotal: string;\n  /** The amount of fiat to be converted to crypto. */\n  paymentSubtotal: string;\n  /** The fiat currency to be converted to crypto. */\n  paymentCurrency: string;\n  /** The amount of crypto to be purchased. */\n  purchaseAmount: string;\n  /** The crypto currency to be purchased. */\n  purchaseCurrency: string;\n  /** The network to send the crypto on. */\n  destinationNetwork: string;\n  /** The fees associated with the quote. */\n  fees: OnrampOrderFee[];\n  /** The exchange rate used to convert fiat to crypto i.e. the crypto value of one fiat. */\n  exchangeRate: string;\n}\n\n/**\n * Unauthorized.\n */\nexport type UnauthorizedErrorResponse = Error;\n\n/**\n * Internal server error.\n */\nexport type InternalServerErrorResponse = Error;\n\n/**\n * Bad gateway.\n */\nexport type BadGatewayErrorResponse = Error;\n\n/**\n * Service unavailable.\n */\nexport type ServiceUnavailableErrorResponse = Error;\n\n/**\n * A payment method is required to complete this operation.\n */\nexport type PaymentMethodRequiredErrorResponse = Error;\n\n/**\n * Idempotency key conflict.\n */\nexport type IdempotencyErrorResponse = Error;\n\n/**\n * The resource already exists.\n */\nexport type AlreadyExistsErrorResponse = Error;\n\n/**\n * The underlying SQL string is invalid.\n */\nexport type InvalidSQLQueryErrorResponse = Error;\n\n/**\n * The request timed out.\n */\nexport type TimedOutErrorResponse = Error;\n\nexport type X402VerifyResponseResponse = {\n  /** Indicates whether the payment is valid. */\n  isValid: boolean;\n  invalidReason?: X402VerifyInvalidReason;\n  /**\n   * The onchain address of the client that is paying for the resource.\n\nFor EVM networks, the payer will be a 0x-prefixed, checksum EVM address.\n\nFor Solana-based networks, the payer will be a base58-encoded Solana address.\n   * @pattern ^0x[a-fA-F0-9]{40}|[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\n   */\n  payer: string;\n};\n\nexport type X402SettleResponseResponse = {\n  /** Indicates whether the payment settlement is successful. */\n  success: boolean;\n  errorReason?: X402SettleErrorReason;\n  /**\n   * The onchain address of the client that is paying for the resource.\n\nFor EVM networks, the payer will be a 0x-prefixed, checksum EVM address.\n\nFor Solana-based networks, the payer will be a base58-encoded Solana address.\n   * @pattern ^0x[a-fA-F0-9]{40}|[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\n   */\n  payer: string;\n  /**\n   * The transaction of the settlement.\nFor EVM networks, the transaction will be a 0x-prefixed, EVM transaction hash.\nFor Solana-based networks, the transaction will be a base58-encoded Solana signature.\n   * @pattern ^0x[a-fA-F0-9]{40}|[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\n   */\n  transaction: string;\n  /** The network where the settlement occurred. */\n  network: string;\n};\n\nexport type X402SupportedPaymentKindsResponseResponse = {\n  /** The list of supported payment kinds. */\n  kinds: X402SupportedPaymentKind[];\n};\n\n/**\n * Rate limit exceeded.\n */\nexport type RateLimitExceededResponse = Error;\n\n/**\n * A JWT signed using your Wallet Secret, encoded in base64. Refer to the\n[Generate Wallet Token](https://docs.cdp.coinbase.com/api-reference/v2/authentication#2-generate-wallet-token)\nsection of our Authentication docs for more details on how to generate your Wallet Token.\n\n */\nexport type XWalletAuthParameter = string;\n\n/**\n * An optional [UUID v4](https://www.uuidgenerator.net/version4) request header for making requests safely retryable.\nWhen included, duplicate requests with the same key will return identical responses. \nRefer to our [Idempotency docs](https://docs.cdp.coinbase.com/api-reference/v2/idempotency) for more information on using idempotency keys.\n\n */\nexport type IdempotencyKeyParameter = string;\n\nexport type ListEndUsersParams = {\n  /**\n   * The number of end users to return per page.\n   */\n  pageSize?: number;\n  /**\n   * The token for the desired page of end users. Will be empty if there are no more end users to fetch.\n   */\n  pageToken?: string;\n  /**\n   * Sort end users. Defaults to ascending order (oldest first).\n   */\n  sort?: ListEndUsersSortItem[];\n};\n\nexport type ListEndUsersSortItem = (typeof ListEndUsersSortItem)[keyof typeof ListEndUsersSortItem];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const ListEndUsersSortItem = {\n  \"createdAt=asc\": \"createdAt=asc\",\n  \"createdAt=desc\": \"createdAt=desc\",\n} as const;\n\nexport type ListEndUsers200AllOf = {\n  /** The list of end users. */\n  endUsers: EndUser[];\n};\n\nexport type ListEndUsers200 = ListEndUsers200AllOf & ListResponse;\n\n/**\n * The request body for a developer to verify an end user's access token.\n */\nexport type ValidateEndUserAccessTokenBody = {\n  /** The access token in JWT format to verify. */\n  accessToken: string;\n};\n\nexport type ListEvmAccountsParams = {\n  /**\n   * The number of accounts to return per page.\n   */\n  pageSize?: number;\n  /**\n   * The token for the next page of accounts, if any.\n   */\n  pageToken?: string;\n};\n\nexport type ListEvmAccounts200AllOf = {\n  /** The list of EVM accounts. */\n  accounts: EvmAccount[];\n};\n\nexport type ListEvmAccounts200 = ListEvmAccounts200AllOf & ListResponse;\n\nexport type CreateEvmAccountBody = {\n  /**\n   * An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all EVM accounts in the developer's CDP Project.\n   * @pattern ^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\n   */\n  name?: string;\n  /**\n   * The ID of the account-level policy to apply to the account.\n   * @pattern ^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\n   */\n  accountPolicy?: string;\n};\n\nexport type UpdateEvmAccountBody = {\n  /**\n   * An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all EVM accounts in the developer's CDP Project.\n   * @pattern ^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\n   */\n  name?: string;\n  /**\n   * The ID of the account-level policy to apply to the account, or an empty string to unset attached policy.\n   * @pattern (^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)|(^$)\n   */\n  accountPolicy?: string;\n};\n\n/**\n * The network to send the transaction to.\n */\nexport type SendEvmTransactionBodyNetwork =\n  (typeof SendEvmTransactionBodyNetwork)[keyof typeof SendEvmTransactionBodyNetwork];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SendEvmTransactionBodyNetwork = {\n  base: \"base\",\n  \"base-sepolia\": \"base-sepolia\",\n  ethereum: \"ethereum\",\n  \"ethereum-sepolia\": \"ethereum-sepolia\",\n  avalanche: \"avalanche\",\n  polygon: \"polygon\",\n  optimism: \"optimism\",\n  arbitrum: \"arbitrum\",\n} as const;\n\nexport type SendEvmTransactionBody = {\n  /** The network to send the transaction to. */\n  network: SendEvmTransactionBodyNetwork;\n  /** The RLP-encoded transaction to sign and send, as a 0x-prefixed hex string. */\n  transaction: string;\n};\n\nexport type SendEvmTransaction200 = {\n  /** The hash of the transaction, as a 0x-prefixed hex string. */\n  transactionHash: string;\n};\n\nexport type SignEvmTransactionBody = {\n  /** The RLP-encoded transaction to sign, as a 0x-prefixed hex string. */\n  transaction: string;\n};\n\nexport type SignEvmTransaction200 = {\n  /** The RLP-encoded signed transaction, as a 0x-prefixed hex string. */\n  signedTransaction: string;\n};\n\nexport type SignEvmHashBody = {\n  /** The arbitrary 32 byte hash to sign. */\n  hash: string;\n};\n\nexport type SignEvmHash200 = {\n  /** The signature of the hash, as a 0x-prefixed hex string. */\n  signature: string;\n};\n\nexport type SignEvmMessageBody = {\n  /** The message to sign. */\n  message: string;\n};\n\nexport type SignEvmMessage200 = {\n  /** The signature of the message, as a 0x-prefixed hex string. */\n  signature: string;\n};\n\nexport type SignEvmTypedData200 = {\n  /** The signature of the typed data, as a 0x-prefixed hex string. */\n  signature: string;\n};\n\nexport type ListEvmSmartAccountsParams = {\n  /**\n   * The number of accounts to return per page.\n   */\n  pageSize?: number;\n  /**\n   * The token for the next page of accounts, if any.\n   */\n  pageToken?: string;\n};\n\nexport type ListEvmSmartAccounts200AllOf = {\n  /** The list of Smart Accounts. */\n  accounts: EvmSmartAccount[];\n};\n\nexport type ListEvmSmartAccounts200 = ListEvmSmartAccounts200AllOf & ListResponse;\n\nexport type CreateEvmSmartAccountBody = {\n  /** Today, only a single owner can be set for a Smart Account, but this is an array to allow setting multiple owners in the future. */\n  owners: string[];\n  /**\n   * An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all EVM accounts in the developer's CDP Project.\n   * @pattern ^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\n   */\n  name?: string;\n};\n\nexport type ImportEvmAccountBody = {\n  /** The base64-encoded, encrypted private key of the EVM account. The private key must be encrypted using the CDP SDK's encryption scheme. */\n  encryptedPrivateKey: string;\n  /**\n   * An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all EVM accounts in the developer's CDP Project.\n   * @pattern ^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\n   */\n  name?: string;\n  /**\n   * The ID of the account-level policy to apply to the account.\n   * @pattern ^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\n   */\n  accountPolicy?: string;\n};\n\nexport type ExportEvmAccountBody = {\n  /** The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key. */\n  exportEncryptionKey: string;\n};\n\nexport type ExportEvmAccount200 = {\n  /** The base64-encoded, encrypted private key of the EVM account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request. */\n  encryptedPrivateKey: string;\n};\n\nexport type ExportEvmAccountByNameBody = {\n  /** The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key. */\n  exportEncryptionKey: string;\n};\n\nexport type ExportEvmAccountByName200 = {\n  /** The base64-encoded, encrypted private key of the EVM account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request. */\n  encryptedPrivateKey: string;\n};\n\nexport type UpdateEvmSmartAccountBody = {\n  /**\n   * An optional name for the smart account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all EVM smart accounts in the developer's CDP Project.\n   * @pattern ^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\n   */\n  name?: string;\n};\n\nexport type PrepareUserOperationBody = {\n  network: EvmUserOperationNetwork;\n  /** The list of calls to make from the Smart Account. */\n  calls: EvmCall[];\n  /** The URL of the paymaster to use for the user operation. */\n  paymasterUrl?: string;\n};\n\nexport type PrepareAndSendUserOperationBody = {\n  network: EvmUserOperationNetwork;\n  /** The list of calls to make from the Smart Account. */\n  calls: EvmCall[];\n  /** The URL of the paymaster to use for the user operation. */\n  paymasterUrl?: string;\n};\n\nexport type SendUserOperationBody = {\n  /** The hex-encoded signature of the user operation. This should be a 65-byte signature consisting of the `r`, `s`, and `v` values of the ECDSA signature. Note that the `v` value should conform to the `personal_sign` standard, which means it should be 27 or 28. */\n  signature: string;\n};\n\nexport type ListSpendPermissionsParams = {\n  /**\n   * The number of spend permissions to return per page.\n   */\n  pageSize?: number;\n  /**\n   * The token for the next page of spend permissions. Will be empty if there are no more spend permissions to fetch.\n   */\n  pageToken?: string;\n};\n\nexport type ListSpendPermissions200AllOf = {\n  /** The spend permissions for the smart account. */\n  spendPermissions: SpendPermissionResponseObject[];\n};\n\nexport type ListSpendPermissions200 = ListSpendPermissions200AllOf & ListResponse;\n\nexport type GetEvmSwapPriceParams = {\n  network: EvmSwapsNetwork;\n  toToken: ToToken;\n  fromToken: FromToken;\n  fromAmount: FromAmount;\n  taker: Taker;\n  signerAddress?: SignerAddress;\n  gasPrice?: GasPrice;\n  slippageBps?: SlippageBps;\n};\n\nexport type CreateEvmSwapQuoteBody = {\n  network: EvmSwapsNetwork;\n  /**\n   * The 0x-prefixed contract address of the token to receive.\n   * @pattern ^0x[a-fA-F0-9]{40}$\n   */\n  toToken: string;\n  /**\n   * The 0x-prefixed contract address of the token to send.\n   * @pattern ^0x[a-fA-F0-9]{40}$\n   */\n  fromToken: string;\n  /**\n   * The amount of the `fromToken` to send in atomic units of the token. For example, `1000000000000000000` when sending ETH equates to 1 ETH, `1000000` when sending USDC equates to 1 USDC, etc.\n   * @pattern ^\\d+$\n   */\n  fromAmount: string;\n  /**\n   * The 0x-prefixed address that holds the `fromToken` balance and has the `Permit2` allowance set for the swap.\n   * @pattern ^0x[a-fA-F0-9]{40}$\n   */\n  taker: string;\n  /**\n   * The 0x-prefixed Externally Owned Account (EOA) address that will sign the `Permit2` EIP-712 permit message. This is only needed if `taker` is a smart contract.\n   * @pattern ^0x[a-fA-F0-9]{40}$\n   */\n  signerAddress?: string;\n  /**\n   * The target gas price for the swap transaction, in Wei. For EIP-1559 transactions, this value should be seen as the `maxFeePerGas` value. If not provided, the API will use an estimate based on the current network conditions.\n   * @pattern ^\\d+$\n   */\n  gasPrice?: string;\n  /**\n   * The maximum acceptable slippage of the `toToken` in basis points. If this parameter is set to 0, no slippage will be tolerated. If not provided, the default slippage tolerance is 100 bps (i.e., 1%).\n   * @minimum 0\n   * @maximum 10000\n   */\n  slippageBps?: number;\n};\n\nexport type ListEvmTokenBalancesParams = {\n  /**\n   * The number of balances to return per page.\n   */\n  pageSize?: number;\n  /**\n   * The token for the next page of balances. Will be empty if there are no more balances to fetch.\n   */\n  pageToken?: string;\n};\n\nexport type ListEvmTokenBalances200AllOf = {\n  /** The list of EVM token balances. */\n  balances: TokenBalance[];\n};\n\nexport type ListEvmTokenBalances200 = ListEvmTokenBalances200AllOf & ListResponse;\n\n/**\n * The network to request funds from.\n */\nexport type RequestEvmFaucetBodyNetwork =\n  (typeof RequestEvmFaucetBodyNetwork)[keyof typeof RequestEvmFaucetBodyNetwork];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const RequestEvmFaucetBodyNetwork = {\n  \"base-sepolia\": \"base-sepolia\",\n  \"ethereum-sepolia\": \"ethereum-sepolia\",\n  \"ethereum-hoodi\": \"ethereum-hoodi\",\n} as const;\n\n/**\n * The token to request funds for.\n */\nexport type RequestEvmFaucetBodyToken =\n  (typeof RequestEvmFaucetBodyToken)[keyof typeof RequestEvmFaucetBodyToken];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const RequestEvmFaucetBodyToken = {\n  eth: \"eth\",\n  usdc: \"usdc\",\n  eurc: \"eurc\",\n  cbbtc: \"cbbtc\",\n} as const;\n\nexport type RequestEvmFaucetBody = {\n  /** The network to request funds from. */\n  network: RequestEvmFaucetBodyNetwork;\n  /**\n   * The address to request funds to, which is a 0x-prefixed hexadecimal string.\n   * @pattern ^0x[0-9a-fA-F]{40}$\n   */\n  address: string;\n  /** The token to request funds for. */\n  token: RequestEvmFaucetBodyToken;\n};\n\nexport type RequestEvmFaucet200 = {\n  /** The hash of the transaction that requested the funds.\n   **Note:** In rare cases, when gas conditions are unusually high, the transaction may not confirm, and the system may issue a replacement transaction to complete the faucet request. In these rare cases, the `transactionHash` will be out of sync with the actual faucet transaction that was confirmed onchain. */\n  transactionHash: string;\n};\n\nexport type ListPoliciesParams = {\n  /**\n   * The number of policies to return per page.\n   */\n  pageSize?: number;\n  /**\n   * The token for the next page of policies, if any.\n   */\n  pageToken?: string;\n  /**\n   * The scope of the policies to return. If `project`, the response will include exactly one policy, which is the project-level policy. If `account`, the response will include all account-level policies for the developer's CDP Project.\n   */\n  scope?: ListPoliciesScope;\n};\n\nexport type ListPoliciesScope = (typeof ListPoliciesScope)[keyof typeof ListPoliciesScope];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const ListPoliciesScope = {\n  project: \"project\",\n  account: \"account\",\n} as const;\n\nexport type ListPolicies200AllOf = {\n  /** The list of policies. */\n  policies: Policy[];\n};\n\nexport type ListPolicies200 = ListPolicies200AllOf & ListResponse;\n\n/**\n * The scope of the policy.\n */\nexport type CreatePolicyBodyScope =\n  (typeof CreatePolicyBodyScope)[keyof typeof CreatePolicyBodyScope];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const CreatePolicyBodyScope = {\n  project: \"project\",\n  account: \"account\",\n} as const;\n\nexport type CreatePolicyBody = {\n  /** The scope of the policy. */\n  scope: CreatePolicyBodyScope;\n  /**\n   * An optional human-readable description for the policy.\nPolicy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.\n   * @pattern ^[A-Za-z0-9 ,.]{1,50}$\n   */\n  description?: string;\n  /** A list of rules that comprise the policy. There is a limit of 10 rules per policy. */\n  rules: Rule[];\n};\n\nexport type UpdatePolicyBody = {\n  /**\n   * An optional human-readable description for the policy.\nPolicy descriptions can consist of alphanumeric characters, spaces, commas, and periods, and be 50 characters or less.\n   * @pattern ^[A-Za-z0-9 ,.]{1,50}$\n   */\n  description?: string;\n  /** A list of rules that comprise the policy. There is a limit of 10 rules per policy. */\n  rules: Rule[];\n};\n\nexport type ListSolanaAccountsParams = {\n  /**\n   * The number of accounts to return per page.\n   */\n  pageSize?: number;\n  /**\n   * The token for the next page of accounts, if any.\n   */\n  pageToken?: string;\n};\n\nexport type ListSolanaAccounts200AllOf = {\n  /** The list of Solana accounts. */\n  accounts: SolanaAccount[];\n};\n\nexport type ListSolanaAccounts200 = ListSolanaAccounts200AllOf & ListResponse;\n\nexport type CreateSolanaAccountBody = {\n  /**\n   * An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all Solana accounts in the developer's CDP Project.\n   * @pattern ^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\n   */\n  name?: string;\n  /**\n   * The ID of the account-level policy to apply to the account.\n   * @pattern ^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\n   */\n  accountPolicy?: string;\n};\n\nexport type UpdateSolanaAccountBody = {\n  /**\n   * An optional name for the account. Account names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all Solana accounts in the developer's CDP Project.\n   * @pattern ^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\n   */\n  name?: string;\n  /**\n   * The ID of the account-level policy to apply to the account, or an empty string to unset attached policy.\n   * @pattern (^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)|(^$)\n   */\n  accountPolicy?: string;\n};\n\nexport type ImportSolanaAccountBody = {\n  /** The base64-encoded, encrypted 32-byte private key of the Solana account. The private key must be encrypted using the CDP SDK's encryption scheme. */\n  encryptedPrivateKey: string;\n  /**\n   * An optional name for the account.\nAccount names can consist of alphanumeric characters and hyphens, and be between 2 and 36 characters long.\nAccount names must be unique across all EVM accounts in the developer's CDP Project.\n   * @pattern ^[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$\n   */\n  name?: string;\n};\n\nexport type ExportSolanaAccountBody = {\n  /** The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key. */\n  exportEncryptionKey: string;\n};\n\nexport type ExportSolanaAccount200 = {\n  /** The base64-encoded, encrypted private key of the Solana account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request. */\n  encryptedPrivateKey: string;\n};\n\nexport type ExportSolanaAccountByNameBody = {\n  /** The base64-encoded, public part of the RSA key in DER format used to encrypt the account private key. */\n  exportEncryptionKey: string;\n};\n\nexport type ExportSolanaAccountByName200 = {\n  /** The base64-encoded, encrypted private key of the Solana account which is a 32 byte raw private key. The private key is encrypted in transport using the exportEncryptionKey in the request. */\n  encryptedPrivateKey: string;\n};\n\nexport type SignSolanaTransactionBody = {\n  /** The base64 encoded transaction to sign. */\n  transaction: string;\n};\n\nexport type SignSolanaTransaction200 = {\n  /** The base64 encoded signed transaction. */\n  signedTransaction: string;\n};\n\nexport type SignSolanaMessageBody = {\n  /** The arbitrary message to sign. */\n  message: string;\n};\n\nexport type SignSolanaMessage200 = {\n  /** The signature of the message, as a base58 encoded string. */\n  signature: string;\n};\n\n/**\n * The Solana network to send the transaction to.\n */\nexport type SendSolanaTransactionBodyNetwork =\n  (typeof SendSolanaTransactionBodyNetwork)[keyof typeof SendSolanaTransactionBodyNetwork];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const SendSolanaTransactionBodyNetwork = {\n  solana: \"solana\",\n  \"solana-devnet\": \"solana-devnet\",\n} as const;\n\nexport type SendSolanaTransactionBody = {\n  /** The Solana network to send the transaction to. */\n  network: SendSolanaTransactionBodyNetwork;\n  /** The base64 encoded transaction to sign and send. This transaction can contain multiple instructions for native Solana batching. */\n  transaction: string;\n};\n\nexport type SendSolanaTransaction200 = {\n  /** The base58 encoded transaction signature. */\n  transactionSignature: string;\n};\n\n/**\n * The token to request funds for.\n */\nexport type RequestSolanaFaucetBodyToken =\n  (typeof RequestSolanaFaucetBodyToken)[keyof typeof RequestSolanaFaucetBodyToken];\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const RequestSolanaFaucetBodyToken = {\n  sol: \"sol\",\n  usdc: \"usdc\",\n} as const;\n\nexport type RequestSolanaFaucetBody = {\n  /**\n   * The address to request funds to, which is a base58-encoded string.\n   * @pattern ^[1-9A-HJ-NP-Za-km-z]{32,44}$\n   */\n  address: string;\n  /** The token to request funds for. */\n  token: RequestSolanaFaucetBodyToken;\n};\n\nexport type RequestSolanaFaucet200 = {\n  /** The signature identifying the transaction that requested the funds. */\n  transactionSignature: string;\n};\n\nexport type ListSolanaTokenBalancesParams = {\n  /**\n   * The number of balances to return per page.\n   */\n  pageSize?: number;\n  /**\n   * The token for the next page of balances. Will be empty if there are no more balances to fetch.\n   */\n  pageToken?: string;\n};\n\nexport type ListSolanaTokenBalances200AllOf = {\n  /** The list of Solana token balances. */\n  balances: SolanaTokenBalance[];\n};\n\nexport type ListSolanaTokenBalances200 = ListSolanaTokenBalances200AllOf & ListResponse;\n\nexport type ListDataTokenBalancesParams = {\n  /**\n   * The number of balances to return per page.\n   */\n  pageSize?: number;\n  /**\n   * The token for the next page of balances. Will be empty if there are no more balances to fetch.\n   */\n  pageToken?: string;\n};\n\nexport type ListDataTokenBalances200AllOf = {\n  /** The list of EVM token balances. */\n  balances: TokenBalance[];\n};\n\nexport type ListDataTokenBalances200 = ListDataTokenBalances200AllOf & ListResponse;\n\nexport type VerifyX402PaymentBody = {\n  x402Version: X402Version;\n  paymentPayload: X402PaymentPayload;\n  paymentRequirements: X402PaymentRequirements;\n};\n\nexport type SettleX402PaymentBody = {\n  x402Version: X402Version;\n  paymentPayload: X402PaymentPayload;\n  paymentRequirements: X402PaymentRequirements;\n};\n\nexport type CreateOnrampOrderBody = {\n  /** The timestamp of when the user acknowledged that by using Coinbase Onramp they are accepting the Coinbase Terms  (https://www.coinbase.com/legal/guest-checkout/us), User Agreement (https://www.coinbase.com/legal/user_agreement),  and Privacy Policy (https://www.coinbase.com/legal/privacy). */\n  agreementAcceptedAt: string;\n  /** The address the purchased crypto will be sent to. */\n  destinationAddress: string;\n  /** The name of the crypto network the purchased currency will be sent on.\n\nUse the [Onramp Buy Options API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-buy-options) to discover the supported networks for your user's location. */\n  destinationNetwork: string;\n  /** The verified email address of the user requesting the onramp transaction. This email must be verified by your app (via OTP) before being used with the Onramp API. */\n  email: string;\n  /** If true, this API will return a quote without creating any transaction. */\n  isQuote?: boolean;\n  /** Optional partner order reference ID. */\n  partnerOrderRef?: string;\n  /** A unique string that represents the user in your app. This can be used to link individual transactions  together so you can retrieve the transaction history for your users. Prefix this string with sandbox-  (e.g. \"sandbox-user-1234\") to perform a sandbox transaction which will allow you to test your integration  without any real transfer of funds.\n\nThis value can be used with with [Onramp User Transactions API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-onramp-transactions-by-id) to retrieve all transactions created by the user. */\n  partnerUserRef: string;\n  /** A string representing the amount of fiat the user wishes to pay in exchange for crypto. When using  this parameter, the returned quote will be inclusive of fees i.e. the user will pay this exact amount  of the payment currency. */\n  paymentAmount?: string;\n  /** The fiat currency to be converted to crypto. */\n  paymentCurrency: string;\n  paymentMethod: OnrampOrderPaymentMethodTypeId;\n  /** The phone number of the user requesting the onramp transaction in E.164 format. This phone number must  be verified by your app (via OTP) before being used with the Onramp API.\n\nPlease refer to the [Onramp docs](https://docs.cdp.coinbase.com/onramp-&-offramp/onramp-apis/apple-pay-onramp-api) for more details on phone number verification requirements and best practices. */\n  phoneNumber: string;\n  /** Timestamp of when the user's phone number was verified via OTP. User phone number must be verified  every 60 days. If this timestamp is older than 60 days, an error will be returned. */\n  phoneNumberVerifiedAt: string;\n  /** A string representing the amount of crypto the user wishes to purchase. When using this parameter the  returned quote will be exclusive of fees i.e. the user will receive this exact amount of the purchase  currency. */\n  purchaseAmount?: string;\n  /** The ticker (e.g. `BTC`, `USDC`, `SOL`) or the Coinbase UUID (e.g. `d85dce9b-5b73-5c3c-8978-522ce1d1c1b4`)  of the crypto asset to be purchased.\n\nUse the [Onramp Buy Options API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-buy-options) to discover the supported purchase currencies for your user's location. */\n  purchaseCurrency: string;\n  /** The IP address of the end user requesting the onramp transaction. */\n  clientIp?: string;\n  /** The domain that the Apple Pay button will be rendered on. Required when using the `GUEST_CHECKOUT_APPLE_PAY`  payment method and embedding the payment link in an iframe. */\n  domain?: string;\n};\n\nexport type CreateOnrampOrder201 = {\n  order: OnrampOrder;\n  paymentLink?: OnrampPaymentLink;\n};\n\nexport type GetOnrampOrderById200 = {\n  order: OnrampOrder;\n};\n\nexport type CreateOnrampSessionBody = {\n  /** The ticker (e.g. `BTC`, `USDC`, `SOL`) or the Coinbase UUID (e.g. `d85dce9b-5b73-5c3c-8978-522ce1d1c1b4`)  of the crypto asset to be purchased.\n\nUse the [Onramp Buy Options API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-buy-options) to discover the supported purchase currencies for your user's location. */\n  purchaseCurrency: string;\n  /** The name of the crypto network the purchased currency will be sent on.\n\nUse the [Onramp Buy Options API](https://docs.cdp.coinbase.com/api-reference/rest-api/onramp-offramp/get-buy-options) to discover the supported networks for your user's location. */\n  destinationNetwork: string;\n  /** The address the purchased crypto will be sent to. */\n  destinationAddress: string;\n  /** A string representing the amount of fiat the user wishes to pay in exchange for crypto. */\n  paymentAmount?: string;\n  /** The fiat currency to be converted to crypto. */\n  paymentCurrency?: string;\n  paymentMethod?: OnrampQuotePaymentMethodTypeId;\n  /** The ISO 3166-1 two letter country code (e.g. US). */\n  country?: string;\n  /** The ISO 3166-2 two letter state code (e.g. NY). Only required for US. */\n  subdivision?: string;\n  /** URL to redirect the user to when they successfully complete a transaction. This URL will be  embedded in the returned onramp URL as a query parameter. */\n  redirectUrl?: string;\n  /** The IP address of the end user requesting the onramp transaction. */\n  clientIp?: string;\n};\n\nexport type CreateOnrampSession201 = {\n  session: OnrampSession;\n  quote?: OnrampQuote;\n};\n","/**\n * To add a new error, follow the instructions at\n * https://github.com/anza-xyz/kit/tree/main/packages/errors/#adding-a-new-error\n *\n * @module\n * @privateRemarks\n * WARNING:\n *   - Don't remove error codes\n *   - Don't change or reorder error codes.\n *\n * Good naming conventions:\n *   - Prefixing common errors  e.g. under the same package  can be a good way to namespace them. E.g. All codec-related errors start with `SOLANA_ERROR__CODECS__`.\n *   - Use consistent names  e.g. choose `PDA` or `PROGRAM_DERIVED_ADDRESS` and stick with it. Ensure your names are consistent with existing error codes. The decision might have been made for you.\n *   - Recommended prefixes and suffixes:\n *     - `MALFORMED_`: Some input was not constructed properly. E.g. `MALFORMED_BASE58_ENCODED_ADDRESS`.\n *     - `INVALID_`: Some input is invalid (other than because it was MALFORMED). E.g. `INVALID_NUMBER_OF_BYTES`.\n *     - `EXPECTED_`: Some input was different than expected, no need to specify the \"GOT\" part unless necessary. E.g. `EXPECTED_DECODED_ACCOUNT`.\n *     - `_CANNOT_`: Some operation cannot be performed or some input cannot be used due to some condition. E.g. `CANNOT_DECODE_EMPTY_BYTE_ARRAY` or `PDA_CANNOT_END_WITH_PDA_MARKER`.\n *     - `_MUST_BE_`: Some condition must be true. E.g. `NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE`.\n *     - `_FAILED_TO_`: Tried to perform some operation and failed. E.g. `FAILED_TO_DECODE_ACCOUNT`.\n *     - `_NOT_FOUND`: Some operation lead to not finding something. E.g. `ACCOUNT_NOT_FOUND`.\n *     - `_OUT_OF_RANGE`: Some value is out of range. E.g. `ENUM_DISCRIMINATOR_OUT_OF_RANGE`.\n *     - `_EXCEEDED`: Some limit was exceeded. E.g. `PDA_MAX_SEED_LENGTH_EXCEEDED`.\n *     - `_MISMATCH`: Some elements do not match. E.g. `ENCODER_DECODER_FIXED_SIZE_MISMATCH`.\n *     - `_MISSING`: Some required input is missing. E.g. `TRANSACTION_FEE_PAYER_MISSING`.\n *     - `_UNIMPLEMENTED`: Some required component is not available in the environment. E.g. `SUBTLE_CRYPTO_VERIFY_FUNCTION_UNIMPLEMENTED`.\n */\nexport const SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;\nexport const SOLANA_ERROR__INVALID_NONCE = 2;\nexport const SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;\nexport const SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;\nexport const SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;\nexport const SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;\nexport const SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;\nexport const SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;\nexport const SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;\nexport const SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10;\n\n// JSON-RPC-related errors.\n// Reserve error codes in the range [-32768, -32000]\n// Keep in sync with https://github.com/anza-xyz/agave/blob/master/rpc-client-api/src/custom_error.rs\nexport const SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;\nexport const SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;\nexport const SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;\nexport const SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;\nexport const SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE = -32019;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY = -32018;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE = -32017;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;\nexport const SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;\n\n// Addresses-related errors.\n// Reserve error codes in the range [2800000-2800999].\nexport const SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 2800000;\nexport const SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;\nexport const SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;\nexport const SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;\nexport const SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;\nexport const SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;\nexport const SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;\nexport const SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011;\n\n// Account-related errors.\n// Reserve error codes in the range [3230000-3230999].\nexport const SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 3230000;\nexport const SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;\nexport const SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;\nexport const SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;\nexport const SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;\n\n// Subtle-Crypto-related errors.\n// Reserve error codes in the range [3610000-3610999].\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 3610000;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;\n\n// Crypto-related errors.\n// Reserve error codes in the range [3611000-3611050].\nexport const SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611000;\n\n// Key-related errors.\n// Reserve error codes in the range [3704000-3704999].\nexport const SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704000;\nexport const SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;\nexport const SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;\nexport const SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;\nexport const SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;\n\n// Instruction-related errors.\n// Reserve error codes in the range [4128000-4128999].\nexport const SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128000;\nexport const SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;\nexport const SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;\n\n// Instruction errors.\n// Reserve error codes starting with [4615000-4615999] for the Rust enum `InstructionError`.\n// Error names here are dictated by the RPC (see ./instruction-error.ts).\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615000;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;\n\n// Signer-related errors.\n// Reserve error codes in the range [5508000-5508999].\nexport const SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508000;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;\nexport const SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;\nexport const SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;\nexport const SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;\n\n// Transaction-related errors.\n// Reserve error codes in the range [5663000-5663999].\nexport const SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663000;\nexport const SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;\nexport const SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;\nexport const SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;\nexport const SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;\nexport const SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;\nexport const SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;\nexport const SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;\nexport const SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;\nexport const SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;\nexport const SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;\nexport const SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;\nexport const SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;\nexport const SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;\nexport const SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020;\n\n// Transaction errors.\n// Reserve error codes starting with [7050000-7050999] for the Rust enum `TransactionError`.\n// Error names here are dictated by the RPC (see ./transaction-error.ts).\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 7050000;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;\n// `InstructionError` intentionally omitted.\nexport const SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;\n\n// Instruction plan related errors.\n// Reserve error codes in the range [7618000-7618999].\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN = 7618000;\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE = 7618001;\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN = 7618002;\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN = 7618003;\n\n// Codec-related errors.\n// Reserve error codes in the range [8078000-8078999].\nexport const SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078000;\nexport const SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;\nexport const SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;\nexport const SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;\nexport const SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;\nexport const SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;\nexport const SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;\nexport const SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;\nexport const SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;\nexport const SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;\nexport const SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;\nexport const SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;\nexport const SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;\nexport const SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;\nexport const SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;\nexport const SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;\nexport const SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;\nexport const SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;\nexport const SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;\nexport const SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;\n\n// RPC-related errors.\n// Reserve error codes in the range [8100000-8100999].\nexport const SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 8100000;\nexport const SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;\nexport const SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;\nexport const SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;\n\n// RPC-Subscriptions-related errors.\n// Reserve error codes in the range [8190000-8190999].\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 8190000;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;\n\n// Invariant violation errors.\n// Reserve error codes in the range [9900000-9900999].\n// These errors should only be thrown when there is a bug with the\n// library itself and should, in theory, never reach the end user.\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 9900000;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND = 9900005;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND = 9900006;\n\n/**\n * A union of every Solana error code\n *\n * @privateRemarks\n * You might be wondering why this is not a TypeScript enum or const enum.\n *\n * One of the goals of this library is to enable people to use some or none of it without having to\n * bundle all of it.\n *\n * If we made the set of error codes an enum then anyone who imported it (even if to only use a\n * single error code) would be forced to bundle every code and its label.\n *\n * Const enums appear to solve this problem by letting the compiler inline only the codes that are\n * actually used. Unfortunately exporting ambient (const) enums from a library like `@solana/errors`\n * is not safe, for a variety of reasons covered here: https://stackoverflow.com/a/28818850\n */\nexport type SolanaErrorCode =\n    | typeof SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED\n    | typeof SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT\n    | typeof SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT\n    | typeof SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND\n    | typeof SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE\n    | typeof SOLANA_ERROR__ADDRESSES__MALFORMED_PDA\n    | typeof SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED\n    | typeof SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER\n    | typeof SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED\n    | typeof SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY\n    | typeof SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS\n    | typeof SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE\n    | typeof SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__INVALID_CONSTANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS\n    | typeof SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE\n    | typeof SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES\n    | typeof SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS\n    | typeof SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE\n    | typeof SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH\n    | typeof SOLANA_ERROR__INVALID_NONCE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE\n    | typeof SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__INVALID_PARAMS\n    | typeof SOLANA_ERROR__JSON_RPC__INVALID_REQUEST\n    | typeof SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND\n    | typeof SOLANA_ERROR__JSON_RPC__PARSE_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__SCAN_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION\n    | typeof SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY\n    | typeof SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__MALFORMED_BIGINT_STRING\n    | typeof SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR\n    | typeof SOLANA_ERROR__MALFORMED_NUMBER_STRING\n    | typeof SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD\n    | typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW\n    | typeof SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR\n    | typeof SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID\n    | typeof SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS\n    | typeof SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING\n    | typeof SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION\n    | typeof SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES\n    | typeof SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME\n    | typeof SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE\n    | typeof SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES\n    | typeof SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE\n    | typeof SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH\n    | typeof SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT;\n\n/**\n * Errors of this type are understood to have an optional {@link SolanaError} nested inside as\n * `cause`.\n */\nexport type SolanaErrorCodeWithCause = typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE;\n","import { secp256r1 } from '@noble/curves/p256'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as PublicKey from './PublicKey.js'\nimport type * as Signature from './Signature.js'\nimport * as Entropy from './internal/entropy.js'\n\n/** Re-export of noble/curves P256 utilities. */\nexport const noble = secp256r1\n\n/**\n * Computes the P256 ECDSA public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const publicKey = P256.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nexport function getPublicKey(\n  options: getPublicKey.Options,\n): PublicKey.PublicKey {\n  const { privateKey } = options\n  const point = secp256r1.ProjectivePoint.fromPrivateKey(\n    typeof privateKey === 'string'\n      ? privateKey.slice(2)\n      : Hex.fromBytes(privateKey).slice(2),\n  )\n  return PublicKey.from(point)\n}\n\nexport declare namespace getPublicKey {\n  type Options = {\n    /**\n     * Private key to compute the public key from.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Generates a random P256 ECDSA private key.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: randomPrivateKey.Options<as> = {},\n): randomPrivateKey.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const bytes = secp256r1.utils.randomPrivateKey()\n  if (as === 'Hex') return Hex.fromBytes(bytes) as never\n  return bytes as never\n}\n\nexport declare namespace randomPrivateKey {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Hex.fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Recovers the signing public key from the signed payload and signature.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey: '0x...' })\n *\n * const publicKey = P256.recoverPublicKey({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The recovery options.\n * @returns The recovered public key.\n */\nexport function recoverPublicKey(\n  options: recoverPublicKey.Options,\n): PublicKey.PublicKey {\n  const { payload, signature } = options\n  const { r, s, yParity } = signature\n  const signature_ = new secp256r1.Signature(\n    BigInt(r),\n    BigInt(s),\n  ).addRecoveryBit(yParity)\n  const payload_ =\n    payload instanceof Uint8Array ? Hex.fromBytes(payload) : payload\n  const point = signature_.recoverPublicKey(payload_.substring(2))\n  return PublicKey.from(point)\n}\n\nexport declare namespace recoverPublicKey {\n  type Options = {\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** Signature of the payload. */\n    signature: Signature.Signature\n  }\n\n  type ErrorType =\n    | PublicKey.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Signs the payload with the provided private key and returns a P256 signature.\n *\n * @example\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const signature = P256.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The ECDSA {@link ox#Signature.Signature}.\n */\nexport function sign(options: sign.Options): Signature.Signature {\n  const {\n    extraEntropy = Entropy.extraEntropy,\n    hash,\n    payload,\n    privateKey,\n  } = options\n  const { r, s, recovery } = secp256r1.sign(\n    payload instanceof Uint8Array ? payload : Bytes.fromHex(payload),\n    privateKey instanceof Uint8Array ? privateKey : Bytes.fromHex(privateKey),\n    {\n      extraEntropy:\n        typeof extraEntropy === 'boolean'\n          ? extraEntropy\n          : Hex.from(extraEntropy).slice(2),\n      lowS: true,\n      ...(hash ? { prehash: true } : {}),\n    },\n  )\n  return {\n    r,\n    s,\n    yParity: recovery,\n  }\n}\n\nexport declare namespace sign {\n  type Options = {\n    /**\n     * Extra entropy to add to the signing process. Setting to `false` will disable it.\n     * @default true\n     */\n    extraEntropy?: boolean | Hex.Hex | Bytes.Bytes | undefined\n    /**\n     * If set to `true`, the payload will be hashed (sha256) before being signed.\n     */\n    hash?: boolean | undefined\n    /**\n     * Payload to sign.\n     */\n    payload: Hex.Hex | Bytes.Bytes\n    /**\n     * ECDSA private key.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Bytes.fromHex.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a payload was signed by the provided public key.\n *\n * @example\n *\n * ```ts twoslash\n * import { P256 } from 'ox'\n *\n * const privateKey = P256.randomPrivateKey()\n * const publicKey = P256.getPublicKey({ privateKey })\n * const signature = P256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = P256.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nexport function verify(options: verify.Options): boolean {\n  const { hash, payload, publicKey, signature } = options\n  return secp256r1.verify(\n    signature,\n    payload instanceof Uint8Array ? payload : Bytes.fromHex(payload),\n    PublicKey.toHex(publicKey).substring(2),\n    ...(hash ? [{ prehash: true, lowS: true }] : []),\n  )\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** If set to `true`, the payload will be hashed (sha256) before being verified. */\n    hash?: boolean | undefined\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** Public key that signed the payload. */\n    publicKey: PublicKey.PublicKey<boolean>\n    /** Signature of the payload. */\n    signature: Signature.Signature<boolean>\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n","'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n *\n * @returns {Function}\n */\nexport default function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n}\n","import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { WalletPermission } from '../../types/eip1193.js'\nimport type { Prettify } from '../../types/utils.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type RequestPermissionsParameters = Prettify<\n  {\n    eth_accounts: Record<string, any>\n  } & {\n    [key: string]: Record<string, any>\n  }\n>\nexport type RequestPermissionsReturnType = WalletPermission[]\n\nexport type RequestPermissionsErrorType = RequestErrorType | ErrorType\n\n/**\n * Requests permissions for a wallet.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/requestPermissions\n * - JSON-RPC Methods: [`wallet_requestPermissions`](https://eips.ethereum.org/EIPS/eip-2255)\n *\n * @param client - Client to use\n * @param parameters - {@link RequestPermissionsParameters}\n * @returns The wallet permissions. {@link RequestPermissionsReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { requestPermissions } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const permissions = await requestPermissions(client, {\n *   eth_accounts: {}\n * })\n */\nexport async function requestPermissions<\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  permissions: RequestPermissionsParameters,\n) {\n  return client.request(\n    {\n      method: 'wallet_requestPermissions',\n      params: [permissions],\n    },\n    { retryCount: 0 },\n  )\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/payment/utils/validation.ts","import { z } from 'zod'\n\nimport type {\n  AbiConstructor as AbiConstructorType,\n  AbiEventParameter as AbiEventParameterType,\n  AbiFallback as AbiFallbackType,\n  AbiFunction as AbiFunctionType,\n  AbiParameter as AbiParameterType,\n  AbiReceive as AbiReceiveType,\n  Address as AddressType,\n  TypedData as TTypedData,\n} from './abi.js'\n\nimport { isSolidityType } from './human-readable/runtime/utils.js'\nimport { bytesRegex, execTyped, integerRegex } from './regex.js'\n\nconst Identifier = z.string().regex(/[a-zA-Z$_][a-zA-Z0-9$_]*/)\n\nexport const Address = z.string().transform((val, ctx) => {\n  const regex = /^0x[a-fA-F0-9]{40}$/\n\n  if (!regex.test(val)) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      message: `Invalid Address ${val}`,\n    })\n  }\n\n  return val as AddressType\n})\n\n// From https://docs.soliditylang.org/en/latest/abi-spec.html#types\nexport const SolidityAddress = z.literal('address')\nexport const SolidityBool = z.literal('bool')\nexport const SolidityBytes = z.string().regex(bytesRegex)\nexport const SolidityFunction = z.literal('function')\nexport const SolidityString = z.literal('string')\nexport const SolidityTuple = z.literal('tuple')\nexport const SolidityInt = z.string().regex(integerRegex)\nexport const SolidityArrayWithoutTuple = z\n  .string()\n  .regex(\n    /^(address|bool|function|string|bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?|u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?)(\\[[0-9]{0,}\\])+$/,\n  )\nexport const SolidityArrayWithTuple = z\n  .string()\n  .regex(/^tuple(\\[[0-9]{0,}\\])+$/)\nexport const SolidityArray = z.union([\n  SolidityArrayWithTuple,\n  SolidityArrayWithoutTuple,\n])\n\nexport const AbiParameter: z.ZodType<AbiParameterType> = z.lazy(() =>\n  z.intersection(\n    z.object({\n      name: z.union([Identifier.optional(), z.literal('')]),\n      /** Representation used by Solidity compiler */\n      internalType: z.string().optional(),\n    }),\n    z.union([\n      z.object({\n        type: z.union([\n          SolidityAddress,\n          SolidityBool,\n          SolidityBytes,\n          SolidityFunction,\n          SolidityString,\n          SolidityInt,\n          SolidityArrayWithoutTuple,\n        ]),\n      }),\n      z.object({\n        type: z.union([SolidityTuple, SolidityArrayWithTuple]),\n        components: z.array(AbiParameter).readonly(),\n      }),\n    ]),\n  ),\n)\n\nexport const AbiEventParameter: z.ZodType<AbiEventParameterType> =\n  z.intersection(AbiParameter, z.object({ indexed: z.boolean().optional() }))\n\nexport const AbiStateMutability = z.union([\n  z.literal('pure'),\n  z.literal('view'),\n  z.literal('nonpayable'),\n  z.literal('payable'),\n])\n\nexport const AbiFunction = z.preprocess(\n  (val) => {\n    const abiFunction = val as unknown as AbiFunctionType\n    // Calculate `stateMutability` for deprecated `constant` and `payable` fields\n    if (abiFunction.stateMutability === undefined) {\n      if (abiFunction.constant) abiFunction.stateMutability = 'view'\n      else if (abiFunction.payable) abiFunction.stateMutability = 'payable'\n      else abiFunction.stateMutability = 'nonpayable'\n    }\n    return val\n  },\n  z.object({\n    type: z.literal('function'),\n    /**\n     * @deprecated use `pure` or `view` from {@link AbiStateMutability} instead\n     * https://github.com/ethereum/solidity/issues/992\n     */\n    constant: z.boolean().optional(),\n    /**\n     * @deprecated Vyper used to provide gas estimates\n     * https://github.com/vyperlang/vyper/issues/2151\n     */\n    gas: z.number().optional(),\n    inputs: z.array(AbiParameter).readonly(),\n    name: Identifier,\n    outputs: z.array(AbiParameter).readonly(),\n    /**\n     * @deprecated use `payable` or `nonpayable` from {@link AbiStateMutability} instead\n     * https://github.com/ethereum/solidity/issues/992\n     */\n    payable: z.boolean().optional(),\n    stateMutability: AbiStateMutability,\n  }),\n)\n\nexport const AbiConstructor = z.preprocess(\n  (val) => {\n    const abiFunction = val as unknown as AbiConstructorType\n    // Calculate `stateMutability` for deprecated `payable` field\n    if (abiFunction.stateMutability === undefined) {\n      if (abiFunction.payable) abiFunction.stateMutability = 'payable'\n      else abiFunction.stateMutability = 'nonpayable'\n    }\n    return val\n  },\n  z.object({\n    type: z.literal('constructor'),\n    /**\n     * @deprecated use `pure` or `view` from {@link AbiStateMutability} instead\n     * https://github.com/ethereum/solidity/issues/992\n     */\n    inputs: z.array(AbiParameter).readonly(),\n    /**\n     * @deprecated use `payable` or `nonpayable` from {@link AbiStateMutability} instead\n     * https://github.com/ethereum/solidity/issues/992\n     */\n    payable: z.boolean().optional(),\n    stateMutability: z.union([z.literal('nonpayable'), z.literal('payable')]),\n  }),\n)\n\nexport const AbiFallback = z.preprocess(\n  (val) => {\n    const abiFunction = val as unknown as AbiFallbackType\n    // Calculate `stateMutability` for deprecated `payable` field\n    if (abiFunction.stateMutability === undefined) {\n      if (abiFunction.payable) abiFunction.stateMutability = 'payable'\n      else abiFunction.stateMutability = 'nonpayable'\n    }\n    return val\n  },\n  z.object({\n    type: z.literal('fallback'),\n    /**\n     * @deprecated use `payable` or `nonpayable` from {@link AbiStateMutability} instead\n     * https://github.com/ethereum/solidity/issues/992\n     */\n    payable: z.boolean().optional(),\n    stateMutability: z.union([z.literal('nonpayable'), z.literal('payable')]),\n  }),\n)\n\nexport const AbiReceive = z.object({\n  type: z.literal('receive'),\n  stateMutability: z.literal('payable'),\n})\n\nexport const AbiEvent = z.object({\n  type: z.literal('event'),\n  anonymous: z.boolean().optional(),\n  inputs: z.array(AbiEventParameter).readonly(),\n  name: Identifier,\n})\n\nexport const AbiError = z.object({\n  type: z.literal('error'),\n  inputs: z.array(AbiParameter).readonly(),\n  name: z.string(),\n})\n\nexport const AbiItemType = z.union([\n  z.literal('constructor'),\n  z.literal('event'),\n  z.literal('error'),\n  z.literal('fallback'),\n  z.literal('function'),\n  z.literal('receive'),\n])\n\n/**\n * Zod Schema for Contract [ABI Specification](https://docs.soliditylang.org/en/latest/abi-spec.html#json)\n *\n * @example\n * const parsedAbi = Abi.parse([])\n */\nexport const Abi = z\n  .array(\n    z.union([\n      AbiError,\n      AbiEvent,\n      // TODO: Replace code below to `z.switch` (https://github.com/colinhacks/zod/issues/2106)\n      // Need to redefine `AbiFunction | AbiConstructor | AbiFallback | AbiReceive` since `z.discriminate` doesn't support `z.preprocess` on `options`\n      // https://github.com/colinhacks/zod/issues/1490\n      z.preprocess(\n        (val) => {\n          const abiItem = val as\n            | AbiConstructorType\n            | AbiFallbackType\n            | AbiFunctionType\n            | AbiReceiveType\n          if (abiItem.type === 'receive') return abiItem\n          // Calculate `stateMutability` for deprecated fields: `constant` and `payable`\n          if (\n            (val as { stateMutability: AbiFunctionType['stateMutability'] })\n              .stateMutability === undefined\n          ) {\n            if (\n              abiItem.type === 'function' &&\n              (abiItem as AbiFunctionType).constant\n            )\n              abiItem.stateMutability = 'view'\n            else if (\n              (\n                abiItem as\n                  | AbiConstructorType\n                  | AbiFallbackType\n                  | AbiFunctionType\n              ).payable\n            )\n              abiItem.stateMutability = 'payable'\n            else abiItem.stateMutability = 'nonpayable'\n          }\n\n          return val\n        },\n        z.intersection(\n          z.object({\n            /**\n             * @deprecated use `pure` or `view` from {@link AbiStateMutability} instead\n             * https://github.com/ethereum/solidity/issues/992\n             */\n            constant: z.boolean().optional(),\n            /**\n             * @deprecated Vyper used to provide gas estimates\n             * https://github.com/vyperlang/vyper/issues/2151\n             */\n            gas: z.number().optional(),\n            /**\n             * @deprecated use `payable` or `nonpayable` from {@link AbiStateMutability} instead\n             * https://github.com/ethereum/solidity/issues/992\n             */\n            payable: z.boolean().optional(),\n          }),\n          z.discriminatedUnion('type', [\n            z.object({\n              type: z.literal('function'),\n              inputs: z.array(AbiParameter).readonly(),\n              name: z.string().regex(/[a-zA-Z$_][a-zA-Z0-9$_]*/),\n              outputs: z.array(AbiParameter).readonly(),\n              stateMutability: AbiStateMutability,\n            }),\n            z.object({\n              type: z.literal('constructor'),\n              inputs: z.array(AbiParameter).readonly(),\n              stateMutability: z.union([\n                z.literal('payable'),\n                z.literal('nonpayable'),\n              ]),\n            }),\n            z.object({\n              type: z.literal('fallback'),\n              inputs: z.tuple([]).optional(),\n              stateMutability: z.union([\n                z.literal('payable'),\n                z.literal('nonpayable'),\n              ]),\n            }),\n            z.object({\n              type: z.literal('receive'),\n              stateMutability: z.literal('payable'),\n            }),\n          ]),\n        ),\n      ),\n    ]),\n  )\n  .readonly()\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// Typed Data Types\n\nexport const TypedDataDomain = z.object({\n  chainId: z.number().optional(),\n  name: Identifier.optional(),\n  salt: z.string().optional(),\n  verifyingContract: Address.optional(),\n  version: z.string().optional(),\n})\n\nexport const TypedDataType = z.union([\n  SolidityAddress,\n  SolidityBool,\n  SolidityBytes,\n  SolidityString,\n  SolidityInt,\n  SolidityArray,\n])\n\nexport const TypedDataParameter = z.object({\n  name: Identifier,\n  type: z.string(),\n})\n\nexport const TypedData = z\n  .record(Identifier, z.array(TypedDataParameter))\n  .transform((val, ctx) => validateTypedDataKeys(val, ctx))\n\n// Helper Functions.\nfunction validateTypedDataKeys(\n  typedData: Record<string, { type: string; name: string }[]>,\n  zodContext: z.RefinementCtx,\n): TTypedData {\n  const keys = Object.keys(typedData)\n\n  for (let i = 0; i < keys.length; i++) {\n    if (isSolidityType(keys[i]!)) {\n      zodContext.addIssue({\n        code: 'custom',\n        message: `Invalid key. ${keys[i]} is a solidity type.`,\n      })\n\n      return z.NEVER\n    }\n\n    validateTypedDataParameters(keys[i]!, typedData, zodContext)\n  }\n\n  return typedData as any\n}\n\nconst typeWithoutTupleRegex =\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*?)(?<array>(?:\\[\\d*?\\])+?)?$/\n\nfunction validateTypedDataParameters(\n  key: string,\n  typedData: Record<string, { type: string; name: string }[]>,\n  zodContext: z.RefinementCtx,\n  ancestors = new Set<string>(),\n) {\n  const val = typedData[key] as { type: string; name: string }[]\n  const length = val.length\n\n  for (let i = 0; i < length; i++) {\n    if (val[i]?.type! === key) {\n      zodContext.addIssue({\n        code: 'custom',\n        message: `Invalid type. ${key} is a self reference.`,\n      })\n\n      return z.NEVER\n    }\n    const match = execTyped<{ array?: string; type: string }>(\n      typeWithoutTupleRegex,\n      val[i]?.type!,\n    )\n\n    if (!match?.type) {\n      zodContext.addIssue({\n        code: 'custom',\n        message: `Invalid type. ${key} does not have a type.`,\n      })\n\n      return z.NEVER\n    }\n\n    if (match.type in typedData) {\n      if (ancestors.has(match.type)) {\n        zodContext.addIssue({\n          code: 'custom',\n          message: `Invalid type. ${match.type} is a circular reference.`,\n        })\n\n        return z.NEVER\n      }\n\n      validateTypedDataParameters(\n        match.type,\n        typedData,\n        zodContext,\n        new Set([...ancestors, match.type]),\n      )\n    } else if (!isSolidityType(match.type)) {\n      zodContext.addIssue({\n        code: 'custom',\n        message: `Invalid type. ${match.type} is not a valid EIP-712 type.`,\n      })\n    }\n  }\n\n  return\n}\n","import { InvalidDecimalNumberError } from '../../errors/unit.js'\nimport type { ErrorType } from '../../errors/utils.js'\n\nexport type ParseUnitsErrorType = ErrorType\n\n/**\n * Multiplies a string representation of a number by a given exponent of base 10 (10exponent).\n *\n * - Docs: https://viem.sh/docs/utilities/parseUnits\n *\n * @example\n * import { parseUnits } from 'viem'\n *\n * parseUnits('420', 9)\n * // 420000000000n\n */\nexport function parseUnits(value: string, decimals: number) {\n  if (!/^(-?)([0-9]*)\\.?([0-9]*)$/.test(value))\n    throw new InvalidDecimalNumberError({ value })\n\n  let [integer, fraction = '0'] = value.split('.')\n\n  const negative = integer.startsWith('-')\n  if (negative) integer = integer.slice(1)\n\n  // trim trailing zeros.\n  fraction = fraction.replace(/(0+)$/, '')\n\n  // round off if the fraction is larger than the number of decimals.\n  if (decimals === 0) {\n    if (Math.round(Number(`.${fraction}`)) === 1)\n      integer = `${BigInt(integer) + 1n}`\n    fraction = ''\n  } else if (fraction.length > decimals) {\n    const [left, unit, right] = [\n      fraction.slice(0, decimals - 1),\n      fraction.slice(decimals - 1, decimals),\n      fraction.slice(decimals),\n    ]\n\n    const rounded = Math.round(Number(`${unit}.${right}`))\n    if (rounded > 9)\n      fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, '0')\n    else fraction = `${left}${rounded}`\n\n    if (fraction.length > decimals) {\n      fraction = fraction.slice(1)\n      integer = `${BigInt(integer) + 1n}`\n    }\n\n    fraction = fraction.slice(0, decimals)\n  } else {\n    fraction = fraction.padEnd(decimals, '0')\n  }\n\n  return BigInt(`${negative ? '-' : ''}${integer}${fraction}`)\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/payment/utils/translatePayment.ts","import type {\n  CdpOpenApiClient,\n  ListResponse,\n  SpendPermissionResponseObject as SpendPermissionResponseObjectApi,\n} from \"../../openapi-client/index.js\";\nimport type {\n  ListSpendPermissionsOptions,\n  SpendPermission,\n} from \"../../spend-permissions/types.js\";\nimport type { Address, Hex } from \"../../types/misc.js\";\n\nexport type SpendPermissionResponseObject = Omit<\n  SpendPermissionResponseObjectApi,\n  \"permission\" | \"permissionHash\"\n> & {\n  permissionHash: Hex;\n  permission: SpendPermission;\n};\n\nexport type ListSpendPermissionsResult = ListResponse & {\n  spendPermissions: SpendPermissionResponseObject[];\n};\n\n/**\n * Lists the spend permissions for a smart account.\n *\n * @param client - The OpenApiClient instance.\n * @param options - The options for listing the spend permissions.\n *\n * @returns A promise that resolves to the spend permissions.\n */\nexport async function listSpendPermissions(\n  client: typeof CdpOpenApiClient,\n  options: ListSpendPermissionsOptions,\n): Promise<ListSpendPermissionsResult> {\n  const result = await client.listSpendPermissions(options.address, {\n    pageSize: options.pageSize,\n    pageToken: options.pageToken,\n  });\n\n  return {\n    spendPermissions: result.spendPermissions.map(permission => ({\n      ...permission,\n      permissionHash: permission.permissionHash as Hex,\n      permission: {\n        ...permission.permission,\n        account: permission.permission.account as Address,\n        spender: permission.permission.spender as Address,\n        token: permission.permission.token as Address,\n        allowance: BigInt(permission.permission.allowance),\n        period: Number(permission.permission.period),\n        start: Number(permission.permission.start),\n        end: Number(permission.permission.end),\n        salt: BigInt(permission.permission.salt),\n        extraData: permission.permission.extraData as Hex,\n      },\n    })),\n  };\n}\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const megaethTestnet = /*#__PURE__*/ defineChain({\n  id: 6342,\n  blockTime: 1_000,\n  name: 'MegaETH Testnet',\n  nativeCurrency: {\n    name: 'MegaETH Testnet Ether',\n    symbol: 'ETH',\n    decimals: 18,\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://carrot.megaeth.com/rpc'],\n      webSocket: ['wss://carrot.megaeth.com/ws'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'MegaETH Testnet Explorer',\n      url: 'https://www.megaexplorer.xyz/',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n    },\n  },\n  testnet: true,\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const taiko = /*#__PURE__*/ defineChain({\n  id: 167000,\n  name: 'Taiko Mainnet',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'Ether',\n    symbol: 'ETH',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://rpc.mainnet.taiko.xyz'],\n      webSocket: ['wss://ws.mainnet.taiko.xyz'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Taikoscan',\n      url: 'https://taikoscan.io',\n      apiUrl: 'https://api.taikoscan.io/api',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xcb2436774C3e191c85056d248EF4260ce5f27A9D',\n    },\n  },\n})\n","import { chainConfig } from '../../op-stack/chainConfig.js'\nimport { defineChain } from '../../utils/chain/defineChain.js'\n\nconst sourceId = 11_155_111 // sepolia\n\nexport const funkiSepolia = defineChain({\n  ...chainConfig,\n  id: 3397901,\n  network: 'funkiSepolia',\n  name: 'Funki Sepolia Sandbox',\n  nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: ['https://funki-testnet.alt.technology'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Funki Sepolia Sandbox Explorer',\n      url: 'https://sepolia-sandbox.funkichain.com/',\n    },\n  },\n  testnet: true,\n  contracts: {\n    ...chainConfig.contracts,\n    multicall3: {\n      address: '0xca11bde05977b3631167028862be2a173976ca11',\n      blockCreated: 1620204,\n    },\n  },\n  sourceId,\n})\n","import type * as Errors from './Errors.js'\n\nconst bigIntSuffix = '#__bigint'\n\n/**\n * Parses a JSON string, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.parse('{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}')\n * // @log: {\n * // @log:   foo: 'bar',\n * // @log:   baz: 69420694206942069420694206942069420694206942069420n\n * // @log: }\n * ```\n *\n * @param string - The value to parse.\n * @param reviver - A function that transforms the results.\n * @returns The parsed value.\n */\nexport function parse(\n  string: string,\n  reviver?: ((this: any, key: string, value: any) => any) | undefined,\n) {\n  return JSON.parse(string, (key, value_) => {\n    const value = value_\n    if (typeof value === 'string' && value.endsWith(bigIntSuffix))\n      return BigInt(value.slice(0, -bigIntSuffix.length))\n    return typeof reviver === 'function' ? reviver(key, value) : value\n  })\n}\n\nexport declare namespace parse {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Stringifies a value to its JSON representation, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.stringify({\n *   foo: 'bar',\n *   baz: 69420694206942069420694206942069420694206942069420n,\n * })\n * // @log: '{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}'\n * ```\n *\n * @param value - The value to stringify.\n * @param replacer - A function that transforms the results. It is passed the key and value of the property, and must return the value to be used in the JSON string. If this function returns `undefined`, the property is not included in the resulting JSON string.\n * @param space - A string or number that determines the indentation of the JSON string. If it is a number, it indicates the number of spaces to use as indentation; if it is a string (e.g. `'\\t'`), it uses the string as the indentation character.\n * @returns The JSON string.\n */\nexport function stringify(\n  value: any,\n  replacer?: ((this: any, key: string, value: any) => any) | null | undefined,\n  space?: string | number | undefined,\n) {\n  return JSON.stringify(\n    value,\n    (key, value) => {\n      if (typeof replacer === 'function') return replacer(key, value)\n      if (typeof value === 'bigint') return value.toString() + bigIntSuffix\n      return value\n    },\n    space,\n  )\n}\n\nexport declare namespace stringify {\n  type ErrorType = Errors.GlobalErrorType\n}\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const tac = /*#__PURE__*/ defineChain({\n  id: 239,\n  name: 'TAC',\n  nativeCurrency: { name: 'TAC', symbol: 'TAC', decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: ['https://rpc.ankr.com/tac'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Blockscout',\n      url: 'https://tac.blockscout.com',\n      apiUrl: 'https://tac.blockscout.com/api',\n    },\n    native: {\n      name: 'TAC Explorer',\n      url: 'https://explorer.tac.build',\n      apiUrl: 'https://explorer.tac.build/api',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xca11bde05977b3631167028862be2a173976ca11',\n      blockCreated: 0,\n    },\n  },\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const chiliz = /*#__PURE__*/ defineChain({\n  id: 88_888,\n  name: 'Chiliz Chain',\n  network: 'chiliz-chain',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'CHZ',\n    symbol: 'CHZ',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://rpc.chiliz.com'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Chiliz Explorer',\n      url: 'https://scan.chiliz.com',\n      apiUrl: 'https://scan.chiliz.com/api',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 8080847,\n    },\n  },\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const zkFair = /*#__PURE__*/ defineChain({\n  id: 42766,\n  name: 'ZKFair Mainnet',\n  network: 'zkfair-mainnet',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'USD Coin',\n    symbol: 'USDC',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://rpc.zkfair.io'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'zkFair Explorer',\n      url: 'https://scan.zkfair.io',\n      apiUrl: 'https://scan.zkfair.io/api',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xca11bde05977b3631167028862be2a173976ca11',\n      blockCreated: 6090959,\n    },\n  },\n  testnet: false,\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const beamTestnet = /*#__PURE__*/ defineChain({\n  id: 13337,\n  name: 'Beam Testnet',\n  network: 'beam',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'Beam',\n    symbol: 'BEAM',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://build.onbeam.com/rpc/testnet'],\n      webSocket: ['wss://build.onbeam.com/ws/testnet'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Beam Explorer',\n      url: 'https://subnets-test.avax.network/beam',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0x9bf49b704ee2a095b95c1f2d4eb9010510c41c9e',\n      blockCreated: 3,\n    },\n  },\n  testnet: true,\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const moonriver = /*#__PURE__*/ defineChain({\n  id: 1285,\n  name: 'Moonriver',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'MOVR',\n    symbol: 'MOVR',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://moonriver.public.blastapi.io'],\n      webSocket: ['wss://moonriver.public.blastapi.io'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Moonscan',\n      url: 'https://moonriver.moonscan.io',\n      apiUrl: 'https://api-moonriver.moonscan.io/api',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 1597904,\n    },\n  },\n  testnet: false,\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const rolluxTestnet = /*#__PURE__*/ defineChain({\n  id: 57000,\n  name: 'Rollux Testnet',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'Syscoin',\n    symbol: 'SYS',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://rpc-tanenbaum.rollux.com/'],\n      webSocket: ['wss://rpc-tanenbaum.rollux.com/wss'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'RolluxTestnetExplorer',\n      url: 'https://rollux.tanenbaum.io',\n      apiUrl: 'https://rollux.tanenbaum.io/api',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 1813675,\n    },\n  },\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const moonbeam = /*#__PURE__*/ defineChain({\n  id: 1284,\n  name: 'Moonbeam',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'GLMR',\n    symbol: 'GLMR',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://moonbeam.public.blastapi.io'],\n      webSocket: ['wss://moonbeam.public.blastapi.io'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Moonscan',\n      url: 'https://moonscan.io',\n      apiUrl: 'https://api-moonbeam.moonscan.io/api',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 609002,\n    },\n  },\n  testnet: false,\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const syscoin = /*#__PURE__*/ defineChain({\n  id: 57,\n  name: 'Syscoin Mainnet',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'Syscoin',\n    symbol: 'SYS',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://rpc.syscoin.org'],\n      webSocket: ['wss://rpc.syscoin.org/wss'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'SyscoinExplorer',\n      url: 'https://explorer.syscoin.org',\n      apiUrl: 'https://explorer.syscoin.org/api',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 287139,\n    },\n  },\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const moonbaseAlpha = /*#__PURE__*/ defineChain({\n  id: 1287,\n  name: 'Moonbase Alpha',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'DEV',\n    symbol: 'DEV',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://rpc.api.moonbase.moonbeam.network'],\n      webSocket: ['wss://wss.api.moonbase.moonbeam.network'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Moonscan',\n      url: 'https://moonbase.moonscan.io',\n      apiUrl: 'https://moonbase.moonscan.io/api',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 1850686,\n    },\n  },\n  testnet: true,\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const beam = /*#__PURE__*/ defineChain({\n  id: 4337,\n  name: 'Beam',\n  network: 'beam',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'Beam',\n    symbol: 'BEAM',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://build.onbeam.com/rpc'],\n      webSocket: ['wss://build.onbeam.com/ws'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Beam Explorer',\n      url: 'https://subnets.avax.network/beam',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0x4956f15efdc3dc16645e90cc356eafa65ffc65ec',\n      blockCreated: 1,\n    },\n  },\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const mantaSepoliaTestnet = /*#__PURE__*/ defineChain({\n  id: 3_441_006,\n  name: 'Manta Pacific Sepolia Testnet',\n  network: 'manta-sepolia',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'ETH',\n    symbol: 'ETH',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://pacific-rpc.sepolia-testnet.manta.network/http'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Manta Sepolia Testnet Explorer',\n      url: 'https://pacific-explorer.sepolia-testnet.manta.network',\n      apiUrl: 'https://pacific-explorer.sepolia-testnet.manta.network/api',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xca54918f7B525C8df894668846506767412b53E3',\n      blockCreated: 479584,\n    },\n  },\n  testnet: true,\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const flame = /*#__PURE__*/ defineChain({\n  id: 253368190,\n  name: 'Flame',\n  network: 'flame',\n  nativeCurrency: {\n    symbol: 'TIA',\n    name: 'TIA',\n    decimals: 18,\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://rpc.flame.astria.org'],\n      webSocket: ['wss://ws.flame.astria.org'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Flame Explorer',\n      url: 'https://explorer.flame.astria.org',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 6829148,\n    },\n  },\n})\n","import type { Address } from 'abitype'\n\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type {\n  Capabilities,\n  ChainIdToCapabilities,\n  ExtractCapabilities,\n} from '../../types/capabilities.js'\nimport type { Prettify } from '../../types/utils.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\n\nexport type GetCapabilitiesParameters<\n  chainId extends number | undefined = undefined,\n> = {\n  account?: Account | Address | undefined\n  chainId?: chainId | number | undefined\n}\n\nexport type GetCapabilitiesReturnType<\n  chainId extends number | undefined = undefined,\n> = Prettify<\n  chainId extends number\n    ? ExtractCapabilities<'getCapabilities', 'ReturnType'>\n    : ChainIdToCapabilities<\n        Capabilities<ExtractCapabilities<'getCapabilities', 'ReturnType'>>,\n        number\n      >\n>\n\nexport type GetCapabilitiesErrorType = RequestErrorType | ErrorType\n\n/**\n * Extract capabilities that a connected wallet supports (e.g. paymasters, session keys, etc).\n *\n * - Docs: https://viem.sh/docs/actions/wallet/getCapabilities\n * - JSON-RPC Methods: [`wallet_getCapabilities`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns The wallet's capabilities. {@link GetCapabilitiesReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getCapabilities } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const capabilities = await getCapabilities(client)\n */\nexport async function getCapabilities<\n  chainId extends number | undefined = undefined,\n>(\n  client: Client<Transport>,\n  parameters: GetCapabilitiesParameters<chainId> = {},\n): Promise<GetCapabilitiesReturnType<chainId>> {\n  const { account = client.account, chainId } = parameters\n\n  const account_ = account ? parseAccount(account) : undefined\n\n  const params = chainId\n    ? ([account_?.address, [numberToHex(chainId)]] as const)\n    : ([account_?.address] as const)\n  const capabilities_raw = await client.request({\n    method: 'wallet_getCapabilities',\n    params,\n  })\n\n  const capabilities = {} as ChainIdToCapabilities<\n    ExtractCapabilities<'getCapabilities', 'ReturnType'>,\n    number\n  >\n  for (const [chainId, capabilities_] of Object.entries(capabilities_raw)) {\n    capabilities[Number(chainId)] = {}\n    for (let [key, value] of Object.entries(capabilities_)) {\n      if (key === 'addSubAccount') key = 'unstable_addSubAccount'\n      capabilities[Number(chainId)][key] = value\n    }\n  }\n  return (\n    typeof chainId === 'number' ? capabilities[chainId] : capabilities\n  ) as never\n}\n","import { fixEncoderSize, transformEncoder, VariableSizeEncoder } from '@solana/codecs-core';\nimport { getArrayEncoder, getBytesEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Encoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\n\nimport { SignaturesMap } from '../transaction';\n\nfunction getSignaturesToEncode(signaturesMap: SignaturesMap): SignatureBytes[] {\n    const signatures = Object.values(signaturesMap);\n    if (signatures.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES);\n    }\n\n    return signatures.map(signature => {\n        if (!signature) {\n            return new Uint8Array(64).fill(0) as SignatureBytes;\n        }\n        return signature;\n    });\n}\n\nexport function getSignaturesEncoder(): VariableSizeEncoder<SignaturesMap> {\n    return transformEncoder(\n        getArrayEncoder(fixEncoderSize(getBytesEncoder(), 64), { size: getShortU16Encoder() }),\n        getSignaturesToEncode,\n    );\n}\n","import { chainConfig } from '../../op-stack/chainConfig.js'\nimport { defineChain } from '../../utils/chain/defineChain.js'\n\nconst sourceId = 56 // bsc mainnet\n\nexport const opBNB = /*#__PURE__*/ defineChain({\n  id: 204,\n  name: 'opBNB',\n  nativeCurrency: {\n    name: 'BNB',\n    symbol: 'BNB',\n    decimals: 18,\n  },\n  rpcUrls: {\n    default: { http: ['https://opbnb-mainnet-rpc.bnbchain.org'] },\n  },\n  blockExplorers: {\n    default: {\n      name: 'opBNB (BSCScan)',\n      url: 'https://opbnb.bscscan.com',\n      apiUrl: 'https://api-opbnb.bscscan.com/api',\n    },\n  },\n  contracts: {\n    ...chainConfig.contracts,\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 512881,\n    },\n    l2OutputOracle: {\n      [sourceId]: {\n        address: '0x153CAB79f4767E2ff862C94aa49573294B13D169',\n      },\n    },\n    portal: {\n      [sourceId]: {\n        address: '0x1876EA7702C0ad0C6A2ae6036DE7733edfBca519',\n      },\n    },\n    l1StandardBridge: {\n      [sourceId]: {\n        address: '0xF05F0e4362859c3331Cb9395CBC201E3Fa6757Ea',\n      },\n    },\n  },\n  sourceId,\n})\n","import { sendSwapOperation } from \"./sendSwapOperation.js\";\nimport { sendSwapTransaction } from \"./sendSwapTransaction.js\";\nimport {\n  CreateSwapQuoteOptions,\n  CreateSwapQuoteResult,\n  ExecuteSwapQuoteOptions,\n  ExecuteSwapQuoteResult,\n  SwapUnavailableResult,\n} from \"../../../client/evm/evm.types.js\";\nimport {\n  CdpOpenApiClientType,\n  CreateSwapQuoteResponse,\n  type SendEvmTransactionBodyNetwork,\n  type EvmUserOperationNetwork,\n} from \"../../../openapi-client/index.js\";\nimport { Address, Hex } from \"../../../types/misc.js\";\n\nimport type { EvmSmartAccount } from \"../../../accounts/evm/types.js\";\n\n/**\n * Creates a quote for a swap between two tokens on an EVM network.\n *\n * @param {CdpOpenApiClientType} client - The client to use to create the swap quote.\n * @param {CreateSwapQuoteOptions} options - The options for creating a swap quote.\n *\n * @returns {Promise<CreateSwapQuoteResult | SwapUnavailableResult>} A promise that resolves to the swap quote result or a response indicating that liquidity is unavailable.\n *\n * @example **Creating a swap quote**\n * ```ts\n * const swapQuote = await createSwapQuote(client, {\n *   network: \"ethereum\",\n *   toToken: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\", // USDC\n *   fromToken: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\", // WETH\n *   fromAmount: BigInt(\"1000000000000000000\"), // 1 WETH in wei\n *   taker: \"0x1234567890123456789012345678901234567890\"\n * });\n * ```\n */\nexport async function createSwapQuote(\n  client: CdpOpenApiClientType,\n  options: CreateSwapQuoteOptions,\n): Promise<CreateSwapQuoteResult | SwapUnavailableResult> {\n  // Validate required parameters\n  if (!options.taker) {\n    throw new Error(\"taker is required for createSwapQuote\");\n  }\n\n  // Store validated taker for type safety\n  const taker = options.taker as Address;\n\n  // Call the createEvmSwapQuote function directly with the client's configured API\n  const response = await client.createEvmSwapQuote(\n    {\n      network: options.network,\n      toToken: options.toToken,\n      fromToken: options.fromToken,\n      fromAmount: options.fromAmount.toString(),\n      taker: taker,\n      signerAddress: options.signerAddress,\n      gasPrice: options.gasPrice?.toString(),\n      slippageBps: options.slippageBps,\n    },\n    options.idempotencyKey,\n  );\n\n  // Check if liquidity is unavailable\n  if (!response.liquidityAvailable) {\n    // Return the SwapUnavailableResult\n    return {\n      liquidityAvailable: false,\n    };\n  }\n\n  // At this point we know it's a CreateSwapQuoteResponse with liquidityAvailable as true\n  const swapResponse = response as CreateSwapQuoteResponse;\n  const result: CreateSwapQuoteResult = {\n    liquidityAvailable: true,\n    network: options.network,\n    toToken: swapResponse.toToken as Address,\n    fromToken: swapResponse.fromToken as Address,\n    fromAmount: BigInt(swapResponse.fromAmount),\n    toAmount: BigInt(swapResponse.toAmount),\n    minToAmount: BigInt(swapResponse.minToAmount),\n    blockNumber: BigInt(swapResponse.blockNumber),\n    fees: {\n      gasFee: swapResponse.fees.gasFee\n        ? {\n            amount: BigInt(swapResponse.fees.gasFee.amount),\n            token: swapResponse.fees.gasFee.token as Address,\n          }\n        : undefined,\n      protocolFee: swapResponse.fees.protocolFee\n        ? {\n            amount: BigInt(swapResponse.fees.protocolFee.amount),\n            token: swapResponse.fees.protocolFee.token as Address,\n          }\n        : undefined,\n    },\n    issues: {\n      allowance: swapResponse.issues.allowance\n        ? {\n            currentAllowance: BigInt(swapResponse.issues.allowance.currentAllowance),\n            spender: swapResponse.issues.allowance.spender as Address,\n          }\n        : undefined,\n      balance: swapResponse.issues.balance\n        ? {\n            token: swapResponse.issues.balance.token as Address,\n            currentBalance: BigInt(swapResponse.issues.balance.currentBalance),\n            requiredBalance: BigInt(swapResponse.issues.balance.requiredBalance),\n          }\n        : undefined,\n      simulationIncomplete: swapResponse.issues.simulationIncomplete,\n    },\n    transaction: swapResponse.transaction\n      ? {\n          to: swapResponse.transaction.to as Address,\n          data: swapResponse.transaction.data as Hex,\n          value: BigInt(swapResponse.transaction.value),\n          gas: BigInt(swapResponse.transaction.gas),\n          gasPrice: BigInt(swapResponse.transaction.gasPrice),\n        }\n      : undefined,\n    permit2: swapResponse.permit2\n      ? {\n          eip712: {\n            domain: {\n              ...swapResponse.permit2.eip712.domain,\n              verifyingContract: swapResponse.permit2.eip712.domain.verifyingContract as\n                | Address\n                | undefined,\n              salt: swapResponse.permit2.eip712.domain.salt as Hex | undefined,\n            },\n            types: swapResponse.permit2.eip712.types,\n            primaryType: swapResponse.permit2.eip712.primaryType,\n            message: swapResponse.permit2.eip712.message,\n          },\n        }\n      : undefined,\n    // Add the execute method\n    execute: async (\n      executeOptions: ExecuteSwapQuoteOptions = {},\n    ): Promise<ExecuteSwapQuoteResult> => {\n      if (options.smartAccount) {\n        // Smart account execution - use sendSwapOperation\n        const userOpResult = await sendSwapOperation(client, {\n          smartAccount: options.smartAccount as EvmSmartAccount,\n          network: result.network as EvmUserOperationNetwork,\n          swapQuote: result,\n          idempotencyKey: executeOptions.idempotencyKey,\n        });\n\n        return {\n          userOpHash: userOpResult.userOpHash,\n          smartAccountAddress: userOpResult.smartAccountAddress,\n          status: userOpResult.status,\n        };\n      } else {\n        // EOA execution - use sendSwapTransaction\n        const { transactionHash } = await sendSwapTransaction(client, {\n          address: taker,\n          network: result.network as SendEvmTransactionBodyNetwork,\n          swapQuote: result,\n          idempotencyKey: executeOptions.idempotencyKey,\n        });\n\n        return { transactionHash };\n      }\n    },\n  };\n\n  return result;\n}\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nconst sourceId = 11_155_111 // sepolia\n\nexport const blastSepolia = /*#__PURE__*/ defineChain({\n  id: 168_587_773,\n  name: 'Blast Sepolia',\n  nativeCurrency: {\n    name: 'Ether',\n    symbol: 'ETH',\n    decimals: 18,\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://sepolia.blast.io'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Blastscan',\n      url: 'https://sepolia.blastscan.io',\n      apiUrl: 'https://api-sepolia.blastscan.io/api',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xca11bde05977b3631167028862be2a173976ca11',\n      blockCreated: 756690,\n    },\n  },\n  testnet: true,\n  sourceId,\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const arbitrumSepolia = /*#__PURE__*/ defineChain({\n  id: 421_614,\n  name: 'Arbitrum Sepolia',\n  blockTime: 250,\n  nativeCurrency: {\n    name: 'Arbitrum Sepolia Ether',\n    symbol: 'ETH',\n    decimals: 18,\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://sepolia-rollup.arbitrum.io/rpc'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Arbiscan',\n      url: 'https://sepolia.arbiscan.io',\n      apiUrl: 'https://api-sepolia.arbiscan.io/api',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xca11bde05977b3631167028862be2a173976ca11',\n      blockCreated: 81930,\n    },\n  },\n  testnet: true,\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const eduChainTestnet = /*#__PURE__*/ defineChain({\n  id: 656476,\n  name: 'EDU Chain Testnet',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'EDU',\n    symbol: 'EDU',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://rpc.open-campus-codex.gelato.digital/'],\n      webSocket: ['wss://ws.open-campus-codex.gelato.digital'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'EDU Chain Testnet Explorer',\n      url: 'https://opencampus-codex.blockscout.com',\n      apiUrl: 'https://opencampus-codex.blockscout.com/api',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 15514133,\n    },\n  },\n  testnet: true,\n})\n","import { chainConfig } from '../../op-stack/chainConfig.js'\nimport { defineChain } from '../../utils/chain/defineChain.js'\n\nconst sourceId = 1 // mainnet\n\nexport const unichain = /*#__PURE__*/ defineChain({\n  ...chainConfig,\n  id: 130,\n  name: 'Unichain',\n  nativeCurrency: { name: 'Ether', symbol: 'ETH', decimals: 18 },\n  blockTime: 1_000,\n  rpcUrls: {\n    default: {\n      http: ['https://mainnet.unichain.org/'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Uniscan',\n      url: 'https://uniscan.xyz',\n      apiUrl: 'https://api.uniscan.xyz/api',\n    },\n  },\n  contracts: {\n    ...chainConfig.contracts,\n    multicall3: {\n      address: '0xca11bde05977b3631167028862be2a173976ca11',\n      blockCreated: 0,\n    },\n    disputeGameFactory: {\n      [sourceId]: {\n        address: '0x2F12d621a16e2d3285929C9996f478508951dFe4',\n      },\n    },\n    portal: {\n      [sourceId]: {\n        address: '0x0bd48f6B86a26D3a217d0Fa6FfE2B491B956A7a2',\n      },\n    },\n    l1StandardBridge: {\n      [sourceId]: {\n        address: '0x81014F44b0a345033bB2b3B21C7a1A308B35fEeA',\n      },\n    },\n  },\n  sourceId,\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const forma = /*#__PURE__*/ defineChain({\n  id: 984122,\n  name: 'Forma',\n  network: 'forma',\n  nativeCurrency: {\n    symbol: 'TIA',\n    name: 'TIA',\n    decimals: 18,\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://rpc.forma.art'],\n      webSocket: ['wss://ws.forma.art'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Forma Explorer',\n      url: 'https://explorer.forma.art',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xd53C6FFB123F7349A32980F87faeD8FfDc9ef079',\n      blockCreated: 252705,\n    },\n  },\n})\n","import { defineChain } from '../../utils/chain/defineChain.js'\n\nexport const rollux = /*#__PURE__*/ defineChain({\n  id: 570,\n  name: 'Rollux Mainnet',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'Syscoin',\n    symbol: 'SYS',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://rpc.rollux.com'],\n      webSocket: ['wss://rpc.rollux.com/wss'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'RolluxExplorer',\n      url: 'https://explorer.rollux.com',\n      apiUrl: 'https://explorer.rollux.com/api',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 119222,\n    },\n  },\n})\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    containsBytes,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getBooleanDecoder,\n    getBooleanEncoder,\n    getConstantDecoder,\n    getConstantEncoder,\n    getTupleDecoder,\n    getTupleEncoder,\n    getUnionDecoder,\n    getUnionEncoder,\n    getUnitDecoder,\n    getUnitEncoder,\n} from '@solana/codecs-data-structures';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { isOption, isSome, None, none, Option, OptionOrNullable, Some, some } from './option';\nimport { wrapNullable } from './unwrap-option';\n\n/**\n * Defines the configuration options for {@link Option} codecs.\n *\n * The `getOptionCodec` function behaves similarly to {@link getNullableCodec}\n * but encodes `Option<T>` types instead of `T | null` types.\n *\n * This configuration controls how {@link None} values are encoded and how presence\n * is determined when decoding.\n *\n * @typeParam TPrefix - A number codec, encoder, or decoder used as the presence prefix.\n *\n * @see {@link getOptionEncoder}\n * @see {@link getOptionDecoder}\n * @see {@link getOptionCodec}\n */\nexport type OptionCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Specifies how {@link None} values are represented in the encoded data.\n     *\n     * - By default, {@link None} values are omitted from encoding.\n     * - `'zeroes'`: The bytes allocated for the value are filled with zeroes. This requires a fixed-size codec for the item.\n     * - Custom byte array: {@link None} values are replaced with a predefined byte sequence. This results in a variable-size codec.\n     *\n     * @defaultValue No explicit `noneValue` is used; {@link None} values are omitted.\n     */\n    noneValue?: ReadonlyUint8Array | 'zeroes';\n\n    /**\n     * The presence prefix used to distinguish between {@link None} and present values.\n     *\n     * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`).\n     * - Custom number codec: Allows defining a different number size for the prefix.\n     * - `null`: No prefix is used; `noneValue` (if provided) determines {@link None}.\n     *   If no `noneValue` is set, {@link None} is identified by the absence of bytes.\n     *\n     * @defaultValue `u8` prefix.\n     */\n    prefix?: TPrefix | null;\n};\n\n/**\n * Returns an encoder for optional values using the {@link Option} type.\n *\n * This encoder serializes an {@link OptionOrNullable} value using a configurable approach:\n * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, {@link None} values are encoded as zeroes.\n * - If `noneValue` is a byte array, {@link None} values are replaced with the provided constant.\n *\n * Unlike {@link getNullableEncoder}, this encoder accepts both {@link Option} and {@link Nullable} values.\n *\n * For more details, see {@link getOptionCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param item - The encoder for the value that may be present.\n * @param config - Configuration options for encoding optional values.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding option values.\n *\n * @example\n * Encoding an optional string.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const encoder = getOptionEncoder(stringCodec);\n *\n * encoder.encode(some('Hi'));\n * encoder.encode('Hi');\n * // 0x01020000004869\n * //   | |       -- utf8 string content (\"Hi\").\n * //   | -- u32 string prefix (2 characters).\n * //   -- 1-byte prefix (Some).\n *\n * encoder.encode(none());\n * encoder.encode(null);\n * // 0x00\n * //   -- 1-byte prefix (None).\n * ```\n *\n * @see {@link getOptionCodec}\n */\nexport function getOptionEncoder<TFrom, TSize extends number>(\n    item: FixedSizeEncoder<TFrom, TSize>,\n    config: OptionCodecConfig<NumberEncoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeEncoder<OptionOrNullable<TFrom>, TSize>;\nexport function getOptionEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: OptionCodecConfig<FixedSizeNumberEncoder> & { noneValue: 'zeroes' },\n): FixedSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: OptionCodecConfig<NumberEncoder> & { noneValue: 'zeroes' },\n): VariableSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: OptionCodecConfig<NumberEncoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: OptionCodecConfig<NumberEncoder> = {},\n): Encoder<OptionOrNullable<TFrom>> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformEncoder(getUnitEncoder(), (_boolean: boolean) => undefined);\n        }\n        return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n\n    return getUnionEncoder(\n        [\n            transformEncoder(getTupleEncoder([prefix, noneValue]), (_value: None | null): [boolean, void] => [\n                false,\n                undefined,\n            ]),\n            transformEncoder(getTupleEncoder([prefix, item]), (value: Some<TFrom> | TFrom): [boolean, TFrom] => [\n                true,\n                isOption(value) && isSome(value) ? value.value : value,\n            ]),\n        ],\n        variant => {\n            const option = isOption<TFrom>(variant) ? variant : wrapNullable(variant);\n            return Number(isSome(option));\n        },\n    );\n}\n\n/**\n * Returns a decoder for optional values using the {@link Option} type.\n *\n * This decoder deserializes an `Option<T>` value using a configurable approach:\n * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, `None` values are identified by zeroes.\n * - If `noneValue` is a byte array, `None` values match the provided constant.\n *\n * Unlike {@link getNullableDecoder}, this decoder always outputs an {@link Option} type.\n *\n * For more details, see {@link getOptionCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The decoder for the value that may be present.\n * @param config - Configuration options for decoding optional values.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding option values.\n *\n * @example\n * Decoding an optional string with a size prefix.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const decoder = getOptionDecoder(stringCodec);\n *\n * decoder.decode(new Uint8Array([0x01, 0x02, 0x00, 0x00, 0x00, 0x48, 0x69]));\n * // some('Hi')\n *\n * decoder.decode(new Uint8Array([0x00]));\n * // none()\n * ```\n *\n * @see {@link getOptionCodec}\n */\nexport function getOptionDecoder<TTo, TSize extends number>(\n    item: FixedSizeDecoder<TTo, TSize>,\n    config: OptionCodecConfig<NumberDecoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeDecoder<Option<TTo>, TSize>;\nexport function getOptionDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: OptionCodecConfig<FixedSizeNumberDecoder> & { noneValue: 'zeroes' },\n): FixedSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: OptionCodecConfig<NumberDecoder> & { noneValue: 'zeroes' },\n): VariableSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: OptionCodecConfig<NumberDecoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: OptionCodecConfig<NumberDecoder> = {},\n): Decoder<Option<TTo>> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformDecoder(getUnitDecoder(), () => false);\n        }\n        return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n\n    return getUnionDecoder(\n        [\n            transformDecoder(getTupleDecoder([prefix, noneValue]), () => none<TTo>()),\n            transformDecoder(getTupleDecoder([prefix, item]), ([, value]) => some(value)),\n        ],\n        (bytes, offset) => {\n            if (config.prefix === null && !config.noneValue) {\n                return Number(offset < bytes.length);\n            }\n            if (config.prefix === null && config.noneValue != null) {\n                const zeroValue =\n                    config.noneValue === 'zeroes' ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n                return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n            }\n            return Number(prefix.read(bytes, offset)[0]);\n        },\n    );\n}\n\n/**\n * Returns a codec for encoding and decoding optional values using the {@link Option} type.\n *\n * This codec serializes and deserializes `Option<T>` values using a configurable approach:\n * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`).\n * - If `noneValue: 'zeroes'` is set, `None` values are encoded/decoded as zeroes.\n * - If `noneValue` is a byte array, `None` values are represented by the provided constant.\n * - If `prefix: null` is set, the codec determines `None` values solely from `noneValue` or the presence of bytes.\n *\n * For more details on the configuration options, see {@link OptionCodecConfig}.\n *\n * Note that this behaves similarly to {@link getNullableCodec}, except it\n * encodes {@link OptionOrNullable} values and decodes {@link Option} values.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The codec for the value that may be present.\n * @param config - Configuration options for encoding and decoding option values.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding option values.\n *\n * @example\n * Encoding and decoding an optional string with a size prefix.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const codec = getOptionCodec(stringCodec);\n *\n * const someBytes = codec.encode(some('Hi'));\n * // 0x01020000004869\n * //   | |       -- utf8 string content (\"Hi\").\n * //   | -- u32 string prefix (2 characters).\n * //   -- 1-byte prefix (Some).\n *\n * const noneBytes = codec.encode(none());\n * // 0x00\n * //   -- 1-byte prefix (None).\n *\n * codec.decode(someBytes); // some('Hi')\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Encoding nullable values.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const codec = getOptionCodec(stringCodec);\n *\n * const someBytes = codec.encode('Hi'); // 0x01020000004869\n * const noneBytes = codec.encode(null); // 0x00\n *\n * codec.decode(someBytes); // some('Hi')\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Encoding and decoding an optional number with a fixed size.\n * ```ts\n * const codec = getOptionCodec(getU16Codec(), { noneValue: 'zeroes' });\n *\n * const someBytes = codec.encode(some(42)); // 0x012a00\n * const noneBytes = codec.encode(none());   // 0x000000\n *\n * codec.decode(someBytes); // some(42)\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Encoding and decoding {@link None} values with a custom byte sequence and no prefix.\n * ```ts\n * const codec = getOptionCodec(getU16Codec(), {\n *   noneValue: new Uint8Array([0xff, 0xff]),\n *   prefix: null,\n * });\n *\n * const someBytes = codec.encode(some(42)); // 0x2a00\n * const noneBytes = codec.encode(none());   // 0xffff\n *\n * codec.decode(someBytes); // some(42)\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Identifying {@link None} values by the absence of bytes.\n * ```ts\n * const codec = getOptionCodec(getU16Codec(), { prefix: null });\n *\n * const someBytes = codec.encode(some(42)); // 0x2a00\n * const noneBytes = codec.encode(none());   // new Uint8Array(0)\n *\n * codec.decode(someBytes); // some(42)\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @remarks\n * Separate {@link getOptionEncoder} and {@link getOptionDecoder} functions are available.\n *\n * ```ts\n * const bytes = getOptionEncoder(getU32Encoder()).encode(some(42));\n * const value = getOptionDecoder(getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getOptionEncoder}\n * @see {@link getOptionDecoder}\n */\nexport function getOptionCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    item: FixedSizeCodec<TFrom, TTo, TSize>,\n    config: OptionCodecConfig<NumberCodec> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeCodec<OptionOrNullable<TFrom>, Option<TTo>, TSize>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: OptionCodecConfig<FixedSizeNumberCodec> & { noneValue: 'zeroes' },\n): FixedSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: OptionCodecConfig<NumberCodec> & { noneValue: 'zeroes' },\n): VariableSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: OptionCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: OptionCodecConfig<NumberCodec> = {},\n): Codec<OptionOrNullable<TFrom>, Option<TTo>> {\n    type ConfigCast = OptionCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array };\n    return combineCodec(\n        getOptionEncoder<TFrom>(item, config as ConfigCast),\n        getOptionDecoder<TTo>(item, config as ConfigCast),\n    );\n}\n","/**\n * @module Axios\n */\n\nimport { AxiosInstance, AxiosHeaders } from \"axios\";\n\nimport { convertBigIntsToStrings } from \"../../../utils/bigint.js\";\nimport { getAuthHeaders } from \"../../utils/http.js\";\n\nexport interface AuthInterceptorOptions {\n  /**\n   * The API key ID\n   *\n   * Examples:\n   *  'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'\n   *  'organizations/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/apiKeys/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'\n   */\n  apiKeyId: string;\n\n  /**\n   * The API key secret\n   *\n   * Examples:\n   *  'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx==' (Edwards key (Ed25519))\n   *  '-----BEGIN EC PRIVATE KEY-----\\n...\\n...\\n...==\\n-----END EC PRIVATE KEY-----\\n' (EC key (ES256))\n   */\n  apiKeySecret: string;\n\n  /** The Wallet Secret */\n  walletSecret?: string;\n\n  /** The source of the request */\n  source?: string;\n\n  /** The version of the source of the request */\n  sourceVersion?: string;\n\n  /** Optional expiration time in seconds (defaults to 120) */\n  expiresIn?: number;\n\n  /** Whether to log request/response details */\n  debug?: boolean;\n}\n\n/**\n * Axios interceptor for adding the JWT to the Authorization header.\n *\n * @param axiosClient - The Axios client instance to add the interceptor to\n * @param options - Options for the request including API keys and debug flag\n * @returns The modified request configuration with the Authorization header added\n */\nexport function withAuth(axiosClient: AxiosInstance, options: AuthInterceptorOptions) {\n  axiosClient.interceptors.request.use(async axiosConfig => {\n    const method = axiosConfig.method?.toString().toUpperCase() || \"GET\";\n\n    if (!axiosConfig.url) {\n      throw new Error(\"URL is required for authentication\");\n    }\n\n    const fullyQualifiedURL = axiosClient.getUri() + axiosConfig.url;\n\n    // Parse URL to get host and path\n    const url = new URL(fullyQualifiedURL);\n\n    // Convert bigints in request body to strings for safe serialization\n    if (axiosConfig.data) {\n      axiosConfig.data = convertBigIntsToStrings(axiosConfig.data);\n    }\n\n    // Get authentication headers\n    const headers = await getAuthHeaders({\n      apiKeyId: options.apiKeyId,\n      apiKeySecret: options.apiKeySecret,\n      requestMethod: method,\n      requestHost: url.host,\n      requestPath: url.pathname,\n      requestBody: axiosConfig.data,\n      walletSecret: options.walletSecret,\n      source: options.source,\n      sourceVersion: options.sourceVersion,\n      expiresIn: options.expiresIn,\n    });\n\n    // Add headers to request config\n    axiosConfig.headers = new AxiosHeaders({\n      ...axiosConfig.headers,\n      ...headers,\n    });\n\n    if (options.debug) {\n      // eslint-disable-next-line no-console\n      console.log(\"Request:\", {\n        method,\n        url: fullyQualifiedURL,\n        headers: axiosConfig.headers,\n        data: axiosConfig.data,\n      });\n    }\n\n    return axiosConfig;\n  });\n\n  if (options.debug) {\n    axiosClient.interceptors.response.use(\n      response => {\n        // eslint-disable-next-line no-console\n        console.log(\"Response:\", {\n          status: response.status,\n          statusText: response.statusText,\n          headers: response.headers,\n          data: response.data,\n        });\n        return response;\n      },\n      error => {\n        // Ensure we have access to the error response details\n        const errorDetails = {\n          status: error.response?.status,\n          statusText: error.response?.statusText,\n          headers: error.response?.headers,\n          data: error.response?.data,\n          message: error.message,\n          cause: error.cause,\n        };\n\n        // eslint-disable-next-line no-console\n        console.error(\"Response Error:\", errorDetails);\n        return Promise.reject(error);\n      },\n    );\n  }\n\n  return axiosClient;\n}\n","import { WaitForTransactionReceiptParameters } from \"viem\";\nimport { base, baseSepolia, mainnet, sepolia } from \"viem/chains\";\n\nimport { mapChainToNetwork } from \"./chainToNetworkMapper.js\";\nimport { isMethodSupportedOnNetwork } from \"./networkCapabilities.js\";\nimport { resolveViemClients } from \"./resolveViemClients.js\";\nimport { transferWithViem } from \"../../actions/evm/transfer/transferWithViem.js\";\nimport { Analytics } from \"../../analytics.js\";\n\nimport type { EvmServerAccount, NetworkScopedEvmServerAccount, DistributedOmit } from \"./types.js\";\nimport type { ListTokenBalancesOptions } from \"../../actions/evm/listTokenBalances.js\";\nimport type { RequestFaucetOptions } from \"../../actions/evm/requestFaucet.js\";\nimport type {\n  SendTransactionOptions,\n  TransactionResult,\n} from \"../../actions/evm/sendTransaction.js\";\nimport type { UseSpendPermissionOptions } from \"../../actions/evm/spend-permissions/types.js\";\nimport type { AccountQuoteSwapOptions, AccountSwapOptions } from \"../../actions/evm/swap/types.js\";\nimport type { TransferOptions } from \"../../actions/evm/transfer/types.js\";\nimport type { EvmSwapsNetwork } from \"../../openapi-client/generated/coinbaseDeveloperPlatformAPIs.schemas.js\";\nimport type {\n  ListEvmTokenBalancesNetwork,\n  SendEvmTransactionBodyNetwork,\n  SpendPermissionNetwork,\n} from \"../../openapi-client/index.js\";\nimport type { Address, TransactionRequestEIP1559 } from \"../../types/misc.js\";\n\n/**\n * Options for converting a pre-existing EvmAccount to a NetworkScopedEvmServerAccount.\n */\nexport type ToNetworkScopedEvmServerAccountOptions = {\n  /** The EvmAccount that was previously created. */\n  account: EvmServerAccount;\n  /** The network to scope the account to. */\n  network: string;\n};\n\n/**\n * Creates a Network-scoped Server-managed EvmAccount instance from an existing EvmAccount.\n * Use this to interact with previously deployed EvmAccounts on a specific network.\n *\n * @param {ToNetworkScopedEvmServerAccountOptions} options - Configuration options.\n * @param {EvmServerAccount} options.account - The EvmServerAccount that was previously created.\n * @param {string} options.network - The network to scope the account to.\n * @returns {NetworkScopedEvmServerAccount} A configured NetworkScopedEvmServerAccount instance ready for signing.\n */\nexport async function toNetworkScopedEvmServerAccount<Network extends string>(\n  options: ToNetworkScopedEvmServerAccountOptions & { network: Network },\n): Promise<NetworkScopedEvmServerAccount<Network>> {\n  const { publicClient, walletClient, chain } = await resolveViemClients({\n    networkOrNodeUrl: options.network,\n    account: options.account,\n  });\n\n  /*\n   * Determine the actual network name from the resolved chain\n   * This handles cases where options.network is an RPC URL\n   */\n  const resolvedNetworkName = mapChainToNetwork(chain) ?? options.network;\n\n  const shouldUseApiForSends =\n    chain.id === base.id ||\n    chain.id === baseSepolia.id ||\n    chain.id === mainnet.id ||\n    chain.id === sepolia.id;\n\n  const account = {\n    address: options.account.address as Address,\n    network: options.network,\n    signMessage: options.account.signMessage,\n    sign: options.account.sign,\n    signTransaction: options.account.signTransaction,\n    signTypedData: options.account.signTypedData,\n    name: options.account.name,\n    type: \"evm-server\",\n    policies: options.account.policies,\n    sendTransaction: async (txOpts: Omit<SendTransactionOptions, \"address\" | \"network\">) => {\n      if (shouldUseApiForSends) {\n        return options.account.sendTransaction({\n          ...txOpts,\n          network: mapChainToNetwork(chain) as SendEvmTransactionBodyNetwork,\n        });\n      } else {\n        Analytics.trackAction({\n          action: \"send_transaction\",\n          accountType: \"evm_server\",\n          properties: {\n            network: options.network,\n            managed: true,\n          },\n        });\n\n        const hash = await walletClient.sendTransaction(\n          txOpts.transaction as TransactionRequestEIP1559,\n        );\n        return { transactionHash: hash };\n      }\n    },\n    transfer: async (transferArgs: Omit<TransferOptions, \"address\" | \"network\">) => {\n      if (shouldUseApiForSends) {\n        return options.account.transfer({\n          ...transferArgs,\n          network: mapChainToNetwork(chain) as SendEvmTransactionBodyNetwork,\n        });\n      } else {\n        Analytics.trackAction({\n          action: \"transfer\",\n          accountType: \"evm_server\",\n          properties: {\n            network: options.network,\n            managed: true,\n          },\n        });\n\n        return transferWithViem(walletClient, account, transferArgs);\n      }\n    },\n    waitForTransactionReceipt: async (\n      waitOptions: WaitForTransactionReceiptParameters | TransactionResult,\n    ) => {\n      Analytics.trackAction({\n        action: \"wait_for_transaction_receipt\",\n        accountType: \"evm_server\",\n        properties: {\n          managed: true,\n        },\n      });\n\n      if (\"transactionHash\" in waitOptions) {\n        return publicClient.waitForTransactionReceipt({\n          hash: waitOptions.transactionHash,\n        });\n      }\n      return publicClient.waitForTransactionReceipt(waitOptions);\n    },\n  } as NetworkScopedEvmServerAccount<Network>;\n\n  if (isMethodSupportedOnNetwork(\"listTokenBalances\", resolvedNetworkName)) {\n    Object.assign(account, {\n      listTokenBalances: async (\n        listTokenBalancesOptions: Omit<ListTokenBalancesOptions, \"address\" | \"network\">,\n      ) => {\n        Analytics.trackAction({\n          action: \"list_token_balances\",\n          accountType: \"evm_server\",\n          properties: {\n            managed: true,\n          },\n        });\n\n        return options.account.listTokenBalances({\n          ...listTokenBalancesOptions,\n          network: options.network as ListEvmTokenBalancesNetwork,\n        });\n      },\n    });\n  }\n\n  if (isMethodSupportedOnNetwork(\"requestFaucet\", resolvedNetworkName)) {\n    Object.assign(account, {\n      requestFaucet: async (faucetOptions: Omit<RequestFaucetOptions, \"address\" | \"network\">) => {\n        Analytics.trackAction({\n          action: \"request_faucet\",\n          accountType: \"evm_server\",\n          properties: {\n            managed: true,\n          },\n        });\n\n        return options.account.requestFaucet({\n          ...faucetOptions,\n          network: chain.id === baseSepolia.id ? \"base-sepolia\" : \"ethereum-sepolia\",\n        });\n      },\n    });\n  }\n\n  if (isMethodSupportedOnNetwork(\"quoteSwap\", resolvedNetworkName)) {\n    Object.assign(account, {\n      quoteSwap: async (quoteSwapOptions: DistributedOmit<AccountQuoteSwapOptions, \"network\">) => {\n        Analytics.trackAction({\n          action: \"quote_swap\",\n          accountType: \"evm_server\",\n          properties: {\n            managed: true,\n          },\n        });\n\n        return options.account.quoteSwap({\n          ...quoteSwapOptions,\n          network: options.network as EvmSwapsNetwork,\n        });\n      },\n    });\n  }\n\n  if (isMethodSupportedOnNetwork(\"swap\", resolvedNetworkName)) {\n    Object.assign(account, {\n      swap: async (swapOptions: DistributedOmit<AccountSwapOptions, \"network\">) => {\n        Analytics.trackAction({\n          action: \"swap\",\n          accountType: \"evm_server\",\n          properties: {\n            managed: true,\n          },\n        });\n\n        /*\n         * For network-scoped accounts, we need to add the network parameter\n         * for inline swaps while preserving quote-based swaps as-is\n         */\n        const swapOptionsWithNetwork =\n          \"swapQuote\" in swapOptions\n            ? swapOptions // Quote-based swap, pass through\n            : { ...swapOptions, network: options.network as EvmSwapsNetwork }; // Inline swap, add network\n\n        return options.account.swap(swapOptionsWithNetwork as AccountSwapOptions);\n      },\n    });\n  }\n\n  if (isMethodSupportedOnNetwork(\"useSpendPermission\", resolvedNetworkName)) {\n    Object.assign(account, {\n      useSpendPermission: async (\n        spendPermissionOptions: Omit<UseSpendPermissionOptions, \"network\">,\n      ) => {\n        Analytics.trackAction({\n          action: \"use_spend_permission\",\n          accountType: \"evm_server\",\n          properties: {\n            managed: true,\n          },\n        });\n\n        return options.account.useSpendPermission({\n          ...spendPermissionOptions,\n          network: options.network as SpendPermissionNetwork,\n        });\n      },\n    });\n  }\n\n  return account;\n}\n","/**\n * Internal module for NIST P256, P384, P521 curves.\n * Do not use for now.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256, sha384, sha512 } from '@noble/hashes/sha2';\nimport { createCurve, type CurveFnWithCreate } from './_shortw_utils.ts';\nimport { createHasher, type Hasher } from './abstract/hash-to-curve.ts';\nimport { Field } from './abstract/modular.ts';\nimport { mapToCurveSimpleSWU } from './abstract/weierstrass.ts';\n\nconst Fp256 = Field(BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'));\nconst p256_a = Fp256.create(BigInt('-3'));\nconst p256_b = BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b');\n\n/**\n * secp256r1 curve, ECDSA and ECDH methods.\n * Field: `2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n-1n`\n */\n// prettier-ignore\nexport const p256: CurveFnWithCreate = createCurve({\n  a: p256_a,\n  b: p256_b,\n  Fp: Fp256,\n  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n  h: BigInt(1),\n  lowS: false\n} as const, sha256);\n/** Alias to p256. */\nexport const secp256r1: CurveFnWithCreate = p256;\n\nconst p256_mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fp256, {\n    A: p256_a,\n    B: p256_b,\n    Z: Fp256.create(BigInt('-10')),\n  }))();\n\n/** Hashing / encoding to p256 points / field. RFC 9380 methods. */\nexport const p256_hasher: Hasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(secp256r1.ProjectivePoint, (scalars: bigint[]) => p256_mapSWU(scalars[0]), {\n    DST: 'P256_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'P256_XMD:SHA-256_SSWU_NU_',\n    p: Fp256.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256,\n  }))();\n\n// Field over which we'll do calculations.\nconst Fp384 = Field(\n  BigInt(\n    '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff'\n  )\n);\nconst p384_a = Fp384.create(BigInt('-3'));\n// prettier-ignore\nconst p384_b = BigInt('0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef');\n\n/**\n * secp384r1 curve, ECDSA and ECDH methods.\n * Field: `2n**384n - 2n**128n - 2n**96n + 2n**32n - 1n`.\n * */\n// prettier-ignore\nexport const p384: CurveFnWithCreate = createCurve({\n  a: p384_a,\n  b: p384_b,\n  Fp: Fp384,\n  n: BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973'),\n  Gx: BigInt('0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7'),\n  Gy: BigInt('0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f'),\n  h: BigInt(1),\n  lowS: false\n} as const, sha384);\n/** Alias to p384. */\nexport const secp384r1: CurveFnWithCreate = p384;\n\nconst p384_mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fp384, {\n    A: p384_a,\n    B: p384_b,\n    Z: Fp384.create(BigInt('-12')),\n  }))();\n\n/** Hashing / encoding to p384 points / field. RFC 9380 methods. */\nexport const p384_hasher: Hasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(secp384r1.ProjectivePoint, (scalars: bigint[]) => p384_mapSWU(scalars[0]), {\n    DST: 'P384_XMD:SHA-384_SSWU_RO_',\n    encodeDST: 'P384_XMD:SHA-384_SSWU_NU_',\n    p: Fp384.ORDER,\n    m: 1,\n    k: 192,\n    expand: 'xmd',\n    hash: sha384,\n  }))();\n\n// Field over which we'll do calculations.\nconst Fp521 = Field(\n  BigInt(\n    '0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n  )\n);\n\nconst p521_a = Fp521.create(BigInt('-3'));\nconst p521_b = BigInt(\n  '0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00'\n);\n\n/**\n * NIST secp521r1 aka p521 curve, ECDSA and ECDH methods.\n * Field: `2n**521n - 1n`.\n */\n// prettier-ignore\nexport const p521: CurveFnWithCreate = createCurve({\n  a: p521_a,\n  b: p521_b,\n  Fp: Fp521,\n  n: BigInt(\n    '0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409'\n  ),\n  Gx: BigInt(\n    '0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66'\n  ),\n  Gy: BigInt(\n    '0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650'\n  ),\n  h: BigInt(1),\n  lowS: false,\n  allowedPrivateKeyLengths: [130, 131, 132] // P521 keys are variable-length. Normalize to 132b\n} as const, sha512);\n/** Alias to p521. */\nexport const secp521r1: CurveFnWithCreate = p521;\n\nconst p521_mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fp521, {\n    A: p521_a,\n    B: p521_b,\n    Z: Fp521.create(BigInt('-4')),\n  }))();\n\n/** Hashing / encoding to p521 points / field. RFC 9380 methods. */\nexport const p521_hasher: Hasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(secp521r1.ProjectivePoint, (scalars: bigint[]) => p521_mapSWU(scalars[0]), {\n    DST: 'P521_XMD:SHA-512_SSWU_RO_',\n    encodeDST: 'P521_XMD:SHA-512_SSWU_NU_',\n    p: Fp521.ORDER,\n    m: 1,\n    k: 256,\n    expand: 'xmd',\n    hash: sha512,\n  }))();\n","import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport {\n  type ChecksumAddressErrorType,\n  checksumAddress,\n} from '../../utils/address/getAddress.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type GetAddressesReturnType = Address[]\n\nexport type GetAddressesErrorType =\n  | RequestErrorType\n  | ChecksumAddressErrorType\n  | ErrorType\n\n/**\n * Returns a list of account addresses owned by the wallet or client.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/getAddresses\n * - JSON-RPC Methods: [`eth_accounts`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_accounts)\n *\n * @param client - Client to use\n * @returns List of account addresses owned by the wallet or client. {@link GetAddressesReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getAddresses } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const accounts = await getAddresses(client)\n */\nexport async function getAddresses<\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n>(client: Client<Transport, chain, account>): Promise<GetAddressesReturnType> {\n  if (client.account?.type === 'local') return [client.account.address]\n  const addresses = await client.request(\n    { method: 'eth_accounts' },\n    { dedupe: true },\n  )\n  return addresses.map((address) => checksumAddress(address))\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/sign/base-account/utils/constants.ts","import { secp256k1 } from '@noble/curves/secp256k1'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as Json from './Json.js'\nimport * as Solidity from './Solidity.js'\nimport type { Compute, ExactPartial, OneOf } from './internal/types.js'\n\n/** Root type for an ECDSA signature. */\nexport type Signature<\n  recovered extends boolean = true,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<\n  recovered extends true\n    ? {\n        r: bigintType\n        s: bigintType\n        yParity: numberType\n      }\n    : {\n        r: bigintType\n        s: bigintType\n        yParity?: numberType | undefined\n      }\n>\n\n/** RPC-formatted ECDSA signature. */\nexport type Rpc<recovered extends boolean = true> = Signature<\n  recovered,\n  Hex.Hex,\n  Hex.Hex\n>\n\n/** (Legacy) ECDSA signature. */\nexport type Legacy<bigintType = bigint, numberType = number> = {\n  r: bigintType\n  s: bigintType\n  v: numberType\n}\n\n/** RPC-formatted (Legacy) ECDSA signature. */\nexport type LegacyRpc = Legacy<Hex.Hex, Hex.Hex>\n\nexport type Tuple = readonly [yParity: Hex.Hex, r: Hex.Hex, s: Hex.Hex]\n\n/**\n * Asserts that a Signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.assert({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @error: InvalidSignatureRError:\n * // @error: Value `-549...n` is an invalid r value.\n * // @error: r must be a positive integer less than 2^256.\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function assert(\n  signature: ExactPartial<Signature>,\n  options: assert.Options = {},\n): asserts signature is Signature {\n  const { recovered } = options\n  if (typeof signature.r === 'undefined')\n    throw new MissingPropertiesError({ signature })\n  if (typeof signature.s === 'undefined')\n    throw new MissingPropertiesError({ signature })\n  if (recovered && typeof signature.yParity === 'undefined')\n    throw new MissingPropertiesError({ signature })\n  if (signature.r < 0n || signature.r > Solidity.maxUint256)\n    throw new InvalidRError({ value: signature.r })\n  if (signature.s < 0n || signature.s > Solidity.maxUint256)\n    throw new InvalidSError({ value: signature.s })\n  if (\n    typeof signature.yParity === 'number' &&\n    signature.yParity !== 0 &&\n    signature.yParity !== 1\n  )\n    throw new InvalidYParityError({ value: signature.yParity })\n}\n\nexport declare namespace assert {\n  type Options = {\n    /** Whether or not the signature should be recovered (contain `yParity`). */\n    recovered?: boolean\n  }\n\n  type ErrorType =\n    | MissingPropertiesError\n    | InvalidRError\n    | InvalidSError\n    | InvalidYParityError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#Bytes.Bytes} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param signature - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromBytes(signature: Bytes.Bytes): Signature {\n  return fromHex(Hex.fromBytes(signature))\n}\n\nexport declare namespace fromBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#Hex.Hex} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param serialized - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nexport function fromHex(signature: Hex.Hex): Signature {\n  if (signature.length !== 130 && signature.length !== 132)\n    throw new InvalidSerializedSizeError({ signature })\n\n  const r = BigInt(Hex.slice(signature, 0, 32))\n  const s = BigInt(Hex.slice(signature, 32, 64))\n\n  const yParity = (() => {\n    const yParity = Number(`0x${signature.slice(130)}`)\n    if (Number.isNaN(yParity)) return undefined\n    try {\n      return vToYParity(yParity)\n    } catch {\n      throw new InvalidYParityError({ value: yParity })\n    }\n  })()\n\n  if (typeof yParity === 'undefined')\n    return {\n      r,\n      s,\n    } as never\n  return {\n    r,\n    s,\n    yParity,\n  } as never\n}\n\nexport declare namespace fromHex {\n  type ErrorType =\n    | Hex.from.ErrorType\n    | InvalidSerializedSizeError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Extracts a {@link ox#Signature.Signature} from an arbitrary object that may include signature properties.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.extract({\n *   baz: 'barry',\n *   foo: 'bar',\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n *   zebra: 'stripes',\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @param value - The arbitrary object to extract the signature from.\n * @returns The extracted {@link ox#Signature.Signature}.\n */\nexport function extract(value: extract.Value): Signature | undefined {\n  if (typeof value.r === 'undefined') return undefined\n  if (typeof value.s === 'undefined') return undefined\n  return from(value as any)\n}\n\nexport declare namespace extract {\n  type Value = {\n    r?: bigint | Hex.Hex | undefined\n    s?: bigint | Hex.Hex | undefined\n    yParity?: number | Hex.Hex | undefined\n    v?: number | Hex.Hex | undefined\n  }\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates a typed {@link ox#Signature.Signature} object from a {@link ox#Signature.Signature}, {@link ox#Signature.Legacy}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db801')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @example\n * ### From Legacy\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n *   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n *   v: 27,\n * })\n * // @log: {\n * // @log:   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n * // @log:   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n * // @log:   yParity: 0\n * // @log: }\n * ```\n *\n * @param signature - The signature value to instantiate.\n * @returns The instantiated {@link ox#Signature.Signature}.\n */\nexport function from<\n  const signature extends\n    | OneOf<Signature<boolean> | Rpc<boolean> | Legacy | LegacyRpc>\n    | Hex.Hex\n    | Bytes.Bytes,\n>(\n  signature:\n    | signature\n    | OneOf<Signature<boolean> | Rpc<boolean> | Legacy | LegacyRpc>\n    | Hex.Hex\n    | Bytes.Bytes,\n): from.ReturnType<signature> {\n  const signature_ = (() => {\n    if (typeof signature === 'string') return fromHex(signature)\n    if (signature instanceof Uint8Array) return fromBytes(signature)\n    if (typeof signature.r === 'string') return fromRpc(signature)\n    if (signature.v) return fromLegacy(signature)\n    return {\n      r: signature.r,\n      s: signature.s,\n      ...(typeof signature.yParity !== 'undefined'\n        ? { yParity: signature.yParity }\n        : {}),\n    }\n  })()\n  assert(signature_)\n  return signature_ as never\n}\n\nexport declare namespace from {\n  type ReturnType<\n    signature extends\n      | OneOf<Signature<boolean> | Rpc<boolean> | Legacy | LegacyRpc>\n      | Hex.Hex\n      | Bytes.Bytes,\n  > = signature extends Signature<boolean> & { v?: undefined }\n    ? signature\n    : Signature\n\n  type ErrorType =\n    | assert.ErrorType\n    | fromBytes.ErrorType\n    | fromHex.ErrorType\n    | vToYParity.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerBytes(new Uint8Array([132, 51, 23, ...]))\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerBytes(signature: Bytes.Bytes): Signature<false> {\n  return fromDerHex(Hex.fromBytes(signature))\n}\n\nexport declare namespace fromDerBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerHex('0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromDerHex(signature: Hex.Hex): Signature<false> {\n  const { r, s } = secp256k1.Signature.fromDER(Hex.from(signature).slice(2))\n  return { r, s }\n}\n\nexport declare namespace fromDerHex {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Legacy} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.fromLegacy({ r: 1n, s: 2n, v: 28 })\n * // @log: { r: 1n, s: 2n, yParity: 1 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Legacy} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromLegacy(signature: Legacy): Signature {\n  return {\n    r: signature.r,\n    s: signature.s,\n    yParity: vToYParity(signature.v),\n  }\n}\n\nexport declare namespace fromLegacy {\n  type ErrorType = vToYParity.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Rpc} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromRpc({\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Rpc} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nexport function fromRpc(signature: {\n  r: Hex.Hex\n  s: Hex.Hex\n  yParity?: Hex.Hex | undefined\n  v?: Hex.Hex | undefined\n}): Signature {\n  const yParity = (() => {\n    const v = signature.v ? Number(signature.v) : undefined\n    let yParity = signature.yParity ? Number(signature.yParity) : undefined\n    if (typeof v === 'number' && typeof yParity !== 'number')\n      yParity = vToYParity(v)\n    if (typeof yParity !== 'number')\n      throw new InvalidYParityError({ value: signature.yParity })\n    return yParity\n  })()\n\n  return {\n    r: BigInt(signature.r),\n    s: BigInt(signature.s),\n    yParity,\n  }\n}\n\nexport declare namespace fromRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Tuple} to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromTuple(['0x01', '0x7b', '0x1c8'])\n * // @log: {\n * // @log:   r: 123n,\n * // @log:   s: 456n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @param tuple - The {@link ox#Signature.Tuple} to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nexport function fromTuple(tuple: Tuple): Signature {\n  const [yParity, r, s] = tuple\n  return from({\n    r: r === '0x' ? 0n : BigInt(r),\n    s: s === '0x' ? 0n : BigInt(s),\n    yParity: yParity === '0x' ? 0 : Number(yParity),\n  })\n}\n\nexport declare namespace fromTuple {\n  type ErrorType = from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toBytes({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: Uint8Array [102, 16, 10, ...]\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toBytes(signature: Signature<boolean>): Bytes.Bytes {\n  return Bytes.fromHex(toHex(signature))\n}\n\nexport declare namespace toBytes {\n  type ErrorType =\n    | toHex.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nexport function toHex(signature: Signature<boolean>): Hex.Hex {\n  assert(signature)\n\n  const r = signature.r\n  const s = signature.s\n\n  const signature_ = Hex.concat(\n    Hex.fromNumber(r, { size: 32 }),\n    Hex.fromNumber(s, { size: 32 }),\n    // If the signature is recovered, add the recovery byte to the signature.\n    typeof signature.yParity === 'number'\n      ? Hex.fromNumber(yParityToV(signature.yParity), { size: 1 })\n      : '0x',\n  )\n\n  return signature_\n}\n\nexport declare namespace toHex {\n  type ErrorType =\n    | Hex.concat.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerBytes(signature)\n * // @log: Uint8Array [132, 51, 23, ...]\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerBytes(signature: Signature<boolean>): Bytes.Bytes {\n  const sig = new secp256k1.Signature(signature.r, signature.s)\n  return sig.toDERRawBytes()\n}\n\nexport declare namespace toDerBytes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerHex(signature)\n * // @log: '0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8'\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nexport function toDerHex(signature: Signature<boolean>): Hex.Hex {\n  const sig = new secp256k1.Signature(signature.r, signature.s)\n  return `0x${sig.toDERHex()}`\n}\n\nexport declare namespace toDerHex {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Legacy}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.toLegacy({ r: 1n, s: 2n, yParity: 1 })\n * // @log: { r: 1n, s: 2n, v: 28 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Legacy}.\n */\nexport function toLegacy(signature: Signature): Legacy {\n  return {\n    r: signature.r,\n    s: signature.s,\n    v: yParityToV(signature.yParity),\n  }\n}\n\nexport declare namespace toLegacy {\n  type ErrorType = yParityToV.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toRpc({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Rpc}.\n */\nexport function toRpc(signature: Signature): Rpc {\n  const { r, s, yParity } = signature\n  return {\n    r: Hex.fromNumber(r, { size: 32 }),\n    s: Hex.fromNumber(s, { size: 32 }),\n    yParity: yParity === 0 ? '0x0' : '0x1',\n  }\n}\n\nexport declare namespace toRpc {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a {@link ox#Signature.Signature} to a serialized {@link ox#Signature.Tuple} to be used for signatures in Transaction Envelopes, EIP-7702 Authorization Lists, etc.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signatureTuple = Signature.toTuple({\n *   r: 123n,\n *   s: 456n,\n *   yParity: 1,\n * })\n * // @log: [yParity: '0x01', r: '0x7b', s: '0x1c8']\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The {@link ox#Signature.Tuple}.\n */\nexport function toTuple(signature: Signature): Tuple {\n  const { r, s, yParity } = signature\n\n  return [\n    yParity ? '0x01' : '0x',\n    r === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(r!)),\n    s === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(s!)),\n  ] as const\n}\n\nexport declare namespace toTuple {\n  type ErrorType =\n    | Hex.trimLeft.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Validates a Signature. Returns `true` if the signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const valid = Signature.validate({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: false\n * ```\n *\n * @param signature - The signature object to assert.\n */\nexport function validate(\n  signature: ExactPartial<Signature>,\n  options: validate.Options = {},\n): boolean {\n  try {\n    assert(signature, options)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type Options = {\n    /** Whether or not the signature should be recovered (contain `yParity`). */\n    recovered?: boolean\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const yParity = Signature.vToYParity(28)\n * // @log: 1\n * ```\n *\n * @param v - The ECDSA `v` value to convert.\n * @returns The `yParity` value.\n */\nexport function vToYParity(v: number): Signature['yParity'] {\n  if (v === 0 || v === 27) return 0\n  if (v === 1 || v === 28) return 1\n  if (v >= 35) return v % 2 === 0 ? 1 : 0\n  throw new InvalidVError({ value: v })\n}\n\nexport declare namespace vToYParity {\n  type ErrorType = InvalidVError | Errors.GlobalErrorType\n}\n\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const v = Signature.yParityToV(1)\n * // @log: 28\n * ```\n *\n * @param yParity - The ECDSA `yParity` value to convert.\n * @returns The `v` value.\n */\nexport function yParityToV(yParity: number): number {\n  if (yParity === 0) return 27\n  if (yParity === 1) return 28\n  throw new InvalidYParityError({ value: yParity })\n}\n\nexport declare namespace yParityToV {\n  type ErrorType = InvalidVError | Errors.GlobalErrorType\n}\n\n/** Thrown when the serialized signature is of an invalid size. */\nexport class InvalidSerializedSizeError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidSerializedSizeError'\n\n  constructor({ signature }: { signature: Hex.Hex | Bytes.Bytes }) {\n    super(`Value \\`${signature}\\` is an invalid signature size.`, {\n      metaMessages: [\n        'Expected: 64 bytes or 65 bytes.',\n        `Received ${Hex.size(Hex.from(signature))} bytes.`,\n      ],\n    })\n  }\n}\n\n/** Thrown when the signature is missing either an `r`, `s`, or `yParity` property. */\nexport class MissingPropertiesError extends Errors.BaseError {\n  override readonly name = 'Signature.MissingPropertiesError'\n\n  constructor({ signature }: { signature: unknown }) {\n    super(\n      `Signature \\`${Json.stringify(signature)}\\` is missing either an \\`r\\`, \\`s\\`, or \\`yParity\\` property.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `r` value. */\nexport class InvalidRError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidRError'\n\n  constructor({ value }: { value: unknown }) {\n    super(\n      `Value \\`${value}\\` is an invalid r value. r must be a positive integer less than 2^256.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `s` value. */\nexport class InvalidSError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidSError'\n\n  constructor({ value }: { value: unknown }) {\n    super(\n      `Value \\`${value}\\` is an invalid s value. s must be a positive integer less than 2^256.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `yParity` value. */\nexport class InvalidYParityError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidYParityError'\n\n  constructor({ value }: { value: unknown }) {\n    super(\n      `Value \\`${value}\\` is an invalid y-parity value. Y-parity must be 0 or 1.`,\n    )\n  }\n}\n\n/** Thrown when the signature has an invalid `v` value. */\nexport class InvalidVError extends Errors.BaseError {\n  override readonly name = 'Signature.InvalidVError'\n\n  constructor({ value }: { value: number }) {\n    super(`Value \\`${value}\\` is an invalid v value. v must be 27, 28 or >=35.`)\n  }\n}\n","import type { Address } from 'abitype'\nimport { BaseError } from '../../errors/base.js'\nimport type { Hex } from '../../types/misc.js'\n\nexport type AccountNotDeployedErrorType = AccountNotDeployedError & {\n  name: 'AccountNotDeployedError'\n}\nexport class AccountNotDeployedError extends BaseError {\n  static message = /aa20/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Smart Account is not deployed.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- No `factory`/`factoryData` or `initCode` properties are provided for Smart Account deployment.',\n        '- An incorrect `sender` address is provided.',\n      ],\n      name: 'AccountNotDeployedError',\n    })\n  }\n}\n\nexport type ExecutionRevertedErrorType = ExecutionRevertedError & {\n  code: -32521\n  name: 'ExecutionRevertedError'\n}\nexport class ExecutionRevertedError extends BaseError {\n  static code = -32521\n  static message = /execution reverted/\n\n  data?: { revertData?: Hex } | undefined\n\n  constructor({\n    cause,\n    data,\n    message,\n  }: {\n    cause?: BaseError | undefined\n    data?: { revertData?: Hex } | undefined\n    message?: string | undefined\n  } = {}) {\n    const reason = message\n      ?.replace('execution reverted: ', '')\n      ?.replace('execution reverted', '')\n    super(\n      `Execution reverted ${\n        reason ? `with reason: ${reason}` : 'for an unknown reason'\n      }.`,\n      {\n        cause,\n        name: 'ExecutionRevertedError',\n      },\n    )\n\n    this.data = data\n  }\n}\n\nexport type FailedToSendToBeneficiaryErrorType =\n  FailedToSendToBeneficiaryError & {\n    name: 'FailedToSendToBeneficiaryError'\n  }\nexport class FailedToSendToBeneficiaryError extends BaseError {\n  static message = /aa91/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Failed to send funds to beneficiary.', {\n      cause,\n      name: 'FailedToSendToBeneficiaryError',\n    })\n  }\n}\n\nexport type GasValuesOverflowErrorType = GasValuesOverflowError & {\n  name: 'GasValuesOverflowError'\n}\nexport class GasValuesOverflowError extends BaseError {\n  static message = /aa94/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Gas value overflowed.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- one of the gas values exceeded 2**120 (uint120)',\n      ].filter(Boolean) as string[],\n      name: 'GasValuesOverflowError',\n    })\n  }\n}\n\nexport type HandleOpsOutOfGasErrorType = HandleOpsOutOfGasError & {\n  name: 'HandleOpsOutOfGasError'\n}\nexport class HandleOpsOutOfGasError extends BaseError {\n  static message = /aa95/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super(\n      'The `handleOps` function was called by the Bundler with a gas limit too low.',\n      {\n        cause,\n        name: 'HandleOpsOutOfGasError',\n      },\n    )\n  }\n}\n\nexport type InitCodeFailedErrorType = InitCodeFailedError & {\n  name: 'InitCodeFailedError'\n}\nexport class InitCodeFailedError extends BaseError {\n  static message = /aa13/\n  constructor({\n    cause,\n    factory,\n    factoryData,\n    initCode,\n  }: {\n    cause?: BaseError | undefined\n    factory?: Address | undefined\n    factoryData?: Hex | undefined\n    initCode?: Hex | undefined\n  }) {\n    super('Failed to simulate deployment for Smart Account.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- Invalid `factory`/`factoryData` or `initCode` properties are present',\n        '- Smart Account deployment execution ran out of gas (low `verificationGasLimit` value)',\n        '- Smart Account deployment execution reverted with an error\\n',\n        factory && `factory: ${factory}`,\n        factoryData && `factoryData: ${factoryData}`,\n        initCode && `initCode: ${initCode}`,\n      ].filter(Boolean) as string[],\n      name: 'InitCodeFailedError',\n    })\n  }\n}\n\nexport type InitCodeMustCreateSenderErrorType =\n  InitCodeMustCreateSenderError & {\n    name: 'InitCodeMustCreateSenderError'\n  }\nexport class InitCodeMustCreateSenderError extends BaseError {\n  static message = /aa15/\n  constructor({\n    cause,\n    factory,\n    factoryData,\n    initCode,\n  }: {\n    cause?: BaseError | undefined\n    factory?: Address | undefined\n    factoryData?: Hex | undefined\n    initCode?: Hex | undefined\n  }) {\n    super(\n      'Smart Account initialization implementation did not create an account.',\n      {\n        cause,\n        metaMessages: [\n          'This could arise when:',\n          '- `factory`/`factoryData` or `initCode` properties are invalid',\n          '- Smart Account initialization implementation is incorrect\\n',\n          factory && `factory: ${factory}`,\n          factoryData && `factoryData: ${factoryData}`,\n          initCode && `initCode: ${initCode}`,\n        ].filter(Boolean) as string[],\n        name: 'InitCodeMustCreateSenderError',\n      },\n    )\n  }\n}\n\nexport type InitCodeMustReturnSenderErrorType =\n  InitCodeMustReturnSenderError & {\n    name: 'InitCodeMustReturnSenderError'\n  }\nexport class InitCodeMustReturnSenderError extends BaseError {\n  static message = /aa14/\n  constructor({\n    cause,\n    factory,\n    factoryData,\n    initCode,\n    sender,\n  }: {\n    cause?: BaseError | undefined\n    factory?: Address | undefined\n    factoryData?: Hex | undefined\n    initCode?: Hex | undefined\n    sender?: Address | undefined\n  }) {\n    super(\n      'Smart Account initialization implementation does not return the expected sender.',\n      {\n        cause,\n        metaMessages: [\n          'This could arise when:',\n          'Smart Account initialization implementation does not return a sender address\\n',\n          factory && `factory: ${factory}`,\n          factoryData && `factoryData: ${factoryData}`,\n          initCode && `initCode: ${initCode}`,\n          sender && `sender: ${sender}`,\n        ].filter(Boolean) as string[],\n        name: 'InitCodeMustReturnSenderError',\n      },\n    )\n  }\n}\n\nexport type InsufficientPrefundErrorType = InsufficientPrefundError & {\n  name: 'InsufficientPrefundError'\n}\nexport class InsufficientPrefundError extends BaseError {\n  static message = /aa21/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super(\n      'Smart Account does not have sufficient funds to execute the User Operation.',\n      {\n        cause,\n        metaMessages: [\n          'This could arise when:',\n          '- the Smart Account does not have sufficient funds to cover the required prefund, or',\n          '- a Paymaster was not provided',\n        ].filter(Boolean) as string[],\n        name: 'InsufficientPrefundError',\n      },\n    )\n  }\n}\n\nexport type InternalCallOnlyErrorType = InternalCallOnlyError & {\n  name: 'InternalCallOnlyError'\n}\nexport class InternalCallOnlyError extends BaseError {\n  static message = /aa92/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Bundler attempted to call an invalid function on the EntryPoint.', {\n      cause,\n      name: 'InternalCallOnlyError',\n    })\n  }\n}\n\nexport type InvalidAggregatorErrorType = InvalidAggregatorError & {\n  name: 'InvalidAggregatorError'\n}\nexport class InvalidAggregatorError extends BaseError {\n  static message = /aa96/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super(\n      'Bundler used an invalid aggregator for handling aggregated User Operations.',\n      {\n        cause,\n        name: 'InvalidAggregatorError',\n      },\n    )\n  }\n}\n\nexport type InvalidAccountNonceErrorType = InvalidAccountNonceError & {\n  name: 'InvalidAccountNonceError'\n}\nexport class InvalidAccountNonceError extends BaseError {\n  static message = /aa25/\n  constructor({\n    cause,\n    nonce,\n  }: {\n    cause?: BaseError | undefined\n    nonce?: bigint | undefined\n  }) {\n    super('Invalid Smart Account nonce used for User Operation.', {\n      cause,\n      metaMessages: [nonce && `nonce: ${nonce}`].filter(Boolean) as string[],\n      name: 'InvalidAccountNonceError',\n    })\n  }\n}\n\nexport type InvalidBeneficiaryErrorType = InvalidBeneficiaryError & {\n  name: 'InvalidBeneficiaryError'\n}\nexport class InvalidBeneficiaryError extends BaseError {\n  static message = /aa90/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Bundler has not set a beneficiary address.', {\n      cause,\n      name: 'InvalidBeneficiaryError',\n    })\n  }\n}\n\nexport type InvalidFieldsErrorType = InvalidFieldsError & {\n  name: 'InvalidFieldsError'\n}\nexport class InvalidFieldsError extends BaseError {\n  static code = -32602\n\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Invalid fields set on User Operation.', {\n      cause,\n      name: 'InvalidFieldsError',\n    })\n  }\n}\n\nexport type InvalidPaymasterAndDataErrorType = InvalidPaymasterAndDataError & {\n  name: 'InvalidPaymasterAndDataError'\n}\nexport class InvalidPaymasterAndDataError extends BaseError {\n  static message = /aa93/\n  constructor({\n    cause,\n    paymasterAndData,\n  }: {\n    cause?: BaseError | undefined\n    paymasterAndData?: Hex | undefined\n  }) {\n    super('Paymaster properties provided are invalid.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `paymasterAndData` property is of an incorrect length\\n',\n        paymasterAndData && `paymasterAndData: ${paymasterAndData}`,\n      ].filter(Boolean) as string[],\n      name: 'InvalidPaymasterAndDataError',\n    })\n  }\n}\n\nexport type PaymasterDepositTooLowErrorType = PaymasterDepositTooLowError & {\n  code: -32508\n  name: 'PaymasterDepositTooLowError'\n}\nexport class PaymasterDepositTooLowError extends BaseError {\n  static code = -32508\n  static message = /aa31/\n\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Paymaster deposit for the User Operation is too low.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the Paymaster has deposited less than the expected amount via the `deposit` function',\n      ].filter(Boolean) as string[],\n      name: 'PaymasterDepositTooLowError',\n    })\n  }\n}\n\nexport type PaymasterFunctionRevertedErrorType =\n  PaymasterFunctionRevertedError & {\n    name: 'PaymasterFunctionRevertedError'\n  }\nexport class PaymasterFunctionRevertedError extends BaseError {\n  static message = /aa33/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('The `validatePaymasterUserOp` function on the Paymaster reverted.', {\n      cause,\n      name: 'PaymasterFunctionRevertedError',\n    })\n  }\n}\n\nexport type PaymasterNotDeployedErrorType = PaymasterNotDeployedError & {\n  name: 'PaymasterNotDeployedError'\n}\nexport class PaymasterNotDeployedError extends BaseError {\n  static message = /aa30/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('The Paymaster contract has not been deployed.', {\n      cause,\n      name: 'PaymasterNotDeployedError',\n    })\n  }\n}\n\nexport type PaymasterRateLimitErrorType = PaymasterRateLimitError & {\n  code: -32504\n  name: 'PaymasterRateLimitError'\n}\nexport class PaymasterRateLimitError extends BaseError {\n  static code = -32504\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      'UserOperation rejected because paymaster (or signature aggregator) is throttled/banned.',\n      {\n        cause,\n        name: 'PaymasterRateLimitError',\n      },\n    )\n  }\n}\n\nexport type PaymasterStakeTooLowErrorType = PaymasterStakeTooLowError & {\n  code: -32505\n  name: 'PaymasterStakeTooLowError'\n}\nexport class PaymasterStakeTooLowError extends BaseError {\n  static code = -32505\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      'UserOperation rejected because paymaster (or signature aggregator) is throttled/banned.',\n      {\n        cause,\n        name: 'PaymasterStakeTooLowError',\n      },\n    )\n  }\n}\n\nexport type PaymasterPostOpFunctionRevertedErrorType =\n  PaymasterPostOpFunctionRevertedError & {\n    name: 'PaymasterPostOpFunctionRevertedError'\n  }\nexport class PaymasterPostOpFunctionRevertedError extends BaseError {\n  static message = /aa50/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Paymaster `postOp` function reverted.', {\n      cause,\n      name: 'PaymasterPostOpFunctionRevertedError',\n    })\n  }\n}\n\nexport type SenderAlreadyConstructedErrorType =\n  SenderAlreadyConstructedError & {\n    name: 'SenderAlreadyConstructedError'\n  }\nexport class SenderAlreadyConstructedError extends BaseError {\n  static message = /aa10/\n  constructor({\n    cause,\n    factory,\n    factoryData,\n    initCode,\n  }: {\n    cause?: BaseError | undefined\n    factory?: Address | undefined\n    factoryData?: Hex | undefined\n    initCode?: Hex | undefined\n  }) {\n    super('Smart Account has already been deployed.', {\n      cause,\n      metaMessages: [\n        'Remove the following properties and try again:',\n        factory && '`factory`',\n        factoryData && '`factoryData`',\n        initCode && '`initCode`',\n      ].filter(Boolean) as string[],\n      name: 'SenderAlreadyConstructedError',\n    })\n  }\n}\n\nexport type SignatureCheckFailedErrorType = SignatureCheckFailedError & {\n  code: -32507\n  name: 'SignatureCheckFailedError'\n}\nexport class SignatureCheckFailedError extends BaseError {\n  static code = -32507\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      'UserOperation rejected because account signature check failed (or paymaster signature, if the paymaster uses its data as signature).',\n      {\n        cause,\n        name: 'SignatureCheckFailedError',\n      },\n    )\n  }\n}\n\nexport type SmartAccountFunctionRevertedErrorType =\n  SmartAccountFunctionRevertedError & {\n    name: 'SmartAccountFunctionRevertedError'\n  }\nexport class SmartAccountFunctionRevertedError extends BaseError {\n  static message = /aa23/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('The `validateUserOp` function on the Smart Account reverted.', {\n      cause,\n      name: 'SmartAccountFunctionRevertedError',\n    })\n  }\n}\n\nexport type UnsupportedSignatureAggregatorErrorType =\n  UnsupportedSignatureAggregatorError & {\n    code: -32506\n    name: 'UnsupportedSignatureAggregatorError'\n  }\nexport class UnsupportedSignatureAggregatorError extends BaseError {\n  static code = -32506\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      'UserOperation rejected because account specified unsupported signature aggregator.',\n      {\n        cause,\n        name: 'UnsupportedSignatureAggregatorError',\n      },\n    )\n  }\n}\n\nexport type UserOperationExpiredErrorType = UserOperationExpiredError & {\n  name: 'UserOperationExpiredError'\n}\nexport class UserOperationExpiredError extends BaseError {\n  static message = /aa22/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('User Operation expired.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `validAfter` or `validUntil` values returned from `validateUserOp` on the Smart Account are not satisfied',\n      ].filter(Boolean) as string[],\n      name: 'UserOperationExpiredError',\n    })\n  }\n}\n\nexport type UserOperationPaymasterExpiredErrorType =\n  UserOperationPaymasterExpiredError & {\n    name: 'UserOperationPaymasterExpiredError'\n  }\nexport class UserOperationPaymasterExpiredError extends BaseError {\n  static message = /aa32/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Paymaster for User Operation expired.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `validAfter` or `validUntil` values returned from `validatePaymasterUserOp` on the Paymaster are not satisfied',\n      ].filter(Boolean) as string[],\n      name: 'UserOperationPaymasterExpiredError',\n    })\n  }\n}\n\nexport type UserOperationSignatureErrorType = UserOperationSignatureError & {\n  name: 'UserOperationSignatureError'\n}\nexport class UserOperationSignatureError extends BaseError {\n  static message = /aa24/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Signature provided for the User Operation is invalid.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `signature` for the User Operation is incorrectly computed, and unable to be verified by the Smart Account',\n      ].filter(Boolean) as string[],\n      name: 'UserOperationSignatureError',\n    })\n  }\n}\n\nexport type UserOperationPaymasterSignatureErrorType =\n  UserOperationPaymasterSignatureError & {\n    name: 'UserOperationPaymasterSignatureError'\n  }\nexport class UserOperationPaymasterSignatureError extends BaseError {\n  static message = /aa34/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('Signature provided for the User Operation is invalid.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `signature` for the User Operation is incorrectly computed, and unable to be verified by the Paymaster',\n      ].filter(Boolean) as string[],\n      name: 'UserOperationPaymasterSignatureError',\n    })\n  }\n}\n\nexport type UserOperationRejectedByEntryPointErrorType =\n  UserOperationRejectedByEntryPointError & {\n    code: -32500\n    name: 'UserOperationRejectedByEntryPointError'\n  }\nexport class UserOperationRejectedByEntryPointError extends BaseError {\n  static code = -32500\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      \"User Operation rejected by EntryPoint's `simulateValidation` during account creation or validation.\",\n      {\n        cause,\n        name: 'UserOperationRejectedByEntryPointError',\n      },\n    )\n  }\n}\n\nexport type UserOperationRejectedByPaymasterErrorType =\n  UserOperationRejectedByPaymasterError & {\n    code: -32501\n    name: 'UserOperationRejectedByPaymasterError'\n  }\nexport class UserOperationRejectedByPaymasterError extends BaseError {\n  static code = -32501\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\"User Operation rejected by Paymaster's `validatePaymasterUserOp`.\", {\n      cause,\n      name: 'UserOperationRejectedByPaymasterError',\n    })\n  }\n}\n\nexport type UserOperationRejectedByOpCodeErrorType =\n  UserOperationRejectedByOpCodeError & {\n    code: -32502\n    name: 'UserOperationRejectedByOpCodeError'\n  }\nexport class UserOperationRejectedByOpCodeError extends BaseError {\n  static code = -32502\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super('User Operation rejected with op code validation error.', {\n      cause,\n      name: 'UserOperationRejectedByOpCodeError',\n    })\n  }\n}\n\nexport type UserOperationOutOfTimeRangeErrorType =\n  UserOperationOutOfTimeRangeError & {\n    code: -32503\n    name: 'UserOperationOutOfTimeRangeError'\n  }\nexport class UserOperationOutOfTimeRangeError extends BaseError {\n  static code = -32503\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      'UserOperation out of time-range: either wallet or paymaster returned a time-range, and it is already expired (or will expire soon).',\n      {\n        cause,\n        name: 'UserOperationOutOfTimeRangeError',\n      },\n    )\n  }\n}\n\nexport type UnknownBundlerErrorType = UnknownBundlerError & {\n  name: 'UnknownBundlerError'\n}\nexport class UnknownBundlerError extends BaseError {\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(\n      `An error occurred while executing user operation: ${cause?.shortMessage}`,\n      {\n        cause,\n        name: 'UnknownBundlerError',\n      },\n    )\n  }\n}\n\nexport type VerificationGasLimitExceededErrorType =\n  VerificationGasLimitExceededError & {\n    name: 'VerificationGasLimitExceededError'\n  }\nexport class VerificationGasLimitExceededError extends BaseError {\n  static message = /aa40/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('User Operation verification gas limit exceeded.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the gas used for verification exceeded the `verificationGasLimit`',\n      ].filter(Boolean) as string[],\n      name: 'VerificationGasLimitExceededError',\n    })\n  }\n}\n\nexport type VerificationGasLimitTooLowErrorType =\n  VerificationGasLimitTooLowError & {\n    name: 'VerificationGasLimitTooLowError'\n  }\nexport class VerificationGasLimitTooLowError extends BaseError {\n  static message = /aa41/\n  constructor({\n    cause,\n  }: {\n    cause?: BaseError | undefined\n  }) {\n    super('User Operation verification gas limit is too low.', {\n      cause,\n      metaMessages: [\n        'This could arise when:',\n        '- the `verificationGasLimit` is too low to verify the User Operation',\n      ].filter(Boolean) as string[],\n      name: 'VerificationGasLimitTooLowError',\n    })\n  }\n}\n","import {\n  EvmUserOperationStatus,\n  EvmUserOperation,\n  CdpOpenApiClientType,\n} from \"../../openapi-client/index.js\";\nimport { wait, WaitOptions } from \"../../utils/wait.js\";\n\nimport type { Address, Hex } from \"../../types/misc.js\";\n\n/**\n * Options for waiting for a user operation.\n */\nexport type WaitForUserOperationOptions = {\n  /** The hash of the user operation. */\n  userOpHash: Hex;\n  /** The address of the smart account. */\n  smartAccountAddress: Address;\n  /** Optional options for the wait operation. */\n  waitOptions?: WaitOptions;\n};\n\n/**\n * Represents a failed user operation.\n */\nexport type FailedOperation = {\n  /** The address of the smart account. */\n  smartAccountAddress: Address;\n  /** The status of the user operation. */\n  status: typeof EvmUserOperationStatus.failed;\n  /** The hash of the user operation. This is not the transaction hash which is only available after the operation is completed.*/\n  userOpHash: Hex;\n};\n\n/**\n * Represents a completed user operation.\n */\nexport type CompletedOperation = {\n  /** The address of the smart account. */\n  smartAccountAddress: Address;\n  /** The transaction hash that executed the completed user operation. */\n  transactionHash: string;\n  /** The status of the user operation. */\n  status: typeof EvmUserOperationStatus.complete;\n  /** The hash of the user operation. This is not the transaction hash which is only available after the operation is completed.*/\n  userOpHash: Hex;\n};\n\n/**\n * Represents the return type of the waitForUserOperation function.\n */\nexport type WaitForUserOperationReturnType = FailedOperation | CompletedOperation;\n\n/**\n * Waits for a user operation to complete or fail.\n *\n * @example\n * ```ts\n * import { waitForUserOperation } from \"@coinbase/cdp-sdk\";\n *\n * const result = await waitForUserOperation(client, {\n *   userOpHash: \"0x1234567890123456789012345678901234567890\",\n *   smartAccountAddress: \"0x1234567890123456789012345678901234567890\",\n *   waitOptions: {\n *     timeoutSeconds: 30,\n *   },\n * });\n * ```\n *\n * @param {CdpOpenApiClientType} client - The client to use to wait for the user operation.\n * @param {WaitForUserOperationOptions} options - The options for the wait operation.\n * @returns {Promise<WaitForUserOperationReturnType>} The result of the user operation.\n */\nexport async function waitForUserOperation(\n  client: CdpOpenApiClientType,\n  options: WaitForUserOperationOptions,\n): Promise<WaitForUserOperationReturnType> {\n  const { userOpHash, smartAccountAddress } = options;\n\n  const reload = async () => {\n    const response = await client.getUserOperation(smartAccountAddress, userOpHash);\n    return response;\n  };\n\n  const transform = (operation: EvmUserOperation): WaitForUserOperationReturnType => {\n    if (operation.status === EvmUserOperationStatus.failed) {\n      return {\n        smartAccountAddress: smartAccountAddress,\n        status: EvmUserOperationStatus.failed,\n        userOpHash: operation.userOpHash as Hex,\n      } satisfies FailedOperation;\n    } else if (operation.status === EvmUserOperationStatus.complete) {\n      return {\n        smartAccountAddress: smartAccountAddress,\n        transactionHash: operation.transactionHash!,\n        status: EvmUserOperationStatus.complete,\n        userOpHash: operation.userOpHash as Hex,\n      } satisfies CompletedOperation;\n    } else {\n      throw new Error(\"User operation is not terminal\");\n    }\n  };\n\n  const waitOptions = options.waitOptions || {\n    timeoutSeconds: 30,\n  };\n\n  return await wait(reload, isTerminal, transform, waitOptions);\n}\n\nconst isTerminal = (operation: EvmUserOperation): boolean => {\n  return (\n    operation.status === EvmUserOperationStatus.complete ||\n    operation.status === EvmUserOperationStatus.failed\n  );\n};\n","import { Connection } from \"@solana/web3.js\";\n\nimport {\n  GENESIS_HASH_MAINNET,\n  GENESIS_HASH_DEVNET,\n  USDC_MAINNET_MINT_ADDRESS,\n  USDC_DEVNET_MINT_ADDRESS,\n} from \"./constants.js\";\n\nexport type Network = \"mainnet\" | \"devnet\";\n\ntype GetOrCreateConnectionOptions = {\n  networkOrConnection: Network | Connection;\n};\n\n/**\n * Get a connection for the Solana network\n *\n * @param options - The options for the connection\n *\n * @param options.networkOrConnection - The network to use or a connection\n *\n * @returns The connection\n */\nexport function getOrCreateConnection({\n  networkOrConnection,\n}: GetOrCreateConnectionOptions): Connection {\n  if (typeof networkOrConnection !== \"string\") {\n    return networkOrConnection;\n  }\n\n  return new Connection(\n    networkOrConnection === \"mainnet\"\n      ? \"https://api.mainnet-beta.solana.com\"\n      : \"https://api.devnet.solana.com\",\n  );\n}\n\n/**\n * Legacy function for compatibility during migration\n *\n * @param connection - The Solana Connection instance\n * @returns The network type (mainnet or devnet)\n */\nexport async function getConnectedNetwork(connection: Connection): Promise<Network> {\n  const genesisHash = await connection.getGenesisHash();\n\n  if (genesisHash === GENESIS_HASH_MAINNET) {\n    return \"mainnet\";\n  } else if (genesisHash === GENESIS_HASH_DEVNET) {\n    return \"devnet\";\n  }\n\n  throw new Error(\"Unknown or unsupported network\");\n}\n\n/**\n * Get the USDC mint address for the given connection\n *\n * @param network - The network to use\n *\n * @returns The USDC mint address\n */\nexport function getUsdcMintAddress(network: Network): string {\n  if (network === \"mainnet\") {\n    return USDC_MAINNET_MINT_ADDRESS;\n  }\n  return USDC_DEVNET_MINT_ADDRESS;\n}\n","import {\n    combineCodec,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    transformEncoder,\n} from '@solana/codecs-core';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\n/**\n * Represents a string that validates as a Solana address. Functions that require well-formed\n * addresses should specify their inputs in terms of this type.\n *\n * Whenever you need to validate an arbitrary string as a base58-encoded address, use the\n * {@link address}, {@link assertIsAddress}, or {@link isAddress} functions in this package.\n */\nexport type Address<TAddress extends string = string> = Brand<EncodedString<TAddress, 'base58'>, 'Address'>;\n\nlet memoizedBase58Encoder: Encoder<string> | undefined;\nlet memoizedBase58Decoder: Decoder<string> | undefined;\n\nfunction getMemoizedBase58Encoder(): Encoder<string> {\n    if (!memoizedBase58Encoder) memoizedBase58Encoder = getBase58Encoder();\n    return memoizedBase58Encoder;\n}\n\nfunction getMemoizedBase58Decoder(): Decoder<string> {\n    if (!memoizedBase58Decoder) memoizedBase58Decoder = getBase58Decoder();\n    return memoizedBase58Decoder;\n}\n\n/**\n * A type guard that returns `true` if the input string conforms to the {@link Address} type, and\n * refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isAddress } from '@solana/addresses';\n *\n * if (isAddress(ownerAddress)) {\n *     // At this point, `ownerAddress` has been refined to a\n *     // `Address` that can be used with the RPC.\n *     const { value: lamports } = await rpc.getBalance(ownerAddress).send();\n *     setBalanceLamports(lamports);\n * } else {\n *     setError(`${ownerAddress} is not an address`);\n * }\n * ```\n */\nexport function isAddress(putativeAddress: string): putativeAddress is Address<typeof putativeAddress> {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest address (32 bytes of zeroes)\n        putativeAddress.length < 32 ||\n        // Highest address (32 bytes of 255)\n        putativeAddress.length > 44\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    try {\n        return base58Encoder.encode(putativeAddress).byteLength === 32;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * From time to time you might acquire a string, that you expect to validate as an address or public\n * key, from an untrusted network API or user input. Use this function to assert that such an\n * arbitrary string is a base58-encoded address.\n *\n * @example\n * ```ts\n * import { assertIsAddress } from '@solana/addresses';\n *\n * // Imagine a function that fetches an account's balance when a user submits a form.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const address: string = accountAddressInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `address` to `Address`.\n *         assertIsAddress(address);\n *         // At this point, `address` is an `Address` that can be used with the RPC.\n *         const balanceInLamports = await rpc.getBalance(address).send();\n *     } catch (e) {\n *         // `address` turned out not to be a base58-encoded address\n *     }\n * }\n * ```\n */\nexport function assertIsAddress(putativeAddress: string): asserts putativeAddress is Address<typeof putativeAddress> {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest address (32 bytes of zeroes)\n        putativeAddress.length < 32 ||\n        // Highest address (32 bytes of 255)\n        putativeAddress.length > 44\n    ) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeAddress.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeAddress);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\n/**\n * Combines _asserting_ that a string is an address with _coercing_ it to the {@link Address} type.\n * It's most useful with untrusted input.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n *\n * await transfer(address(fromAddress), address(toAddress), lamports(100000n));\n * ```\n *\n * > [!TIP]\n * > When starting from a known-good address as a string, it's more efficient to typecast it rather\n * than to use the {@link address} helper, because the helper unconditionally performs validation on\n * its input.\n * >\n * > ```ts\n * > import { Address } from '@solana/addresses';\n * >\n * > const MEMO_PROGRAM_ADDRESS =\n * >     'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr' as Address<'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'>;\n * > ```\n */\nexport function address<TAddress extends string = string>(putativeAddress: TAddress): Address<TAddress> {\n    assertIsAddress(putativeAddress);\n    return putativeAddress as Address<TAddress>;\n}\n\n/**\n * Returns an encoder that you can use to encode a base58-encoded address to a byte array.\n *\n * @example\n * ```ts\n * import { getAddressEncoder } from '@solana/addresses';\n *\n * const address = 'B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka' as Address;\n * const addressEncoder = getAddressEncoder();\n * const addressBytes = addressEncoder.encode(address);\n * // Uint8Array(32) [\n * //   150, 183, 190,  48, 171,   8, 39, 156,\n * //   122, 213, 172, 108, 193,  95, 26, 158,\n * //   149, 243, 115, 254,  20, 200, 36,  30,\n * //   248, 179, 178, 232, 220,  89, 53, 127\n * // ]\n * ```\n */\nexport function getAddressEncoder(): FixedSizeEncoder<Address, 32> {\n    return transformEncoder(fixEncoderSize(getMemoizedBase58Encoder(), 32), putativeAddress =>\n        address(putativeAddress),\n    );\n}\n\n/**\n * Returns a decoder that you can use to convert an array of 32 bytes representing an address to the\n * base58-encoded representation of that address.\n *\n * @example\n * ```ts\n * import { getAddressDecoder } from '@solana/addresses';\n *\n * const addressBytes = new Uint8Array([\n *     150, 183, 190,  48, 171,   8, 39, 156,\n *     122, 213, 172, 108, 193,  95, 26, 158,\n *     149, 243, 115, 254,  20, 200, 36,  30,\n *     248, 179, 178, 232, 220,  89, 53, 127\n * ]);\n * const addressDecoder = getAddressDecoder();\n * const address = addressDecoder.decode(addressBytes); // B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka\n * ```\n */\nexport function getAddressDecoder(): FixedSizeDecoder<Address, 32> {\n    return fixDecoderSize(getMemoizedBase58Decoder(), 32) as FixedSizeDecoder<Address, 32>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a base-58 encoded address.\n *\n * @see {@link getAddressDecoder}\n * @see {@link getAddressEncoder}\n */\nexport function getAddressCodec(): FixedSizeCodec<Address, Address, 32> {\n    return combineCodec(getAddressEncoder(), getAddressDecoder());\n}\n\nexport function getAddressComparator(): (x: string, y: string) => number {\n    return new Intl.Collator('en', {\n        caseFirst: 'lower',\n        ignorePunctuation: false,\n        localeMatcher: 'best fit',\n        numeric: false,\n        sensitivity: 'variant',\n        usage: 'sort',\n    }).compare;\n}\n","import * as chains from \"viem/chains\";\n\nimport type { Chain } from \"viem\";\n\n/**\n * Network identifier to viem chain mapping\n */\nexport const NETWORK_TO_CHAIN_MAP: Record<string, Chain> = {\n  base: chains.base,\n  \"base-sepolia\": chains.baseSepolia,\n  ethereum: chains.mainnet,\n  \"ethereum-sepolia\": chains.sepolia,\n  polygon: chains.polygon,\n  \"polygon-mumbai\": chains.polygonMumbai,\n  arbitrum: chains.arbitrum,\n  \"arbitrum-sepolia\": chains.arbitrumSepolia,\n  optimism: chains.optimism,\n  \"optimism-sepolia\": chains.optimismSepolia,\n};\n\n/**\n * Resolves a network identifier to a viem chain\n *\n * @param network - The network identifier to resolve\n * @returns The resolved viem chain\n * @throws Error if the network identifier is not supported\n */\nexport function resolveNetworkToChain(network: string): Chain {\n  const chain = NETWORK_TO_CHAIN_MAP[network.toLowerCase()];\n  if (!chain) {\n    throw new Error(`Unsupported network identifier: ${network}`);\n  }\n  return chain;\n}\n","import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport { getAddress } from '../../utils/address/getAddress.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\n\nexport type RequestAddressesReturnType = Address[]\n\nexport type RequestAddressesErrorType = RequestErrorType | ErrorType\n\n/**\n * Requests a list of accounts managed by a wallet.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/requestAddresses\n * - JSON-RPC Methods: [`eth_requestAccounts`](https://eips.ethereum.org/EIPS/eip-1102)\n *\n * Sends a request to the wallet, asking for permission to access the user's accounts. After the user accepts the request, it will return a list of accounts (addresses).\n *\n * This API can be useful for dapps that need to access the user's accounts in order to execute transactions or interact with smart contracts.\n *\n * @param client - Client to use\n * @returns List of accounts managed by a wallet {@link RequestAddressesReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { requestAddresses } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const accounts = await requestAddresses(client)\n */\nexport async function requestAddresses<\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n): Promise<RequestAddressesReturnType> {\n  const addresses = await client.request(\n    { method: 'eth_requestAccounts' },\n    { dedupe: true, retryCount: 0 },\n  )\n  return addresses.map((address) => getAddress(address))\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/core/error/utils.ts","import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { ExtractCapabilities } from '../../types/capabilities.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { WalletGetCallsStatusReturnType } from '../../types/eip1193.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RpcTransactionReceipt } from '../../types/rpc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { sliceHex } from '../../utils/data/slice.js'\nimport { trim } from '../../utils/data/trim.js'\nimport { hexToBigInt, hexToNumber } from '../../utils/encoding/fromHex.js'\nimport { receiptStatuses } from '../../utils/formatters/transactionReceipt.js'\nimport {\n  fallbackMagicIdentifier,\n  fallbackTransactionErrorMagicIdentifier,\n} from './sendCalls.js'\n\nexport type GetCallsStatusParameters = { id: string }\n\nexport type GetCallsStatusReturnType = Prettify<\n  Omit<\n    WalletGetCallsStatusReturnType<\n      ExtractCapabilities<'getCallsStatus', 'ReturnType'>,\n      number,\n      bigint,\n      'success' | 'reverted'\n    >,\n    'status'\n  > & {\n    statusCode: number\n    status: 'pending' | 'success' | 'failure' | undefined\n  }\n>\n\nexport type GetCallsStatusErrorType = RequestErrorType | ErrorType\n\n/**\n * Returns the status of a call batch that was sent via `sendCalls`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/getCallsStatus\n * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns Status of the calls. {@link GetCallsStatusReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getCallsStatus } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const { receipts, status } = await getCallsStatus(client, { id: '0xdeadbeef' })\n */\nexport async function getCallsStatus<\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: GetCallsStatusParameters,\n): Promise<GetCallsStatusReturnType> {\n  async function getStatus(id: Hex) {\n    const isTransactions = id.endsWith(fallbackMagicIdentifier.slice(2))\n    if (isTransactions) {\n      const chainId = trim(sliceHex(id, -64, -32))\n      const hashes = sliceHex(id, 0, -64)\n        .slice(2)\n        .match(/.{1,64}/g)\n\n      const receipts = await Promise.all(\n        hashes!.map((hash) =>\n          fallbackTransactionErrorMagicIdentifier.slice(2) !== hash\n            ? client.request(\n                {\n                  method: 'eth_getTransactionReceipt',\n                  params: [`0x${hash}`],\n                },\n                { dedupe: true },\n              )\n            : undefined,\n        ),\n      )\n\n      const status = (() => {\n        if (receipts.some((r) => r === null)) return 100 // pending\n        if (receipts.every((r) => r?.status === '0x1')) return 200 // success\n        if (receipts.every((r) => r?.status === '0x0')) return 500 // complete failure\n        return 600 // partial failure\n      })()\n\n      return {\n        atomic: false,\n        chainId: hexToNumber(chainId),\n        receipts: receipts.filter(Boolean) as RpcTransactionReceipt[],\n        status,\n        version: '2.0.0',\n      }\n    }\n    return client.request({\n      method: 'wallet_getCallsStatus',\n      params: [id],\n    })\n  }\n\n  const {\n    atomic = false,\n    chainId,\n    receipts,\n    version = '2.0.0',\n    ...response\n  } = await getStatus(parameters.id as Hex)\n  const [status, statusCode] = (() => {\n    const statusCode = response.status\n    if (statusCode >= 100 && statusCode < 200)\n      return ['pending', statusCode] as const\n    if (statusCode >= 200 && statusCode < 300)\n      return ['success', statusCode] as const\n    if (statusCode >= 300 && statusCode < 700)\n      return ['failure', statusCode] as const\n    // @ts-expect-error: for backwards compatibility\n    if (statusCode === 'CONFIRMED') return ['success', 200] as const\n    // @ts-expect-error: for backwards compatibility\n    if (statusCode === 'PENDING') return ['pending', 100] as const\n    return [undefined, statusCode]\n  })()\n  return {\n    ...response,\n    atomic,\n    // @ts-expect-error: for backwards compatibility\n    chainId: chainId ? hexToNumber(chainId) : undefined,\n    receipts:\n      receipts?.map((receipt) => ({\n        ...receipt,\n        blockNumber: hexToBigInt(receipt.blockNumber),\n        gasUsed: hexToBigInt(receipt.gasUsed),\n        status: receiptStatuses[receipt.status as '0x0' | '0x1'],\n      })) ?? [],\n    statusCode,\n    status,\n    version,\n  }\n}\n","import { TimeoutError } from \"../errors.js\";\n\n/**\n * Options for the wait function\n */\nexport type WaitOptions = {\n  /** Interval between retries in seconds. Defaults to 0.2 */\n  intervalSeconds?: number;\n  /** Maximum time to wait before timing out in seconds. Defaults to 10 */\n  timeoutSeconds?: number;\n};\n\n/**\n * Polls a resource until a terminal condition is met or timeout occurs.\n *\n * @param reload - Function that fetches the latest state of the resource\n * @param isTerminal - Function that determines if the current state is terminal\n * @param transform - Function that transforms the resource into a new type\n * @param options - Configuration options for polling behavior\n * @returns The resource in its terminal state\n * @throws {TimeoutError} If the operation exceeds the timeout duration\n *\n * @example\n * const result = await wait(\n *   () => fetchOrderStatus(orderId),\n *   (status) => status === 'completed',\n *   (status) => status === 'completed' ? { status } : undefined,\n *   { timeoutSeconds: 30 }\n * );\n */\nexport async function wait<T, K = T>(\n  reload: () => Promise<T>,\n  isTerminal: (obj: T) => boolean,\n  transform: (obj: T) => K = (obj: T) => obj as unknown as K,\n  options: WaitOptions = {},\n): Promise<K> {\n  const { intervalSeconds = 0.2, timeoutSeconds = 10 } = options;\n  const startTime = Date.now();\n\n  while (Date.now() - startTime < timeoutSeconds * 1000) {\n    const updatedObject = await reload();\n\n    if (isTerminal(updatedObject)) {\n      return transform(updatedObject);\n    }\n\n    await new Promise(resolve => setTimeout(resolve, intervalSeconds * 1000));\n  }\n  throw new TimeoutError(\n    `Operation has not reached a terminal state after ${timeoutSeconds} seconds and may still succeed. Retry with a longer timeout using the timeoutSeconds option.`,\n  );\n}\n","import type { ErrorType } from '../../../errors/utils.js'\nimport type { SignedAuthorization } from '../../../types/authorization.js'\nimport type { ExactPartial } from '../../../types/utils.js'\nimport { numberToHex } from '../../../utils/encoding/toHex.js'\nimport { pad } from '../../../utils/index.js'\nimport type { RpcUserOperation } from '../../types/rpc.js'\nimport type { UserOperation } from '../../types/userOperation.js'\n\nexport type FormatUserOperationRequestErrorType = ErrorType\n\nexport function formatUserOperationRequest(\n  request: ExactPartial<UserOperation>,\n) {\n  const rpcRequest = {} as RpcUserOperation\n\n  if (typeof request.callData !== 'undefined')\n    rpcRequest.callData = request.callData\n  if (typeof request.callGasLimit !== 'undefined')\n    rpcRequest.callGasLimit = numberToHex(request.callGasLimit)\n  if (typeof request.factory !== 'undefined')\n    rpcRequest.factory = request.factory\n  if (typeof request.factoryData !== 'undefined')\n    rpcRequest.factoryData = request.factoryData\n  if (typeof request.initCode !== 'undefined')\n    rpcRequest.initCode = request.initCode\n  if (typeof request.maxFeePerGas !== 'undefined')\n    rpcRequest.maxFeePerGas = numberToHex(request.maxFeePerGas)\n  if (typeof request.maxPriorityFeePerGas !== 'undefined')\n    rpcRequest.maxPriorityFeePerGas = numberToHex(request.maxPriorityFeePerGas)\n  if (typeof request.nonce !== 'undefined')\n    rpcRequest.nonce = numberToHex(request.nonce)\n  if (typeof request.paymaster !== 'undefined')\n    rpcRequest.paymaster = request.paymaster\n  if (typeof request.paymasterAndData !== 'undefined')\n    rpcRequest.paymasterAndData = request.paymasterAndData || '0x'\n  if (typeof request.paymasterData !== 'undefined')\n    rpcRequest.paymasterData = request.paymasterData\n  if (typeof request.paymasterPostOpGasLimit !== 'undefined')\n    rpcRequest.paymasterPostOpGasLimit = numberToHex(\n      request.paymasterPostOpGasLimit,\n    )\n  if (typeof request.paymasterVerificationGasLimit !== 'undefined')\n    rpcRequest.paymasterVerificationGasLimit = numberToHex(\n      request.paymasterVerificationGasLimit,\n    )\n  if (typeof request.preVerificationGas !== 'undefined')\n    rpcRequest.preVerificationGas = numberToHex(request.preVerificationGas)\n  if (typeof request.sender !== 'undefined') rpcRequest.sender = request.sender\n  if (typeof request.signature !== 'undefined')\n    rpcRequest.signature = request.signature\n  if (typeof request.verificationGasLimit !== 'undefined')\n    rpcRequest.verificationGasLimit = numberToHex(request.verificationGasLimit)\n  if (typeof request.authorization !== 'undefined')\n    rpcRequest.eip7702Auth = formatAuthorization(request.authorization)\n\n  return rpcRequest\n}\n\nfunction formatAuthorization(authorization: SignedAuthorization) {\n  return {\n    address: authorization.address,\n    chainId: numberToHex(authorization.chainId),\n    nonce: numberToHex(authorization.nonce),\n    r: authorization.r\n      ? numberToHex(BigInt(authorization.r), { size: 32 })\n      : pad('0x', { size: 32 }),\n    s: authorization.s\n      ? numberToHex(BigInt(authorization.s), { size: 32 })\n      : pad('0x', { size: 32 }),\n    yParity: authorization.yParity\n      ? numberToHex(authorization.yParity, { size: 1 })\n      : pad('0x', { size: 32 }),\n  }\n}\n","import type { AbiItemType } from '../../abi.js'\nimport { BaseError } from '../../errors.js'\n\nexport class InvalidSignatureError extends BaseError {\n  override name = 'InvalidSignatureError'\n\n  constructor({\n    signature,\n    type,\n  }: {\n    signature: string\n    type: AbiItemType | 'struct'\n  }) {\n    super(`Invalid ${type} signature.`, {\n      details: signature,\n    })\n  }\n}\n\nexport class UnknownSignatureError extends BaseError {\n  override name = 'UnknownSignatureError'\n\n  constructor({ signature }: { signature: string }) {\n    super('Unknown signature.', {\n      details: signature,\n    })\n  }\n}\n\nexport class InvalidStructSignatureError extends BaseError {\n  override name = 'InvalidStructSignatureError'\n\n  constructor({ signature }: { signature: string }) {\n    super('Invalid struct signature.', {\n      details: signature,\n      metaMessages: ['No properties exist.'],\n    })\n  }\n}\n","import {\n  type TransactionSerializable,\n  type TypedDataDefinition,\n  type TypedData,\n  type HashTypedDataParameters,\n  getTypesForEIP712Domain,\n  serializeTransaction,\n} from \"viem\";\n\nimport { toNetworkScopedEvmServerAccount } from \"./toNetworkScopedEvmServerAccount.js\";\nimport {\n  listTokenBalances,\n  type ListTokenBalancesResult,\n  type ListTokenBalancesOptions,\n} from \"../../actions/evm/listTokenBalances.js\";\nimport {\n  requestFaucet,\n  type RequestFaucetOptions,\n  type RequestFaucetResult,\n} from \"../../actions/evm/requestFaucet.js\";\nimport { sendTransaction } from \"../../actions/evm/sendTransaction.js\";\nimport { useSpendPermission } from \"../../actions/evm/spend-permissions/account.use.js\";\nimport { UseSpendPermissionOptions } from \"../../actions/evm/spend-permissions/types.js\";\nimport { createSwapQuote } from \"../../actions/evm/swap/createSwapQuote.js\";\nimport { sendSwapTransaction } from \"../../actions/evm/swap/sendSwapTransaction.js\";\nimport { accountTransferStrategy } from \"../../actions/evm/transfer/accountTransferStrategy.js\";\nimport { transfer } from \"../../actions/evm/transfer/transfer.js\";\nimport { Analytics } from \"../../analytics.js\";\n\nimport type { EvmServerAccount, NetworkOrRpcUrl } from \"./types.js\";\nimport type {\n  SendTransactionOptions,\n  TransactionResult,\n} from \"../../actions/evm/sendTransaction.js\";\nimport type {\n  AccountSwapOptions,\n  AccountSwapResult,\n  AccountQuoteSwapOptions,\n  AccountQuoteSwapResult,\n} from \"../../actions/evm/swap/types.js\";\nimport type { CdpOpenApiClientType, EvmAccount } from \"../../openapi-client/index.js\";\nimport type { Address, EIP712Domain, Hash, Hex } from \"../../types/misc.js\";\n\n/**\n * Options for converting a pre-existing EvmAccount to a EvmServerAccount.\n */\nexport type ToEvmServerAccountOptions = {\n  /** The EvmAccount that was previously created. */\n  account: EvmAccount;\n};\n\n/**\n * Creates a Server-managed EvmAccount instance from an existing EvmAccount.\n * Use this to interact with previously deployed EvmAccounts, rather than creating new ones.\n *\n * @param {CdpOpenApiClientType} apiClient - The API client.\n * @param {ToEvmServerAccountOptions} options - Configuration options.\n * @param {EvmAccount} options.account - The EvmAccount that was previously created.\n * @returns {EvmServerAccount} A configured EvmAccount instance ready for signing.\n */\nexport function toEvmServerAccount(\n  apiClient: CdpOpenApiClientType,\n  options: ToEvmServerAccountOptions,\n): EvmServerAccount {\n  const account: EvmServerAccount = {\n    address: options.account.address as Address,\n    async signMessage({ message }) {\n      Analytics.trackAction({\n        action: \"sign_message\",\n        accountType: \"evm_server\",\n      });\n\n      const result = await apiClient.signEvmMessage(options.account.address, {\n        message: message.toString(),\n      });\n      return result.signature as Hex;\n    },\n\n    async sign(parameters: { hash: Hash }) {\n      Analytics.trackAction({\n        action: \"sign\",\n        accountType: \"evm_server\",\n      });\n\n      const result = await apiClient.signEvmHash(options.account.address, {\n        hash: parameters.hash,\n      });\n      return result.signature as Hex;\n    },\n\n    async signTransaction(transaction: TransactionSerializable) {\n      Analytics.trackAction({\n        action: \"sign_transaction\",\n        accountType: \"evm_server\",\n      });\n\n      const result = await apiClient.signEvmTransaction(options.account.address, {\n        transaction: serializeTransaction(transaction),\n      });\n      return result.signedTransaction as Hex;\n    },\n\n    async signTypedData<\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(parameters: TypedDataDefinition<typedData, primaryType>) {\n      Analytics.trackAction({\n        action: \"sign_typed_data\",\n        accountType: \"evm_server\",\n      });\n\n      const { domain = {}, message, primaryType } = parameters as HashTypedDataParameters;\n      const types = {\n        EIP712Domain: getTypesForEIP712Domain({ domain }),\n        ...parameters.types,\n      };\n\n      const openApiMessage = {\n        domain: domain as EIP712Domain,\n        types,\n        primaryType,\n        message,\n      };\n\n      const result = await apiClient.signEvmTypedData(options.account.address, openApiMessage);\n      return result.signature as Hex;\n    },\n    async transfer(transferArgs): Promise<TransactionResult> {\n      Analytics.trackAction({\n        action: \"transfer\",\n        accountType: \"evm_server\",\n        properties: {\n          network: transferArgs.network,\n        },\n      });\n\n      return transfer(apiClient, account, transferArgs, accountTransferStrategy);\n    },\n    async listTokenBalances(\n      options: Omit<ListTokenBalancesOptions, \"address\">,\n    ): Promise<ListTokenBalancesResult> {\n      Analytics.trackAction({\n        action: \"list_token_balances\",\n        accountType: \"evm_server\",\n        properties: {\n          network: options.network,\n        },\n      });\n\n      return listTokenBalances(apiClient, {\n        ...options,\n        address: this.address,\n      });\n    },\n    async requestFaucet(\n      options: Omit<RequestFaucetOptions, \"address\">,\n    ): Promise<RequestFaucetResult> {\n      Analytics.trackAction({\n        action: \"request_faucet\",\n        accountType: \"evm_server\",\n        properties: {\n          network: options.network,\n        },\n      });\n\n      return requestFaucet(apiClient, {\n        ...options,\n        address: this.address,\n      });\n    },\n    async sendTransaction(options: Omit<SendTransactionOptions, \"address\">) {\n      Analytics.trackAction({\n        action: \"send_transaction\",\n        accountType: \"evm_server\",\n        properties: {\n          network: options.network,\n        },\n      });\n\n      return sendTransaction(apiClient, {\n        ...options,\n        address: this.address,\n      });\n    },\n    async quoteSwap(options: AccountQuoteSwapOptions): Promise<AccountQuoteSwapResult> {\n      Analytics.trackAction({\n        action: \"quote_swap\",\n        accountType: \"evm_server\",\n        properties: {\n          network: options.network,\n        },\n      });\n\n      return createSwapQuote(apiClient, {\n        ...options,\n        taker: this.address,\n      });\n    },\n    async swap(options: AccountSwapOptions): Promise<AccountSwapResult> {\n      Analytics.trackAction({\n        action: \"swap\",\n        accountType: \"evm_server\",\n        properties: {\n          network: \"network\" in options ? options.network : undefined,\n        },\n      });\n\n      return sendSwapTransaction(apiClient, {\n        ...options,\n        address: this.address,\n        taker: this.address, // Always use account's address as taker\n      });\n    },\n    async useSpendPermission(options: UseSpendPermissionOptions): Promise<TransactionResult> {\n      Analytics.trackAction({\n        action: \"use_spend_permission\",\n        accountType: \"evm_server\",\n        properties: {\n          network: options.network,\n        },\n      });\n\n      return useSpendPermission(apiClient, this.address, options);\n    },\n    name: options.account.name,\n    type: \"evm-server\",\n    policies: options.account.policies,\n    useNetwork: async <Network extends NetworkOrRpcUrl>(networkOrRpcUrl: Network) => {\n      Analytics.trackAction({\n        action: \"use_network\",\n        accountType: \"evm_server\",\n        properties: {\n          network: networkOrRpcUrl,\n        },\n      });\n\n      return toNetworkScopedEvmServerAccount({\n        account,\n        network: networkOrRpcUrl,\n      });\n    },\n  };\n\n  return account;\n}\n","/**\n * Generated by orval v7.6.0 \n * Do not edit manually.\n * Coinbase Developer Platform APIs\n * The Coinbase Developer Platform APIs - leading the world's transition onchain.\n * OpenAPI spec version: 2.0.0\n */\nimport type {\n  CreateSolanaAccountBody,\n  ExportSolanaAccount200,\n  ExportSolanaAccountBody,\n  ExportSolanaAccountByName200,\n  ExportSolanaAccountByNameBody,\n  ImportSolanaAccountBody,\n  ListSolanaAccounts200,\n  ListSolanaAccountsParams,\n  SendSolanaTransaction200,\n  SendSolanaTransactionBody,\n  SignSolanaMessage200,\n  SignSolanaMessageBody,\n  SignSolanaTransaction200,\n  SignSolanaTransactionBody,\n  SolanaAccount,\n  UpdateSolanaAccountBody,\n} from \"../coinbaseDeveloperPlatformAPIs.schemas.js\";\n\nimport { cdpApiClient } from \"../../cdpApiClient.js\";\n\ntype SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];\n\n/**\n * Lists the Solana accounts belonging to the developer.\nThe response is paginated, and by default, returns 20 accounts per page.\n\nIf a name is provided, the response will contain only the account with that name.\n * @summary List Solana accounts or get account by name\n */\nexport const listSolanaAccounts = (\n  params?: ListSolanaAccountsParams,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<ListSolanaAccounts200>(\n    { url: `/v2/solana/accounts`, method: \"GET\", params },\n    options,\n  );\n};\n/**\n * Creates a new Solana account.\n * @summary Create a Solana account\n */\nexport const createSolanaAccount = (\n  createSolanaAccountBody?: CreateSolanaAccountBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<SolanaAccount>(\n    {\n      url: `/v2/solana/accounts`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: createSolanaAccountBody,\n    },\n    options,\n  );\n};\n/**\n * Gets a Solana account by its address.\n * @summary Get a Solana account by address\n */\nexport const getSolanaAccount = (\n  address: string,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<SolanaAccount>(\n    { url: `/v2/solana/accounts/${address}`, method: \"GET\" },\n    options,\n  );\n};\n/**\n * Updates an existing Solana account. Use this to update the account's name or account-level policy.\n * @summary Update a Solana account\n */\nexport const updateSolanaAccount = (\n  address: string,\n  updateSolanaAccountBody: UpdateSolanaAccountBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<SolanaAccount>(\n    {\n      url: `/v2/solana/accounts/${address}`,\n      method: \"PUT\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: updateSolanaAccountBody,\n    },\n    options,\n  );\n};\n/**\n * Gets a Solana account by its name.\n * @summary Get a Solana account by name\n */\nexport const getSolanaAccountByName = (\n  name: string,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<SolanaAccount>(\n    { url: `/v2/solana/accounts/by-name/${name}`, method: \"GET\" },\n    options,\n  );\n};\n/**\n * Import an existing Solana account into the developer's CDP Project. This API should be called from the [CDP SDK](https://github.com/coinbase/cdp-sdk) to ensure that the associated private key is properly encrypted.\n * @summary Import a Solana account\n */\nexport const importSolanaAccount = (\n  importSolanaAccountBody: ImportSolanaAccountBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<SolanaAccount>(\n    {\n      url: `/v2/solana/accounts/import`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: importSolanaAccountBody,\n    },\n    options,\n  );\n};\n/**\n * Export an existing Solana account's private key. It is important to store the private key in a secure place after it's exported.\n * @summary Export an Solana account\n */\nexport const exportSolanaAccount = (\n  address: string,\n  exportSolanaAccountBody: ExportSolanaAccountBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<ExportSolanaAccount200>(\n    {\n      url: `/v2/solana/accounts/${address}/export`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: exportSolanaAccountBody,\n    },\n    options,\n  );\n};\n/**\n * Export an existing Solana account's private key by its name. It is important to store the private key in a secure place after it's exported.\n * @summary Export a Solana account by name\n */\nexport const exportSolanaAccountByName = (\n  name: string,\n  exportSolanaAccountByNameBody: ExportSolanaAccountByNameBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<ExportSolanaAccountByName200>(\n    {\n      url: `/v2/solana/accounts/export/by-name/${name}`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: exportSolanaAccountByNameBody,\n    },\n    options,\n  );\n};\n/**\n * Signs a transaction with the given Solana account.\nThe unsigned transaction should be serialized into a byte array and then encoded as base64.\n\n**Transaction types**\n\nThe following transaction types are supported:\n* [Legacy transactions](https://solana-labs.github.io/solana-web3.js/classes/Transaction.html)\n* [Versioned transactions](https://solana-labs.github.io/solana-web3.js/classes/VersionedTransaction.html)\n\nThe developer is responsible for ensuring that the unsigned transaction is valid, as the API will not validate the transaction.\n * @summary Sign a transaction\n */\nexport const signSolanaTransaction = (\n  address: string,\n  signSolanaTransactionBody: SignSolanaTransactionBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<SignSolanaTransaction200>(\n    {\n      url: `/v2/solana/accounts/${address}/sign/transaction`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: signSolanaTransactionBody,\n    },\n    options,\n  );\n};\n/**\n * Signs an arbitrary message with the given Solana account.\n\n**WARNING:** Never sign a message that you didn't generate, as it can be an arbitrary transaction. For example, it might send all of your funds to an attacker.\n * @summary Sign a message\n */\nexport const signSolanaMessage = (\n  address: string,\n  signSolanaMessageBody: SignSolanaMessageBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<SignSolanaMessage200>(\n    {\n      url: `/v2/solana/accounts/${address}/sign/message`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: signSolanaMessageBody,\n    },\n    options,\n  );\n};\n/**\n * Signs and sends a single Solana transaction using multiple Solana accounts. The transaction may contain contain several instructions, each of which may require signatures from different account keys.\n\nThe transaction should be serialized into a byte array and base64 encoded. The API handles recent blockhash management and fee estimation, leaving the developer to provide only the minimal set of fields necessary to send the transaction.\n\n**Transaction types**\n\nThe following transaction types are supported:\n* [Legacy transactions](https://solana.com/developers/guides/advanced/versions#current-transaction-versions)\n* [Versioned transactions](https://solana.com/developers/guides/advanced/versions)\n\n**Instruction Batching**\n\nTo batch multiple operations, include multiple instructions within a single transaction. All instructions within a transaction are executed atomically - if any instruction fails, the entire transaction fails and is rolled back.\n\n**Network Support**\n\nThe following Solana networks are supported:\n* `solana` - Solana Mainnet\n* `solana-devnet` - Solana Devnet\n\nThe developer is responsible for ensuring that the unsigned transaction is valid, as the API will not validate the transaction.\n * @summary Send a Solana transaction\n */\nexport const sendSolanaTransaction = (\n  sendSolanaTransactionBody: SendSolanaTransactionBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<SendSolanaTransaction200>(\n    {\n      url: `/v2/solana/accounts/send/transaction`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: sendSolanaTransactionBody,\n    },\n    options,\n  );\n};\nexport type ListSolanaAccountsResult = NonNullable<Awaited<ReturnType<typeof listSolanaAccounts>>>;\nexport type CreateSolanaAccountResult = NonNullable<\n  Awaited<ReturnType<typeof createSolanaAccount>>\n>;\nexport type GetSolanaAccountResult = NonNullable<Awaited<ReturnType<typeof getSolanaAccount>>>;\nexport type UpdateSolanaAccountResult = NonNullable<\n  Awaited<ReturnType<typeof updateSolanaAccount>>\n>;\nexport type GetSolanaAccountByNameResult = NonNullable<\n  Awaited<ReturnType<typeof getSolanaAccountByName>>\n>;\nexport type ImportSolanaAccountResult = NonNullable<\n  Awaited<ReturnType<typeof importSolanaAccount>>\n>;\nexport type ExportSolanaAccountResult = NonNullable<\n  Awaited<ReturnType<typeof exportSolanaAccount>>\n>;\nexport type ExportSolanaAccountByNameResult = NonNullable<\n  Awaited<ReturnType<typeof exportSolanaAccountByName>>\n>;\nexport type SignSolanaTransactionResult = NonNullable<\n  Awaited<ReturnType<typeof signSolanaTransaction>>\n>;\nexport type SignSolanaMessageResult = NonNullable<Awaited<ReturnType<typeof signSolanaMessage>>>;\nexport type SendSolanaTransactionResult = NonNullable<\n  Awaited<ReturnType<typeof sendSolanaTransaction>>\n>;\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\nimport { Endian, NumberCodecConfig } from './common';\n\ntype NumberFactorySharedInput<TSize extends number> = {\n    config?: NumberCodecConfig;\n    name: string;\n    size: TSize;\n};\n\ntype NumberFactoryEncoderInput<TFrom, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    range?: [bigint | number, bigint | number];\n    set: (view: DataView, value: TFrom, littleEndian?: boolean) => void;\n};\n\ntype NumberFactoryDecoderInput<TTo, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    get: (view: DataView, littleEndian?: boolean) => TTo;\n};\n\nfunction isLittleEndian(config?: NumberCodecConfig): boolean {\n    return config?.endian === Endian.Big ? false : true;\n}\n\nexport function numberEncoderFactory<TFrom extends bigint | number, TSize extends number>(\n    input: NumberFactoryEncoderInput<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: input.size,\n        write(value: TFrom, bytes: Uint8Array, offset: Offset): Offset {\n            if (input.range) {\n                assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n            }\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n            bytes.set(new Uint8Array(arrayBuffer), offset);\n            return offset + input.size;\n        },\n    });\n}\n\nexport function numberDecoderFactory<TTo extends bigint | number, TSize extends number>(\n    input: NumberFactoryDecoderInput<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: input.size,\n        read(bytes, offset = 0): [TTo, number] {\n            assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);\n            assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);\n            const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n            return [input.get(view, isLittleEndian(input.config)), offset + input.size];\n        },\n    });\n}\n\n/**\n * Helper function to ensure that the ArrayBuffer is converted properly from a Uint8Array\n * Source: https://stackoverflow.com/questions/37228285/uint8array-to-arraybuffer\n */\nfunction toArrayBuffer(bytes: ReadonlyUint8Array | Uint8Array, offset?: number, length?: number): ArrayBuffer {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n","import type { Address } from 'abitype'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { OneOf, PartialBy, Prettify } from '../../../types/utils.js'\nimport { hexToBigInt } from '../../../utils/encoding/fromHex.js'\nimport { numberToHex } from '../../../utils/encoding/toHex.js'\nimport type { UserOperation } from '../../types/userOperation.js'\nimport {\n  type FormatUserOperationRequestErrorType,\n  formatUserOperationRequest,\n} from '../../utils/formatters/userOperationRequest.js'\n\nexport type GetPaymasterDataParameters = OneOf<\n  | PartialBy<\n      Pick<\n        UserOperation<'0.6'>,\n        | 'callData'\n        | 'callGasLimit'\n        | 'initCode'\n        | 'maxFeePerGas'\n        | 'maxPriorityFeePerGas'\n        | 'nonce'\n        | 'sender'\n        | 'preVerificationGas'\n        | 'verificationGasLimit'\n      >,\n      | 'callGasLimit'\n      | 'initCode'\n      | 'maxFeePerGas'\n      | 'maxPriorityFeePerGas'\n      | 'preVerificationGas'\n      | 'verificationGasLimit'\n    >\n  | PartialBy<\n      Pick<\n        UserOperation<'0.7'>,\n        | 'callData'\n        | 'callGasLimit'\n        | 'factory'\n        | 'factoryData'\n        | 'maxFeePerGas'\n        | 'maxPriorityFeePerGas'\n        | 'nonce'\n        | 'sender'\n        | 'preVerificationGas'\n        | 'verificationGasLimit'\n        | 'paymasterPostOpGasLimit'\n        | 'paymasterVerificationGasLimit'\n      >,\n      | 'callGasLimit'\n      | 'factory'\n      | 'factoryData'\n      | 'maxFeePerGas'\n      | 'maxPriorityFeePerGas'\n      | 'preVerificationGas'\n      | 'verificationGasLimit'\n    >\n  | PartialBy<\n      Pick<\n        UserOperation<'0.8'>,\n        | 'callData'\n        | 'callGasLimit'\n        | 'factory'\n        | 'factoryData'\n        | 'maxFeePerGas'\n        | 'maxPriorityFeePerGas'\n        | 'nonce'\n        | 'sender'\n        | 'preVerificationGas'\n        | 'verificationGasLimit'\n        | 'paymasterPostOpGasLimit'\n        | 'paymasterVerificationGasLimit'\n      >,\n      | 'callGasLimit'\n      | 'factory'\n      | 'factoryData'\n      | 'maxFeePerGas'\n      | 'maxPriorityFeePerGas'\n      | 'preVerificationGas'\n      | 'verificationGasLimit'\n    >\n> & {\n  context?: unknown | undefined\n  chainId: number\n  entryPointAddress: Address\n}\n\nexport type GetPaymasterDataReturnType = Prettify<\n  OneOf<\n    | { paymasterAndData: Hex }\n    | {\n        paymaster: Address\n        paymasterData: Hex\n        paymasterPostOpGasLimit?: bigint | undefined\n        paymasterVerificationGasLimit?: bigint | undefined\n      }\n  >\n>\n\nexport type GetPaymasterDataErrorType =\n  | FormatUserOperationRequestErrorType\n  | ErrorType\n\n/**\n * Retrieves paymaster-related User Operation properties to be used for sending the User Operation.\n *\n * - Docs: https://viem.sh/account-abstraction/actions/paymaster/getPaymasterData\n *\n * @param client - Client to use\n * @param parameters - {@link GetPaymasterDataParameters}\n * @returns Paymaster-related User Operation properties. {@link GetPaymasterDataReturnType}\n *\n * @example\n * import { http } from 'viem'\n * import { createPaymasterClient, getPaymasterData } from 'viem/account-abstraction'\n *\n * const paymasterClient = createPaymasterClient({\n *   transport: http('https://...'),\n * })\n *\n * const userOperation = { ... }\n *\n * const values = await getPaymasterData(paymasterClient, {\n *   chainId: 1,\n *   entryPointAddress: '0x...',\n *   ...userOperation,\n * })\n */\nexport async function getPaymasterData(\n  client: Client<Transport>,\n  parameters: GetPaymasterDataParameters,\n): Promise<GetPaymasterDataReturnType> {\n  const { chainId, entryPointAddress, context, ...userOperation } = parameters\n  const request = formatUserOperationRequest(userOperation)\n  const { paymasterPostOpGasLimit, paymasterVerificationGasLimit, ...rest } =\n    await client.request({\n      method: 'pm_getPaymasterData',\n      params: [\n        {\n          ...request,\n          callGasLimit: request.callGasLimit ?? '0x0',\n          verificationGasLimit: request.verificationGasLimit ?? '0x0',\n          preVerificationGas: request.preVerificationGas ?? '0x0',\n        },\n        entryPointAddress,\n        numberToHex(chainId),\n        context,\n      ],\n    })\n  return {\n    ...rest,\n    ...(paymasterPostOpGasLimit && {\n      paymasterPostOpGasLimit: hexToBigInt(paymasterPostOpGasLimit),\n    }),\n    ...(paymasterVerificationGasLimit && {\n      paymasterVerificationGasLimit: hexToBigInt(paymasterVerificationGasLimit),\n    }),\n  } as unknown as GetPaymasterDataReturnType\n}\n","import { safeCaptureStackTrace, SOLANA_ERROR__RPC__INTEGER_OVERFLOW, SolanaError } from '@solana/errors';\nimport type { KeyPath } from '@solana/rpc-transformers';\n\nexport function createSolanaJsonRpcIntegerOverflowError(\n    methodName: string,\n    keyPath: KeyPath,\n    value: bigint,\n): SolanaError<typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW> {\n    let argumentLabel = '';\n    if (typeof keyPath[0] === 'number') {\n        const argPosition = keyPath[0] + 1;\n        const lastDigit = argPosition % 10;\n        const lastTwoDigits = argPosition % 100;\n        if (lastDigit == 1 && lastTwoDigits != 11) {\n            argumentLabel = argPosition + 'st';\n        } else if (lastDigit == 2 && lastTwoDigits != 12) {\n            argumentLabel = argPosition + 'nd';\n        } else if (lastDigit == 3 && lastTwoDigits != 13) {\n            argumentLabel = argPosition + 'rd';\n        } else {\n            argumentLabel = argPosition + 'th';\n        }\n    } else {\n        argumentLabel = `\\`${keyPath[0].toString()}\\``;\n    }\n    const path =\n        keyPath.length > 1\n            ? keyPath\n                  .slice(1)\n                  .map(pathPart => (typeof pathPart === 'number' ? `[${pathPart}]` : pathPart))\n                  .join('.')\n            : undefined;\n    const error = new SolanaError(SOLANA_ERROR__RPC__INTEGER_OVERFLOW, {\n        argumentLabel,\n        keyPath: keyPath as readonly (number | string | symbol)[],\n        methodName,\n        optionalPathLabel: path ? ` at path \\`${path}\\`` : '',\n        value,\n        ...(path !== undefined ? { path } : undefined),\n    });\n    safeCaptureStackTrace(error, createSolanaJsonRpcIntegerOverflowError);\n    return error;\n}\n","import { UserInputValidationError } from \"../../../errors.js\";\nimport { resolveTokenAddress } from \"../../../spend-permissions/utils.js\";\n\nimport type { SpendPermissionNetwork } from \"../../../openapi-client/index.js\";\nimport type { SpendPermission, SpendPermissionInput } from \"../../../spend-permissions/types.js\";\n\n/**\n * Generate a random salt using crypto.getRandomValues().\n *\n * @returns A random bigint salt.\n */\nfunction generateRandomSalt(): bigint {\n  const randomBytes = new Uint8Array(32);\n  crypto.getRandomValues(randomBytes);\n\n  // Convert bytes to bigint\n  let result = 0n;\n  for (let i = 0; i < randomBytes.length; i++) {\n    result = (result << 8n) + BigInt(randomBytes[i]);\n  }\n\n  return result;\n}\n\n/**\n * Resolve a spend permission input to a spend permission.\n *\n * @param spendPermissionInput - The spend permission input to resolve.\n * @param network - The network to resolve the spend permission for.\n *\n * @returns The resolved spend permission.\n */\nexport function resolveSpendPermission(\n  spendPermissionInput: SpendPermissionInput,\n  network: SpendPermissionNetwork,\n): SpendPermission {\n  // Validate that either period or periodInDays is provided, but not both\n  if (\n    spendPermissionInput.period !== undefined &&\n    spendPermissionInput.periodInDays !== undefined\n  ) {\n    throw new UserInputValidationError(\n      \"Cannot specify both 'period' and 'periodInDays'. Please provide only one.\",\n    );\n  }\n\n  if (\n    spendPermissionInput.period === undefined &&\n    spendPermissionInput.periodInDays === undefined\n  ) {\n    throw new UserInputValidationError(\n      \"Must specify either 'period' (in seconds) or 'periodInDays'.\",\n    );\n  }\n\n  // Convert periodInDays to period in seconds if provided\n  const period = spendPermissionInput.period ?? spendPermissionInput.periodInDays! * 24 * 60 * 60;\n\n  // Set defaults for start and end\n  const now = new Date();\n  const startDate = spendPermissionInput.start ?? now;\n\n  /*\n   * For end date default, we need to handle the max uint48 value carefully\n   * JavaScript Date max is around year 275760, but uint48 max (281474976710655) is much larger\n   * So we'll use the max uint48 value directly for end if no end date is provided\n   */\n  const endDate = spendPermissionInput.end;\n\n  // Convert Date objects to seconds since epoch for the contract\n  const start = Math.floor(startDate.getTime() / 1000);\n  const end = endDate ? Math.floor(endDate.getTime() / 1000) : 281474976710655; // Max uint48 value (never expires)\n\n  const { periodInDays: _periodInDays, ...inputWithoutPeriodInDays } = spendPermissionInput;\n\n  return {\n    ...inputWithoutPeriodInDays,\n    token: resolveTokenAddress(spendPermissionInput.token, network),\n    period,\n    start,\n    end,\n    salt: spendPermissionInput.salt ?? generateRandomSalt(),\n    extraData: spendPermissionInput.extraData ?? \"0x\",\n  };\n}\n","import { getAddressDecoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    fixDecoderSize,\n    padRightDecoder,\n    ReadonlyUint8Array,\n    transformDecoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getTupleDecoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getU8Decoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { getTransactionVersionDecoder } from '@solana/transaction-messages';\n\nimport { SignaturesMap, Transaction, TransactionMessageBytes } from '../transaction';\nimport { getSignaturesEncoder } from './signatures-encoder';\n\n/**\n * Returns an encoder that you can use to encode a {@link Transaction} to a byte array in a wire\n * format appropriate for sending to the Solana network for execution.\n */\nexport function getTransactionEncoder(): VariableSizeEncoder<Transaction> {\n    return getStructEncoder([\n        ['signatures', getSignaturesEncoder()],\n        ['messageBytes', getBytesEncoder()],\n    ]);\n}\n\n/**\n * Returns a decoder that you can use to convert a byte array in the Solana transaction wire format\n * to a {@link Transaction} object.\n *\n * @example\n * ```ts\n * import { getTransactionDecoder } from '@solana/transactions';\n *\n * const transactionDecoder = getTransactionDecoder();\n * const transaction = transactionDecoder.decode(wireTransactionBytes);\n * for (const [address, signature] in Object.entries(transaction.signatures)) {\n *     console.log(`Signature by ${address}`, signature);\n * }\n * ```\n */\n\nexport function getTransactionDecoder(): VariableSizeDecoder<Transaction> {\n    return transformDecoder(\n        getStructDecoder([\n            ['signatures', getArrayDecoder(fixDecoderSize(getBytesDecoder(), 64), { size: getShortU16Decoder() })],\n            ['messageBytes', getBytesDecoder()],\n        ]),\n        decodePartiallyDecodedTransaction,\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a {@link Transaction}\n *\n * @see {@link getTransactionDecoder}\n * @see {@link getTransactionEncoder}\n */\nexport function getTransactionCodec(): VariableSizeCodec<Transaction> {\n    return combineCodec(getTransactionEncoder(), getTransactionDecoder());\n}\n\ntype PartiallyDecodedTransaction = {\n    messageBytes: ReadonlyUint8Array;\n    signatures: ReadonlyUint8Array[];\n};\n\nfunction decodePartiallyDecodedTransaction(transaction: PartiallyDecodedTransaction): Transaction {\n    const { messageBytes, signatures } = transaction;\n\n    /*\n    Relevant message structure is at the start:\n    - transaction version (0 bytes for legacy transactions, 1 byte for versioned transactions)\n    - `numRequiredSignatures` (1 byte, we verify this matches the length of signatures)\n    - `numReadOnlySignedAccounts` (1 byte, not used here)\n    - `numReadOnlyUnsignedAccounts` (1 byte, not used here)\n    - static addresses, with signers first. This is an array of addresses, prefixed with a short-u16 length\n    */\n\n    const signerAddressesDecoder = getTupleDecoder([\n        // read transaction version\n        getTransactionVersionDecoder(),\n        // read first byte of header, `numSignerAccounts`\n        // padRight to skip the next 2 bytes, `numReadOnlySignedAccounts` and `numReadOnlyUnsignedAccounts` which we don't need\n        padRightDecoder(getU8Decoder(), 2),\n        // read static addresses\n        getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() }),\n    ]);\n    const [_txVersion, numRequiredSignatures, staticAddresses] = signerAddressesDecoder.decode(messageBytes);\n\n    const signerAddresses = staticAddresses.slice(0, numRequiredSignatures);\n\n    // signer addresses and signatures must be the same length\n    // we encode an all-zero signature when the signature is missing\n    if (signerAddresses.length !== signatures.length) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, {\n            numRequiredSignatures,\n            signaturesLength: signatures.length,\n            signerAddresses,\n        });\n    }\n\n    // combine the signer addresses + signatures into the signatures map\n    const signaturesMap: SignaturesMap = {};\n    signerAddresses.forEach((address, index) => {\n        const signatureForAddress = signatures[index];\n        if (signatureForAddress.every(b => b === 0)) {\n            signaturesMap[address] = null;\n        } else {\n            signaturesMap[address] = signatureForAddress as SignatureBytes;\n        }\n    });\n\n    return {\n        messageBytes: messageBytes as TransactionMessageBytes,\n        signatures: Object.freeze(signaturesMap),\n    };\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/core/telemetry/events/scw-signer.ts","import { p256 } from '@noble/curves/p256'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport type * as Hex from './Hex.js'\nimport * as PublicKey from './PublicKey.js'\nimport type * as Signature from './Signature.js'\nimport type { Compute } from './internal/types.js'\n\n/**\n * Generates an ECDSA P256 key pair that includes:\n *\n * - a `privateKey` of type [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n *\n * - a `publicKey` of type {@link ox#Hex.Hex} or {@link ox#Bytes.Bytes}\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPair()\n * // @log: {\n * // @log:   privateKey: CryptoKey {},\n * // @log:   publicKey: {\n * // @log:     x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:     y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log:     prefix: 4,\n * // @log:   },\n * // @log: }\n * ```\n *\n * @param options - Options for creating the key pair.\n * @returns The key pair.\n */\nexport async function createKeyPair(\n  options: createKeyPair.Options = {},\n): Promise<createKeyPair.ReturnType> {\n  const { extractable = false } = options\n  const keypair = await globalThis.crypto.subtle.generateKey(\n    {\n      name: 'ECDSA',\n      namedCurve: 'P-256',\n    },\n    extractable,\n    ['sign', 'verify'],\n  )\n  const publicKey_raw = await globalThis.crypto.subtle.exportKey(\n    'raw',\n    keypair.publicKey,\n  )\n  const publicKey = PublicKey.from(new Uint8Array(publicKey_raw))\n  return {\n    privateKey: keypair.privateKey,\n    publicKey,\n  }\n}\n\nexport declare namespace createKeyPair {\n  type Options = {\n    /** A boolean value indicating whether it will be possible to export the private key using `globalThis.crypto.subtle.exportKey()`. */\n    extractable?: boolean | undefined\n  }\n\n  type ReturnType = Compute<{\n    privateKey: CryptoKey\n    publicKey: PublicKey.PublicKey\n  }>\n\n  type ErrorType = PublicKey.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Signs a payload with the provided `CryptoKey` private key and returns a P256 signature.\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey } = await WebCryptoP256.createKeyPair()\n *\n * const signature = await WebCryptoP256.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   r: 151231...4423n,\n * // @log:   s: 516123...5512n,\n * // @log: }\n * ```\n *\n * @param options - Options for signing the payload.\n * @returns The P256 ECDSA {@link ox#Signature.Signature}.\n */\nexport async function sign(\n  options: sign.Options,\n): Promise<Signature.Signature<false>> {\n  const { payload, privateKey } = options\n  const signature = await globalThis.crypto.subtle.sign(\n    {\n      name: 'ECDSA',\n      hash: 'SHA-256',\n    },\n    privateKey,\n    Bytes.from(payload),\n  )\n  const signature_bytes = Bytes.fromArray(new Uint8Array(signature))\n  const r = Bytes.toBigInt(Bytes.slice(signature_bytes, 0, 32))\n  let s = Bytes.toBigInt(Bytes.slice(signature_bytes, 32, 64))\n  if (s > p256.CURVE.n / 2n) s = p256.CURVE.n - s\n  return { r, s }\n}\n\nexport declare namespace sign {\n  type Options = {\n    /** Payload to sign. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** ECDSA private key. */\n    privateKey: CryptoKey\n  }\n\n  type ErrorType = Bytes.fromArray.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a payload was signed by the provided public key.\n *\n * @example\n *\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n * const signature = await WebCryptoP256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = await WebCryptoP256.verify({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nexport async function verify(options: verify.Options): Promise<boolean> {\n  const { payload, signature } = options\n\n  const publicKey = await globalThis.crypto.subtle.importKey(\n    'raw',\n    PublicKey.toBytes(options.publicKey),\n    { name: 'ECDSA', namedCurve: 'P-256' },\n    true,\n    ['verify'],\n  )\n\n  return await globalThis.crypto.subtle.verify(\n    {\n      name: 'ECDSA',\n      hash: 'SHA-256',\n    },\n    publicKey,\n    Bytes.concat(Bytes.fromNumber(signature.r), Bytes.fromNumber(signature.s)),\n    Bytes.from(payload),\n  )\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** Public key that signed the payload. */\n    publicKey: PublicKey.PublicKey<boolean>\n    /** Signature of the payload. */\n    signature: Signature.Signature<false>\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/util/provider.ts","import { RpcRequest, RpcRequestTransformer, RpcResponseTransformer } from '@solana/rpc-spec-types';\n\nexport type KeyPathWildcard = { readonly ['__keyPathWildcard:@solana/kit']: unique symbol };\nexport type KeyPath = ReadonlyArray<KeyPath | KeyPathWildcard | number | string>;\n\nexport const KEYPATH_WILDCARD = {} as KeyPathWildcard;\n\ntype NodeVisitor = <TState extends TraversalState>(value: unknown, state: TState) => unknown;\nexport type TraversalState = Readonly<{\n    keyPath: KeyPath;\n}>;\n\nfunction getTreeWalker(visitors: NodeVisitor[]) {\n    return function traverse<TState extends TraversalState>(node: unknown, state: TState): unknown {\n        if (Array.isArray(node)) {\n            return node.map((element, ii) => {\n                const nextState = {\n                    ...state,\n                    keyPath: [...state.keyPath, ii],\n                };\n                return traverse(element, nextState);\n            });\n        } else if (typeof node === 'object' && node !== null) {\n            const out: Record<number | string | symbol, unknown> = {};\n            for (const propName in node) {\n                if (!Object.prototype.hasOwnProperty.call(node, propName)) {\n                    continue;\n                }\n                const nextState = {\n                    ...state,\n                    keyPath: [...state.keyPath, propName],\n                };\n                out[propName] = traverse(node[propName as keyof typeof node], nextState);\n            }\n            return out;\n        } else {\n            return visitors.reduce((acc, visitNode) => visitNode(acc, state), node);\n        }\n    };\n}\n\n/**\n * Creates a transformer that traverses the request parameters and executes the provided visitors at\n * each node. A custom initial state can be provided but must at least provide `{ keyPath: [] }`.\n *\n * @example\n * ```ts\n * import { getTreeWalkerRequestTransformer } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getTreeWalkerRequestTransformer(\n *     [\n *         // Replaces foo.bar with \"baz\".\n *         (node, state) => (state.keyPath === ['foo', 'bar'] ? 'baz' : node),\n *         // Increments all numbers by 1.\n *         node => (typeof node === number ? node + 1 : node),\n *     ],\n *     { keyPath: [] },\n * );\n * ```\n */\nexport function getTreeWalkerRequestTransformer<TState extends TraversalState>(\n    visitors: NodeVisitor[],\n    initialState: TState,\n): RpcRequestTransformer {\n    return <TParams>(request: RpcRequest<TParams>): RpcRequest => {\n        const traverse = getTreeWalker(visitors);\n        return Object.freeze({\n            ...request,\n            params: traverse(request.params, initialState),\n        });\n    };\n}\n\nexport function getTreeWalkerResponseTransformer<TState extends TraversalState>(\n    visitors: NodeVisitor[],\n    initialState: TState,\n): RpcResponseTransformer {\n    return json => getTreeWalker(visitors)(json, initialState);\n}\n","import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Hash } from '../../../types/misc.js'\nimport type { Prettify } from '../../../types/utils.js'\nimport { getAction } from '../../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../../utils/observe.js'\nimport { type PollErrorType, poll } from '../../../utils/poll.js'\nimport { stringify } from '../../../utils/stringify.js'\nimport {\n  WaitForUserOperationReceiptTimeoutError,\n  type WaitForUserOperationReceiptTimeoutErrorType,\n} from '../../errors/userOperation.js'\nimport type { UserOperationReceipt } from '../../types/userOperation.js'\nimport {\n  type GetUserOperationReceiptErrorType,\n  getUserOperationReceipt,\n} from './getUserOperationReceipt.js'\n\nexport type WaitForUserOperationReceiptParameters = {\n  /** The hash of the User Operation. */\n  hash: Hash\n  /**\n   * Polling frequency (in ms). Defaults to the client's pollingInterval config.\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number | undefined\n  /**\n   * The number of times to retry.\n   * @default 6\n   */\n  retryCount?: number | undefined\n  /** Optional timeout (in ms) to wait before stopping polling. */\n  timeout?: number | undefined\n}\n\nexport type WaitForUserOperationReceiptReturnType =\n  Prettify<UserOperationReceipt>\n\nexport type WaitForUserOperationReceiptErrorType =\n  | WaitForUserOperationReceiptTimeoutErrorType\n  | PollErrorType\n  | ObserveErrorType\n  | ErrorType\n\n/**\n * Waits for the User Operation to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the User Operation receipt.\n *\n * - Docs: https://viem.sh/docs/actions/bundler/waitForUserOperationReceipt\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForUserOperationReceiptParameters}\n * @returns The receipt. {@link WaitForUserOperationReceiptReturnType}\n *\n * @example\n * import { createBundlerClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { waitForUserOperationReceipt } from 'viem/actions'\n *\n * const client = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await waitForUserOperationReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport function waitForUserOperationReceipt(\n  client: Client<Transport>,\n  parameters: WaitForUserOperationReceiptParameters,\n): Promise<WaitForUserOperationReceiptReturnType> {\n  const {\n    hash,\n    pollingInterval = client.pollingInterval,\n    retryCount,\n    timeout = 120_000,\n  } = parameters\n\n  let count = 0\n  const observerId = stringify([\n    'waitForUserOperationReceipt',\n    client.uid,\n    hash,\n  ])\n\n  return new Promise((resolve, reject) => {\n    const unobserve = observe(observerId, { resolve, reject }, (emit) => {\n      const done = (fn: () => void) => {\n        unpoll()\n        fn()\n        unobserve()\n      }\n\n      const unpoll = poll(\n        async () => {\n          if (retryCount && count >= retryCount)\n            done(() =>\n              emit.reject(\n                new WaitForUserOperationReceiptTimeoutError({ hash }),\n              ),\n            )\n\n          try {\n            const receipt = await getAction(\n              client,\n              getUserOperationReceipt,\n              'getUserOperationReceipt',\n            )({ hash })\n            done(() => emit.resolve(receipt))\n          } catch (err) {\n            const error = err as GetUserOperationReceiptErrorType\n            if (error.name !== 'UserOperationReceiptNotFoundError')\n              done(() => emit.reject(error))\n          }\n\n          count++\n        },\n        {\n          emitOnBegin: true,\n          interval: pollingInterval,\n        },\n      )\n\n      if (timeout)\n        setTimeout(\n          () =>\n            done(() =>\n              emit.reject(\n                new WaitForUserOperationReceiptTimeoutError({ hash }),\n              ),\n            ),\n          timeout,\n        )\n\n      return unpoll\n    })\n  })\n}\n","import { chainConfig } from '../../op-stack/chainConfig.js'\nimport { defineChain } from '../../utils/chain/defineChain.js'\n\nconst sourceId = 1 // mainnet\n\nexport const blast = /*#__PURE__*/ defineChain({\n  ...chainConfig,\n  id: 81457,\n  name: 'Blast',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'Ether',\n    symbol: 'ETH',\n  },\n  rpcUrls: {\n    default: { http: ['https://rpc.blast.io'] },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Blastscan',\n      url: 'https://blastscan.io',\n      apiUrl: 'https://api.blastscan.io/api',\n    },\n  },\n  contracts: {\n    ...chainConfig.contracts,\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 212929,\n    },\n    l2OutputOracle: {\n      [sourceId]: {\n        address: '0x826D1B0D4111Ad9146Eb8941D7Ca2B6a44215c76',\n        blockCreated: 19300358,\n      },\n    },\n    portal: {\n      [sourceId]: {\n        address: '0x0Ec68c5B10F21EFFb74f2A5C61DFe6b08C0Db6Cb',\n        blockCreated: 19300357,\n      },\n    },\n    l1StandardBridge: {\n      [sourceId]: {\n        address: '0x697402166Fbf2F22E970df8a6486Ef171dbfc524',\n        blockCreated: 19300360,\n      },\n    },\n  },\n  sourceId,\n})\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/payment/pay.ts","import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Hash } from '../../../types/misc.js'\nimport type { Prettify } from '../../../types/utils.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport {\n  UserOperationReceiptNotFoundError,\n  type UserOperationReceiptNotFoundErrorType,\n} from '../../errors/userOperation.js'\nimport type { UserOperationReceipt } from '../../types/userOperation.js'\nimport { formatUserOperationReceipt } from '../../utils/formatters/userOperationReceipt.js'\n\nexport type GetUserOperationReceiptParameters = {\n  /** The hash of the User Operation. */\n  hash: Hash\n}\n\nexport type GetUserOperationReceiptReturnType = Prettify<UserOperationReceipt>\n\nexport type GetUserOperationReceiptErrorType =\n  | RequestErrorType\n  | UserOperationReceiptNotFoundErrorType\n  | ErrorType\n\n/**\n * Returns the User Operation Receipt given a User Operation hash.\n *\n * - Docs: https://viem.sh/docs/actions/bundler/getUserOperationReceipt\n *\n * @param client - Client to use\n * @param parameters - {@link GetUserOperationReceiptParameters}\n * @returns The receipt. {@link GetUserOperationReceiptReturnType}\n *\n * @example\n * import { createBundlerClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getUserOperationReceipt } from 'viem/actions\n *\n * const client = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getUserOperationReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function getUserOperationReceipt(\n  client: Client<Transport>,\n  { hash }: GetUserOperationReceiptParameters,\n) {\n  const receipt = await client.request(\n    {\n      method: 'eth_getUserOperationReceipt',\n      params: [hash],\n    },\n    { dedupe: true },\n  )\n\n  if (!receipt) throw new UserOperationReceiptNotFoundError({ hash })\n\n  return formatUserOperationReceipt(receipt)\n}\n","import {\n    SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT,\n    SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED,\n    SolanaError,\n} from '@solana/errors';\n\nfunction assertIsSecureContext() {\n    if (__BROWSER__ && !globalThis.isSecureContext) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT);\n    }\n}\n\nlet cachedEd25519Decision: PromiseLike<boolean> | boolean | undefined;\nasync function isEd25519CurveSupported(subtle: SubtleCrypto): Promise<boolean> {\n    if (cachedEd25519Decision === undefined) {\n        cachedEd25519Decision = new Promise(resolve => {\n            subtle\n                .generateKey('Ed25519', /* extractable */ false, ['sign', 'verify'])\n                .then(() => {\n                    resolve((cachedEd25519Decision = true));\n                })\n                .catch(() => {\n                    resolve((cachedEd25519Decision = false));\n                });\n        });\n    }\n    if (typeof cachedEd25519Decision === 'boolean') {\n        return cachedEd25519Decision;\n    } else {\n        return await cachedEd25519Decision;\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#digest | `crypto.subtle.digest()`} is available in\n * the current JavaScript environment.\n */\nexport function assertDigestCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.digest !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED);\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#generateKey | `crypto.subtle.generateKey()`} is\n * available in the current JavaScript environment and has support for the Ed25519 curve.\n */\nexport async function assertKeyGenerationIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.generateKey !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED);\n    }\n    if (!(await isEd25519CurveSupported(globalThis.crypto.subtle))) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED);\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#exportKey | `crypto.subtle.exportKey()`} is\n * available in the current JavaScript environment.\n */\nexport function assertKeyExporterIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.exportKey !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED);\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#sign | `crypto.subtle.sign()`} is available in the\n * current JavaScript environment.\n */\nexport function assertSigningCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.sign !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED);\n    }\n}\n/**\n * Throws an exception unless {@link SubtleCrypto#verify | `crypto.subtle.verify()`} is available in\n * the current JavaScript environment.\n */\nexport function assertVerificationCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.verify !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED);\n    }\n}\n","import type { Address } from 'abitype'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { OneOf, PartialBy, Prettify } from '../../../types/utils.js'\nimport { hexToBigInt } from '../../../utils/encoding/fromHex.js'\nimport { numberToHex } from '../../../utils/encoding/toHex.js'\nimport type { UserOperation } from '../../types/userOperation.js'\nimport {\n  type FormatUserOperationRequestErrorType,\n  formatUserOperationRequest,\n} from '../../utils/formatters/userOperationRequest.js'\n\nexport type GetPaymasterStubDataParameters = OneOf<\n  | PartialBy<\n      Pick<\n        UserOperation<'0.6'>,\n        | 'callData'\n        | 'callGasLimit'\n        | 'initCode'\n        | 'maxFeePerGas'\n        | 'maxPriorityFeePerGas'\n        | 'nonce'\n        | 'sender'\n        | 'preVerificationGas'\n        | 'verificationGasLimit'\n      >,\n      | 'callGasLimit'\n      | 'initCode'\n      | 'maxFeePerGas'\n      | 'maxPriorityFeePerGas'\n      | 'preVerificationGas'\n      | 'verificationGasLimit'\n    >\n  | PartialBy<\n      Pick<\n        UserOperation<'0.7'>,\n        | 'callData'\n        | 'callGasLimit'\n        | 'factory'\n        | 'factoryData'\n        | 'maxFeePerGas'\n        | 'maxPriorityFeePerGas'\n        | 'nonce'\n        | 'sender'\n        | 'preVerificationGas'\n        | 'verificationGasLimit'\n      >,\n      | 'callGasLimit'\n      | 'factory'\n      | 'factoryData'\n      | 'maxFeePerGas'\n      | 'maxPriorityFeePerGas'\n      | 'preVerificationGas'\n      | 'verificationGasLimit'\n    >\n> & {\n  context?: unknown | undefined\n  chainId: number\n  entryPointAddress: Address\n}\n\nexport type GetPaymasterStubDataReturnType = Prettify<\n  OneOf<\n    | { paymasterAndData: Hex }\n    | {\n        paymaster: Address\n        paymasterData: Hex\n        paymasterVerificationGasLimit?: bigint | undefined\n        paymasterPostOpGasLimit: bigint\n      }\n  > & {\n    sponsor?: { name: string; icon?: string | undefined } | undefined\n    isFinal?: boolean | undefined\n  }\n>\n\nexport type GetPaymasterStubDataErrorType =\n  | FormatUserOperationRequestErrorType\n  | ErrorType\n\n/**\n * Retrieves paymaster-related User Operation properties to be used for gas estimation.\n *\n * - Docs: https://viem.sh/account-abstraction/actions/paymaster/getPaymasterStubData\n *\n * @param client - Client to use\n * @param parameters - {@link GetPaymasterStubDataParameters}\n * @returns Paymaster-related User Operation properties. {@link GetPaymasterStubDataReturnType}\n *\n * @example\n * import { http } from 'viem'\n * import { createPaymasterClient, getPaymasterStubData } from 'viem/account-abstraction'\n *\n * const paymasterClient = createPaymasterClient({\n *   transport: http('https://...'),\n * })\n *\n * const userOperation = { ... }\n *\n * const values = await getPaymasterStubData(paymasterClient, {\n *   chainId: 1,\n *   entryPointAddress: '0x...',\n *   ...userOperation,\n * })\n */\nexport async function getPaymasterStubData(\n  client: Client<Transport>,\n  parameters: GetPaymasterStubDataParameters,\n): Promise<GetPaymasterStubDataReturnType> {\n  const { chainId, entryPointAddress, context, ...userOperation } = parameters\n  const request = formatUserOperationRequest(userOperation)\n  const { paymasterPostOpGasLimit, paymasterVerificationGasLimit, ...rest } =\n    await client.request({\n      method: 'pm_getPaymasterStubData',\n      params: [\n        {\n          ...request,\n          callGasLimit: request.callGasLimit ?? '0x0',\n          verificationGasLimit: request.verificationGasLimit ?? '0x0',\n          preVerificationGas: request.preVerificationGas ?? '0x0',\n        },\n        entryPointAddress,\n        numberToHex(chainId),\n        context,\n      ],\n    })\n  return {\n    ...rest,\n    ...(paymasterPostOpGasLimit && {\n      paymasterPostOpGasLimit: hexToBigInt(paymasterPostOpGasLimit),\n    }),\n    ...(paymasterVerificationGasLimit && {\n      paymasterVerificationGasLimit: hexToBigInt(paymasterVerificationGasLimit),\n    }),\n  } as unknown as GetPaymasterStubDataReturnType\n}\n","import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BaseError } from '../../errors/base.js'\nimport { BundleFailedError } from '../../errors/calls.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport { type PollErrorType, poll } from '../../utils/poll.js'\nimport { withResolvers } from '../../utils/promise/withResolvers.js'\nimport {\n  type WithRetryParameters,\n  withRetry,\n} from '../../utils/promise/withRetry.js'\nimport { stringify } from '../../utils/stringify.js'\nimport {\n  type GetCallsStatusErrorType,\n  type GetCallsStatusReturnType,\n  getCallsStatus,\n} from './getCallsStatus.js'\n\nexport type WaitForCallsStatusParameters = {\n  /**\n   * The id of the call batch to wait for.\n   */\n  id: string\n  /**\n   * Polling frequency (in ms). Defaults to the client's pollingInterval config.\n   *\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number | undefined\n  /**\n   * Number of times to retry if the call bundle failed.\n   * @default 4 (exponential backoff)\n   */\n  retryCount?: WithRetryParameters['retryCount'] | undefined\n  /**\n   * Time to wait (in ms) between retries.\n   * @default `({ count }) => ~~(1 << count) * 200` (exponential backoff)\n   */\n  retryDelay?: WithRetryParameters['delay'] | undefined\n  /**\n   * The status range to wait for.\n   *\n   * @default (status) => status >= 200\n   */\n  status?: ((parameters: GetCallsStatusReturnType) => boolean) | undefined\n  /**\n   * Whether to throw an error if the call bundle fails.\n   *\n   * @default false\n   */\n  throwOnFailure?: boolean | undefined\n  /**\n   * Optional timeout (in milliseconds) to wait before stopping polling.\n   *\n   * @default 60_000\n   */\n  timeout?: number | undefined\n}\n\nexport type WaitForCallsStatusReturnType = GetCallsStatusReturnType\n\nexport type WaitForCallsStatusErrorType =\n  | ObserveErrorType\n  | PollErrorType\n  | GetCallsStatusErrorType\n  | WaitForCallsStatusTimeoutError\n  | ErrorType\n\n/**\n * Waits for the status & receipts of a call bundle that was sent via `sendCalls`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/waitForCallsStatus\n * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForCallsStatusParameters}\n * @returns Status & receipts of the call bundle. {@link WaitForCallsStatusReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { waitForCallsStatus } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * const { receipts, status } = await waitForCallsStatus(client, { id: '0xdeadbeef' })\n */\nexport async function waitForCallsStatus<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: WaitForCallsStatusParameters,\n): Promise<WaitForCallsStatusReturnType> {\n  const {\n    id,\n    pollingInterval = client.pollingInterval,\n    status = ({ statusCode }) => statusCode === 200 || statusCode >= 300,\n    retryCount = 4,\n    retryDelay = ({ count }) => ~~(1 << count) * 200, // exponential backoff\n    timeout = 60_000,\n    throwOnFailure = false,\n  } = parameters\n  const observerId = stringify(['waitForCallsStatus', client.uid, id])\n\n  const { promise, resolve, reject } =\n    withResolvers<WaitForCallsStatusReturnType>()\n\n  let timer: Timer | undefined\n\n  const unobserve = observe(observerId, { resolve, reject }, (emit) => {\n    const unpoll = poll(\n      async () => {\n        const done = (fn: () => void) => {\n          clearTimeout(timer)\n          unpoll()\n          fn()\n          unobserve()\n        }\n\n        try {\n          const result = await withRetry(\n            async () => {\n              const result = await getAction(\n                client,\n                getCallsStatus,\n                'getCallsStatus',\n              )({ id })\n              if (throwOnFailure && result.status === 'failure')\n                throw new BundleFailedError(result)\n              return result\n            },\n            {\n              retryCount,\n              delay: retryDelay,\n            },\n          )\n          if (!status(result)) return\n          done(() => emit.resolve(result))\n        } catch (error) {\n          done(() => emit.reject(error))\n        }\n      },\n      {\n        interval: pollingInterval,\n        emitOnBegin: true,\n      },\n    )\n\n    return unpoll\n  })\n\n  timer = timeout\n    ? setTimeout(() => {\n        unobserve()\n        clearTimeout(timer)\n        reject(new WaitForCallsStatusTimeoutError({ id }))\n      }, timeout)\n    : undefined\n\n  return await promise\n}\n\nexport type WaitForCallsStatusTimeoutErrorType =\n  WaitForCallsStatusTimeoutError & {\n    name: 'WaitForCallsStatusTimeoutError'\n  }\nexport class WaitForCallsStatusTimeoutError extends BaseError {\n  constructor({ id }: { id: string }) {\n    super(\n      `Timed out while waiting for call bundle with id \"${id}\" to be confirmed.`,\n      { name: 'WaitForCallsStatusTimeoutError' },\n    )\n  }\n}\n","import { p256 } from '@noble/curves/p256'\nimport type * as Errors from '../Errors.js'\nimport * as Hex from '../Hex.js'\nimport * as PublicKey from '../PublicKey.js'\nimport { CredentialCreationFailedError } from '../WebAuthnP256.js'\n\n/** @internal */\nexport type AttestationConveyancePreference =\n  | 'direct'\n  | 'enterprise'\n  | 'indirect'\n  | 'none'\n\n/** @internal */\nexport type AuthenticatorAttachment = 'cross-platform' | 'platform'\n\n/** @internal */\nexport type AuthenticatorTransport =\n  | 'ble'\n  | 'hybrid'\n  | 'internal'\n  | 'nfc'\n  | 'usb'\n\n/** @internal */\nexport type COSEAlgorithmIdentifier = number\n\n/** @internal */\nexport type CredentialMediationRequirement =\n  | 'conditional'\n  | 'optional'\n  | 'required'\n  | 'silent'\n\n/** @internal */\nexport type PublicKeyCredentialType = 'public-key'\n\n/** @internal */\nexport type ResidentKeyRequirement = 'discouraged' | 'preferred' | 'required'\n\n/** @internal */\nexport type UserVerificationRequirement =\n  | 'discouraged'\n  | 'preferred'\n  | 'required'\n\n/** @internal */\nexport type LargeBlobSupport = {\n  support: 'required' | 'preferred'\n}\n\n/** @internal */\nexport type BufferSource = ArrayBufferView | ArrayBuffer\n\n/** @internal */\nexport type PrfExtension = Record<'eval', Record<'first', Uint8Array>>\n\n/** @internal */\nexport interface AuthenticationExtensionsClientInputs {\n  appid?: string\n  credProps?: boolean\n  hmacCreateSecret?: boolean\n  minPinLength?: boolean\n  prf?: PrfExtension\n  largeBlob?: LargeBlobSupport\n}\n\n/** @internal */\nexport interface AuthenticatorSelectionCriteria {\n  authenticatorAttachment?: AuthenticatorAttachment\n  requireResidentKey?: boolean\n  residentKey?: ResidentKeyRequirement\n  userVerification?: UserVerificationRequirement\n}\n\n/** @internal */\nexport interface Credential {\n  readonly id: string\n  readonly type: string\n}\n\n/** @internal */\nexport interface CredentialCreationOptions {\n  publicKey?: PublicKeyCredentialCreationOptions\n  signal?: AbortSignal\n}\n\n/** @internal */\nexport interface CredentialRequestOptions {\n  mediation?: CredentialMediationRequirement\n  publicKey?: PublicKeyCredentialRequestOptions\n  signal?: AbortSignal\n}\n\n/** @internal */\nexport interface PublicKeyCredential extends Credential {\n  readonly authenticatorAttachment: string | null\n  readonly rawId: ArrayBuffer\n  readonly response: AuthenticatorResponse\n  getClientExtensionResults(): AuthenticationExtensionsClientOutputs\n}\n\n/** @internal */\nexport interface PublicKeyCredentialCreationOptions {\n  attestation?: AttestationConveyancePreference\n  authenticatorSelection?: AuthenticatorSelectionCriteria\n  challenge: BufferSource\n  excludeCredentials?: PublicKeyCredentialDescriptor[]\n  extensions?: AuthenticationExtensionsClientInputs\n  pubKeyCredParams: PublicKeyCredentialParameters[]\n  rp: PublicKeyCredentialRpEntity\n  timeout?: number\n  user: PublicKeyCredentialUserEntity\n}\n\n/** @internal */\nexport interface PublicKeyCredentialDescriptor {\n  id: BufferSource\n  transports?: AuthenticatorTransport[]\n  type: PublicKeyCredentialType\n}\n\n/** @internal */\nexport interface PublicKeyCredentialEntity {\n  name: string\n}\n\n/** @internal */\nexport interface PublicKeyCredentialParameters {\n  alg: COSEAlgorithmIdentifier\n  type: PublicKeyCredentialType\n}\n\n/** @internal */\nexport interface PublicKeyCredentialRequestOptions {\n  allowCredentials?: PublicKeyCredentialDescriptor[]\n  challenge: BufferSource\n  extensions?: AuthenticationExtensionsClientInputs\n  rpId?: string\n  timeout?: number\n  userVerification?: UserVerificationRequirement\n}\n\n/** @internal */\nexport interface PublicKeyCredentialRpEntity extends PublicKeyCredentialEntity {\n  id?: string\n}\n\n/** @internal */\nexport interface PublicKeyCredentialUserEntity\n  extends PublicKeyCredentialEntity {\n  displayName: string\n  id: BufferSource\n}\n\n/**\n * Parses an ASN.1 signature into a r and s value.\n *\n * @internal\n */\nexport function parseAsn1Signature(bytes: Uint8Array) {\n  const r_start = bytes[4] === 0 ? 5 : 4\n  const r_end = r_start + 32\n  const s_start = bytes[r_end + 2] === 0 ? r_end + 3 : r_end + 2\n\n  const r = BigInt(Hex.fromBytes(bytes.slice(r_start, r_end)))\n  const s = BigInt(Hex.fromBytes(bytes.slice(s_start)))\n\n  return {\n    r,\n    s: s > p256.CURVE.n / 2n ? p256.CURVE.n - s : s,\n  }\n}\n\n/**\n * Parses a public key into x and y coordinates from the public key\n * defined on the credential.\n *\n * @internal\n */\nexport async function parseCredentialPublicKey(\n  response: AuthenticatorAttestationResponse,\n): Promise<PublicKey.PublicKey> {\n  try {\n    const publicKeyBuffer = response.getPublicKey()\n    if (!publicKeyBuffer) throw new CredentialCreationFailedError()\n\n    // Converting `publicKeyBuffer` throws when credential is created by 1Password Firefox Add-on\n    const publicKeyBytes = new Uint8Array(publicKeyBuffer)\n    const cryptoKey = await crypto.subtle.importKey(\n      'spki',\n      new Uint8Array(publicKeyBytes),\n      {\n        name: 'ECDSA',\n        namedCurve: 'P-256',\n        hash: 'SHA-256',\n      },\n      true,\n      ['verify'],\n    )\n    const publicKey = new Uint8Array(\n      await crypto.subtle.exportKey('raw', cryptoKey),\n    )\n    return PublicKey.from(publicKey)\n  } catch (error) {\n    // Fallback for 1Password Firefox Add-on restricts access to certain credential properties\n    // so we need to use `attestationObject` to extract the public key.\n    // https://github.com/passwordless-id/webauthn/issues/50#issuecomment-2072902094\n    if ((error as Error).message !== 'Permission denied to access object')\n      throw error\n\n    const data = new Uint8Array(response.attestationObject)\n    const coordinateLength = 0x20\n    const cborPrefix = 0x58\n\n    const findStart = (key: number) => {\n      const coordinate = new Uint8Array([key, cborPrefix, coordinateLength])\n      for (let i = 0; i < data.length - coordinate.length; i++)\n        if (coordinate.every((byte, j) => data[i + j] === byte))\n          return i + coordinate.length\n      throw new CredentialCreationFailedError()\n    }\n\n    const xStart = findStart(0x21)\n    const yStart = findStart(0x22)\n\n    return PublicKey.from(\n      new Uint8Array([\n        0x04,\n        ...data.slice(xStart, xStart + coordinateLength),\n        ...data.slice(yStart, yStart + coordinateLength),\n      ]),\n    )\n  }\n}\n\nexport declare namespace parseCredentialPublicKey {\n  type ErrorType = CredentialCreationFailedError | Errors.GlobalErrorType\n}\n","/**\n * Generated by orval v7.6.0 \n * Do not edit manually.\n * Coinbase Developer Platform APIs\n * The Coinbase Developer Platform APIs - leading the world's transition onchain.\n * OpenAPI spec version: 2.0.0\n */\nimport type {\n  CreateEvmSmartAccountBody,\n  CreateSpendPermissionRequest,\n  EvmSmartAccount,\n  EvmUserOperation,\n  ListEvmSmartAccounts200,\n  ListEvmSmartAccountsParams,\n  ListSpendPermissions200,\n  ListSpendPermissionsParams,\n  PrepareAndSendUserOperationBody,\n  PrepareUserOperationBody,\n  RevokeSpendPermissionRequest,\n  SendUserOperationBody,\n  UpdateEvmSmartAccountBody,\n} from \"../coinbaseDeveloperPlatformAPIs.schemas.js\";\n\nimport { cdpApiClient } from \"../../cdpApiClient.js\";\n\ntype SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];\n\n/**\n * Lists the Smart Accounts belonging to the developer's CDP Project.\nThe response is paginated, and by default, returns 20 accounts per page.\n * @summary List Smart Accounts\n */\nexport const listEvmSmartAccounts = (\n  params?: ListEvmSmartAccountsParams,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<ListEvmSmartAccounts200>(\n    { url: `/v2/evm/smart-accounts`, method: \"GET\", params },\n    options,\n  );\n};\n/**\n * Creates a new Smart Account.\n * @summary Create a Smart Account\n */\nexport const createEvmSmartAccount = (\n  createEvmSmartAccountBody: CreateEvmSmartAccountBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<EvmSmartAccount>(\n    {\n      url: `/v2/evm/smart-accounts`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: createEvmSmartAccountBody,\n    },\n    options,\n  );\n};\n/**\n * Gets a Smart Account by its name.\n * @summary Get a Smart Account by name\n */\nexport const getEvmSmartAccountByName = (\n  name: string,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<EvmSmartAccount>(\n    { url: `/v2/evm/smart-accounts/by-name/${name}`, method: \"GET\" },\n    options,\n  );\n};\n/**\n * Gets a Smart Account by its address.\n * @summary Get a Smart Account by address\n */\nexport const getEvmSmartAccount = (\n  address: string,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<EvmSmartAccount>(\n    { url: `/v2/evm/smart-accounts/${address}`, method: \"GET\" },\n    options,\n  );\n};\n/**\n * Updates an existing EVM smart account. Use this to update the smart account's name.\n * @summary Update an EVM Smart Account\n */\nexport const updateEvmSmartAccount = (\n  address: string,\n  updateEvmSmartAccountBody: UpdateEvmSmartAccountBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<EvmSmartAccount>(\n    {\n      url: `/v2/evm/smart-accounts/${address}`,\n      method: \"PUT\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: updateEvmSmartAccountBody,\n    },\n    options,\n  );\n};\n/**\n * Prepares a new user operation on a Smart Account for a specific network.\n * @summary Prepare a user operation\n */\nexport const prepareUserOperation = (\n  address: string,\n  prepareUserOperationBody: PrepareUserOperationBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<EvmUserOperation>(\n    {\n      url: `/v2/evm/smart-accounts/${address}/user-operations`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: prepareUserOperationBody,\n    },\n    options,\n  );\n};\n/**\n * Prepares, signs, and sends a user operation for an EVM Smart Account. This API can be used only if the owner on Smart Account is a CDP EVM Account.\n * @summary Prepare and send a user operation for EVM Smart Account\n */\nexport const prepareAndSendUserOperation = (\n  address: string,\n  prepareAndSendUserOperationBody: PrepareAndSendUserOperationBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<EvmUserOperation>(\n    {\n      url: `/v2/evm/smart-accounts/${address}/user-operations/prepare-and-send`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: prepareAndSendUserOperationBody,\n    },\n    options,\n  );\n};\n/**\n * Gets a user operation by its hash.\n * @summary Get a user operation\n */\nexport const getUserOperation = (\n  address: string,\n  userOpHash: string,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<EvmUserOperation>(\n    { url: `/v2/evm/smart-accounts/${address}/user-operations/${userOpHash}`, method: \"GET\" },\n    options,\n  );\n};\n/**\n * Sends a user operation with a signature.\nThe payload to sign must be the `userOpHash` field of the user operation. This hash should be signed directly (not using `personal_sign` or EIP-191 message hashing).\nThe signature must be 65 bytes in length, consisting of: - 32 bytes for the `r` value - 32 bytes for the `s` value - 1 byte for the `v` value (must be 27 or 28)\nIf using the CDP Paymaster, the user operation must be signed and sent within 2 minutes of being prepared.\n * @summary Send a user operation\n */\nexport const sendUserOperation = (\n  address: string,\n  userOpHash: string,\n  sendUserOperationBody: SendUserOperationBody,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<EvmUserOperation>(\n    {\n      url: `/v2/evm/smart-accounts/${address}/user-operations/${userOpHash}/send`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: sendUserOperationBody,\n    },\n    options,\n  );\n};\n/**\n * Creates a spend permission for the given smart account address.\n * @summary Create a spend permission\n */\nexport const createSpendPermission = (\n  address: string,\n  createSpendPermissionRequest: CreateSpendPermissionRequest,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<EvmUserOperation>(\n    {\n      url: `/v2/evm/smart-accounts/${address}/spend-permissions`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: createSpendPermissionRequest,\n    },\n    options,\n  );\n};\n/**\n * Lists spend permission for the given smart account address.\n * @summary List spend permissions\n */\nexport const listSpendPermissions = (\n  address: string,\n  params?: ListSpendPermissionsParams,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<ListSpendPermissions200>(\n    { url: `/v2/evm/smart-accounts/${address}/spend-permissions/list`, method: \"GET\", params },\n    options,\n  );\n};\n/**\n * Revokes an existing spend permission.\n * @summary Revoke a spend permission\n */\nexport const revokeSpendPermission = (\n  address: string,\n  revokeSpendPermissionRequest: RevokeSpendPermissionRequest,\n  options?: SecondParameter<typeof cdpApiClient>,\n) => {\n  return cdpApiClient<EvmUserOperation>(\n    {\n      url: `/v2/evm/smart-accounts/${address}/spend-permissions/revoke`,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      data: revokeSpendPermissionRequest,\n    },\n    options,\n  );\n};\nexport type ListEvmSmartAccountsResult = NonNullable<\n  Awaited<ReturnType<typeof listEvmSmartAccounts>>\n>;\nexport type CreateEvmSmartAccountResult = NonNullable<\n  Awaited<ReturnType<typeof createEvmSmartAccount>>\n>;\nexport type GetEvmSmartAccountByNameResult = NonNullable<\n  Awaited<ReturnType<typeof getEvmSmartAccountByName>>\n>;\nexport type GetEvmSmartAccountResult = NonNullable<Awaited<ReturnType<typeof getEvmSmartAccount>>>;\nexport type UpdateEvmSmartAccountResult = NonNullable<\n  Awaited<ReturnType<typeof updateEvmSmartAccount>>\n>;\nexport type PrepareUserOperationResult = NonNullable<\n  Awaited<ReturnType<typeof prepareUserOperation>>\n>;\nexport type PrepareAndSendUserOperationResult = NonNullable<\n  Awaited<ReturnType<typeof prepareAndSendUserOperation>>\n>;\nexport type GetUserOperationResult = NonNullable<Awaited<ReturnType<typeof getUserOperation>>>;\nexport type SendUserOperationResult = NonNullable<Awaited<ReturnType<typeof sendUserOperation>>>;\nexport type CreateSpendPermissionResult = NonNullable<\n  Awaited<ReturnType<typeof createSpendPermission>>\n>;\nexport type ListSpendPermissionsResult = NonNullable<\n  Awaited<ReturnType<typeof listSpendPermissions>>\n>;\nexport type RevokeSpendPermissionResult = NonNullable<\n  Awaited<ReturnType<typeof revokeSpendPermission>>\n>;\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  type Account,\n  type Address,\n  type EncodedAccount,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type Option,\n  type OptionOrNullable,\n} from '@solana/kit';\n\nexport type Mint = {\n  /**\n   * Optional authority used to mint new tokens. The mint authority may only\n   * be provided during mint creation. If no mint authority is present\n   * then the mint has a fixed supply and no further tokens may be minted.\n   */\n  mintAuthority: Option<Address>;\n  /** Total supply of tokens. */\n  supply: bigint;\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** Is `true` if this structure has been initialized. */\n  isInitialized: boolean;\n  /** Optional authority to freeze token accounts. */\n  freezeAuthority: Option<Address>;\n};\n\nexport type MintArgs = {\n  /**\n   * Optional authority used to mint new tokens. The mint authority may only\n   * be provided during mint creation. If no mint authority is present\n   * then the mint has a fixed supply and no further tokens may be minted.\n   */\n  mintAuthority: OptionOrNullable<Address>;\n  /** Total supply of tokens. */\n  supply: number | bigint;\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** Is `true` if this structure has been initialized. */\n  isInitialized: boolean;\n  /** Optional authority to freeze token accounts. */\n  freezeAuthority: OptionOrNullable<Address>;\n};\n\nexport function getMintEncoder(): FixedSizeEncoder<MintArgs> {\n  return getStructEncoder([\n    [\n      'mintAuthority',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['supply', getU64Encoder()],\n    ['decimals', getU8Encoder()],\n    ['isInitialized', getBooleanEncoder()],\n    [\n      'freezeAuthority',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getMintDecoder(): FixedSizeDecoder<Mint> {\n  return getStructDecoder([\n    [\n      'mintAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['supply', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n    ['isInitialized', getBooleanDecoder()],\n    [\n      'freezeAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getMintCodec(): FixedSizeCodec<MintArgs, Mint> {\n  return combineCodec(getMintEncoder(), getMintDecoder());\n}\n\nexport function decodeMint<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Mint, TAddress>;\nexport function decodeMint<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Mint, TAddress>;\nexport function decodeMint<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Mint, TAddress> | MaybeAccount<Mint, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getMintDecoder()\n  );\n}\n\nexport async function fetchMint<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Mint, TAddress>> {\n  const maybeAccount = await fetchMaybeMint(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeMint<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Mint, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeMint(maybeAccount);\n}\n\nexport async function fetchAllMint(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Mint>[]> {\n  const maybeAccounts = await fetchAllMaybeMint(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeMint(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Mint>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeMint(maybeAccount));\n}\n\nexport function getMintSize(): number {\n  return 82;\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/payment/getSubscriptionStatus.ts","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/util/checkCrossOriginOpenerPolicy.ts","import type { Address } from 'abitype'\nimport { trim } from '../utils/data/trim.js'\nimport type {\n  CeloTransactionRequest,\n  CeloTransactionSerializable,\n  TransactionSerializableCIP64,\n} from './types.js'\n\nexport function isEmpty(\n  value: string | undefined | number | BigInt,\n): value is undefined {\n  return (\n    value === 0 ||\n    value === 0n ||\n    value === undefined ||\n    value === null ||\n    value === '0' ||\n    value === '' ||\n    (typeof value === 'string' &&\n      (trim(value as Address).toLowerCase() === '0x' ||\n        trim(value as Address).toLowerCase() === '0x00'))\n  )\n}\n\nexport function isPresent(\n  value: string | undefined | number | BigInt,\n): value is string | number | BigInt {\n  return !isEmpty(value)\n}\n\n/** @internal */\nexport function isEIP1559(\n  transaction: CeloTransactionSerializable | CeloTransactionRequest,\n): boolean {\n  return (\n    typeof transaction.maxFeePerGas !== 'undefined' &&\n    typeof transaction.maxPriorityFeePerGas !== 'undefined'\n  )\n}\n\nexport function isCIP64(\n  transaction: CeloTransactionSerializable | CeloTransactionRequest,\n): transaction is TransactionSerializableCIP64 {\n  /*\n   * Enable end user to force the tx to be considered as a CIP-64.\n   *\n   * The preliminary type will be determined as \"eip1559\" by src/utils/transaction/getTransactionType.ts\n   * and so we need the logic below to check for the specific value instead of checking if just any\n   * transaction type is provided. If that's anything else than \"cip64\" then we need to reevaluate the\n   * type based on the transaction fields.\n   *\n   * Modify with caution and according to https://github.com/celo-org/celo-proposals/blob/master/CIPs/cip-0064.md\n   */\n  if (transaction.type === 'cip64') {\n    return true\n  }\n\n  return isEIP1559(transaction) && isPresent(transaction.feeCurrency)\n}\n","import { toHex } from '../../utils/encoding/toHex.js'\nimport { gasPerPubdataDefault } from '../constants/number.js'\nimport type { EIP712DomainFn } from '../types/eip712.js'\nimport type {\n  ZksyncEIP712TransactionSignable,\n  ZksyncTransactionSerializable,\n  ZksyncTransactionSerializableEIP712,\n} from '../types/transaction.js'\nimport { assertEip712Transaction } from './assertEip712Transaction.js'\nimport { hashBytecode } from './hashBytecode.js'\n\nexport const getEip712Domain: EIP712DomainFn<\n  ZksyncTransactionSerializable,\n  ZksyncEIP712TransactionSignable\n> = (transaction) => {\n  assertEip712Transaction(transaction)\n\n  const message = transactionToMessage(\n    transaction as ZksyncTransactionSerializableEIP712,\n  )\n\n  return {\n    domain: {\n      name: 'zkSync',\n      version: '2',\n      chainId: transaction.chainId,\n    },\n    types: {\n      Transaction: [\n        { name: 'txType', type: 'uint256' },\n        { name: 'from', type: 'uint256' },\n        { name: 'to', type: 'uint256' },\n        { name: 'gasLimit', type: 'uint256' },\n        { name: 'gasPerPubdataByteLimit', type: 'uint256' },\n        { name: 'maxFeePerGas', type: 'uint256' },\n        { name: 'maxPriorityFeePerGas', type: 'uint256' },\n        { name: 'paymaster', type: 'uint256' },\n        { name: 'nonce', type: 'uint256' },\n        { name: 'value', type: 'uint256' },\n        { name: 'data', type: 'bytes' },\n        { name: 'factoryDeps', type: 'bytes32[]' },\n        { name: 'paymasterInput', type: 'bytes' },\n      ],\n    },\n    primaryType: 'Transaction',\n    message: message,\n  }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n// Utilities\n\nfunction transactionToMessage(\n  transaction: ZksyncTransactionSerializableEIP712,\n): ZksyncEIP712TransactionSignable {\n  const {\n    gas,\n    nonce,\n    to,\n    from,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    factoryDeps,\n    paymaster,\n    paymasterInput,\n    gasPerPubdata,\n    data,\n  } = transaction\n\n  return {\n    txType: 113n,\n    from: BigInt(from),\n    to: to ? BigInt(to) : 0n,\n    gasLimit: gas ?? 0n,\n    gasPerPubdataByteLimit: gasPerPubdata ?? gasPerPubdataDefault,\n    maxFeePerGas: maxFeePerGas ?? 0n,\n    maxPriorityFeePerGas: maxPriorityFeePerGas ?? 0n,\n    paymaster: paymaster ? BigInt(paymaster) : 0n,\n    nonce: nonce ? BigInt(nonce) : 0n,\n    value: value ?? 0n,\n    data: data ?? '0x',\n    factoryDeps: factoryDeps?.map((dep) => toHex(hashBytecode(dep))) ?? [],\n    paymasterInput: paymasterInput ? paymasterInput : '0x',\n  }\n}\n","/**\n * @module HTTP\n */\n\nimport { generateWalletJwt, generateJwt } from \"./jwt.js\";\nimport { UserInputValidationError } from \"../../errors.js\";\nimport { version } from \"../../version.js\";\n\n/**\n * Options for generating authentication headers for API requests.\n */\nexport interface GetAuthHeadersOptions {\n  /**\n   * The API key ID\n   *\n   * Examples:\n   *  'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'\n   *  'organizations/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/apiKeys/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'\n   */\n  apiKeyId: string;\n\n  /**\n   * The API key secret\n   *\n   * Examples:\n   *  'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx==' (Edwards key (Ed25519))\n   *  '-----BEGIN EC PRIVATE KEY-----\\n...\\n...\\n...==\\n-----END EC PRIVATE KEY-----\\n' (EC key (ES256))\n   */\n  apiKeySecret: string;\n\n  /**\n   * The HTTP method for the request (e.g. 'GET', 'POST')\n   */\n  requestMethod: string;\n\n  /**\n   * The host for the request (e.g. 'api.cdp.coinbase.com')\n   */\n  requestHost: string;\n\n  /**\n   * The path for the request (e.g. '/platform/v1/wallets')\n   */\n  requestPath: string;\n\n  /**\n   * Optional request body data\n   */\n  requestBody?: unknown;\n\n  /**\n   * The Wallet Secret for wallet authentication\n   */\n  walletSecret?: string;\n\n  /**\n   * The source identifier for the request\n   */\n  source?: string;\n\n  /**\n   * The version of the source making the request\n   */\n  sourceVersion?: string;\n\n  /**\n   * Optional expiration time in seconds (defaults to 120)\n   */\n  expiresIn?: number;\n\n  /**\n   * Optional audience claim for the JWT\n   */\n  audience?: string[];\n}\n\n/**\n * Gets authentication headers for a request.\n *\n * @param options - The configuration options for generating auth headers\n * @returns Object containing the authentication headers\n */\nexport async function getAuthHeaders(\n  options: GetAuthHeadersOptions,\n): Promise<Record<string, string>> {\n  const headers: Record<string, string> = {};\n\n  // Generate and add JWT token\n  const jwt = await generateJwt({\n    apiKeyId: options.apiKeyId,\n    apiKeySecret: options.apiKeySecret,\n    requestMethod: options.requestMethod,\n    requestHost: options.requestHost,\n    requestPath: options.requestPath,\n    expiresIn: options.expiresIn,\n    audience: options.audience,\n  });\n  headers[\"Authorization\"] = `Bearer ${jwt}`;\n  headers[\"Content-Type\"] = \"application/json\";\n\n  // Add wallet auth if needed\n  if (requiresWalletAuth(options.requestMethod, options.requestPath)) {\n    if (!options.walletSecret) {\n      throw new UserInputValidationError(\n        \"Wallet Secret not configured. Please set the CDP_WALLET_SECRET environment variable, or pass it as an option to the CdpClient constructor.\",\n      );\n    }\n\n    const walletAuthToken = await generateWalletJwt({\n      walletSecret: options.walletSecret,\n      requestMethod: options.requestMethod,\n      requestHost: options.requestHost,\n      requestPath: options.requestPath,\n      requestData: options.requestBody || {},\n    });\n    headers[\"X-Wallet-Auth\"] = walletAuthToken;\n  }\n\n  // Add correlation data\n  headers[\"Correlation-Context\"] = getCorrelationData(options.source, options.sourceVersion);\n\n  return headers;\n}\n\n/**\n * Returns true if the request indicated by the method and URL requires wallet authentication.\n *\n * @param requestMethod - The HTTP method of the request\n * @param requestPath - The URL path of the request\n * @returns True if the request requires wallet authentication, false otherwise\n */\nfunction requiresWalletAuth(requestMethod: string, requestPath: string): boolean {\n  return (\n    (requestPath?.includes(\"/accounts\") ||\n      requestPath?.includes(\"/spend-permissions\") ||\n      requestPath?.includes(\"/user-operations/prepare-and-send\")) &&\n    (requestMethod === \"POST\" || requestMethod === \"DELETE\" || requestMethod === \"PUT\")\n  );\n}\n\n/**\n * Returns encoded correlation data including the SDK version and language.\n *\n * @param source - The source identifier for the request\n * @param sourceVersion - The version of the source making the request\n * @returns Encoded correlation data as a query string\n */\nexport function getCorrelationData(source?: string, sourceVersion?: string): string {\n  const data = {\n    sdk_version: version,\n    sdk_language: \"typescript\",\n    source: source || \"sdk-auth\",\n  };\n  if (sourceVersion) {\n    data[\"source_version\"] = sourceVersion;\n  }\n  return Object.keys(data)\n    .map(key => `${key}=${encodeURIComponent(data[key])}`)\n    .join(\",\");\n}\n","/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151\n * @module\n */\nimport { Chi, HashMD, Maj } from './_md.ts';\nimport { type CHash, clean, createHasher, rotl } from './utils.ts';\n\n/** Initial SHA1 state */\nconst SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n  0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n\n/** SHA1 legacy hash class. */\nexport class SHA1 extends HashMD<SHA1> {\n  private A = SHA1_IV[0] | 0;\n  private B = SHA1_IV[1] | 0;\n  private C = SHA1_IV[2] | 0;\n  private D = SHA1_IV[3] | 0;\n  private E = SHA1_IV[4] | 0;\n\n  constructor() {\n    super(64, 20, 8, false);\n  }\n  protected get(): [number, number, number, number, number] {\n    const { A, B, C, D, E } = this;\n    return [A, B, C, D, E];\n  }\n  protected set(A: number, B: number, C: number, D: number, E: number): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) SHA1_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 80; i++)\n      SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n    // Compression function main loop, 80 rounds\n    let { A, B, C, D, E } = this;\n    for (let i = 0; i < 80; i++) {\n      let F, K;\n      if (i < 20) {\n        F = Chi(B, C, D);\n        K = 0x5a827999;\n      } else if (i < 40) {\n        F = B ^ C ^ D;\n        K = 0x6ed9eba1;\n      } else if (i < 60) {\n        F = Maj(B, C, D);\n        K = 0x8f1bbcdc;\n      } else {\n        F = B ^ C ^ D;\n        K = 0xca62c1d6;\n      }\n      const T = (rotl(A, 5) + F + E + K + SHA1_W[i]) | 0;\n      E = D;\n      D = C;\n      C = rotl(B, 30);\n      B = A;\n      A = T;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    this.set(A, B, C, D, E);\n  }\n  protected roundClean(): void {\n    clean(SHA1_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nexport const sha1: CHash = /* @__PURE__ */ createHasher(() => new SHA1());\n\n/** Per-round constants */\nconst p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) =>\n  Math.floor(p32 * Math.abs(Math.sin(i + 1)))\n);\n\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */\nconst MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** MD5 legacy hash class. */\nexport class MD5 extends HashMD<MD5> {\n  private A = MD5_IV[0] | 0;\n  private B = MD5_IV[1] | 0;\n  private C = MD5_IV[2] | 0;\n  private D = MD5_IV[3] | 0;\n\n  constructor() {\n    super(64, 16, 8, true);\n  }\n  protected get(): [number, number, number, number] {\n    const { A, B, C, D } = this;\n    return [A, B, C, D];\n  }\n  protected set(A: number, B: number, C: number, D: number): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) MD5_W[i] = view.getUint32(offset, true);\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D } = this;\n    for (let i = 0; i < 64; i++) {\n      let F, g, s;\n      if (i < 16) {\n        F = Chi(B, C, D);\n        g = i;\n        s = [7, 12, 17, 22];\n      } else if (i < 32) {\n        F = Chi(D, B, C);\n        g = (5 * i + 1) % 16;\n        s = [5, 9, 14, 20];\n      } else if (i < 48) {\n        F = B ^ C ^ D;\n        g = (3 * i + 5) % 16;\n        s = [4, 11, 16, 23];\n      } else {\n        F = C ^ (B | ~D);\n        g = (7 * i) % 16;\n        s = [6, 10, 15, 21];\n      }\n      F = F + A + K[i] + MD5_W[g];\n      A = D;\n      D = C;\n      C = B;\n      B = B + rotl(F, s[i % 4]);\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    this.set(A, B, C, D);\n  }\n  protected roundClean(): void {\n    clean(MD5_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */\nexport const md5: CHash = /* @__PURE__ */ createHasher(() => new MD5());\n\n// RIPEMD-160\n\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n]);\nconst Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();\nconst Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (() => {\n  const L = [Id160];\n  const R = [Pi160];\n  const res = [L, R];\n  for (let i = 0; i < 4; i++) for (let j of res) j.push(j[i].map((k) => Rho160[k]));\n  return res;\n})();\nconst idxL = /* @__PURE__ */ (() => idxLR[0])();\nconst idxR = /* @__PURE__ */ (() => idxLR[1])();\n// const [idxL, idxR] = idxLR;\n\nconst shifts160 = /* @__PURE__ */ [\n  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n  0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n  0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction ripemd_f(group: number, x: number, y: number, z: number): number {\n  if (group === 0) return x ^ y ^ z;\n  if (group === 1) return (x & y) | (~x & z);\n  if (group === 2) return (x | ~y) ^ z;\n  if (group === 3) return (x & z) | (y & ~z);\n  return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends HashMD<RIPEMD160> {\n  private h0 = 0x67452301 | 0;\n  private h1 = 0xefcdab89 | 0;\n  private h2 = 0x98badcfe | 0;\n  private h3 = 0x10325476 | 0;\n  private h4 = 0xc3d2e1f0 | 0;\n\n  constructor() {\n    super(64, 20, 8, true);\n  }\n  protected get(): [number, number, number, number, number] {\n    const { h0, h1, h2, h3, h4 } = this;\n    return [h0, h1, h2, h3, h4];\n  }\n  protected set(h0: number, h1: number, h2: number, h3: number, h4: number): void {\n    this.h0 = h0 | 0;\n    this.h1 = h1 | 0;\n    this.h2 = h2 | 0;\n    this.h3 = h3 | 0;\n    this.h4 = h4 | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) BUF_160[i] = view.getUint32(offset, true);\n    // prettier-ignore\n    let al = this.h0 | 0, ar = al,\n        bl = this.h1 | 0, br = bl,\n        cl = this.h2 | 0, cr = cl,\n        dl = this.h3 | 0, dr = dl,\n        el = this.h4 | 0, er = el;\n\n    // Instead of iterating 0 to 80, we split it into 5 groups\n    // And use the groups in constants, functions, etc. Much simpler\n    for (let group = 0; group < 5; group++) {\n      const rGroup = 4 - group;\n      const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n      const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n      const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n      for (let i = 0; i < 16; i++) {\n        const tl = (rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;\n        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n      }\n      // 2 loops are 10% faster\n      for (let i = 0; i < 16; i++) {\n        const tr = (rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;\n        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n      }\n    }\n    // Add the compressed chunk to the current hash value\n    this.set(\n      (this.h1 + cl + dr) | 0,\n      (this.h2 + dl + er) | 0,\n      (this.h3 + el + ar) | 0,\n      (this.h4 + al + br) | 0,\n      (this.h0 + bl + cr) | 0\n    );\n  }\n  protected roundClean(): void {\n    clean(BUF_160);\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */\nexport const ripemd160: CHash = /* @__PURE__ */ createHasher(() => new RIPEMD160());\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/core/telemetry/events/payment.ts","import { SignTransactionOptions } from \"../../client/solana/solana.types.js\";\nimport { CdpOpenApiClientType } from \"../../openapi-client/index.js\";\n\nexport interface SignTransactionResult {\n  /** The signature of the transaction base58 encoded. */\n  signedTransaction: string;\n  /** @deprecated Use signedTransaction instead. */\n  signature: string;\n}\n\n/**\n * Signs a transaction.\n *\n * @param apiClient - The API client.\n * @param {SignTransactionOptions} options - Parameters for signing the transaction.\n * @param {string} options.address - The address to sign the transaction for.\n * @param {string} options.transaction - The transaction to sign.\n * @param {string} [options.idempotencyKey] - An idempotency key.\n *\n * @returns A promise that resolves to the signature.\n *\n * @example\n * ```ts\n * // Create a Solana account\n * const account = await cdp.solana.createAccount();\n *\n * // Add your transaction instructions here\n * const transaction = new Transaction()\n *\n * // Make sure to set requireAllSignatures to false, since signing will be done through the API\n * const serializedTransaction = transaction.serialize({\n *   requireAllSignatures: false,\n * });\n *\n * // Base64 encode the serialized transaction\n * const transaction = Buffer.from(serializedTransaction).toString(\"base64\");\n *\n * // When you want to sign a transaction, you can do so by address and base64 encoded transaction\n * const signature = await signTransaction(cdp.solana, {\n *   address: account.address,\n *   transaction,\n * });\n * ```\n */\nexport async function signTransaction(\n  apiClient: CdpOpenApiClientType,\n  options: SignTransactionOptions,\n): Promise<SignTransactionResult> {\n  const signature = await apiClient.signSolanaTransaction(\n    options.address,\n    {\n      transaction: options.transaction,\n    },\n    options.idempotencyKey,\n  );\n\n  return {\n    signedTransaction: signature.signedTransaction,\n    signature: signature.signedTransaction,\n  };\n}\n","import type { Account } from '../../accounts/types.js'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { EstimateGasParameters as EstimateGasParameters_base } from '../../actions/public/estimateGas.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../errors/account.js'\nimport type { BaseError } from '../../errors/base.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { Filter } from '../../types/utils.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\nimport { getCallError } from '../../utils/errors/getCallError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport { formatTransactionRequest } from '../../utils/formatters/transactionRequest.js'\nimport {\n  type AssertRequestParameters,\n  assertRequest,\n} from '../../utils/transaction/assertRequest.js'\nimport type { LineaRpcSchema } from '../types/rpc.js'\n\nexport type EstimateGasParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n> = EstimateGasParameters_base<chain> & GetAccountParameter<account>\n\nexport type EstimateGasReturnType = {\n  gasLimit: bigint\n  baseFeePerGas: bigint\n  priorityFeePerGas: bigint\n}\n\n/**\n * Estimates the gas and fees per gas necessary to complete a transaction without submitting it to the network.\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateGasParameters}\n * @returns A gas estimate and fees per gas (in wei). {@link EstimateGasReturnType}\n *\n * @example\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { linea } from 'viem/chains'\n * import { estimateGas } from 'viem/linea'\n *\n * const client = createPublicClient({\n *   chain: linea,\n *   transport: http(),\n * })\n * const gasEstimate = await estimateGas(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 0n,\n * })\n */\nexport async function estimateGas<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  args: EstimateGasParameters<chain>,\n): Promise<EstimateGasReturnType> {\n  const { account: account_ = client.account } = args\n\n  if (!account_) throw new AccountNotFoundError()\n  const account = parseAccount(account_)\n\n  try {\n    const {\n      accessList,\n      blockNumber,\n      blockTag,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n      ...rest\n    } = args\n\n    const blockNumberHex =\n      typeof blockNumber === 'bigint' ? numberToHex(blockNumber) : undefined\n    const block = blockNumberHex || blockTag\n\n    assertRequest(args as AssertRequestParameters)\n\n    const chainFormat = client.chain?.formatters?.transactionRequest?.format\n    const format = chainFormat || formatTransactionRequest\n\n    const request = format(\n      {\n        // Pick out extra data that might exist on the chain's transaction request type.\n        ...extract(rest, { format: chainFormat }),\n        account,\n        accessList,\n        data,\n        gas,\n        gasPrice,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        to,\n        value,\n      } as TransactionRequest,\n      'estimateGas',\n    )\n\n    type LineaEstimateGasSchema = Filter<\n      LineaRpcSchema,\n      { Method: 'linea_estimateGas' }\n    >[0]\n    const { baseFeePerGas, gasLimit, priorityFeePerGas } =\n      await client.request<LineaEstimateGasSchema>({\n        method: 'linea_estimateGas',\n        params: block ? [request, block] : [request],\n      })\n    return {\n      baseFeePerGas: BigInt(baseFeePerGas),\n      gasLimit: BigInt(gasLimit),\n      priorityFeePerGas: BigInt(priorityFeePerGas),\n    }\n  } catch (err) {\n    throw getCallError(err as BaseError, {\n      ...args,\n      account,\n      chain: client.chain,\n    })\n  }\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/core/communicator/Communicator.ts","import type { Abi } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ContractFunctionArgs,\n  ContractFunctionName,\n} from '../../types/contract.js'\nimport {\n  type SendTransactionSyncParameters,\n  type SendTransactionSyncReturnType,\n  sendTransactionSync,\n} from './sendTransactionSync.js'\nimport { type WriteContractParameters, writeContract } from './writeContract.js'\n\nexport type { WriteContractErrorType as WriteContractSyncErrorType } from './writeContract.js'\n\nexport type WriteContractSyncParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  functionName extends ContractFunctionName<\n    abi,\n    'nonpayable' | 'payable'\n  > = ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  > = ContractFunctionArgs<abi, 'nonpayable' | 'payable', functionName>,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n> = WriteContractParameters<\n  abi,\n  functionName,\n  args,\n  chain,\n  account,\n  chainOverride\n> &\n  Pick<\n    SendTransactionSyncParameters<chain>,\n    'pollingInterval' | 'throwOnReceiptRevert' | 'timeout'\n  >\n\nexport type WriteContractSyncReturnType<\n  chain extends Chain | undefined = Chain | undefined,\n> = SendTransactionSyncReturnType<chain>\n\n/**\n * Executes a write function on a contract synchronously.\n * Returns the transaction receipt.\n *\n * - Docs: https://viem.sh/docs/contract/writeContractSync\n *\n * A \"write\" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms) is needed to be broadcast in order to change the state.\n *\n * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).\n *\n * __Warning: The `write` internally sends a transaction  it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract#usage) before you execute it.__\n *\n * @param client - Client to use\n * @param parameters - {@link WriteContractParameters}\n * @returns A [Transaction Hash](https://viem.sh/docs/glossary/terms#hash). {@link WriteContractReturnType}\n *\n * @example\n * import { createWalletClient, custom, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { writeContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const receipt = await writeContractSync(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n *   functionName: 'mint',\n *   args: [69420],\n * })\n */\nexport async function writeContractSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  const abi extends Abi | readonly unknown[],\n  functionName extends ContractFunctionName<abi, 'nonpayable' | 'payable'>,\n  args extends ContractFunctionArgs<\n    abi,\n    'nonpayable' | 'payable',\n    functionName\n  >,\n  chainOverride extends Chain | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: WriteContractSyncParameters<\n    abi,\n    functionName,\n    args,\n    chain,\n    account,\n    chainOverride\n  >,\n): Promise<WriteContractSyncReturnType<chain>> {\n  return writeContract.internal(\n    client,\n    sendTransactionSync,\n    'sendTransactionSync',\n    parameters as never,\n  ) as never\n}\n","import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Account } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { GetCallsStatusReturnType } from './getCallsStatus.js'\nimport {\n  type SendCallsErrorType,\n  type SendCallsParameters,\n  sendCalls,\n} from './sendCalls.js'\nimport {\n  type WaitForCallsStatusParameters,\n  waitForCallsStatus,\n} from './waitForCallsStatus.js'\n\nexport type SendCallsSyncParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n> = SendCallsParameters<chain, account, chainOverride, calls> &\n  Pick<\n    WaitForCallsStatusParameters,\n    'pollingInterval' | 'status' | 'throwOnFailure'\n  > & {\n    /** Timeout (ms) to wait for calls to be included in a block. @default chain.blockTime * 3 */\n    timeout?: number | undefined\n  }\n\nexport type SendCallsSyncReturnType = GetCallsStatusReturnType\n\nexport type SendCallsSyncErrorType = SendCallsErrorType\n\n/**\n * Requests the connected wallet to send a batch of calls, and waits for the calls to be included in a block.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendCallsSync\n * - JSON-RPC Methods: [`wallet_sendCalls`](https://eips.ethereum.org/EIPS/eip-5792)\n *\n * @param client - Client to use\n * @returns Calls status. {@link SendCallsSyncReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendCalls } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const status = await sendCallsSync(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   calls: [\n *     {\n *       data: '0xdeadbeef',\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *     },\n *     {\n *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       value: 69420n,\n *     },\n *   ],\n * })\n */\nexport async function sendCallsSync<\n  const calls extends readonly unknown[],\n  chain extends Chain | undefined,\n  account extends Account | undefined = undefined,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SendCallsSyncParameters<chain, account, chainOverride, calls>,\n): Promise<SendCallsSyncReturnType> {\n  const { chain = client.chain } = parameters\n  const timeout =\n    parameters.timeout ?? Math.max((chain?.blockTime ?? 0) * 3, 5_000)\n  const result = await sendCalls(client, parameters)\n  const status = await waitForCallsStatus(client, {\n    ...parameters,\n    id: result.id,\n    timeout,\n  })\n  return status\n}\n","import type { Address, Narrow } from 'abitype'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../../errors/account.js'\nimport type { BaseError } from '../../../errors/base.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Calls } from '../../../types/calls.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { StateOverride } from '../../../types/stateOverride.js'\nimport type {\n  Assign,\n  MaybeRequired,\n  OneOf,\n  Prettify,\n} from '../../../types/utils.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport { getAction } from '../../../utils/getAction.js'\nimport { serializeStateOverride } from '../../../utils/stateOverride.js'\nimport type { SmartAccount } from '../../accounts/types.js'\nimport type { PaymasterActions } from '../../clients/decorators/paymaster.js'\nimport type {\n  DeriveSmartAccount,\n  GetSmartAccountParameter,\n} from '../../types/account.js'\nimport type {\n  DeriveEntryPointVersion,\n  EntryPointVersion,\n} from '../../types/entryPointVersion.js'\nimport type {\n  EstimateUserOperationGasReturnType as EstimateUserOperationGasReturnType_,\n  UserOperation,\n  UserOperationRequest,\n} from '../../types/userOperation.js'\nimport { getUserOperationError } from '../../utils/errors/getUserOperationError.js'\nimport {\n  type FormatUserOperationGasErrorType,\n  formatUserOperationGas,\n} from '../../utils/formatters/userOperationGas.js'\nimport {\n  type FormatUserOperationRequestErrorType,\n  formatUserOperationRequest,\n} from '../../utils/formatters/userOperationRequest.js'\nimport {\n  type PrepareUserOperationErrorType,\n  type PrepareUserOperationParameters,\n  prepareUserOperation,\n} from './prepareUserOperation.js'\n\nexport type EstimateUserOperationGasParameters<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  //\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = GetSmartAccountParameter<account, accountOverride, false> &\n  (\n    | UserOperation // Accept a full-formed User Operation.\n    | Assign<\n        // Accept a partially-formed User Operation (UserOperationRequest) to be filled.\n        UserOperationRequest<_derivedVersion>,\n        OneOf<{ calls: Calls<Narrow<calls>> } | { callData: Hex }> & {\n          paymaster?:\n            | Address\n            | true\n            | {\n                /** Retrieves paymaster-related User Operation properties to be used for sending the User Operation. */\n                getPaymasterData?:\n                  | PaymasterActions['getPaymasterData']\n                  | undefined\n                /** Retrieves paymaster-related User Operation properties to be used for gas estimation. */\n                getPaymasterStubData?:\n                  | PaymasterActions['getPaymasterStubData']\n                  | undefined\n              }\n            | undefined\n          /** Paymaster context to pass to `getPaymasterData` and `getPaymasterStubData` calls. */\n          paymasterContext?: unknown | undefined\n        }\n      >\n  ) &\n  // Allow the EntryPoint address to be overridden, if no Account is provided, it will need to be required.\n  MaybeRequired<\n    { entryPointAddress?: Address },\n    _derivedAccount extends undefined ? true : false\n  > & {\n    /** State overrides for the User Operation call. */\n    stateOverride?: StateOverride | undefined\n  }\n\nexport type EstimateUserOperationGasReturnType<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  //\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = Prettify<EstimateUserOperationGasReturnType_<_derivedVersion>>\n\nexport type EstimateUserOperationGasErrorType =\n  | ParseAccountErrorType\n  | PrepareUserOperationErrorType\n  | FormatUserOperationRequestErrorType\n  | FormatUserOperationGasErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Returns an estimate of gas values necessary to execute the User Operation.\n *\n * - Docs: https://viem.sh/actions/bundler/estimateUserOperationGas\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateUserOperationGasParameters}\n * @returns The gas estimate (in wei). {@link EstimateUserOperationGasReturnType}\n *\n * @example\n * import { createBundlerClient, http, parseEther } from 'viem'\n * import { toSmartAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { estimateUserOperationGas } from 'viem/actions'\n *\n * const account = await toSmartAccount({ ... })\n *\n * const bundlerClient = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const values = await estimateUserOperationGas(bundlerClient, {\n *   account,\n *   calls: [{ to: '0x...', value: parseEther('1') }],\n * })\n */\nexport async function estimateUserOperationGas<\n  const calls extends readonly unknown[],\n  account extends SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = undefined,\n>(\n  client: Client<Transport, Chain | undefined, account>,\n  parameters: EstimateUserOperationGasParameters<\n    account,\n    accountOverride,\n    calls\n  >,\n): Promise<EstimateUserOperationGasReturnType<account, accountOverride>> {\n  const {\n    account: account_ = client.account,\n    entryPointAddress,\n    stateOverride,\n  } = parameters\n\n  if (!account_ && !parameters.sender) throw new AccountNotFoundError()\n  const account = account_ ? parseAccount(account_) : undefined\n\n  const rpcStateOverride = serializeStateOverride(stateOverride)\n\n  const request = account\n    ? await getAction(\n        client,\n        prepareUserOperation,\n        'prepareUserOperation',\n      )({\n        ...parameters,\n        parameters: [\n          'authorization',\n          'factory',\n          'nonce',\n          'paymaster',\n          'signature',\n        ],\n      } as unknown as PrepareUserOperationParameters)\n    : parameters\n\n  try {\n    const params = [\n      formatUserOperationRequest(request as UserOperation),\n      (entryPointAddress ?? account?.entryPoint?.address)!,\n    ] as const\n\n    const result = await client.request({\n      method: 'eth_estimateUserOperationGas',\n      params: rpcStateOverride ? [...params, rpcStateOverride] : [...params],\n    })\n    return formatUserOperationGas(result) as EstimateUserOperationGasReturnType<\n      account,\n      accountOverride\n    >\n  } catch (error) {\n    const calls = (parameters as any).calls\n    throw getUserOperationError(error as BaseError, {\n      ...(request as UserOperation),\n      ...(calls ? { calls } : {}),\n    })\n  }\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  type Account,\n  type Address,\n  type EncodedAccount,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n} from '@solana/kit';\nimport {\n  getNonceStateDecoder,\n  getNonceStateEncoder,\n  getNonceVersionDecoder,\n  getNonceVersionEncoder,\n  type NonceState,\n  type NonceStateArgs,\n  type NonceVersion,\n  type NonceVersionArgs,\n} from '../types';\n\nexport type Nonce = {\n  version: NonceVersion;\n  state: NonceState;\n  authority: Address;\n  blockhash: Address;\n  lamportsPerSignature: bigint;\n};\n\nexport type NonceArgs = {\n  version: NonceVersionArgs;\n  state: NonceStateArgs;\n  authority: Address;\n  blockhash: Address;\n  lamportsPerSignature: number | bigint;\n};\n\nexport function getNonceEncoder(): FixedSizeEncoder<NonceArgs> {\n  return getStructEncoder([\n    ['version', getNonceVersionEncoder()],\n    ['state', getNonceStateEncoder()],\n    ['authority', getAddressEncoder()],\n    ['blockhash', getAddressEncoder()],\n    ['lamportsPerSignature', getU64Encoder()],\n  ]);\n}\n\nexport function getNonceDecoder(): FixedSizeDecoder<Nonce> {\n  return getStructDecoder([\n    ['version', getNonceVersionDecoder()],\n    ['state', getNonceStateDecoder()],\n    ['authority', getAddressDecoder()],\n    ['blockhash', getAddressDecoder()],\n    ['lamportsPerSignature', getU64Decoder()],\n  ]);\n}\n\nexport function getNonceCodec(): FixedSizeCodec<NonceArgs, Nonce> {\n  return combineCodec(getNonceEncoder(), getNonceDecoder());\n}\n\nexport function decodeNonce<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Nonce, TAddress>;\nexport function decodeNonce<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Nonce, TAddress>;\nexport function decodeNonce<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Nonce, TAddress> | MaybeAccount<Nonce, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getNonceDecoder()\n  );\n}\n\nexport async function fetchNonce<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Nonce, TAddress>> {\n  const maybeAccount = await fetchMaybeNonce(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeNonce<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Nonce, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeNonce(maybeAccount);\n}\n\nexport async function fetchAllNonce(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Nonce>[]> {\n  const maybeAccounts = await fetchAllMaybeNonce(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeNonce(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Nonce>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeNonce(maybeAccount));\n}\n\nexport function getNonceSize(): number {\n  return 80;\n}\n","import * as Bytes from '../Bytes.js'\nimport type * as Errors from '../Errors.js'\n\n/** @internal */\nexport function assertSize(bytes: Bytes.Bytes, size_: number): void {\n  if (Bytes.size(bytes) > size_)\n    throw new Bytes.SizeOverflowError({\n      givenSize: Bytes.size(bytes),\n      maxSize: size_,\n    })\n}\n\n/** @internal */\nexport declare namespace assertSize {\n  type ErrorType =\n    | Bytes.size.ErrorType\n    | Bytes.SizeOverflowError\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function assertStartOffset(\n  value: Bytes.Bytes,\n  start?: number | undefined,\n) {\n  if (typeof start === 'number' && start > 0 && start > Bytes.size(value) - 1)\n    throw new Bytes.SliceOffsetOutOfBoundsError({\n      offset: start,\n      position: 'start',\n      size: Bytes.size(value),\n    })\n}\n\nexport declare namespace assertStartOffset {\n  export type ErrorType =\n    | Bytes.SliceOffsetOutOfBoundsError\n    | Bytes.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function assertEndOffset(\n  value: Bytes.Bytes,\n  start?: number | undefined,\n  end?: number | undefined,\n) {\n  if (\n    typeof start === 'number' &&\n    typeof end === 'number' &&\n    Bytes.size(value) !== end - start\n  ) {\n    throw new Bytes.SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: Bytes.size(value),\n    })\n  }\n}\n\n/** @internal */\nexport declare namespace assertEndOffset {\n  type ErrorType =\n    | Bytes.SliceOffsetOutOfBoundsError\n    | Bytes.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport const charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102,\n} as const\n\n/** @internal */\nexport function charCodeToBase16(char: number) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n    return char - charCodeMap.zero\n  if (char >= charCodeMap.A && char <= charCodeMap.F)\n    return char - (charCodeMap.A - 10)\n  if (char >= charCodeMap.a && char <= charCodeMap.f)\n    return char - (charCodeMap.a - 10)\n  return undefined\n}\n\n/** @internal */\nexport function pad(bytes: Bytes.Bytes, options: pad.Options = {}) {\n  const { dir, size = 32 } = options\n  if (size === 0) return bytes\n  if (bytes.length > size)\n    throw new Bytes.SizeExceedsPaddingSizeError({\n      size: bytes.length,\n      targetSize: size,\n      type: 'Bytes',\n    })\n  const paddedBytes = new Uint8Array(size)\n  for (let i = 0; i < size; i++) {\n    const padEnd = dir === 'right'\n    paddedBytes[padEnd ? i : size - i - 1] =\n      bytes[padEnd ? i : bytes.length - i - 1]!\n  }\n  return paddedBytes\n}\n\n/** @internal */\nexport declare namespace pad {\n  type Options = {\n    dir?: 'left' | 'right' | undefined\n    size?: number | undefined\n  }\n\n  type ReturnType = Bytes.Bytes\n\n  type ErrorType = Bytes.SizeExceedsPaddingSizeError | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function trim(\n  value: Bytes.Bytes,\n  options: trim.Options = {},\n): trim.ReturnType {\n  const { dir = 'left' } = options\n\n  let data = value\n\n  let sliceLength = 0\n  for (let i = 0; i < data.length - 1; i++) {\n    if (data[dir === 'left' ? i : data.length - i - 1]!.toString() === '0')\n      sliceLength++\n    else break\n  }\n  data =\n    dir === 'left'\n      ? data.slice(sliceLength)\n      : data.slice(0, data.length - sliceLength)\n\n  return data as trim.ReturnType\n}\n\n/** @internal */\nexport declare namespace trim {\n  type Options = {\n    dir?: 'left' | 'right' | undefined\n  }\n\n  type ReturnType = Bytes.Bytes\n\n  type ErrorType = Errors.GlobalErrorType\n}\n","import {\n  Account,\n  createPublicClient,\n  createWalletClient,\n  http,\n  Transport,\n  type Chain,\n  type PublicClient,\n  type WalletClient,\n} from \"viem\";\nimport { toAccount } from \"viem/accounts\";\nimport * as chains from \"viem/chains\";\n\nimport { getBaseNodeRpcUrl } from \"./getBaseNodeRpcUrl.js\";\nimport { NETWORK_TO_CHAIN_MAP, resolveNetworkToChain } from \"./networkToChainResolver.js\";\nimport { UserInputValidationError } from \"../../errors.js\";\n\nimport type { EvmAccount } from \"./types.js\";\n\n/**\n * Get a chain from the viem chains object\n *\n * @param id - The chain ID\n * @returns The chain\n */\nfunction getChain(id: number): Chain {\n  const chainList = Object.values(chains) as Chain[];\n  const found = chainList.find(chain => chain.id === id);\n  if (!found) throw new Error(`Unsupported chain ID: ${id}`);\n  return found;\n}\n\n/**\n * Determines if the input string is a network identifier or a Node URL\n *\n * @param input - The string to check\n * @returns True if the input is a network identifier, false otherwise\n */\nfunction isNetworkIdentifier(input: string): boolean {\n  const normalizedInput = input.toLowerCase();\n  return NETWORK_TO_CHAIN_MAP[normalizedInput] !== undefined;\n}\n\n/**\n * Resolves a Node URL to a viem chain by making a getChainId call\n *\n * @param nodeUrl - The Node URL to resolve\n * @returns Promise resolving to the viem chain\n */\nasync function resolveNodeUrlToChain(nodeUrl: string): Promise<Chain> {\n  // First validate that it's a proper URL\n  if (!isValidUrl(nodeUrl)) {\n    throw new UserInputValidationError(`Invalid URL format: ${nodeUrl}`);\n  }\n\n  // Create a temporary public client to get the chain ID\n  const tempPublicClient = createPublicClient({\n    transport: http(nodeUrl),\n  });\n\n  try {\n    const chainId = await tempPublicClient.getChainId();\n    const chain = getChain(Number(chainId));\n    return chain;\n  } catch (error) {\n    throw new Error(\n      `Failed to resolve chain ID from Node URL: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n    );\n  }\n}\n\n/**\n * Determines if the input string is a valid URL\n *\n * @param input - The string to validate as a URL\n * @returns True if the input is a valid URL, false otherwise\n */\nfunction isValidUrl(input: string): boolean {\n  try {\n    new URL(input);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Options for resolving viem clients\n */\nexport type ResolveViemClientsOptions = {\n  /** The network identifier (e.g., \"base\", \"base-sepolia\") or Node URL */\n  networkOrNodeUrl: string;\n  /** Optional account to use for the wallet client */\n  account: EvmAccount;\n};\n\n/**\n * Result of resolving viem clients\n */\nexport type ResolvedViemClients = {\n  /** The resolved viem chain */\n  chain: Chain;\n  /** The public client for reading blockchain data */\n  publicClient: PublicClient<Transport, Chain>;\n  /** The wallet client for sending transactions */\n  walletClient: WalletClient<Transport, Chain, Account>;\n};\n\n/**\n * Resolves viem clients based on a network identifier or Node URL.\n *\n * @param options - Configuration options\n * @param options.networkOrNodeUrl - Either a network identifier (e.g., \"base\", \"base-sepolia\") or a full Node URL\n * @param options.account - Optional account to use for the wallet client\n * @returns Promise resolving to an object containing the chain, publicClient, and walletClient\n *\n * @example\n * ```typescript\n * // Using network identifier\n * const clients = await resolveViemClients({\n *   networkOrNodeUrl: \"base\",\n *   account: myAccount\n * });\n *\n * // Using Node URL\n * const clients = await resolveViemClients({\n *   networkOrNodeUrl: \"https://mainnet.base.org\",\n *   account: myAccount\n * });\n * ```\n */\nexport async function resolveViemClients(\n  options: ResolveViemClientsOptions,\n): Promise<ResolvedViemClients> {\n  const { networkOrNodeUrl } = options;\n\n  let chain: Chain;\n\n  // If it's a valid network identifier, use the mapping\n  if (isNetworkIdentifier(networkOrNodeUrl)) {\n    const rpcUrl =\n      networkOrNodeUrl === \"base\" || networkOrNodeUrl === \"base-sepolia\"\n        ? await getBaseNodeRpcUrl(networkOrNodeUrl)\n        : undefined;\n\n    chain = resolveNetworkToChain(networkOrNodeUrl);\n    const publicClient = createPublicClient({\n      chain,\n      transport: http(rpcUrl),\n    });\n    const walletClient = createWalletClient({\n      account: toAccount(options.account),\n      chain,\n      transport: http(rpcUrl),\n    });\n    return {\n      chain,\n      publicClient,\n      walletClient,\n    };\n  }\n\n  // If it's not a valid network identifier, try to treat it as a Node URL\n  try {\n    chain = await resolveNodeUrlToChain(networkOrNodeUrl);\n    const publicClient = createPublicClient({\n      chain,\n      transport: http(networkOrNodeUrl),\n    });\n    const walletClient = createWalletClient({\n      account: toAccount(options.account),\n      chain,\n      transport: http(networkOrNodeUrl),\n    });\n    return {\n      chain,\n      publicClient,\n      walletClient,\n    };\n  } catch (error) {\n    // If the error is from resolveNodeUrlToChain, re-throw it as-is\n    if (\n      error instanceof Error &&\n      (error.message.includes(\"Invalid URL format\") ||\n        error.message.includes(\"Unsupported chain ID\") ||\n        error.message.includes(\"Failed to resolve chain ID\"))\n    ) {\n      throw error;\n    }\n\n    // Otherwise, throw a generic error about unsupported input\n    throw new UserInputValidationError(\n      `Unsupported network identifier or invalid Node URL: ${networkOrNodeUrl}`,\n    );\n  }\n}\n","import { encodeFunctionData, erc20Abi } from \"viem\";\n\nimport { getErc20Address } from \"./utils.js\";\nimport { mapChainToNetwork } from \"../../../accounts/evm/chainToNetworkMapper.js\";\n\nimport type { Network, TransferOptions } from \"./types.js\";\nimport type { EvmAccount } from \"../../../accounts/evm/types.js\";\nimport type { Hex } from \"../../../types/misc.js\";\nimport type { TransactionResult } from \"../sendTransaction.js\";\nimport type { Account, Chain, Transport, WalletClient } from \"viem\";\n\n/**\n * Transfer an amount of a token from a network-scoped account to another account.\n * This function is used for accounts that are scoped to a specific network and use\n * a wallet client for transaction execution instead of the API client.\n *\n * @param walletClient - The wallet client to use for transaction execution.\n * @param from - The account to send the transaction from.\n * @param transferArgs - The transfer options.\n * @returns The result of the transfer.\n */\nexport async function transferWithViem<T extends EvmAccount>(\n  walletClient: WalletClient<Transport, Chain, Account>,\n  from: T,\n  transferArgs: Omit<TransferOptions, \"address\" | \"network\">,\n): Promise<TransactionResult> {\n  const token = transferArgs.token;\n  const to = typeof transferArgs.to === \"string\" ? transferArgs.to : transferArgs.to.address;\n  const value = transferArgs.amount;\n\n  if (token === \"eth\") {\n    const hash = await walletClient.sendTransaction({\n      account: from.address,\n      to,\n      value,\n    });\n    return { transactionHash: hash as Hex };\n  }\n\n  const network = mapChainToNetwork(walletClient.chain) as Network;\n  const erc20Address = getErc20Address(token, network);\n\n  // First approve the transfer\n  await walletClient.sendTransaction({\n    account: from.address,\n    to: erc20Address,\n    data: encodeFunctionData({\n      abi: erc20Abi,\n      functionName: \"approve\",\n      args: [to, value],\n    }),\n  });\n\n  // Then execute the transfer\n  const hash = await walletClient.sendTransaction({\n    account: from.address,\n    to: erc20Address,\n    data: encodeFunctionData({\n      abi: erc20Abi,\n      functionName: \"transfer\",\n      args: [to, value],\n    }),\n  });\n\n  return { transactionHash: hash as Hex };\n}\n","import {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getU32Decoder, getU32Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { getFixedSize, getMaxSize } from './utils';\n\n/**\n * Defines the possible size strategies for array-like codecs (`array`, `map`, and `set`).\n *\n * The size of the collection can be determined using one of the following approaches:\n * - A {@link NumberCodec}, {@link NumberDecoder}, or {@link NumberEncoder} to store a size prefix.\n * - A fixed `number` of items, enforcing an exact length.\n * - The string `\"remainder\"`, which infers the number of items by consuming the rest of the available bytes.\n *   This option is only available when encoding fixed-size items.\n *\n * @typeParam TPrefix - A number codec, decoder, or encoder used for size prefixing.\n */\nexport type ArrayLikeCodecSize<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> =\n    | TPrefix\n    | number\n    | 'remainder';\n\n/**\n * Defines the configuration options for array codecs.\n *\n * @typeParam TPrefix - A number codec, decoder, or encoder used for size prefixing.\n */\nexport type ArrayCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Specifies how the size of the array is determined.\n     *\n     * - A {@link NumberCodec}, {@link NumberDecoder}, or {@link NumberEncoder} stores a size prefix before encoding the array.\n     * - A `number` enforces a fixed number of elements.\n     * - `\"remainder\"` uses all remaining bytes to infer the array length (only for fixed-size items).\n     *\n     * @defaultValue A `u32` size prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Returns an encoder for arrays of values.\n *\n * This encoder serializes arrays by encoding each element using the provided item encoder.\n * By default, a `u32` size prefix is included to indicate the number of items in the array.\n * The `size` option can be used to modify this behaviour.\n *\n * For more details, see {@link getArrayCodec}.\n *\n * @typeParam TFrom - The type of the elements in the array.\n *\n * @param item - The encoder for each item in the array.\n * @param config - Optional configuration for the size encoding strategy.\n * @returns A `VariableSizeEncoder<TFrom[]>` for encoding arrays.\n *\n * @example\n * Encoding an array of `u8` numbers.\n * ```ts\n * const encoder = getArrayEncoder(getU8Encoder());\n * const bytes = encoder.encode([1, 2, 3]);\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix telling us to read 3 items.\n * ```\n *\n * @see {@link getArrayCodec}\n */\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<TFrom[], 0>;\nexport function getArrayEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: ArrayCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom[]> {\n    const size = config.size ?? getU32Encoder();\n    const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize !== null\n            ? { fixedSize }\n            : {\n                  getSizeFromValue: (array: TFrom[]) => {\n                      const prefixSize = typeof size === 'object' ? getEncodedSize(array.length, size) : 0;\n                      return prefixSize + [...array].reduce((all, value) => all + getEncodedSize(value, item), 0);\n                  },\n                  maxSize,\n              }),\n        write: (array: TFrom[], bytes, offset) => {\n            if (typeof size === 'number') {\n                assertValidNumberOfItemsForCodec('array', size, array.length);\n            }\n            if (typeof size === 'object') {\n                offset = size.write(array.length, bytes, offset);\n            }\n            array.forEach(value => {\n                offset = item.write(value, bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder for arrays of values.\n *\n * This decoder deserializes arrays by decoding each element using the provided item decoder.\n * By default, a `u32` size prefix is expected to indicate the number of items in the array.\n * The `size` option can be used to modify this behaviour.\n *\n * For more details, see {@link getArrayCodec}.\n *\n * @typeParam TTo - The type of the decoded elements in the array.\n *\n * @param item - The decoder for each item in the array.\n * @param config - Optional configuration for the size decoding strategy.\n * @returns A `VariableSizeDecoder<TTo[]>` for decoding arrays.\n *\n * @example\n * Decoding an array of `u8` numbers.\n * ```ts\n * const decoder = getArrayDecoder(getU8Decoder());\n * const array = decoder.decode(new Uint8Array([0x03, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03]));\n * // [1, 2, 3]\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix telling us to read 3 items.\n * ```\n *\n * @see {@link getArrayCodec}\n */\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<TTo[], 0>;\nexport function getArrayDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: ArrayCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(item: Decoder<TTo>, config: ArrayCodecConfig<NumberDecoder> = {}): Decoder<TTo[]> {\n    const size = config.size ?? getU32Decoder();\n    const itemSize = getFixedSize(item);\n    const fixedSize = computeArrayLikeCodecSize(size, itemSize);\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize !== null ? { fixedSize } : { maxSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const array: TTo[] = [];\n            if (typeof size === 'object' && bytes.slice(offset).length === 0) {\n                return [array, offset];\n            }\n\n            if (size === 'remainder') {\n                while (offset < bytes.length) {\n                    const [value, newOffset] = item.read(bytes, offset);\n                    offset = newOffset;\n                    array.push(value);\n                }\n                return [array, offset];\n            }\n\n            const [resolvedSize, newOffset] = typeof size === 'number' ? [size, offset] : size.read(bytes, offset);\n            offset = newOffset;\n            for (let i = 0; i < resolvedSize; i += 1) {\n                const [value, newOffset] = item.read(bytes, offset);\n                offset = newOffset;\n                array.push(value);\n            }\n            return [array, offset];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding arrays of values.\n *\n * This codec serializes arrays by encoding each element using the provided item codec.\n * By default, a `u32` size prefix is included to indicate the number of items in the array.\n * The `size` option can be used to modify this behaviour.\n *\n * @typeParam TFrom - The type of the elements to encode.\n * @typeParam TTo - The type of the decoded elements.\n *\n * @param item - The codec for each item in the array.\n * @param config - Optional configuration for the size encoding/decoding strategy.\n * @returns A `VariableSizeCodec<TFrom[], TTo[]>` for encoding and decoding arrays.\n *\n * @example\n * Encoding and decoding an array of `u8` numbers.\n * ```ts\n * const codec = getArrayCodec(getU8Codec());\n * const bytes = codec.encode([1, 2, 3]);\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix telling us to read 3 items.\n *\n * const array = codec.decode(bytes);\n * // [1, 2, 3]\n * ```\n *\n * @example\n * Using a `u16` size prefix instead of `u32`.\n * ```ts\n * const codec = getArrayCodec(getU8Codec(), { size: getU16Codec() });\n * const bytes = codec.encode([1, 2, 3]);\n * // 0x0300010203\n * //   |   -- 3 items of 1 byte each.\n * //   -- 2-byte prefix telling us to read 3 items.\n * ```\n *\n * @example\n * Using a fixed-size array of 3 items.\n * ```ts\n * const codec = getArrayCodec(getU8Codec(), { size: 3 });\n * codec.encode([1, 2, 3]);\n * // 0x010203\n * //   -- 3 items of 1 byte each. There must always be 3 items in the array.\n * ```\n *\n * @example\n * Using the `\"remainder\"` size strategy.\n * ```ts\n * const codec = getArrayCodec(getU8Codec(), { size: 'remainder' });\n * codec.encode([1, 2, 3]);\n * // 0x010203\n * //   -- 3 items of 1 byte each. The size is inferred from the remainder of the bytes.\n * ```\n *\n * @remarks\n * The size of the array can be controlled using the `size` option:\n * - A `Codec<number>` (e.g. `getU16Codec()`) stores a size prefix before the array.\n * - A `number` enforces a fixed number of elements.\n * - `\"remainder\"` uses all remaining bytes to infer the array length.\n *\n * Separate {@link getArrayEncoder} and {@link getArrayDecoder} functions are available.\n *\n * ```ts\n * const bytes = getArrayEncoder(getU8Encoder()).encode([1, 2, 3]);\n * const array = getArrayDecoder(getU8Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getArrayEncoder}\n * @see {@link getArrayDecoder}\n */\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<TFrom[], TTo[], 0>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: ArrayCodecConfig<NumberCodec>,\n): VariableSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> = {},\n): Codec<TFrom[], TTo[]> {\n    return combineCodec(getArrayEncoder(item, config as object), getArrayDecoder(item, config as object));\n}\n\nfunction computeArrayLikeCodecSize(size: number | object | 'remainder', itemSize: number | null): number | null {\n    if (typeof size !== 'number') return null;\n    if (size === 0) return 0;\n    return itemSize === null ? null : itemSize * size;\n}\n","import type { Address } from '@solana/addresses';\nimport { getBase58Encoder, getBase64Encoder } from '@solana/codecs-strings';\nimport type {\n    AccountInfoBase,\n    AccountInfoWithBase58Bytes,\n    AccountInfoWithBase58EncodedData,\n    AccountInfoWithBase64EncodedData,\n} from '@solana/rpc-types';\n\nimport type { Account, BaseAccount, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport type { JsonParsedDataResponse } from './rpc-api';\n\ntype Base64EncodedRpcAccount = AccountInfoBase & AccountInfoWithBase64EncodedData;\n\n/**\n * Parses a base64-encoded account provided by the RPC client into an {@link EncodedAccount} type or\n * a {@link MaybeEncodedAccount} type if the raw data can be set to `null`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * const myAddress = address('1234..5678');\n * const myRpcAccount = await rpc.getAccountInfo(myAddress, { encoding: 'base64' }).send();\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = parseBase64RpcAccount(myRpcAccount);\n * ```\n */\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase64Encoder().encode(rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype Base58EncodedRpcAccount = AccountInfoBase & (AccountInfoWithBase58Bytes | AccountInfoWithBase58EncodedData);\n\n/**\n * Parses a base58-encoded account provided by the RPC client into an {@link EncodedAccount} type or\n * a {@link MaybeEncodedAccount} type if the raw data can be set to `null`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * const myAddress = address('1234..5678');\n * const myRpcAccount = await rpc.getAccountInfo(myAddress, { encoding: 'base58' }).send();\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = parseBase58RpcAccount(myRpcAccount);\n * ```\n */\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase58Encoder().encode(typeof rpcAccount.data === 'string' ? rpcAccount.data : rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype JsonParsedRpcAccount = AccountInfoBase & { readonly data: JsonParsedDataResponse<unknown> };\n\n/**\n * Parses an arbitrary `jsonParsed` account provided by the RPC client into an {@link Account} type\n * or a {@link MaybeAccount} type if the raw data can be set to `null`.\n *\n * The expected data type should be explicitly provided as the first type parameter.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The expected type of this account's data.\n *\n * @example\n * ```ts\n * const myAccount: Account<MyData> = parseJsonRpcAccount<MyData>(myJsonRpcAccount);\n * ```\n */\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount,\n): Account<TData, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): MaybeAccount<TData, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = rpcAccount.data.parsed.info as TData;\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\nfunction parseBaseAccount(rpcAccount: AccountInfoBase): BaseAccount {\n    return Object.freeze({\n        executable: rpcAccount.executable,\n        lamports: rpcAccount.lamports,\n        programAddress: rpcAccount.owner,\n        space: rpcAccount.space,\n    });\n}\n","import { chainConfig } from '../../op-stack/chainConfig.js'\nimport { defineChain } from '../../utils/chain/defineChain.js'\n\nconst sourceId = 11_155_111 // sepolia\n\nexport const zoraSepolia = /*#__PURE__*/ defineChain({\n  ...chainConfig,\n  id: 999999999,\n  name: 'Zora Sepolia',\n  network: 'zora-sepolia',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'Zora Sepolia',\n    symbol: 'ETH',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://sepolia.rpc.zora.energy'],\n      webSocket: ['wss://sepolia.rpc.zora.energy'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Zora Sepolia Explorer',\n      url: 'https://sepolia.explorer.zora.energy/',\n      apiUrl: 'https://sepolia.explorer.zora.energy/api',\n    },\n  },\n  contracts: {\n    ...chainConfig.contracts,\n    l2OutputOracle: {\n      [sourceId]: {\n        address: '0x2615B481Bd3E5A1C0C7Ca3Da1bdc663E8615Ade9',\n      },\n    },\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 83160,\n    },\n    portal: {\n      [sourceId]: {\n        address: '0xeffE2C6cA9Ab797D418f0D91eA60807713f3536f',\n      },\n    },\n    l1StandardBridge: {\n      [sourceId]: {\n        address: '0x5376f1D543dcbB5BD416c56C189e4cB7399fCcCB',\n      },\n    },\n  },\n  sourceId,\n  testnet: true,\n})\n","import { chainConfig } from '../../op-stack/chainConfig.js'\nimport { defineChain } from '../../utils/chain/defineChain.js'\n\nconst sourceId = 1 // ethereum mainnet\n\nexport const zircuit = /*#__PURE__*/ defineChain({\n  ...chainConfig,\n  id: 48900,\n  name: 'Zircuit Mainnet',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'Ether',\n    symbol: 'ETH',\n  },\n  rpcUrls: {\n    default: {\n      http: [\n        'https://mainnet.zircuit.com',\n        'https://zircuit1-mainnet.liquify.com',\n        'https://zircuit1-mainnet.p2pify.com',\n        'https://zircuit-mainnet.drpc.org',\n      ],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Zircuit Explorer',\n      url: 'https://explorer.zircuit.com',\n    },\n  },\n  contracts: {\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n    },\n    l2OutputOracle: {\n      [sourceId]: {\n        address: '0x92Ef6Af472b39F1b363da45E35530c24619245A4',\n      },\n    },\n    portal: {\n      [sourceId]: {\n        address: '0x17bfAfA932d2e23Bd9B909Fd5B4D2e2a27043fb1',\n      },\n    },\n    l1StandardBridge: {\n      [sourceId]: {\n        address: '0x386B76D9cA5F5Fb150B6BFB35CF5379B22B26dd8',\n      },\n    },\n  },\n  testnet: false,\n})\n","import { chainConfig } from '../../op-stack/chainConfig.js'\nimport { defineChain } from '../../utils/chain/defineChain.js'\n\nconst sourceId = 11_155_111 // sepolia\n\nexport const rss3Sepolia = /*#__PURE__*/ defineChain({\n  ...chainConfig,\n  id: 2_331,\n  name: 'RSS3 VSL Sepolia Testnet',\n  nativeCurrency: { name: 'RSS3', symbol: 'RSS3', decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: ['https://rpc.testnet.rss3.io'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'RSS3 VSL Sepolia Testnet Scan',\n      url: 'https://scan.testnet.rss3.io',\n      apiUrl: 'https://scan.testnet.rss3.io/api',\n    },\n  },\n  contracts: {\n    ...chainConfig.contracts,\n    l2OutputOracle: {\n      [sourceId]: {\n        address: '0xDb5c46C3Eaa6Ed6aE8b2379785DF7dd029C0dC81',\n      },\n    },\n    multicall3: {\n      address: '0xca11bde05977b3631167028862be2a173976ca11',\n      blockCreated: 55697,\n    },\n    portal: {\n      [sourceId]: {\n        address: '0xcBD77E8E1E7F06B25baDe67142cdE82652Da7b57',\n        blockCreated: 5345035,\n      },\n    },\n    l1StandardBridge: {\n      [sourceId]: {\n        address: '0xdDD29bb63B0839FB1cE0eE439Ff027738595D07B',\n      },\n    },\n  },\n  testnet: true,\n  sourceId,\n})\n","import { chainConfig } from '../../op-stack/chainConfig.js'\nimport { defineChain } from '../../utils/chain/defineChain.js'\n\nconst sourceId = 1 // mainnet\n\nexport const rss3 = /*#__PURE__*/ defineChain({\n  ...chainConfig,\n  id: 12_553,\n  name: 'RSS3 VSL Mainnet',\n  nativeCurrency: { name: 'RSS3', symbol: 'RSS3', decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: ['https://rpc.rss3.io'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'RSS3 VSL Mainnet Scan',\n      url: 'https://scan.rss3.io',\n      apiUrl: 'https://scan.rss3.io/api',\n    },\n  },\n  contracts: {\n    ...chainConfig.contracts,\n    l2OutputOracle: {\n      [sourceId]: {\n        address: '0xE6f24d2C32B3109B18ed33cF08eFb490b1e09C10',\n      },\n    },\n    multicall3: {\n      address: '0xca11bde05977b3631167028862be2a173976ca11',\n      blockCreated: 14193,\n    },\n    portal: {\n      [sourceId]: {\n        address: '0x6A12432491bbbE8d3babf75F759766774C778Db4',\n        blockCreated: 19387057,\n      },\n    },\n    l1StandardBridge: {\n      [sourceId]: {\n        address: '0x4cbab69108Aa72151EDa5A3c164eA86845f18438',\n      },\n    },\n  },\n  sourceId,\n})\n","import { chainConfig } from '../../celo/chainConfig.js'\nimport { defineChain } from '../../utils/chain/defineChain.js'\n\nconst sourceId = 11_155_111 // sepolia\n// source https://storage.googleapis.com/cel2-rollup-files/celo-sepolia/deployment-l1.json\nexport const celoSepolia = /*#__PURE__*/ defineChain({\n  ...chainConfig,\n  id: 11_142_220,\n  name: 'Celo Sepolia Testnet',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'CELO',\n    symbol: 'S-CELO',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://forno.celo-sepolia.celo-testnet.org'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Celo Sepolia Explorer',\n      url: 'https://celo-sepolia.blockscout.com/',\n      apiUrl: 'https://celo-sepolia.blockscout.com/api',\n    },\n  },\n  contracts: {\n    ...chainConfig.contracts,\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 1,\n    },\n    portal: {\n      [sourceId]: {\n        address: '0x44ae3d41a335a7d05eb533029917aad35662dcc2',\n        blockCreated: 8825790,\n      },\n    },\n    disputeGameFactory: {\n      [sourceId]: {\n        address: '0x57c45d82d1a995f1e135b8d7edc0a6bb5211cfaa',\n        blockCreated: 8825790,\n      },\n    },\n    l1StandardBridge: {\n      [sourceId]: {\n        address: '0xec18a3c30131a0db4246e785355fbc16e2eaf408',\n        blockCreated: 8825790,\n      },\n    },\n  },\n  testnet: true,\n})\n","export type { Chain } from '../types/chain.js'\n// biome-ignore lint/performance/noBarrelFile: entrypoint module\nexport {\n  /** @deprecated Use `zeroGGalileoTestnet` instead. */\n  zeroG,\n} from './definitions/0g.js'\n/** @deprecated Use `zeroGTestnet` instead. */\nexport { zeroGGalileoTestnet } from './definitions/0gGalileoTestnet.js'\nexport { zeroGMainnet } from './definitions/0gMainnet.js'\nexport { zeroGTestnet } from './definitions/0gTestnet.js'\nexport { fireChain } from './definitions/5ireChain.js'\nexport { abey } from './definitions/abey.js'\nexport { abstract } from './definitions/abstract.js'\nexport { abstractTestnet } from './definitions/abstractTestnet.js'\nexport { acala } from './definitions/acala.js'\nexport { acria } from './definitions/acria.js'\nexport { adf } from './definitions/adf.js'\nexport { agungTestnet } from './definitions/agungTestnet.js'\nexport { aioz } from './definitions/aioz.js'\nexport { alephZero } from './definitions/alephZero.js'\nexport { alephZeroTestnet } from './definitions/alephZeroTestnet.js'\nexport { alienx } from './definitions/alienX.js'\nexport { alienxHalTestnet } from './definitions/alienXHalTestnet.js'\nexport { ancient8 } from './definitions/ancient8.js'\nexport { ancient8Sepolia } from './definitions/ancient8Sepolia.js'\nexport { anvil } from './definitions/anvil.js'\nexport { apeChain } from './definitions/apeChain.js'\nexport { apexTestnet } from './definitions/apexTestnet.js'\nexport { arbitrum } from './definitions/arbitrum.js'\nexport { arbitrumGoerli } from './definitions/arbitrumGoerli.js'\nexport { arbitrumNova } from './definitions/arbitrumNova.js'\nexport { arbitrumSepolia } from './definitions/arbitrumSepolia.js'\nexport { arcTestnet } from './definitions/arcTestnet.js'\nexport { arenaz } from './definitions/arenaz.js'\nexport { areonNetwork } from './definitions/areonNetwork.js'\nexport { areonNetworkTestnet } from './definitions/areonNetworkTestnet.js'\nexport { areum } from './definitions/areum.js'\nexport { artelaTestnet } from './definitions/artelaTestnet.js'\nexport { arthera } from './definitions/arthera.js'\nexport { artheraTestnet } from './definitions/artheraTestnet.js'\nexport { assetChain } from './definitions/assetChain.js'\nexport { assetChainTestnet } from './definitions/assetChainTestnet.js'\nexport { astar } from './definitions/astar.js'\n/** @deprecated */\nexport { astarZkEVM } from './definitions/astarZkEVM.js'\n/** @deprecated */\nexport { astarZkyoto } from './definitions/astarZkyoto.js'\nexport { atletaOlympia } from './definitions/atletaOlympia.js'\nexport { aurora } from './definitions/aurora.js'\nexport { auroraTestnet } from './definitions/auroraTestnet.js'\nexport { auroria } from './definitions/auroria.js'\nexport { autheoTestnet } from './definitions/autheoTestnet.js'\nexport { avalanche } from './definitions/avalanche.js'\nexport { avalancheFuji } from './definitions/avalancheFuji.js'\nexport { b3 } from './definitions/b3.js'\nexport { b3Sepolia } from './definitions/b3Sepolia.js'\nexport { bahamut } from './definitions/bahamut.js'\nexport { base, basePreconf } from './definitions/base.js'\nexport { basecampTestnet } from './definitions/basecampTestnet.js'\nexport { baseGoerli } from './definitions/baseGoerli.js'\nexport { baseSepolia, baseSepoliaPreconf } from './definitions/baseSepolia.js'\nexport { beam } from './definitions/beam.js'\nexport { beamTestnet } from './definitions/beamTestnet.js'\nexport { bearNetworkChainMainnet } from './definitions/bearNetworkChainMainnet.js'\nexport { bearNetworkChainTestnet } from './definitions/bearNetworkChainTestnet.js'\nexport { berachain } from './definitions/berachain.js'\nexport { berachainBepolia } from './definitions/berachainBepolia.js'\nexport { berachainTestnet } from './definitions/berachainTestnet.js'\nexport { berachainTestnetbArtio } from './definitions/berachainTestnetbArtio.js'\nexport { bevmMainnet } from './definitions/bevmMainnet.js'\nexport { bifrost } from './definitions/bifrost.js'\nexport { birdlayer } from './definitions/birdlayer.js'\nexport { bitgert } from './definitions/bitgert.js'\nexport { bitkub } from './definitions/bitkub.js'\nexport { bitkubTestnet } from './definitions/bitkubTestnet.js'\nexport { bitlayer } from './definitions/bitlayer.js'\nexport { bitlayerTestnet } from './definitions/bitlayerTestnet.js'\nexport { bitrock } from './definitions/bitrock.js'\nexport { bitTorrent } from './definitions/bitTorrent.js'\nexport { bitTorrentTestnet } from './definitions/bitTorrentTestnet.js'\nexport { blast } from './definitions/blast.js'\nexport { blastSepolia } from './definitions/blastSepolia.js'\nexport { bob } from './definitions/bob.js'\nexport { boba } from './definitions/boba.js'\nexport { bobaSepolia } from './definitions/bobaSepolia.js'\nexport { bobSepolia } from './definitions/bobSepolia.js'\nexport { boolBetaMainnet } from './definitions/boolBetaMainnet.js'\nexport { botanix } from './definitions/botanix.js'\nexport { botanixTestnet } from './definitions/botanixTestnet.js'\nexport { bounceBit } from './definitions/bounceBit.js'\nexport { bounceBitTestnet } from './definitions/bounceBitTestnet.js'\nexport { bronos } from './definitions/bronos.js'\nexport { bronosTestnet } from './definitions/bronosTestnet.js'\nexport { bsc } from './definitions/bsc.js'\nexport { bscGreenfield } from './definitions/bscGreenfield.js'\nexport { bscTestnet } from './definitions/bscTestnet.js'\nexport { bsquared } from './definitions/bsquared.js'\nexport { bsquaredTestnet } from './definitions/bsquaredTestnet.js'\nexport { btr } from './definitions/btr.js'\nexport { btrTestnet } from './definitions/btrTestnet.js'\nexport { bxn } from './definitions/bxn.js'\nexport { bxnTestnet } from './definitions/bxnTestnet.js'\nexport { cannon } from './definitions/cannon.js'\nexport { canto } from './definitions/canto.js'\nexport { celo } from './definitions/celo.js'\n/** @deprecated use `celoSepolia` instead */\nexport { celoAlfajores } from './definitions/celoAlfajores.js'\nexport { celoSepolia } from './definitions/celoSepolia.js'\nexport { chang } from './definitions/chang.js'\nexport { chiliz } from './definitions/chiliz.js'\nexport { chips } from './definitions/chips.js'\nexport { citreaTestnet } from './definitions/citreaTestnet.js'\nexport { classic } from './definitions/classic.js'\nexport { coinbit } from './definitions/coinbit.js'\nexport { coinex } from './definitions/coinex.js'\nexport { confluxESpace } from './definitions/confluxESpace.js'\nexport { confluxESpaceTestnet } from './definitions/confluxESpaceTestnet.js'\nexport { coreDao } from './definitions/coreDao.js'\nexport { coreTestnet1 } from './definitions/coreTestnet1.js'\nexport { coreTestnet2 } from './definitions/coreTestnet2.js'\nexport { corn } from './definitions/corn.js'\nexport { cornTestnet } from './definitions/cornTestnet.js'\nexport { crab } from './definitions/crab.js'\nexport { creatorTestnet } from './definitions/creatorTestnet.js'\nexport { creditCoin3Devnet } from './definitions/creditCoin3Devnet.js'\nexport { creditCoin3Mainnet } from './definitions/creditCoin3Mainnet.js'\nexport { creditCoin3Testnet } from './definitions/creditCoin3Testnet.js'\nexport { cronos } from './definitions/cronos.js'\nexport { cronosTestnet } from './definitions/cronosTestnet.js'\nexport { cronoszkEVM } from './definitions/cronoszkEVM.js'\nexport { cronoszkEVMTestnet } from './definitions/cronoszkEVMTestnet.js'\nexport { crossbell } from './definitions/crossbell.js'\nexport { crossfi } from './definitions/crossfi.js'\nexport { curtis } from './definitions/curtis.js'\nexport { cyber } from './definitions/cyber.js'\nexport { cyberTestnet } from './definitions/cyberTestnet.js'\nexport { dailyNetwork } from './definitions/dailyNetwork.js'\nexport { dailyNetworkTestnet } from './definitions/dailyNetworkTestnet.js'\nexport { darwinia } from './definitions/darwinia.js'\nexport { dbkchain } from './definitions/dbkchain.js'\nexport { dchain } from './definitions/dchain.js'\nexport { dchainTestnet } from './definitions/dchainTestnet.js'\nexport { defichainEvm } from './definitions/defichainEvm.js'\nexport { defichainEvmTestnet } from './definitions/defichainEvmTestnet.js'\nexport { degen } from './definitions/degen.js'\nexport { dfk } from './definitions/dfk.js'\nexport { diode } from './definitions/diode.js'\nexport { disChain } from './definitions/disChain.js'\nexport { dodochainTestnet } from './definitions/dodochainTestnet.js'\nexport { dogechain } from './definitions/dogechain.js'\nexport { domaTestnet } from './definitions/domaTestnet.js'\nexport { donatuz } from './definitions/donatuz.js'\nexport { dosChain } from './definitions/dosChain.js'\nexport { dosChainTestnet } from './definitions/dosChainTestnet.js'\nexport { dreyerxMainnet } from './definitions/dreyerxMainnet.js'\nexport { dreyerxTestnet } from './definitions/dreyerxTestnet.js'\nexport { dustboyIoT } from './definitions/dustboyIoT.js'\nexport { dymension } from './definitions/dymension.js'\nexport { edexa } from './definitions/edexa.js'\nexport { edexaTestnet } from './definitions/edexaTestnet.js'\nexport { edgeless } from './definitions/edgeless.js'\nexport { edgelessTestnet } from './definitions/edgelessTestnet.js'\nexport { edgeware } from './definitions/edgeware.js'\nexport { edgewareTestnet } from './definitions/edgewareTestnet.js'\nexport { eduChain } from './definitions/eduChain.js'\nexport { eduChainTestnet } from './definitions/eduChainTestnet.js'\nexport { ekta } from './definitions/ekta.js'\nexport { ektaTestnet } from './definitions/ektaTestnet.js'\nexport { elastos } from './definitions/elastos.js'\nexport { elastosTestnet } from './definitions/elastosTestnet.js'\nexport { electroneum } from './definitions/electroneum.js'\nexport { electroneumTestnet } from './definitions/electroneumTestnet.js'\nexport { elysiumTestnet } from './definitions/elysiumTestnet.js'\nexport { energy } from './definitions/energy.js'\nexport { eni } from './definitions/eni.js'\nexport { eniTestnet } from './definitions/eniTestnet.js'\nexport { enuls } from './definitions/enuls.js'\nexport { eon } from './definitions/eon.js'\nexport { eos } from './definitions/eos.js'\nexport { eosTestnet } from './definitions/eosTestnet.js'\nexport { eteria } from './definitions/eteria.js'\nexport { etherlink } from './definitions/etherlink.js'\nexport { etherlinkTestnet } from './definitions/etherlinkTestnet.js'\nexport { ethernity } from './definitions/ethernity.js'\nexport { etp } from './definitions/etp.js'\nexport { evmos } from './definitions/evmos.js'\nexport { evmosTestnet } from './definitions/evmosTestnet.js'\nexport { excelonMainnet } from './definitions/excelonMainnet.js'\nexport { expanse } from './definitions/expanse.js'\nexport { exsat } from './definitions/exSat.js'\nexport { exsatTestnet } from './definitions/exSatTestnet.js'\nexport { fantom } from './definitions/fantom.js'\n/** @deprecated Use `sonicTestnet` instead. */\nexport { fantomSonicTestnet } from './definitions/fantomSonicTestnet.js'\nexport { fantomTestnet } from './definitions/fantomTestnet.js'\nexport { fibo } from './definitions/fibo.js'\nexport { filecoin } from './definitions/filecoin.js'\nexport { filecoinCalibration } from './definitions/filecoinCalibration.js'\nexport { filecoinHyperspace } from './definitions/filecoinHyperspace.js'\nexport { flame } from './definitions/flame.js'\nexport { flare } from './definitions/flare.js'\nexport { flareTestnet } from './definitions/flareTestnet.js'\nexport { flowMainnet } from './definitions/flowMainnet.js'\n/** @deprecated */\nexport { flowPreviewnet } from './definitions/flowPreviewnet.js'\nexport { flowTestnet } from './definitions/flowTestnet.js'\nexport { fluence } from './definitions/fluence.js'\nexport { fluenceStage } from './definitions/fluenceStage.js'\nexport { fluenceTestnet } from './definitions/fluenceTestnet.js'\nexport { fluentTestnet } from './definitions/fluentTestnet.js'\nexport { form } from './definitions/form.js'\nexport { forma } from './definitions/forma.js'\nexport { formTestnet } from './definitions/formTestnet.js'\nexport { forta } from './definitions/forta.js'\n/** @deprecated Use `anvil` instead. */\nexport { foundry } from './definitions/foundry.js'\nexport { fraxtal } from './definitions/fraxtal.js'\nexport { fraxtalTestnet } from './definitions/fraxtalTestnet.js'\nexport { funkiMainnet } from './definitions/funkiMainnet.js'\nexport { funkiSepolia } from './definitions/funkiSepolia.js'\nexport { fuse } from './definitions/fuse.js'\nexport { fuseSparknet } from './definitions/fuseSparknet.js'\nexport { fusion } from './definitions/fusion.js'\nexport { fusionTestnet } from './definitions/fusionTestnet.js'\nexport { garnet } from './definitions/garnet.js'\nexport { gatechain } from './definitions/gatechain.js'\nexport { geist } from './definitions/geist.js'\nexport { genesys } from './definitions/genesys.js'\nexport { giwaSepolia } from './definitions/giwaSepolia.js'\nexport { glideL1Protocol } from './definitions/glideL1Protocol.js'\nexport { glideL2Protocol } from './definitions/glideL2Protocol.js'\nexport { gnosis } from './definitions/gnosis.js'\nexport { gnosisChiado } from './definitions/gnosisChiado.js'\nexport { goat } from './definitions/goat.js'\nexport { gobi } from './definitions/gobi.js'\nexport { goChain } from './definitions/goChain.js'\nexport { godwoken } from './definitions/godwoken.js'\nexport { goerli } from './definitions/goerli.js'\nexport { graphite } from './definitions/graphite.js'\nexport { graphiteTestnet } from './definitions/graphiteTestnet.js'\nexport { gravity } from './definitions/gravity.js'\nexport { gunz } from './definitions/gunz.js'\nexport { guruNetwork } from './definitions/guruNetwork.js'\nexport { guruTestnet } from './definitions/guruTestnet.js'\nexport { ham } from './definitions/ham.js'\nexport { happychainTestnet } from './definitions/happychainTestnet.js'\nexport { haqqMainnet } from './definitions/haqqMainnet.js'\nexport { haqqTestedge2 } from './definitions/haqqTestedge2.js'\nexport { hardhat } from './definitions/hardhat.js'\nexport { harmonyOne } from './definitions/harmonyOne.js'\nexport { hashkey } from './definitions/hashKeyChain.js'\nexport { hashkeyTestnet } from './definitions/hashkeyChainTestnet.js'\nexport { haustTestnet } from './definitions/haustTestnet.js'\nexport { hedera } from './definitions/hedera.js'\nexport { hederaPreviewnet } from './definitions/hederaPreviewnet.js'\nexport { hederaTestnet } from './definitions/hederaTestnet.js'\nexport { hela } from './definitions/hela.js'\nexport { hemi } from './definitions/hemi.js'\nexport { hemiSepolia } from './definitions/hemiSepolia.js'\nexport { holesky } from './definitions/holesky.js'\nexport { hoodi } from './definitions/hoodi.js'\nexport { hpb } from './definitions/hpb.js'\nexport { huddle01Mainnet } from './definitions/huddle01Mainnet.js'\nexport { huddle01Testnet } from './definitions/huddle01Testnet.js'\nexport { humanity } from './definitions/humanity.js'\nexport { humanityTestnet } from './definitions/humanityTestnet.js'\nexport { humanode } from './definitions/humanode.js'\nexport { humanodeTestnet5 } from './definitions/humanodeTestnet5.js'\nexport { hychain } from './definitions/hychain.js'\nexport { hychainTestnet } from './definitions/hychainTestnet.js'\nexport { hyperliquidEvmTestnet } from './definitions/hyperliquidEvmTestnet.js'\nexport { icbNetwork } from './definitions/icbNetwork.js'\nexport { idchain } from './definitions/idchain.js'\nexport { immutableZkEvm } from './definitions/immutableZkEvm.js'\nexport { immutableZkEvmTestnet } from './definitions/immutableZkEvmTestnet.js'\nexport { inEVM } from './definitions/inEVM.js'\nexport { initVerse } from './definitions/initVerse.js'\nexport { initVerseGenesis } from './definitions/initVerseGenesis.js'\nexport { injective } from './definitions/injective.js'\nexport { injectiveTestnet } from './definitions/injectiveTestnet.js'\nexport { ink } from './definitions/ink.js'\nexport { inkSepolia } from './definitions/inkSepolia.js'\nexport { iota } from './definitions/iota.js'\nexport { iotaTestnet } from './definitions/iotaTestnet.js'\nexport { iotex } from './definitions/iotex.js'\nexport { iotexTestnet } from './definitions/iotexTestnet.js'\nexport { iSunCoin } from './definitions/iSunCoin.js'\nexport { jbc } from './definitions/jbc.js'\nexport { jbcTestnet } from './definitions/jbcTestnet.js'\nexport { jocMainnet } from './definitions/jocMainnet.js'\nexport { jocTestnet } from './definitions/jocTestnet.js'\nexport { jovay } from './definitions/jovay.js'\nexport { jovaySepolia } from './definitions/jovaySepolia.js'\nexport { juneo } from './definitions/juneo.js'\nexport { juneoBCH1Chain } from './definitions/juneoBCH1Chain.js'\nexport { juneoDAI1Chain } from './definitions/juneoDAI1Chain.js'\nexport { juneoDOGE1Chain } from './definitions/juneoDOGE1Chain.js'\nexport { juneoEUR1Chain } from './definitions/juneoEUR1Chain.js'\nexport { juneoGLD1Chain } from './definitions/juneoGLD1Chain.js'\nexport { juneoLINK1Chain } from './definitions/juneoLINK1Chain.js'\nexport { juneoLTC1Chain } from './definitions/juneoLTC1Chain.js'\nexport { juneomBTC1Chain } from './definitions/juneomBTC1Chain.js'\nexport { juneoSGD1Chain } from './definitions/juneoSGD1Chain.js'\nexport { juneoSocotraTestnet } from './definitions/juneoSocotraTestnet.js'\nexport { juneoUSD1Chain } from './definitions/juneoUSD1Chain.js'\nexport { juneoUSDT1Chain } from './definitions/juneoUSDT1Chain.js'\nexport { kaia } from './definitions/kaia.js'\nexport { kairos } from './definitions/kairos.js'\n/** @deprecated Use `kakarotStarknetSepolia` instead. */\nexport { kakarotSepolia } from './definitions/kakarotSepolia.js'\nexport { kakarotStarknetSepolia } from './definitions/kakarotStarknetSepolia.js'\nexport { kardiaChain } from './definitions/kardiaChain.js'\nexport { karura } from './definitions/karura.js'\nexport { katana } from './definitions/katana.js'\nexport { kava } from './definitions/kava.js'\nexport { kavaTestnet } from './definitions/kavaTestnet.js'\nexport { kcc } from './definitions/kcc.js'\nexport { kiiTestnetOro } from './definitions/kiiTestnet.js'\nexport { kinto } from './definitions/kinto.js'\n/** @deprecated Use `kaia` instead. */\nexport { klaytn } from './definitions/klaytn.js'\n/** @deprecated Use `kairos` instead. */\nexport { klaytnBaobab } from './definitions/klaytnBaobab.js'\nexport { koi } from './definitions/koi.js'\nexport { kroma } from './definitions/kroma.js'\nexport { kromaSepolia } from './definitions/kromaSepolia.js'\nexport { l3x } from './definitions/l3x.js'\nexport { l3xTestnet } from './definitions/l3xTestnet.js'\nexport { lavita } from './definitions/lavita.js'\nexport { lens } from './definitions/lens.js'\nexport { lensTestnet } from './definitions/lensTestnet.js'\nexport { lestnet } from './definitions/lestnet.js'\nexport { lightlinkPegasus } from './definitions/lightlinkPegasus.js'\nexport { lightlinkPhoenix } from './definitions/lightlinkPhoenix.js'\nexport { linea } from './definitions/linea.js'\n/** @deprecated Use `lineaSepolia` instead. */\nexport { lineaGoerli } from './definitions/lineaGoerli.js'\nexport { lineaSepolia } from './definitions/lineaSepolia.js'\n/** @deprecated Use `lineaSepolia` instead. */\nexport { lineaTestnet } from './definitions/lineaTestnet.js'\nexport { lisk } from './definitions/lisk.js'\nexport { liskSepolia } from './definitions/liskSepolia.js'\nexport { loadAlphanet } from './definitions/loadAlphanet.js'\nexport { localhost } from './definitions/localhost.js'\nexport { loop } from './definitions/loop.js'\nexport { lukso } from './definitions/lukso.js'\nexport { luksoTestnet } from './definitions/luksoTestnet.js'\nexport { lumiaMainnet } from './definitions/lumiaMainnet.js'\nexport { lumiaTestnet } from './definitions/lumiaTestnet.js'\nexport { lumoz } from './definitions/lumoz.js'\nexport { lumozTestnet } from './definitions/lumozTestnet.js'\nexport { lycan } from './definitions/lycan.js'\nexport { lyra } from './definitions/lyra.js'\nexport { mainnet } from './definitions/mainnet.js'\nexport { mandala } from './definitions/mandala.js'\nexport { manta } from './definitions/manta.js'\nexport { mantaSepoliaTestnet } from './definitions/mantaSepoliaTestnet.js'\nexport { mantaTestnet } from './definitions/mantaTestnet.js'\nexport { mantle } from './definitions/mantle.js'\nexport { mantleSepoliaTestnet } from './definitions/mantleSepoliaTestnet.js'\nexport { mantleTestnet } from './definitions/mantleTestnet.js'\nexport { mantraDuKongEVMTestnet } from './definitions/mantraDuKongEVMTestnet.js'\nexport { mantraEVM } from './definitions/mantraEVM.js'\nexport { mapProtocol } from './definitions/mapProtocol.js'\nexport { matchain } from './definitions/matchain.js'\nexport { matchainTestnet } from './definitions/matchainTestnet.js'\nexport { mchVerse } from './definitions/mchVerse.js'\nexport { megaethTestnet } from './definitions/megaethTestnet.js'\nexport { mekong } from './definitions/mekong.js'\nexport { meld } from './definitions/meld.js'\nexport { memecore } from './definitions/memecore.js'\nexport { formicarium } from './definitions/memecoreFormicariumTestnet.js'\nexport { merlin } from './definitions/merlin.js'\nexport { merlinErigonTestnet } from './definitions/merlinErigonTestnet.js'\nexport { metachain } from './definitions/metachain.js'\nexport { metachainIstanbul } from './definitions/metachainIstanbul.js'\nexport { metadium } from './definitions/metadium.js'\nexport { metalL2 } from './definitions/metalL2.js'\nexport { meter } from './definitions/meter.js'\nexport { meterTestnet } from './definitions/meterTestnet.js'\nexport { metis } from './definitions/metis.js'\n/** @deprecated Use `metisSepolia` instead. */\nexport { metisGoerli } from './definitions/metisGoerli.js'\nexport { metisSepolia } from './definitions/metisSepolia.js'\nexport { mev } from './definitions/mev.js'\nexport { mevTestnet } from './definitions/mevTestnet.js'\nexport { mint } from './definitions/mint.js'\nexport { mintSepoliaTestnet } from './definitions/mintSepoliaTestnet.js'\nexport { mitosisTestnet } from './definitions/mitosisTestnet.js'\nexport { mode } from './definitions/mode.js'\nexport { modeTestnet } from './definitions/modeTestnet.js'\nexport { monadTestnet } from './definitions/monadTestnet.js'\nexport { moonbaseAlpha } from './definitions/moonbaseAlpha.js'\nexport { moonbeam } from './definitions/moonbeam.js'\nexport { moonbeamDev } from './definitions/moonbeamDev.js'\nexport { moonriver } from './definitions/moonriver.js'\nexport { morph } from './definitions/morph.js'\nexport { morphHolesky } from './definitions/morphHolesky.js'\nexport { morphSepolia } from './definitions/morphSepolia.js'\nexport { nahmii } from './definitions/nahmii.js'\nexport { nautilus } from './definitions/nautilus.js'\nexport { near } from './definitions/near.js'\nexport { nearTestnet } from './definitions/nearTestnet.js'\nexport { neonDevnet } from './definitions/neonDevnet.js'\nexport { neonMainnet } from './definitions/neonMainnet.js'\nexport { neoxMainnet } from './definitions/neoxMainnet.js'\nexport { neoxT4 } from './definitions/neoxT4.js'\nexport { newton } from './definitions/newton.js'\nexport { nexi } from './definitions/nexi.js'\nexport { nexilix } from './definitions/nexilix.js'\nexport { nibiru } from './definitions/nibiru.js'\nexport { nitrographTestnet } from './definitions/nitrographTestnet.js'\nexport { nomina } from './definitions/nomina.js'\nexport { oasisTestnet } from './definitions/oasisTestnet.js'\nexport { oasys } from './definitions/oasys.js'\nexport { odysseyTestnet } from './definitions/odysseyTestnet.js'\nexport { okc } from './definitions/okc.js'\nexport { omax } from './definitions/omax.js'\nexport { omni } from './definitions/omni.js'\nexport { omniOmega } from './definitions/omniOmega.js'\nexport { oneWorld } from './definitions/oneWorld.js'\nexport { oortMainnetDev } from './definitions/oortmainnetDev.js'\nexport { opBNB } from './definitions/opBNB.js'\nexport { opBNBTestnet } from './definitions/opBNBTestnet.js'\nexport { openledger } from './definitions/openledger.js'\nexport { optimism } from './definitions/optimism.js'\nexport { optimismGoerli } from './definitions/optimismGoerli.js'\nexport { optimismSepolia } from './definitions/optimismSepolia.js'\nexport { optopia } from './definitions/optopia.js'\nexport { optopiaTestnet } from './definitions/optopiaTestnet.js'\nexport { orderly } from './definitions/orderly.js'\nexport { orderlySepolia } from './definitions/orderlySepolia.js'\nexport { otimDevnet } from './definitions/otimDevnet.js'\nexport { palm } from './definitions/palm.js'\nexport { palmTestnet } from './definitions/palmTestnet.js'\nexport { peaq } from './definitions/peaq.js'\nexport { pgn } from './definitions/pgn.js'\nexport { pgnTestnet } from './definitions/pgnTestnet.js'\nexport { phoenix } from './definitions/phoenix.js'\nexport { planq } from './definitions/planq.js'\nexport { plasma } from './definitions/plasma.js'\nexport { plasmaDevnet } from './definitions/plasmaDevnet.js'\nexport { plasmaTestnet } from './definitions/plasmaTestnet.js'\nexport { playfiAlbireo } from './definitions/playfiAlbireo.js'\nexport { plinga } from './definitions/plinga.js'\n/** @deprecated Use `plumeMainnet` instead. */\nexport { plume } from './definitions/plume.js'\n/** @deprecated Use `plumeSepolia` instead. */\nexport { plumeDevnet } from './definitions/plumeDevnet.js'\nexport { plumeMainnet } from './definitions/plumeMainnet.js'\nexport { plumeSepolia } from './definitions/plumeSepolia.js'\n/** @deprecated Use `plumeSepolia` instead. */\nexport { plumeTestnet } from './definitions/plumeTestnet.js'\nexport { polterTestnet } from './definitions/polterTestnet.js'\nexport { polygon } from './definitions/polygon.js'\nexport { polygonAmoy } from './definitions/polygonAmoy.js'\nexport { polygonMumbai } from './definitions/polygonMumbai.js'\nexport { polygonZkEvm } from './definitions/polygonZkEvm.js'\nexport { polygonZkEvmCardona } from './definitions/polygonZkEvmCardona.js'\n/** @deprecated Use `polygonZkEvmCardona` instead. */\nexport { polygonZkEvmTestnet } from './definitions/polygonZkEvmTestnet.js'\nexport { polynomial } from './definitions/polynomial.js'\nexport { polynomialSepolia } from './definitions/polynomialSepolia.js'\nexport { premiumBlockTestnet } from './definitions/premiumBlock.js'\nexport { pulsechain } from './definitions/pulsechain.js'\nexport { pulsechainV4 } from './definitions/pulsechainV4.js'\nexport { pumpfiTestnet } from './definitions/pumpfiTestnet.js'\nexport { pyrope } from './definitions/pyrope.js'\nexport { ql1 } from './definitions/ql1.js'\nexport { qMainnet } from './definitions/qMainnet.js'\nexport { qTestnet } from './definitions/qTestnet.js'\nexport { quai } from './definitions/quai.js'\nexport { quaiTestnet } from './definitions/quaiTestnet.js'\nexport { real } from './definitions/real.js'\nexport { redbellyMainnet } from './definitions/redbellyMainnet.js'\nexport { redbellyTestnet } from './definitions/redbellyTestnet.js'\nexport { reddio } from './definitions/reddio.js'\nexport { reddioSepolia } from './definitions/reddioSepolia.js'\nexport { redstone } from './definitions/redstone.js'\nexport { rei } from './definitions/rei.js'\nexport { reyaNetwork } from './definitions/reyaNetwork.js'\nexport { riseTestnet } from './definitions/riseTestnet.js'\nexport { rivalz } from './definitions/rivalz.js'\nexport { rollux } from './definitions/rollux.js'\nexport { rolluxTestnet } from './definitions/rolluxTestnet.js'\nexport { ronin } from './definitions/ronin.js'\nexport { root } from './definitions/root.js'\nexport { rootPorcini } from './definitions/rootPorcini.js'\nexport { rootstock } from './definitions/rootstock.js'\nexport { rootstockTestnet } from './definitions/rootstockTestnet.js'\nexport { rss3 } from './definitions/rss3.js'\nexport { rss3Sepolia } from './definitions/rss3Sepolia.js'\nexport { saakuru } from './definitions/saakuru.js'\nexport { saga } from './definitions/saga.js'\nexport { saigon } from './definitions/saigon.js'\nexport { sanko } from './definitions/sanko.js'\nexport { sapphire } from './definitions/sapphire.js'\nexport { sapphireTestnet } from './definitions/sapphireTestnet.js'\nexport { satoshiVM } from './definitions/satoshivm.js'\nexport { satoshiVMTestnet } from './definitions/satoshivmTestnet.js'\nexport { scroll } from './definitions/scroll.js'\nexport { scrollSepolia } from './definitions/scrollSepolia.js'\nexport { sei } from './definitions/sei.js'\nexport { seiDevnet } from './definitions/seiDevnet.js'\nexport { seismicDevnet } from './definitions/seismicDevnet.js'\nexport { seiTestnet } from './definitions/seiTestnet.js'\nexport { sepolia } from './definitions/sepolia.js'\nexport { shape } from './definitions/shape.js'\nexport { shapeSepolia } from './definitions/shapeSepolia.js'\nexport { shardeum } from './definitions/shardeum.js'\nexport { shardeumSphinx } from './definitions/shardeumSphinx.js'\nexport { shibarium } from './definitions/shibarium.js'\nexport { shibariumTestnet } from './definitions/shibariumTestnet.js'\nexport { shiden } from './definitions/shiden.js'\nexport { shimmer } from './definitions/shimmer.js'\nexport { shimmerTestnet } from './definitions/shimmerTestnet.js'\nexport { sidraChain } from './definitions/sidra.js'\nexport { silicon } from './definitions/silicon.js'\nexport { siliconSepolia } from './definitions/siliconSepolia.js'\nexport { sixProtocol } from './definitions/sixProtocol.js'\nexport { skaleBlockBrawlers } from './definitions/skale/brawl.js'\nexport { skaleCalypso } from './definitions/skale/calypso.js'\nexport { skaleCalypsoTestnet } from './definitions/skale/calypsoTestnet.js'\nexport { skaleCryptoBlades } from './definitions/skale/cryptoBlades.js'\n/** @deprecated */\nexport { skaleCryptoColosseum } from './definitions/skale/cryptoColosseum.js'\nexport { skaleEuropa } from './definitions/skale/europa.js'\nexport { skaleEuropaTestnet } from './definitions/skale/europaTestnet.js'\nexport { skaleExorde } from './definitions/skale/exorde.js'\n/** @deprecated */\nexport { skaleHumanProtocol } from './definitions/skale/humanProtocol.js'\nexport { skaleNebula } from './definitions/skale/nebula.js'\nexport { skaleNebulaTestnet } from './definitions/skale/nebulaTestnet.js'\n/** @deprecated Use `skaleEuropa` instead.*/\nexport { skaleRazor } from './definitions/skale/razor.js'\nexport { skaleTitan } from './definitions/skale/titan.js'\nexport { skaleTitanTestnet } from './definitions/skale/titanTestnet.js'\nexport { sketchpad } from './definitions/sketchpad.js'\nexport { snax } from './definitions/snax.js'\nexport { snaxTestnet } from './definitions/snaxTestnet.js'\nexport { somniaTestnet } from './definitions/somniaTestnet.js'\nexport { soneium } from './definitions/soneium.js'\nexport { soneiumMinato } from './definitions/soneiumMinato.js'\nexport { songbird } from './definitions/songbird.js'\nexport { songbirdTestnet } from './definitions/songbirdTestnet.js'\nexport { sonic } from './definitions/sonic.js'\n/** @deprecated Use `sonicTestnet` instead. */\nexport { sonicBlazeTestnet } from './definitions/sonicBlazeTestnet.js'\nexport { sonicTestnet } from './definitions/sonicTestnet.js'\nexport { sophon } from './definitions/sophon.js'\nexport { sophonTestnet } from './definitions/sophonTestnet.js'\nexport { sova } from './definitions/sova.js'\nexport { sovaSepolia } from './definitions/sovaSepolia.js'\nexport { spicy } from './definitions/spicy.js'\nexport {\n  statusSepolia,\n  statusSepolia as statusNetworkSepolia,\n} from './definitions/statusNetworkSepolia.js'\nexport { step } from './definitions/step.js'\nexport { story } from './definitions/story.js'\nexport { storyAeneid } from './definitions/storyAeneid.js'\n/** @deprecated Use `storyAeneid` instead. */\nexport { storyOdyssey } from './definitions/storyOdyssey.js'\n/** @deprecated Use `storyAeneid` instead. */\nexport { storyTestnet } from './definitions/storyTestnet.js'\nexport { stratis } from './definitions/stratis.js'\nexport { superlumio } from './definitions/superlumio.js'\nexport { superposition } from './definitions/superposition.js'\nexport { superseed } from './definitions/superseed.js'\nexport { superseedSepolia } from './definitions/superseedSepolia.js'\nexport { surgeTestnet } from './definitions/surgeTestnet.js'\nexport { swan } from './definitions/swan.js'\nexport { swanProximaTestnet } from './definitions/swanProximaTestnet.js'\nexport { swanSaturnTestnet } from './definitions/swanSaturnTestnet.js'\nexport { swellchain } from './definitions/swellchain.js'\nexport { swellchainTestnet } from './definitions/swellchainTestnet.js'\nexport { swissdlt } from './definitions/swissdlt.js'\nexport { syscoin } from './definitions/syscoin.js'\nexport { syscoinTestnet } from './definitions/syscoinTestnet.js'\nexport { tac } from './definitions/tac.js'\nexport { tacSPB } from './definitions/tacSPB.js'\nexport { taiko } from './definitions/taiko.js'\nexport { taikoHekla } from './definitions/taikoHekla.js'\nexport { taikoJolnir } from './definitions/taikoJolnir.js'\nexport { taikoKatla } from './definitions/taikoKatla.js'\nexport { taikoTestnetSepolia } from './definitions/taikoTestnetSepolia.js'\nexport { taraxa } from './definitions/taraxa.js'\nexport { taraxaTestnet } from './definitions/taraxaTestnet.js'\nexport { teaSepolia } from './definitions/teaSepolia.js'\nexport { telcoinTestnet } from './definitions/telcoinTestnet.js'\nexport { telos } from './definitions/telos.js'\nexport { telosTestnet } from './definitions/telosTestnet.js'\nexport { tenet } from './definitions/tenet.js'\nexport { ternoa } from './definitions/ternoa.js'\nexport { thaiChain } from './definitions/thaiChain.js'\nexport { that } from './definitions/that.js'\nexport { theta } from './definitions/theta.js'\nexport { thetaTestnet } from './definitions/thetaTestnet.js'\nexport { thunderCore } from './definitions/thunderCore.js'\nexport { thunderTestnet } from './definitions/thunderTestnet.js'\nexport { tiktrixTestnet } from './definitions/tiktrixTestnet.js'\nexport { tomb } from './definitions/tomb.js'\nexport { treasure } from './definitions/treasure.js'\nexport { treasureTopaz } from './definitions/treasureTopaz.js'\nexport { tron } from './definitions/tron.js'\nexport { tronNile } from './definitions/tronNile.js'\nexport { tronShasta } from './definitions/tronShasta.js'\nexport { ubiq } from './definitions/ubiq.js'\nexport { ultra } from './definitions/ultra.js'\nexport { ultraTestnet } from './definitions/ultraTestnet.js'\nexport { ultron } from './definitions/ultron.js'\nexport { ultronTestnet } from './definitions/ultronTestnet.js'\nexport { unichain } from './definitions/unichain.js'\nexport { unichainSepolia } from './definitions/unichainSepolia.js'\nexport { unique } from './definitions/unique.js'\nexport { uniqueOpal } from './definitions/uniqueOpal.js'\nexport { uniqueQuartz } from './definitions/uniqueQuartz.js'\nexport { unreal } from './definitions/unreal.js'\nexport { vana } from './definitions/vana.js'\nexport { vanaMoksha } from './definitions/vanaMoksha.js'\nexport { vanar } from './definitions/vanar.js'\nexport { vechain } from './definitions/vechain.js'\nexport { velas } from './definitions/velas.js'\nexport { viction } from './definitions/viction.js'\nexport { victionTestnet } from './definitions/victionTestnet.js'\nexport { vision } from './definitions/vision.js'\nexport { visionTestnet } from './definitions/visionTestnet.js'\nexport { wanchain } from './definitions/wanchain.js'\nexport { wanchainTestnet } from './definitions/wanchainTestnet.js'\n/** @deprecated Use `loadAlphanet` instead. */\nexport { weaveVMAlphanet } from './definitions/weavevmAlphanet.js'\nexport { wemix } from './definitions/wemix.js'\nexport { wemixTestnet } from './definitions/wemixTestnet.js'\nexport { westendAssetHub } from './definitions/westendAssetHub.js'\nexport { whitechain } from './definitions/whitechain.js'\nexport { whitechainTestnet } from './definitions/whitechainTestnet.js'\nexport { wmcTestnet } from './definitions/wmcTestnet.js'\nexport { worldchain } from './definitions/worldchain.js'\nexport { worldchainSepolia } from './definitions/worldchainSepolia.js'\nexport { worldLand } from './definitions/worldLand.js'\nexport { xai } from './definitions/xai.js'\nexport { xaiTestnet } from './definitions/xaiTestnet.js'\nexport { xdc } from './definitions/xdc.js'\nexport { xdcTestnet } from './definitions/xdcTestnet.js'\nexport { xLayer } from './definitions/xLayer.js'\nexport {\n  /** @deprecated Use `xLayerTestnet` */\n  x1Testnet,\n  xLayerTestnet,\n} from './definitions/xLayerTestnet.js'\nexport { xphereMainnet } from './definitions/xphereMainnet.js'\nexport { xphereTestnet } from './definitions/xphereTestnet.js'\nexport { xrOne } from './definitions/xrOne.js'\nexport { xrplevmDevnet } from './definitions/xrplevmDevnet.js'\nexport { xrplevmTestnet } from './definitions/xrplevmTestnet.js'\nexport { xrSepolia } from './definitions/xrSepolia.js'\nexport { yooldoVerse } from './definitions/yooldoVerse.js'\nexport { yooldoVerseTestnet } from './definitions/yooldoVerseTestnet.js'\nexport { zenchainTestnet } from './definitions/zenchainTestnet.js'\nexport { zeniq } from './definitions/zeniq.js'\nexport { zeroNetwork } from './definitions/zeroNetwork.js'\nexport { zetachain } from './definitions/zetachain.js'\nexport { zetachainAthensTestnet } from './definitions/zetachainAthensTestnet.js'\nexport { zhejiang } from './definitions/zhejiang.js'\nexport { zilliqa } from './definitions/zilliqa.js'\nexport { zilliqaTestnet } from './definitions/zilliqaTestnet.js'\nexport { zircuit } from './definitions/zircuit.js'\nexport { zircuitGarfieldTestnet } from './definitions/zircuitGarfieldTestnet.js'\n/** @deprecated Use zircuitGarfieldTestnet instead */\nexport { zircuitTestnet } from './definitions/zircuitTestnet.js'\nexport { zkFair } from './definitions/zkFair.js'\nexport { zkFairTestnet } from './definitions/zkFairTestnet.js'\nexport { zkLinkNova } from './definitions/zkLinkNova.js'\nexport { zkLinkNovaSepoliaTestnet } from './definitions/zkLinkNovaSepoliaTestnet.js'\nexport {\n  /** @deprecated Use `zksync` instead */\n  zksync as zkSync,\n  zksync,\n} from './definitions/zksync.js'\nexport {\n  /** @deprecated Use `zksync` instead */\n  zksyncInMemoryNode as zkSyncInMemoryNode,\n  zksyncInMemoryNode,\n} from './definitions/zksyncInMemoryNode.js'\nexport { zksyncLocalCustomHyperchain } from './definitions/zksyncLocalCustomHyperchain.js'\nexport { zksyncLocalHyperchain } from './definitions/zksyncLocalHyperchain.js'\nexport { zksyncLocalHyperchainL1 } from './definitions/zksyncLocalHyperchainL1.js'\nexport {\n  /** @deprecated Use `zksync` instead */\n  zksyncLocalNode as zkSyncLocalNode,\n  zksyncLocalNode,\n} from './definitions/zksyncLocalNode.js'\nexport {\n  /** @deprecated Use `zksync` instead */\n  zksyncSepoliaTestnet as zkSyncSepoliaTestnet,\n  zksyncSepoliaTestnet,\n} from './definitions/zksyncSepoliaTestnet.js'\nexport { zora } from './definitions/zora.js'\nexport { zoraSepolia } from './definitions/zoraSepolia.js'\nexport { zoraTestnet } from './definitions/zoraTestnet.js'\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Required type exports to prevent TypeScript error \"TS2742\".\n\nexport type {\n  assertTransactionCIP42 as assertTransactionCIP42Celo,\n  assertTransactionCIP64 as assertTransactionCIP64Celo,\n  SerializeTransactionCIP64ReturnType,\n  serializers as serializersCelo,\n  serializeTransaction as serializeTransactionCelo,\n} from '../celo/serializers.js'\nexport type {\n  CeloBlock,\n  CeloRpcBlock,\n  CeloRpcTransaction,\n  CeloRpcTransactionRequest,\n  CeloTransaction,\n  CeloTransactionRequest,\n  CeloTransactionSerializable,\n  CeloTransactionSerialized,\n  CeloTransactionType,\n  RpcTransactionCIP42,\n  RpcTransactionCIP64,\n  RpcTransactionRequestCIP64,\n  TransactionCIP42,\n  TransactionCIP64,\n  TransactionRequestCIP64,\n  TransactionSerializableCIP42,\n  TransactionSerializableCIP64,\n  TransactionSerializedCIP42,\n  TransactionSerializedCIP64,\n} from '../celo/types.js'\nexport type {\n  assertTransactionDeposit as assertTransactionDepositOpStack,\n  SerializeTransactionDepositReturnType,\n  SerializeTransactionErrorType,\n  SerializeTransactionReturnType,\n  serializers as serializersOpStack,\n  serializeTransaction as serializeTransactionOpStack,\n} from '../op-stack/serializers.js'\nexport type {\n  OpStackBlock,\n  OpStackBlockOverrides,\n  OpStackRpcBlock,\n  OpStackRpcBlockOverrides,\n} from '../op-stack/types/block.js'\nexport type {\n  OpStackDepositTransaction,\n  OpStackRpcDepositTransaction,\n  OpStackRpcTransaction,\n  OpStackRpcTransactionReceipt,\n  OpStackRpcTransactionReceiptOverrides,\n  OpStackTransaction,\n  OpStackTransactionReceipt,\n  OpStackTransactionReceiptOverrides,\n  OpStackTransactionSerializable,\n  OpStackTransactionSerialized,\n  OpStackTransactionType,\n  TransactionSerializableDeposit,\n  TransactionSerializedDeposit,\n} from '../op-stack/types/transaction.js'\nexport type {\n  Assign,\n  Omit,\n  PartialBy,\n  Prettify,\n  UnionLooseOmit,\n} from '../types/utils.js'\nexport type {\n  /** @deprecated Use `ZksyncBlock` instead */\n  ZksyncBlock as ZkSyncBlock,\n  ZksyncBlock,\n  /** @deprecated Use `ZksyncRpcBlock` instead */\n  ZksyncRpcBlock as ZkSyncRpcBlock,\n  ZksyncRpcBlock,\n} from '../zksync/types/block.js'\nexport type { ChainEIP712 } from '../zksync/types/chain.js'\nexport type {\n  /** @deprecated Use `ZksyncEip712Meta` instead */\n  ZksyncEip712Meta as ZkSyncEip712Meta,\n  ZksyncEip712Meta,\n} from '../zksync/types/eip712.js'\nexport type {\n  /** @deprecated Use `ZksyncFeeValues` instead */\n  ZksyncFeeValues as ZkSyncFeeValues,\n  ZksyncFeeValues,\n} from '../zksync/types/fee.js'\nexport type {\n  /** @deprecated Use `ZksyncL2ToL1Log` instead */\n  ZksyncL2ToL1Log as ZkSyncL2ToL1Log,\n  ZksyncL2ToL1Log,\n  /** @deprecated Use `ZksyncLog` instead */\n  ZksyncLog as ZkSyncLog,\n  ZksyncLog,\n  /** @deprecated Use `ZksyncRpcL2ToL1Log` instead */\n  ZksyncRpcL2ToL1Log as ZkSyncRpcL2ToL1Log,\n  ZksyncRpcL2ToL1Log,\n  /** @deprecated Use `ZkSyncRpcLog` instead */\n  ZksyncRpcLog as ZkSyncRpcLog,\n  ZksyncRpcLog,\n} from '../zksync/types/log.js'\nexport type {\n  /** @deprecated Use `ZksyncTransactionRequest_internal` instead */\n  TransactionRequest as ZkSyncTransactionRequest_internal,\n  TransactionRequest as ZksyncTransactionRequest_internal,\n  TransactionRequestEIP712,\n  /** @deprecated Use `ZksyncEIP712TransactionSignable` instead */\n  ZksyncEIP712TransactionSignable as ZkSyncEIP712TransactionSignable,\n  ZksyncEIP712TransactionSignable,\n  /** @deprecated Use `ZksyncRawBlockTransactions` instead */\n  ZksyncRawBlockTransactions as ZkSyncRawBlockTransactions,\n  ZksyncRawBlockTransactions,\n  /** @deprecated Use `ZksyncRpcTransaction` instead */\n  ZksyncRpcTransaction as ZkSyncRpcTransaction,\n  ZksyncRpcTransaction,\n  /** @deprecated Use `ZksyncRpcTransactionEIP712` instead */\n  ZksyncRpcTransactionEIP712 as ZkSyncRpcTransactionEIP712,\n  ZksyncRpcTransactionEIP712,\n  /** @deprecated Use `ZksyncRpcTransactionPriority` instead */\n  ZksyncRpcTransactionPriority as ZkSyncRpcTransactionPriority,\n  ZksyncRpcTransactionPriority,\n  /** @deprecated Use `ZksyncRpcTransactionReceipt` instead */\n  ZksyncRpcTransactionReceipt as ZkSyncRpcTransactionReceipt,\n  ZksyncRpcTransactionReceipt,\n  /** @deprecated Use `ZksyncRpcTransactionReceiptOverrides` instead */\n  ZksyncRpcTransactionReceiptOverrides as ZkSyncRpcTransactionReceiptOverrides,\n  ZksyncRpcTransactionReceiptOverrides,\n  /** @deprecated Use `ZksyncRpcTransactionRequest` instead */\n  ZksyncRpcTransactionRequest as ZkSyncRpcTransactionRequest,\n  ZksyncRpcTransactionRequest,\n  /** @deprecated Use `ZksyncRpcTransactionRequestEIP712` instead */\n  ZksyncRpcTransactionRequestEIP712 as ZkSyncRpcTransactionRequestEIP712,\n  ZksyncRpcTransactionRequestEIP712,\n  /** @deprecated Use `ZksyncTransaction` instead */\n  ZksyncTransaction as ZkSyncTransaction,\n  ZksyncTransaction,\n  /** @deprecated Use `ZksyncTransactionDetails` instead */\n  ZksyncTransactionDetails as ZkSyncTransactionDetails,\n  ZksyncTransactionDetails,\n  /** @deprecated Use `ZksyncTransactionEIP712` instead */\n  ZksyncTransactionEIP712 as ZkSyncTransactionEIP712,\n  ZksyncTransactionEIP712,\n  /** @deprecated Use `ZksyncTransactionReceipt` instead */\n  ZksyncTransactionReceipt as ZkSyncTransactionReceipt,\n  ZksyncTransactionReceipt,\n  /** @deprecated Use `ZksyncTransactionReceiptOverrides` instead */\n  ZksyncTransactionReceiptOverrides as ZkSyncTransactionReceiptOverrides,\n  ZksyncTransactionReceiptOverrides,\n  /** @deprecated Use `ZksyncTransactionRequest` instead */\n  ZksyncTransactionRequest as ZkSyncTransactionRequest,\n  ZksyncTransactionRequest,\n  /** @deprecated Use `ZksyncTransactionRequestEIP712` instead */\n  ZksyncTransactionRequestEIP712 as ZkSyncTransactionRequestEIP712,\n  ZksyncTransactionRequestEIP712,\n  /** @deprecated Use `ZksyncTransactionSerializable` instead */\n  ZksyncTransactionSerializable as ZkSyncTransactionSerializable,\n  ZksyncTransactionSerializable,\n  /** @deprecated Use `ZksyncTransactionSerializableEIP712` instead */\n  ZksyncTransactionSerializableEIP712 as ZkSyncTransactionSerializableEIP712,\n  ZksyncTransactionSerializableEIP712,\n  /** @deprecated Use `ZksyncTransactionSerialized` instead */\n  ZksyncTransactionSerialized as ZkSyncTransactionSerialized,\n  ZksyncTransactionSerialized,\n  /** @deprecated Use `ZksyncTransactionSerializedEIP712` instead */\n  ZksyncTransactionSerializedEIP712 as ZkSyncTransactionSerializedEIP712,\n  ZksyncTransactionSerializedEIP712,\n  /** @deprecated Use `ZksyncTransactionType` instead */\n  ZksyncTransactionType as ZkSyncTransactionType,\n  ZksyncTransactionType,\n} from '../zksync/types/transaction.js'\n","import type { Address, Narrow } from 'abitype'\nimport { parseAccount } from '../../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../../errors/account.js'\nimport type { BaseError } from '../../../errors/base.js'\nimport type { ErrorType } from '../../../errors/utils.js'\nimport type { Calls } from '../../../types/calls.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { Hex } from '../../../types/misc.js'\nimport type { Assign, MaybeRequired, OneOf } from '../../../types/utils.js'\nimport type { RequestErrorType } from '../../../utils/buildRequest.js'\nimport { getAction } from '../../../utils/getAction.js'\nimport type { SmartAccount } from '../../accounts/types.js'\nimport type { PaymasterActions } from '../../clients/decorators/paymaster.js'\nimport type {\n  DeriveSmartAccount,\n  GetSmartAccountParameter,\n} from '../../types/account.js'\nimport type {\n  DeriveEntryPointVersion,\n  EntryPointVersion,\n} from '../../types/entryPointVersion.js'\nimport type {\n  UserOperation,\n  UserOperationRequest,\n} from '../../types/userOperation.js'\nimport { getUserOperationError } from '../../utils/errors/getUserOperationError.js'\nimport {\n  type FormatUserOperationRequestErrorType,\n  formatUserOperationRequest,\n} from '../../utils/formatters/userOperationRequest.js'\nimport {\n  type PrepareUserOperationErrorType,\n  type PrepareUserOperationParameters,\n  prepareUserOperation,\n} from './prepareUserOperation.js'\n\nexport type SendUserOperationParameters<\n  account extends SmartAccount | undefined = SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n  calls extends readonly unknown[] = readonly unknown[],\n  //\n  _derivedAccount extends SmartAccount | undefined = DeriveSmartAccount<\n    account,\n    accountOverride\n  >,\n  _derivedVersion extends\n    EntryPointVersion = DeriveEntryPointVersion<_derivedAccount>,\n> = GetSmartAccountParameter<account, accountOverride, false> &\n  (\n    | UserOperation // Accept a full-formed User Operation.\n    | Assign<\n        // Accept a partially-formed User Operation (UserOperationRequest) to be filled.\n        UserOperationRequest<_derivedVersion>,\n        OneOf<{ calls: Calls<Narrow<calls>> } | { callData: Hex }> & {\n          paymaster?:\n            | Address\n            | true\n            | {\n                /** Retrieves paymaster-related User Operation properties to be used for sending the User Operation. */\n                getPaymasterData?:\n                  | PaymasterActions['getPaymasterData']\n                  | undefined\n                /** Retrieves paymaster-related User Operation properties to be used for gas estimation. */\n                getPaymasterStubData?:\n                  | PaymasterActions['getPaymasterStubData']\n                  | undefined\n              }\n            | undefined\n          /** Paymaster context to pass to `getPaymasterData` and `getPaymasterStubData` calls. */\n          paymasterContext?: unknown | undefined\n        }\n      >\n  ) &\n  // Allow the EntryPoint address to be overridden, if no Account is provided, it will need to be required.\n  MaybeRequired<\n    { entryPointAddress?: Address },\n    _derivedAccount extends undefined ? true : false\n  >\nexport type SendUserOperationReturnType = Hex\n\nexport type SendUserOperationErrorType =\n  | FormatUserOperationRequestErrorType\n  | PrepareUserOperationErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Broadcasts a User Operation to the Bundler.\n *\n * - Docs: https://viem.sh/actions/bundler/sendUserOperation\n *\n * @param client - Client to use\n * @param parameters - {@link SendUserOperationParameters}\n * @returns The User Operation hash. {@link SendUserOperationReturnType}\n *\n * @example\n * import { createBundlerClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { toSmartAccount } from 'viem/accounts'\n * import { sendUserOperation } from 'viem/actions'\n *\n * const account = await toSmartAccount({ ... })\n *\n * const bundlerClient = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const values = await sendUserOperation(bundlerClient, {\n *   account,\n *   calls: [{ to: '0x...', value: parseEther('1') }],\n * })\n */\nexport async function sendUserOperation<\n  const calls extends readonly unknown[],\n  account extends SmartAccount | undefined,\n  accountOverride extends SmartAccount | undefined = undefined,\n>(\n  client: Client<Transport, Chain | undefined, account>,\n  parameters: SendUserOperationParameters<account, accountOverride, calls>,\n) {\n  const { account: account_ = client.account, entryPointAddress } = parameters\n\n  if (!account_ && !parameters.sender) throw new AccountNotFoundError()\n  const account = account_ ? parseAccount(account_) : undefined\n\n  const request = account\n    ? await getAction(\n        client,\n        prepareUserOperation,\n        'prepareUserOperation',\n      )(parameters as unknown as PrepareUserOperationParameters)\n    : parameters\n\n  const signature = (parameters.signature ||\n    (await account?.signUserOperation?.(request as UserOperation)))!\n\n  const rpcParameters = formatUserOperationRequest({\n    ...request,\n    signature,\n  } as UserOperation)\n\n  try {\n    return await client.request(\n      {\n        method: 'eth_sendUserOperation',\n        params: [\n          rpcParameters,\n          (entryPointAddress ?? account?.entryPoint?.address)!,\n        ],\n      },\n      { retryCount: 0 },\n    )\n  } catch (error) {\n    const calls = (parameters as any).calls\n    throw getUserOperationError(error as BaseError, {\n      ...(request as UserOperation),\n      ...(calls ? { calls } : {}),\n      signature,\n    })\n  }\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/payment/getPaymentStatus.ts","/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { type Input, Hash, abytes, aexists, aoutput, clean, createView, toBytes } from './utils.ts';\n\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n\n  readonly blockLen: number;\n  readonly outputLen: number;\n  readonly padOffset: number;\n  readonly isLE: boolean;\n\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(blockLen: number, outputLen: number, padOffset: number, isLE: boolean) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const { view, buffer, blockLen } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    clean(this.buffer.subarray(pos));\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n  0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n  0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n","export const entryPoint06Abi = [\n  {\n    inputs: [\n      { name: 'preOpGas', type: 'uint256' },\n      { name: 'paid', type: 'uint256' },\n      { name: 'validAfter', type: 'uint48' },\n      { name: 'validUntil', type: 'uint48' },\n      { name: 'targetSuccess', type: 'bool' },\n      { name: 'targetResult', type: 'bytes' },\n    ],\n    name: 'ExecutionResult',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { name: 'opIndex', type: 'uint256' },\n      { name: 'reason', type: 'string' },\n    ],\n    name: 'FailedOp',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'sender', type: 'address' }],\n    name: 'SenderAddressResult',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'aggregator', type: 'address' }],\n    name: 'SignatureValidationFailed',\n    type: 'error',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'preOpGas', type: 'uint256' },\n          { name: 'prefund', type: 'uint256' },\n          { name: 'sigFailed', type: 'bool' },\n          { name: 'validAfter', type: 'uint48' },\n          { name: 'validUntil', type: 'uint48' },\n          { name: 'paymasterContext', type: 'bytes' },\n        ],\n\n        name: 'returnInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'senderInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'factoryInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'paymasterInfo',\n        type: 'tuple',\n      },\n    ],\n    name: 'ValidationResult',\n    type: 'error',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'preOpGas', type: 'uint256' },\n          { name: 'prefund', type: 'uint256' },\n          { name: 'sigFailed', type: 'bool' },\n          { name: 'validAfter', type: 'uint48' },\n          { name: 'validUntil', type: 'uint48' },\n          { name: 'paymasterContext', type: 'bytes' },\n        ],\n\n        name: 'returnInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'senderInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'factoryInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'stake', type: 'uint256' },\n          { name: 'unstakeDelaySec', type: 'uint256' },\n        ],\n\n        name: 'paymasterInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          { name: 'aggregator', type: 'address' },\n          {\n            components: [\n              { name: 'stake', type: 'uint256' },\n              {\n                name: 'unstakeDelaySec',\n                type: 'uint256',\n              },\n            ],\n\n            name: 'stakeInfo',\n            type: 'tuple',\n          },\n        ],\n\n        name: 'aggregatorInfo',\n        type: 'tuple',\n      },\n    ],\n    name: 'ValidationResultWithAggregation',\n    type: 'error',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'factory',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'paymaster',\n        type: 'address',\n      },\n    ],\n    name: 'AccountDeployed',\n    type: 'event',\n  },\n  { anonymous: false, inputs: [], name: 'BeforeExecution', type: 'event' },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'totalDeposit',\n        type: 'uint256',\n      },\n    ],\n    name: 'Deposited',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'aggregator',\n        type: 'address',\n      },\n    ],\n    name: 'SignatureAggregatorChanged',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'totalStaked',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'unstakeDelaySec',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeLocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawTime',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeUnlocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeWithdrawn',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: true,\n\n        name: 'paymaster',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      { indexed: false, name: 'success', type: 'bool' },\n      {\n        indexed: false,\n\n        name: 'actualGasCost',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'actualGasUsed',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationEvent',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'UserOperationRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'Withdrawn',\n    type: 'event',\n  },\n  {\n    inputs: [],\n    name: 'SIG_VALIDATION_FAILED',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'initCode', type: 'bytes' },\n      { name: 'sender', type: 'address' },\n      { name: 'paymasterAndData', type: 'bytes' },\n    ],\n    name: '_validateSenderAndPaymaster',\n    outputs: [],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'unstakeDelaySec', type: 'uint32' }],\n    name: 'addStake',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'balanceOf',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'depositTo',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: '', type: 'address' }],\n    name: 'deposits',\n    outputs: [\n      { name: 'deposit', type: 'uint112' },\n      { name: 'staked', type: 'bool' },\n      { name: 'stake', type: 'uint112' },\n      { name: 'unstakeDelaySec', type: 'uint32' },\n      { name: 'withdrawTime', type: 'uint48' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'getDepositInfo',\n    outputs: [\n      {\n        components: [\n          { name: 'deposit', type: 'uint112' },\n          { name: 'staked', type: 'bool' },\n          { name: 'stake', type: 'uint112' },\n          { name: 'unstakeDelaySec', type: 'uint32' },\n          { name: 'withdrawTime', type: 'uint48' },\n        ],\n\n        name: 'info',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'sender', type: 'address' },\n      { name: 'key', type: 'uint192' },\n    ],\n    name: 'getNonce',\n    outputs: [{ name: 'nonce', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'initCode', type: 'bytes' }],\n    name: 'getSenderAddress',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          { name: 'callGasLimit', type: 'uint256' },\n          {\n            name: 'verificationGasLimit',\n            type: 'uint256',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'maxFeePerGas', type: 'uint256' },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'userOp',\n        type: 'tuple',\n      },\n    ],\n    name: 'getUserOpHash',\n    outputs: [{ name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            components: [\n              { name: 'sender', type: 'address' },\n              { name: 'nonce', type: 'uint256' },\n              { name: 'initCode', type: 'bytes' },\n              { name: 'callData', type: 'bytes' },\n              {\n                name: 'callGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'verificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              {\n                name: 'maxFeePerGas',\n                type: 'uint256',\n              },\n              {\n                name: 'maxPriorityFeePerGas',\n                type: 'uint256',\n              },\n              {\n                name: 'paymasterAndData',\n                type: 'bytes',\n              },\n              { name: 'signature', type: 'bytes' },\n            ],\n\n            name: 'userOps',\n            type: 'tuple[]',\n          },\n          {\n            name: 'aggregator',\n            type: 'address',\n          },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'opsPerAggregator',\n        type: 'tuple[]',\n      },\n      { name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleAggregatedOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          { name: 'callGasLimit', type: 'uint256' },\n          {\n            name: 'verificationGasLimit',\n            type: 'uint256',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'maxFeePerGas', type: 'uint256' },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'ops',\n        type: 'tuple[]',\n      },\n      { name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'key', type: 'uint192' }],\n    name: 'incrementNonce',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'callData', type: 'bytes' },\n      {\n        components: [\n          {\n            components: [\n              { name: 'sender', type: 'address' },\n              { name: 'nonce', type: 'uint256' },\n              {\n                name: 'callGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'verificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { name: 'paymaster', type: 'address' },\n              {\n                name: 'maxFeePerGas',\n                type: 'uint256',\n              },\n              {\n                name: 'maxPriorityFeePerGas',\n                type: 'uint256',\n              },\n            ],\n\n            name: 'mUserOp',\n            type: 'tuple',\n          },\n          { name: 'userOpHash', type: 'bytes32' },\n          { name: 'prefund', type: 'uint256' },\n          { name: 'contextOffset', type: 'uint256' },\n          { name: 'preOpGas', type: 'uint256' },\n        ],\n\n        name: 'opInfo',\n        type: 'tuple',\n      },\n      { name: 'context', type: 'bytes' },\n    ],\n    name: 'innerHandleOp',\n    outputs: [{ name: 'actualGasCost', type: 'uint256' }],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: '', type: 'address' },\n      { name: '', type: 'uint192' },\n    ],\n    name: 'nonceSequenceNumber',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          { name: 'callGasLimit', type: 'uint256' },\n          {\n            name: 'verificationGasLimit',\n            type: 'uint256',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'maxFeePerGas', type: 'uint256' },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'op',\n        type: 'tuple',\n      },\n      { name: 'target', type: 'address' },\n      { name: 'targetCallData', type: 'bytes' },\n    ],\n    name: 'simulateHandleOp',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          { name: 'callGasLimit', type: 'uint256' },\n          {\n            name: 'verificationGasLimit',\n            type: 'uint256',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'maxFeePerGas', type: 'uint256' },\n          {\n            name: 'maxPriorityFeePerGas',\n            type: 'uint256',\n          },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'userOp',\n        type: 'tuple',\n      },\n    ],\n    name: 'simulateValidation',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'unlockStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n    ],\n    name: 'withdrawStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      { name: 'withdrawAmount', type: 'uint256' },\n    ],\n    name: 'withdrawTo',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  { stateMutability: 'payable', type: 'receive' },\n] as const\n\nexport const entryPoint07Abi = [\n  {\n    inputs: [\n      { name: 'success', type: 'bool' },\n      { name: 'ret', type: 'bytes' },\n    ],\n    name: 'DelegateAndRevert',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { name: 'opIndex', type: 'uint256' },\n      { name: 'reason', type: 'string' },\n    ],\n    name: 'FailedOp',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { name: 'opIndex', type: 'uint256' },\n      { name: 'reason', type: 'string' },\n      { name: 'inner', type: 'bytes' },\n    ],\n    name: 'FailedOpWithRevert',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'returnData', type: 'bytes' }],\n    name: 'PostOpReverted',\n    type: 'error',\n  },\n  { inputs: [], name: 'ReentrancyGuardReentrantCall', type: 'error' },\n  {\n    inputs: [{ name: 'sender', type: 'address' }],\n    name: 'SenderAddressResult',\n    type: 'error',\n  },\n  {\n    inputs: [{ name: 'aggregator', type: 'address' }],\n    name: 'SignatureValidationFailed',\n    type: 'error',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'factory',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'paymaster',\n        type: 'address',\n      },\n    ],\n    name: 'AccountDeployed',\n    type: 'event',\n  },\n  { anonymous: false, inputs: [], name: 'BeforeExecution', type: 'event' },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'totalDeposit',\n        type: 'uint256',\n      },\n    ],\n    name: 'Deposited',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'PostOpRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'aggregator',\n        type: 'address',\n      },\n    ],\n    name: 'SignatureAggregatorChanged',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'totalStaked',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'unstakeDelaySec',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeLocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawTime',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeUnlocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeWithdrawn',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: true,\n\n        name: 'paymaster',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      { indexed: false, name: 'success', type: 'bool' },\n      {\n        indexed: false,\n\n        name: 'actualGasCost',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'actualGasUsed',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationEvent',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationPrefundTooLow',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'UserOperationRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'Withdrawn',\n    type: 'event',\n  },\n  {\n    inputs: [{ name: 'unstakeDelaySec', type: 'uint32' }],\n    name: 'addStake',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'balanceOf',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'target', type: 'address' },\n      { name: 'data', type: 'bytes' },\n    ],\n    name: 'delegateAndRevert',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'depositTo',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: '', type: 'address' }],\n    name: 'deposits',\n    outputs: [\n      { name: 'deposit', type: 'uint256' },\n      { name: 'staked', type: 'bool' },\n      { name: 'stake', type: 'uint112' },\n      { name: 'unstakeDelaySec', type: 'uint32' },\n      { name: 'withdrawTime', type: 'uint48' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'account', type: 'address' }],\n    name: 'getDepositInfo',\n    outputs: [\n      {\n        components: [\n          { name: 'deposit', type: 'uint256' },\n          { name: 'staked', type: 'bool' },\n          { name: 'stake', type: 'uint112' },\n          { name: 'unstakeDelaySec', type: 'uint32' },\n          { name: 'withdrawTime', type: 'uint48' },\n        ],\n\n        name: 'info',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'sender', type: 'address' },\n      { name: 'key', type: 'uint192' },\n    ],\n    name: 'getNonce',\n    outputs: [{ name: 'nonce', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'initCode', type: 'bytes' }],\n    name: 'getSenderAddress',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          {\n            name: 'accountGasLimits',\n            type: 'bytes32',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'gasFees', type: 'bytes32' },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'userOp',\n        type: 'tuple',\n      },\n    ],\n    name: 'getUserOpHash',\n    outputs: [{ name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            components: [\n              { name: 'sender', type: 'address' },\n              { name: 'nonce', type: 'uint256' },\n              { name: 'initCode', type: 'bytes' },\n              { name: 'callData', type: 'bytes' },\n              {\n                name: 'accountGasLimits',\n                type: 'bytes32',\n              },\n              {\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { name: 'gasFees', type: 'bytes32' },\n              {\n                name: 'paymasterAndData',\n                type: 'bytes',\n              },\n              { name: 'signature', type: 'bytes' },\n            ],\n\n            name: 'userOps',\n            type: 'tuple[]',\n          },\n          {\n            name: 'aggregator',\n            type: 'address',\n          },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'opsPerAggregator',\n        type: 'tuple[]',\n      },\n      { name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleAggregatedOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { name: 'sender', type: 'address' },\n          { name: 'nonce', type: 'uint256' },\n          { name: 'initCode', type: 'bytes' },\n          { name: 'callData', type: 'bytes' },\n          {\n            name: 'accountGasLimits',\n            type: 'bytes32',\n          },\n          {\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { name: 'gasFees', type: 'bytes32' },\n          { name: 'paymasterAndData', type: 'bytes' },\n          { name: 'signature', type: 'bytes' },\n        ],\n\n        name: 'ops',\n        type: 'tuple[]',\n      },\n      { name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'key', type: 'uint192' }],\n    name: 'incrementNonce',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: 'callData', type: 'bytes' },\n      {\n        components: [\n          {\n            components: [\n              { name: 'sender', type: 'address' },\n              { name: 'nonce', type: 'uint256' },\n              {\n                name: 'verificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'callGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'paymasterVerificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'paymasterPostOpGasLimit',\n                type: 'uint256',\n              },\n              {\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { name: 'paymaster', type: 'address' },\n              {\n                name: 'maxFeePerGas',\n                type: 'uint256',\n              },\n              {\n                name: 'maxPriorityFeePerGas',\n                type: 'uint256',\n              },\n            ],\n\n            name: 'mUserOp',\n            type: 'tuple',\n          },\n          { name: 'userOpHash', type: 'bytes32' },\n          { name: 'prefund', type: 'uint256' },\n          { name: 'contextOffset', type: 'uint256' },\n          { name: 'preOpGas', type: 'uint256' },\n        ],\n\n        name: 'opInfo',\n        type: 'tuple',\n      },\n      { name: 'context', type: 'bytes' },\n    ],\n    name: 'innerHandleOp',\n    outputs: [{ name: 'actualGasCost', type: 'uint256' }],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { name: '', type: 'address' },\n      { name: '', type: 'uint192' },\n    ],\n    name: 'nonceSequenceNumber',\n    outputs: [{ name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ name: 'interfaceId', type: 'bytes4' }],\n    name: 'supportsInterface',\n    outputs: [{ name: '', type: 'bool' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'unlockStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n    ],\n    name: 'withdrawStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      { name: 'withdrawAmount', type: 'uint256' },\n    ],\n    name: 'withdrawTo',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  { stateMutability: 'payable', type: 'receive' },\n] as const\n\nexport const entryPoint08Abi = [\n  { inputs: [], stateMutability: 'nonpayable', type: 'constructor' },\n  {\n    inputs: [\n      { internalType: 'bool', name: 'success', type: 'bool' },\n      { internalType: 'bytes', name: 'ret', type: 'bytes' },\n    ],\n    name: 'DelegateAndRevert',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { internalType: 'uint256', name: 'opIndex', type: 'uint256' },\n      { internalType: 'string', name: 'reason', type: 'string' },\n    ],\n    name: 'FailedOp',\n    type: 'error',\n  },\n  {\n    inputs: [\n      { internalType: 'uint256', name: 'opIndex', type: 'uint256' },\n      { internalType: 'string', name: 'reason', type: 'string' },\n      { internalType: 'bytes', name: 'inner', type: 'bytes' },\n    ],\n    name: 'FailedOpWithRevert',\n    type: 'error',\n  },\n  { inputs: [], name: 'InvalidShortString', type: 'error' },\n  {\n    inputs: [{ internalType: 'bytes', name: 'returnData', type: 'bytes' }],\n    name: 'PostOpReverted',\n    type: 'error',\n  },\n  { inputs: [], name: 'ReentrancyGuardReentrantCall', type: 'error' },\n  {\n    inputs: [{ internalType: 'address', name: 'sender', type: 'address' }],\n    name: 'SenderAddressResult',\n    type: 'error',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'aggregator', type: 'address' }],\n    name: 'SignatureValidationFailed',\n    type: 'error',\n  },\n  {\n    inputs: [{ internalType: 'string', name: 'str', type: 'string' }],\n    name: 'StringTooLong',\n    type: 'error',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'factory',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'paymaster',\n        type: 'address',\n      },\n    ],\n    name: 'AccountDeployed',\n    type: 'event',\n  },\n  { anonymous: false, inputs: [], name: 'BeforeExecution', type: 'event' },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'totalDeposit',\n        type: 'uint256',\n      },\n    ],\n    name: 'Deposited',\n    type: 'event',\n  },\n  { anonymous: false, inputs: [], name: 'EIP712DomainChanged', type: 'event' },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'bytes',\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'PostOpRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'aggregator',\n        type: 'address',\n      },\n    ],\n    name: 'SignatureAggregatorChanged',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'totalStaked',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'unstakeDelaySec',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeLocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'withdrawTime',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeUnlocked',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'StakeWithdrawn',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'paymaster',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'nonce',\n        type: 'uint256',\n      },\n      { indexed: false, internalType: 'bool', name: 'success', type: 'bool' },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'actualGasCost',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'actualGasUsed',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationEvent',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'nonce',\n        type: 'uint256',\n      },\n    ],\n    name: 'UserOperationPrefundTooLow',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'userOpHash',\n        type: 'bytes32',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'sender',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'nonce',\n        type: 'uint256',\n      },\n      {\n        indexed: false,\n        internalType: 'bytes',\n        name: 'revertReason',\n        type: 'bytes',\n      },\n    ],\n    name: 'UserOperationRevertReason',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'account',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: 'amount',\n        type: 'uint256',\n      },\n    ],\n    name: 'Withdrawn',\n    type: 'event',\n  },\n  {\n    inputs: [\n      { internalType: 'uint32', name: 'unstakeDelaySec', type: 'uint32' },\n    ],\n    name: 'addStake',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'account', type: 'address' }],\n    name: 'balanceOf',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: 'target', type: 'address' },\n      { internalType: 'bytes', name: 'data', type: 'bytes' },\n    ],\n    name: 'delegateAndRevert',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'account', type: 'address' }],\n    name: 'depositTo',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'eip712Domain',\n    outputs: [\n      { internalType: 'bytes1', name: 'fields', type: 'bytes1' },\n      { internalType: 'string', name: 'name', type: 'string' },\n      { internalType: 'string', name: 'version', type: 'string' },\n      { internalType: 'uint256', name: 'chainId', type: 'uint256' },\n      { internalType: 'address', name: 'verifyingContract', type: 'address' },\n      { internalType: 'bytes32', name: 'salt', type: 'bytes32' },\n      { internalType: 'uint256[]', name: 'extensions', type: 'uint256[]' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'address', name: 'account', type: 'address' }],\n    name: 'getDepositInfo',\n    outputs: [\n      {\n        components: [\n          { internalType: 'uint256', name: 'deposit', type: 'uint256' },\n          { internalType: 'bool', name: 'staked', type: 'bool' },\n          { internalType: 'uint112', name: 'stake', type: 'uint112' },\n          { internalType: 'uint32', name: 'unstakeDelaySec', type: 'uint32' },\n          { internalType: 'uint48', name: 'withdrawTime', type: 'uint48' },\n        ],\n        internalType: 'struct IStakeManager.DepositInfo',\n        name: 'info',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getDomainSeparatorV4',\n    outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: 'sender', type: 'address' },\n      { internalType: 'uint192', name: 'key', type: 'uint192' },\n    ],\n    name: 'getNonce',\n    outputs: [{ internalType: 'uint256', name: 'nonce', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'getPackedUserOpTypeHash',\n    outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],\n    stateMutability: 'pure',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'bytes', name: 'initCode', type: 'bytes' }],\n    name: 'getSenderAddress',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: 'address', name: 'sender', type: 'address' },\n          { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n          { internalType: 'bytes', name: 'initCode', type: 'bytes' },\n          { internalType: 'bytes', name: 'callData', type: 'bytes' },\n          {\n            internalType: 'bytes32',\n            name: 'accountGasLimits',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint256',\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { internalType: 'bytes32', name: 'gasFees', type: 'bytes32' },\n          { internalType: 'bytes', name: 'paymasterAndData', type: 'bytes' },\n          { internalType: 'bytes', name: 'signature', type: 'bytes' },\n        ],\n        internalType: 'struct PackedUserOperation',\n        name: 'userOp',\n        type: 'tuple',\n      },\n    ],\n    name: 'getUserOpHash',\n    outputs: [{ internalType: 'bytes32', name: '', type: 'bytes32' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            components: [\n              { internalType: 'address', name: 'sender', type: 'address' },\n              { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n              { internalType: 'bytes', name: 'initCode', type: 'bytes' },\n              { internalType: 'bytes', name: 'callData', type: 'bytes' },\n              {\n                internalType: 'bytes32',\n                name: 'accountGasLimits',\n                type: 'bytes32',\n              },\n              {\n                internalType: 'uint256',\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { internalType: 'bytes32', name: 'gasFees', type: 'bytes32' },\n              {\n                internalType: 'bytes',\n                name: 'paymasterAndData',\n                type: 'bytes',\n              },\n              { internalType: 'bytes', name: 'signature', type: 'bytes' },\n            ],\n            internalType: 'struct PackedUserOperation[]',\n            name: 'userOps',\n            type: 'tuple[]',\n          },\n          {\n            internalType: 'contract IAggregator',\n            name: 'aggregator',\n            type: 'address',\n          },\n          { internalType: 'bytes', name: 'signature', type: 'bytes' },\n        ],\n        internalType: 'struct IEntryPoint.UserOpsPerAggregator[]',\n        name: 'opsPerAggregator',\n        type: 'tuple[]',\n      },\n      { internalType: 'address payable', name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleAggregatedOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          { internalType: 'address', name: 'sender', type: 'address' },\n          { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n          { internalType: 'bytes', name: 'initCode', type: 'bytes' },\n          { internalType: 'bytes', name: 'callData', type: 'bytes' },\n          {\n            internalType: 'bytes32',\n            name: 'accountGasLimits',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'uint256',\n            name: 'preVerificationGas',\n            type: 'uint256',\n          },\n          { internalType: 'bytes32', name: 'gasFees', type: 'bytes32' },\n          { internalType: 'bytes', name: 'paymasterAndData', type: 'bytes' },\n          { internalType: 'bytes', name: 'signature', type: 'bytes' },\n        ],\n        internalType: 'struct PackedUserOperation[]',\n        name: 'ops',\n        type: 'tuple[]',\n      },\n      { internalType: 'address payable', name: 'beneficiary', type: 'address' },\n    ],\n    name: 'handleOps',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'uint192', name: 'key', type: 'uint192' }],\n    name: 'incrementNonce',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'bytes', name: 'callData', type: 'bytes' },\n      {\n        components: [\n          {\n            components: [\n              { internalType: 'address', name: 'sender', type: 'address' },\n              { internalType: 'uint256', name: 'nonce', type: 'uint256' },\n              {\n                internalType: 'uint256',\n                name: 'verificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'callGasLimit',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'paymasterVerificationGasLimit',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'paymasterPostOpGasLimit',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'preVerificationGas',\n                type: 'uint256',\n              },\n              { internalType: 'address', name: 'paymaster', type: 'address' },\n              {\n                internalType: 'uint256',\n                name: 'maxFeePerGas',\n                type: 'uint256',\n              },\n              {\n                internalType: 'uint256',\n                name: 'maxPriorityFeePerGas',\n                type: 'uint256',\n              },\n            ],\n            internalType: 'struct EntryPoint.MemoryUserOp',\n            name: 'mUserOp',\n            type: 'tuple',\n          },\n          { internalType: 'bytes32', name: 'userOpHash', type: 'bytes32' },\n          { internalType: 'uint256', name: 'prefund', type: 'uint256' },\n          { internalType: 'uint256', name: 'contextOffset', type: 'uint256' },\n          { internalType: 'uint256', name: 'preOpGas', type: 'uint256' },\n        ],\n        internalType: 'struct EntryPoint.UserOpInfo',\n        name: 'opInfo',\n        type: 'tuple',\n      },\n      { internalType: 'bytes', name: 'context', type: 'bytes' },\n    ],\n    name: 'innerHandleOp',\n    outputs: [\n      { internalType: 'uint256', name: 'actualGasCost', type: 'uint256' },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      { internalType: 'address', name: '', type: 'address' },\n      { internalType: 'uint192', name: '', type: 'uint192' },\n    ],\n    name: 'nonceSequenceNumber',\n    outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'senderCreator',\n    outputs: [\n      { internalType: 'contract ISenderCreator', name: '', type: 'address' },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [{ internalType: 'bytes4', name: 'interfaceId', type: 'bytes4' }],\n    name: 'supportsInterface',\n    outputs: [{ internalType: 'bool', name: '', type: 'bool' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'unlockStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address payable',\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n    ],\n    name: 'withdrawStake',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address payable',\n        name: 'withdrawAddress',\n        type: 'address',\n      },\n      { internalType: 'uint256', name: 'withdrawAmount', type: 'uint256' },\n    ],\n    name: 'withdrawTo',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  { stateMutability: 'payable', type: 'receive' },\n] as const\n","import { SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, SolanaError } from '@solana/errors';\n\nexport type AllowedHttpRequestHeaders = Readonly<\n    {\n        // Someone can still sneak a forbidden header past Typescript if they do something like\n        // fOo-BaR, but at that point they deserve the runtime failure.\n        [K in DisallowedHeaders | ForbiddenHeaders as\n            | Capitalize<Lowercase<K>> // `Foo-bar`\n            | K // `Foo-Bar`\n            | Lowercase<K> // `foo-bar`\n            | Uncapitalize<K> // `foo-Bar`\n            // `FOO-BAR`\n            | Uppercase<K>]?: never;\n    } & { [headerName: string]: string }\n>;\n// These are headers that we simply don't allow the developer to override because they're\n// fundamental to the operation of the JSON-RPC transport.\ntype DisallowedHeaders = 'Accept' | 'Content-Length' | 'Content-Type' | 'Solana-Client';\ntype ForbiddenHeaders =\n    | 'Accept-Charset'\n    // Though technically forbidden in non-Node environments, we don't have a way to target\n    // TypeScript types depending on which platform you are authoring for. `Accept-Encoding` is\n    // therefore omitted from the forbidden headers type, but is still a runtime error in dev mode\n    // when supplied in a non-Node context.\n    // | 'Accept-Encoding'\n    | 'Access-Control-Request-Headers'\n    | 'Access-Control-Request-Method'\n    | 'Connection'\n    | 'Content-Length'\n    | 'Cookie'\n    | 'Date'\n    | 'DNT'\n    | 'Expect'\n    | 'Host'\n    | 'Keep-Alive'\n    | 'Origin'\n    | 'Permissions-Policy'\n    | 'Referer'\n    | 'TE'\n    | 'Trailer'\n    | 'Transfer-Encoding'\n    | 'Upgrade'\n    | 'Via'\n    | `Proxy-${string}`\n    | `Sec-${string}`;\n\n// These are headers which are fundamental to the JSON-RPC transport, and must not be modified.\nconst DISALLOWED_HEADERS: Record<string, boolean> = {\n    accept: true,\n    'content-length': true,\n    'content-type': true,\n};\n// https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\nconst FORBIDDEN_HEADERS: Record<string, boolean> = /* @__PURE__ */ Object.assign(\n    {\n        'accept-charset': true,\n        'access-control-request-headers': true,\n        'access-control-request-method': true,\n        connection: true,\n        'content-length': true,\n        cookie: true,\n        date: true,\n        dnt: true,\n        expect: true,\n        host: true,\n        'keep-alive': true,\n        origin: true,\n        'permissions-policy': true,\n        // Prefix matching is implemented in code, below.\n        // 'proxy-': true,\n        // 'sec-': true,\n        referer: true,\n        te: true,\n        trailer: true,\n        'transfer-encoding': true,\n        upgrade: true,\n        via: true,\n    },\n    __NODEJS__ ? undefined : { 'accept-encoding': true },\n);\n\nexport function assertIsAllowedHttpRequestHeaders(\n    headers: Record<string, string>,\n): asserts headers is AllowedHttpRequestHeaders {\n    const badHeaders = Object.keys(headers).filter(headerName => {\n        const lowercaseHeaderName = headerName.toLowerCase();\n        return (\n            DISALLOWED_HEADERS[headerName.toLowerCase()] === true ||\n            FORBIDDEN_HEADERS[headerName.toLowerCase()] === true ||\n            lowercaseHeaderName.startsWith('proxy-') ||\n            lowercaseHeaderName.startsWith('sec-')\n        );\n    });\n    if (badHeaders.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, {\n            headers: badHeaders,\n        });\n    }\n}\n\n// Lowercasing header names makes it easier to override user-supplied headers, such as those defined\n// in the `DisallowedHeaders` type.\nexport function normalizeHeaders<T extends Record<string, string>>(\n    headers: T,\n): { [K in string & keyof T as Lowercase<K>]: T[K] } {\n    const out: Record<string, string> = {};\n    for (const headerName in headers) {\n        out[headerName.toLowerCase()] = headers[headerName];\n    }\n    return out as { [K in string & keyof T as Lowercase<K>]: T[K] };\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/sign/base-account/SCWKeyManager.ts","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { Transaction } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link TransactionSendingSignerConfig#signAndSendTransactions | signAndSendTransactions} method.\n *\n * @see {@link BaseTransactionSignerConfig}\n */\nexport type TransactionSendingSignerConfig = BaseTransactionSignerConfig;\n\n/**\n * A signer interface that signs one or multiple transactions\n * before sending them immediately to the blockchain.\n *\n * It defines a {@link TransactionSendingSignerConfig#signAndSendTransactions | signAndSendTransactions}\n * function that returns the transaction signature (i.e. its identifier) for each provided\n * {@link Transaction}.\n *\n * This interface is required for PDA wallets and other types of wallets that don't provide an\n * interface for signing transactions without sending them.\n *\n * Note that it is also possible for such signers to modify the provided transactions\n * before signing and sending them. This enables use cases where the modified transactions\n * cannot be shared with the app and thus must be sent directly.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const myTransactionSendingSigner: TransactionSendingSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     signAndSendTransactions: async (transactions: Transaction[]): Promise<SignatureBytes[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Single signer**. Since this signer also sends the provided transactions,\n *   we can only use a single {@link TransactionSendingSigner} for a given set of transactions.\n * - **Last signer**. Trivially, that signer must also be the last one used.\n * - **Potential conflicts**. Since signers may decide to modify the given\n *   transactions before sending them, they may invalidate previous signatures.\n *   However, signers may decide not to modify a transaction based\n *   on the existence of signatures for that transaction.\n * - **Potential confirmation**. Whilst this is not required by this interface,\n *   it is also worth noting that most wallets will also wait for the transaction\n *   to be confirmed (typically with a `confirmed` commitment)\n *   before notifying the app that they are done.\n *\n * @see {@link isTransactionSendingSigner}\n * @see {@link assertIsTransactionSendingSigner}\n */\nexport type TransactionSendingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signAndSendTransactions(\n        transactions: readonly Transaction[],\n        config?: TransactionSendingSignerConfig,\n    ): Promise<readonly SignatureBytes[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionSendingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionSendingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionSendingSigner({ address, signAndSendTransactions: async () => {} }); // true\n * isTransactionSendingSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionSendingSigner}\n */\nexport function isTransactionSendingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionSendingSigner<TAddress> {\n    return 'signAndSendTransactions' in value && typeof value.signAndSendTransactions === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionSendingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionSendingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionSendingSigner({ address, signAndSendTransactions: async () => {} }); // void\n * assertIsTransactionSendingSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionSendingSigner}\n */\nexport function assertIsTransactionSendingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionSendingSigner<TAddress> {\n    if (!isTransactionSendingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/sign/base-account/utils/createSmartAccount.ts","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/builder/core/createBaseAccountSDK.ts","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/public-utilities/spend-permission/methods/getHash.ts","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/core/telemetry/logEvent.ts","import type * as Errors from '../Errors.js'\nimport * as Hex from '../Hex.js'\n\n/** @internal */\nexport function assertSize(hex: Hex.Hex, size_: number): void {\n  if (Hex.size(hex) > size_)\n    throw new Hex.SizeOverflowError({\n      givenSize: Hex.size(hex),\n      maxSize: size_,\n    })\n}\n\n/** @internal */\nexport declare namespace assertSize {\n  type ErrorType =\n    | Hex.size.ErrorType\n    | Hex.SizeOverflowError\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function assertStartOffset(value: Hex.Hex, start?: number | undefined) {\n  if (typeof start === 'number' && start > 0 && start > Hex.size(value) - 1)\n    throw new Hex.SliceOffsetOutOfBoundsError({\n      offset: start,\n      position: 'start',\n      size: Hex.size(value),\n    })\n}\n\nexport declare namespace assertStartOffset {\n  type ErrorType =\n    | Hex.SliceOffsetOutOfBoundsError\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function assertEndOffset(\n  value: Hex.Hex,\n  start?: number | undefined,\n  end?: number | undefined,\n) {\n  if (\n    typeof start === 'number' &&\n    typeof end === 'number' &&\n    Hex.size(value) !== end - start\n  ) {\n    throw new Hex.SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: Hex.size(value),\n    })\n  }\n}\n\nexport declare namespace assertEndOffset {\n  type ErrorType =\n    | Hex.SliceOffsetOutOfBoundsError\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function pad(hex_: Hex.Hex, options: pad.Options = {}) {\n  const { dir, size = 32 } = options\n\n  if (size === 0) return hex_\n\n  const hex = hex_.replace('0x', '')\n  if (hex.length > size * 2)\n    throw new Hex.SizeExceedsPaddingSizeError({\n      size: Math.ceil(hex.length / 2),\n      targetSize: size,\n      type: 'Hex',\n    })\n\n  return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}` as Hex.Hex\n}\n\n/** @internal */\nexport declare namespace pad {\n  type Options = {\n    dir?: 'left' | 'right' | undefined\n    size?: number | undefined\n  }\n  type ErrorType = Hex.SizeExceedsPaddingSizeError | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function trim(\n  value: Hex.Hex,\n  options: trim.Options = {},\n): trim.ReturnType {\n  const { dir = 'left' } = options\n\n  let data = value.replace('0x', '')\n\n  let sliceLength = 0\n  for (let i = 0; i < data.length - 1; i++) {\n    if (data[dir === 'left' ? i : data.length - i - 1]!.toString() === '0')\n      sliceLength++\n    else break\n  }\n  data =\n    dir === 'left'\n      ? data.slice(sliceLength)\n      : data.slice(0, data.length - sliceLength)\n\n  if (data === '0') return '0x'\n  if (dir === 'right' && data.length % 2 === 1) return `0x${data}0`\n  return `0x${data}` as trim.ReturnType\n}\n\n/** @internal */\nexport declare namespace trim {\n  type Options = {\n    dir?: 'left' | 'right' | undefined\n  }\n\n  type ReturnType = Hex.Hex\n\n  type ErrorType = Errors.GlobalErrorType\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/store/chain-clients/utils.ts","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/payment/constants.ts","import type { AbiItemType, AbiParameter } from '../../abi.js'\n\n/**\n * Gets {@link parameterCache} cache key namespaced by {@link type}. This prevents parameters from being accessible to types that don't allow them (e.g. `string indexed foo` not allowed outside of `type: 'event'`).\n * @param param ABI parameter string\n * @param type ABI parameter type\n * @returns Cache key for {@link parameterCache}\n */\nexport function getParameterCacheKey(\n  param: string,\n  type?: AbiItemType | 'struct',\n) {\n  if (type) return `${type}:${param}`\n  return param\n}\n\n/**\n * Basic cache seeded with common ABI parameter strings.\n *\n * **Note: When seeding more parameters, make sure you benchmark performance. The current number is the ideal balance between performance and having an already existing cache.**\n */\nexport const parameterCache = new Map<\n  string,\n  AbiParameter & { indexed?: boolean }\n>([\n  // Unnamed\n  ['address', { type: 'address' }],\n  ['bool', { type: 'bool' }],\n  ['bytes', { type: 'bytes' }],\n  ['bytes32', { type: 'bytes32' }],\n  ['int', { type: 'int256' }],\n  ['int256', { type: 'int256' }],\n  ['string', { type: 'string' }],\n  ['uint', { type: 'uint256' }],\n  ['uint8', { type: 'uint8' }],\n  ['uint16', { type: 'uint16' }],\n  ['uint24', { type: 'uint24' }],\n  ['uint32', { type: 'uint32' }],\n  ['uint64', { type: 'uint64' }],\n  ['uint96', { type: 'uint96' }],\n  ['uint112', { type: 'uint112' }],\n  ['uint160', { type: 'uint160' }],\n  ['uint192', { type: 'uint192' }],\n  ['uint256', { type: 'uint256' }],\n\n  // Named\n  ['address owner', { type: 'address', name: 'owner' }],\n  ['address to', { type: 'address', name: 'to' }],\n  ['bool approved', { type: 'bool', name: 'approved' }],\n  ['bytes _data', { type: 'bytes', name: '_data' }],\n  ['bytes data', { type: 'bytes', name: 'data' }],\n  ['bytes signature', { type: 'bytes', name: 'signature' }],\n  ['bytes32 hash', { type: 'bytes32', name: 'hash' }],\n  ['bytes32 r', { type: 'bytes32', name: 'r' }],\n  ['bytes32 root', { type: 'bytes32', name: 'root' }],\n  ['bytes32 s', { type: 'bytes32', name: 's' }],\n  ['string name', { type: 'string', name: 'name' }],\n  ['string symbol', { type: 'string', name: 'symbol' }],\n  ['string tokenURI', { type: 'string', name: 'tokenURI' }],\n  ['uint tokenId', { type: 'uint256', name: 'tokenId' }],\n  ['uint8 v', { type: 'uint8', name: 'v' }],\n  ['uint256 balance', { type: 'uint256', name: 'balance' }],\n  ['uint256 tokenId', { type: 'uint256', name: 'tokenId' }],\n  ['uint256 value', { type: 'uint256', name: 'value' }],\n\n  // Indexed\n  [\n    'event:address indexed from',\n    { type: 'address', name: 'from', indexed: true },\n  ],\n  ['event:address indexed to', { type: 'address', name: 'to', indexed: true }],\n  [\n    'event:uint indexed tokenId',\n    { type: 'uint256', name: 'tokenId', indexed: true },\n  ],\n  [\n    'event:uint256 indexed tokenId',\n    { type: 'uint256', name: 'tokenId', indexed: true },\n  ],\n])\n","import { generateKeyPair, privateDecrypt, constants, createPrivateKey } from \"crypto\";\n\nimport { Keypair } from \"@solana/web3.js\";\nimport bs58 from \"bs58\";\n\n/**\n * Generates a new RSA key pair with 4096-bit private key.\n * - Private key in PKCS1 DER format\n * - Public key in PKIX/SPKI DER format\n *\n * @returns A promise that resolves to the generated key pair, or rejects with an error.\n */\nexport const generateExportEncryptionKeyPair = async () => {\n  return await new Promise<{\n    publicKey: string;\n    privateKey: string;\n  }>((resolve, reject) => {\n    generateKeyPair(\n      \"rsa\",\n      {\n        modulusLength: 4096,\n        publicKeyEncoding: {\n          type: \"spki\",\n          format: \"der\",\n        },\n        privateKeyEncoding: {\n          type: \"pkcs1\",\n          format: \"der\",\n        },\n      },\n      (err, publicKey, privateKey) => {\n        if (err) {\n          reject(err);\n        }\n        resolve({\n          publicKey: publicKey.toString(\"base64\"),\n          privateKey: privateKey.toString(\"base64\"),\n        });\n      },\n    );\n  });\n};\n\n/**\n * Decrypts a ciphertext using RSA-OAEP-SHA256.\n * - Parses PKCS1 private key\n * - Uses RSA-OAEP-SHA256 for decryption\n * - Returns hex-encoded result\n *\n * @param b64PrivateKey - The base64-encoded private key in PKCS1 DER format.\n * @param b64Cipher - The base64-encoded ciphertext.\n * @returns The decrypted key hex string, or throws an error if decryption fails.\n */\nexport const decryptWithPrivateKey = (b64PrivateKey: string, b64Cipher: string): string => {\n  try {\n    // Create a private key object from the PKCS1 DER format\n    const privateKey = createPrivateKey({\n      key: Buffer.from(b64PrivateKey, \"base64\"),\n      format: \"der\",\n      type: \"pkcs1\",\n    });\n\n    const decryptedBuffer = privateDecrypt(\n      {\n        key: privateKey,\n        padding: constants.RSA_PKCS1_OAEP_PADDING,\n        oaepHash: \"sha256\",\n      },\n      Buffer.from(b64Cipher, \"base64\"),\n    );\n\n    return decryptedBuffer.toString(\"hex\");\n  } catch (error) {\n    throw new Error(`Decryption failed: ${String(error)}`);\n  }\n};\n\n/**\n * Format a private key to a base58 string for easy import into Solana wallet apps.\n *\n * @param privateKey - The private key as a hex string\n * @returns The formatted private key as a base58 string\n */\nexport const formatSolanaPrivateKey = (privateKey: string): string => {\n  const privateKeyBytes = Buffer.from(privateKey, \"hex\");\n  const keypair = Keypair.fromSeed(privateKeyBytes);\n  const fullKey = Buffer.concat([keypair.secretKey.subarray(0, 32), keypair.publicKey.toBytes()]);\n  return bs58.encode(fullKey);\n};\n","import { chainConfig } from '../../op-stack/chainConfig.js'\nimport { defineChain } from '../../utils/chain/defineChain.js'\n\nconst sourceId = 11_155_111 // sepolia\n\nexport const bobSepolia = defineChain({\n  ...chainConfig,\n  id: 808813,\n  name: 'BOB Sepolia',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'ETH',\n    symbol: 'ETH',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://bob-sepolia.rpc.gobob.xyz'],\n      webSocket: ['wss://bob-sepolia.rpc.gobob.xyz'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'BOB Sepolia Explorer',\n      url: 'https://bob-sepolia.explorer.gobob.xyz',\n    },\n  },\n  contracts: {\n    ...chainConfig.contracts,\n    multicall3: {\n      address: '0xcA11bde05977b3631167028862bE2a173976CA11',\n      blockCreated: 35677,\n    },\n    l2OutputOracle: {\n      [sourceId]: {\n        address: '0x14D0069452b4AE2b250B395b8adAb771E4267d2f',\n        blockCreated: 4462615,\n      },\n    },\n    portal: {\n      [sourceId]: {\n        address: '0x867B1Aa872b9C8cB5E9F7755feDC45BB24Ad0ae4',\n        blockCreated: 4462615,\n      },\n    },\n  },\n  testnet: true,\n  sourceId,\n})\n","import type { ChainFormatters } from '../types/chain.js'\nimport type { RpcTransaction } from '../types/rpc.js'\nimport { hexToBigInt } from '../utils/encoding/fromHex.js'\nimport { defineBlock } from '../utils/formatters/block.js'\nimport {\n  defineTransaction,\n  formatTransaction,\n} from '../utils/formatters/transaction.js'\nimport { defineTransactionRequest } from '../utils/formatters/transactionRequest.js'\nimport type {\n  CeloBlock,\n  CeloRpcBlock,\n  CeloRpcTransaction,\n  CeloRpcTransactionRequest,\n  CeloTransaction,\n  CeloTransactionRequest,\n} from './types.js'\nimport { isCIP64 } from './utils.js'\n\nexport const formatters = {\n  block: /*#__PURE__*/ defineBlock({\n    format(args: CeloRpcBlock): CeloBlock {\n      const transactions = args.transactions?.map((transaction) => {\n        if (typeof transaction === 'string') return transaction\n        const formatted = formatTransaction(transaction as RpcTransaction)\n        return {\n          ...formatted,\n          ...(transaction.gatewayFee\n            ? {\n                gatewayFee: hexToBigInt(transaction.gatewayFee),\n                gatewayFeeRecipient: transaction.gatewayFeeRecipient,\n              }\n            : {}),\n          feeCurrency: transaction.feeCurrency,\n        }\n      })\n      return {\n        transactions,\n      } as CeloBlock\n    },\n  }),\n  transaction: /*#__PURE__*/ defineTransaction({\n    format(args: CeloRpcTransaction): CeloTransaction {\n      if (args.type === '0x7e')\n        return {\n          isSystemTx: args.isSystemTx,\n          mint: args.mint ? hexToBigInt(args.mint) : undefined,\n          sourceHash: args.sourceHash,\n          type: 'deposit',\n        } as CeloTransaction\n\n      const transaction = { feeCurrency: args.feeCurrency } as CeloTransaction\n\n      if (args.type === '0x7b') transaction.type = 'cip64'\n      else {\n        if (args.type === '0x7c') transaction.type = 'cip42'\n\n        transaction.gatewayFee = args.gatewayFee\n          ? hexToBigInt(args.gatewayFee)\n          : null\n        transaction.gatewayFeeRecipient = args.gatewayFeeRecipient\n      }\n\n      return transaction\n    },\n  }),\n  transactionRequest: /*#__PURE__*/ defineTransactionRequest({\n    format(args: CeloTransactionRequest): CeloRpcTransactionRequest {\n      const request = {} as CeloRpcTransactionRequest\n\n      if (args.feeCurrency) request.feeCurrency = args.feeCurrency\n      if (isCIP64(args)) request.type = '0x7b'\n\n      return request\n    },\n  }),\n} as const satisfies ChainFormatters\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/public-utilities/spend-permission/utils.ts","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/payment/utils/sdkManager.ts","import type { createSolanaRpcApi } from '@solana/rpc-api';\n\nimport { createSolanaJsonRpcIntegerOverflowError } from './rpc-integer-overflow-error';\n\n/**\n * When you create {@link Rpc} instances with custom transports but otherwise the default RPC API\n * behaviours, use this.\n *\n * @example\n * ```ts\n * const myCustomRpc = createRpc({\n *     api: createSolanaRpcApi(DEFAULT_RPC_CONFIG),\n *     transport: myCustomTransport,\n * });\n * ```\n */\nexport const DEFAULT_RPC_CONFIG: Partial<NonNullable<Parameters<typeof createSolanaRpcApi>[0]>> = {\n    defaultCommitment: 'confirmed',\n    onIntegerOverflow(request, keyPath, value) {\n        throw createSolanaJsonRpcIntegerOverflowError(request.methodName, keyPath, value);\n    },\n};\n","/**\n * This function is a replacement for `JSON.parse` that can handle large\n * unsafe integers by parsing them as BigInts. It transforms every\n * numerical value into a BigInt without loss of precision.\n */\nexport function parseJsonWithBigInts(json: string): unknown {\n    return JSON.parse(wrapIntegersInBigIntValueObject(json), (_, value) => {\n        return isBigIntValueObject(value) ? unwrapBigIntValueObject(value) : value;\n    });\n}\n\nfunction wrapIntegersInBigIntValueObject(json: string): string {\n    const out = [];\n    let inQuote = false;\n    for (let ii = 0; ii < json.length; ii++) {\n        let isEscaped = false;\n        if (json[ii] === '\\\\') {\n            out.push(json[ii++]);\n            isEscaped = !isEscaped;\n        }\n        if (json[ii] === '\"') {\n            out.push(json[ii]);\n            if (!isEscaped) {\n                inQuote = !inQuote;\n            }\n            continue;\n        }\n        if (!inQuote) {\n            const consumedNumber = consumeNumber(json, ii);\n            if (consumedNumber?.length) {\n                ii += consumedNumber.length - 1;\n                // Don't wrap numbers that contain a decimal point or a negative exponent.\n                if (consumedNumber.match(/\\.|[eE]-/)) {\n                    out.push(consumedNumber);\n                } else {\n                    out.push(wrapBigIntValueObject(consumedNumber));\n                }\n                continue;\n            }\n        }\n        out.push(json[ii]);\n    }\n\n    return out.join('');\n}\n\nfunction consumeNumber(json: string, ii: number): string | null {\n    /** @see https://stackoverflow.com/a/13340826/11440277 */\n    const JSON_NUMBER_REGEX = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/;\n\n    // Stop early if the first character isn't a digit or a minus sign.\n    if (!json[ii]?.match(/[-\\d]/)) {\n        return null;\n    }\n\n    // Otherwise, check if the next characters form a valid JSON number.\n    const numberMatch = json.slice(ii).match(JSON_NUMBER_REGEX);\n    return numberMatch ? numberMatch[0] : null;\n}\n\ntype BigIntValueObject = {\n    // `$` implies 'this is a value object'.\n    // `n` implies 'interpret the value as a bigint'.\n    $n: string;\n};\n\nfunction wrapBigIntValueObject(value: string): string {\n    return `{\"$n\":\"${value}\"}`;\n}\n\nfunction unwrapBigIntValueObject({ $n }: BigIntValueObject): bigint {\n    if ($n.match(/[eE]/)) {\n        const [units, exponent] = $n.split(/[eE]/);\n        return BigInt(units) * BigInt(10) ** BigInt(exponent);\n    }\n    return BigInt($n);\n}\n\nfunction isBigIntValueObject(value: unknown): value is BigIntValueObject {\n    return !!value && typeof value === 'object' && '$n' in value && typeof value.$n === 'string';\n}\n","import type {\n  AbiParameterToPrimitiveType,\n  AbiType,\n  Address,\n  SolidityAddress,\n  SolidityArrayWithoutTuple,\n  SolidityBool,\n  SolidityBytes,\n  SolidityInt,\n  SolidityString,\n} from 'abitype'\n\nimport {\n  AbiEncodingLengthMismatchError,\n  type AbiEncodingLengthMismatchErrorType,\n  BytesSizeMismatchError,\n  type BytesSizeMismatchErrorType,\n  UnsupportedPackedAbiType,\n} from '../../errors/abi.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\nimport {\n  type BoolToHexErrorType,\n  boolToHex,\n  type NumberToHexErrorType,\n  numberToHex,\n  type StringToHexErrorType,\n  stringToHex,\n} from '../encoding/toHex.js'\nimport { arrayRegex, bytesRegex, integerRegex } from '../regex.js'\n\ntype PackedAbiType =\n  | SolidityAddress\n  | SolidityBool\n  | SolidityBytes\n  | SolidityInt\n  | SolidityString\n  | SolidityArrayWithoutTuple\n\ntype EncodePackedValues<\n  packedAbiTypes extends readonly PackedAbiType[] | readonly unknown[],\n> = {\n  [K in keyof packedAbiTypes]: packedAbiTypes[K] extends AbiType\n    ? AbiParameterToPrimitiveType<{ type: packedAbiTypes[K] }>\n    : unknown\n}\n\nexport type EncodePackedErrorType =\n  | AbiEncodingLengthMismatchErrorType\n  | ConcatHexErrorType\n  | EncodeErrorType\n  | ErrorType\n\nexport function encodePacked<\n  const packedAbiTypes extends readonly PackedAbiType[] | readonly unknown[],\n>(types: packedAbiTypes, values: EncodePackedValues<packedAbiTypes>): Hex {\n  if (types.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: types.length as number,\n      givenLength: values.length as number,\n    })\n\n  const data: Hex[] = []\n  for (let i = 0; i < (types as unknown[]).length; i++) {\n    const type = types[i]\n    const value = values[i]\n    data.push(encode(type, value))\n  }\n  return concatHex(data)\n}\n\ntype EncodeErrorType =\n  | BoolToHexErrorType\n  | BytesSizeMismatchErrorType\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | PadErrorType\n  | StringToHexErrorType\n  | UnsupportedPackedAbiType\n  | ErrorType\n\nfunction encode<const packedAbiType extends PackedAbiType | unknown>(\n  type: packedAbiType,\n  value: EncodePackedValues<[packedAbiType]>[0],\n  isArray = false,\n): Hex {\n  if (type === 'address') {\n    const address = value as Address\n    if (!isAddress(address)) throw new InvalidAddressError({ address })\n    return pad(address.toLowerCase() as Hex, {\n      size: isArray ? 32 : null,\n    }) as Address\n  }\n  if (type === 'string') return stringToHex(value as string)\n  if (type === 'bytes') return value as Hex\n  if (type === 'bool')\n    return pad(boolToHex(value as boolean), { size: isArray ? 32 : 1 })\n\n  const intMatch = (type as string).match(integerRegex)\n  if (intMatch) {\n    const [_type, baseType, bits = '256'] = intMatch\n    const size = Number.parseInt(bits, 10) / 8\n    return numberToHex(value as number, {\n      size: isArray ? 32 : size,\n      signed: baseType === 'int',\n    })\n  }\n\n  const bytesMatch = (type as string).match(bytesRegex)\n  if (bytesMatch) {\n    const [_type, size] = bytesMatch\n    if (Number.parseInt(size, 10) !== ((value as Hex).length - 2) / 2)\n      throw new BytesSizeMismatchError({\n        expectedSize: Number.parseInt(size, 10),\n        givenSize: ((value as Hex).length - 2) / 2,\n      })\n    return pad(value as Hex, { dir: 'right', size: isArray ? 32 : null }) as Hex\n  }\n\n  const arrayMatch = (type as string).match(arrayRegex)\n  if (arrayMatch && Array.isArray(value)) {\n    const [_type, childType] = arrayMatch\n    const data: Hex[] = []\n    for (let i = 0; i < value.length; i++) {\n      data.push(encode(childType, value[i], true))\n    }\n    if (data.length === 0) return '0x'\n    return concatHex(data)\n  }\n\n  throw new UnsupportedPackedAbiType(type)\n}\n","import type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { SignTransactionErrorType as SignTransactionErrorType_account } from '../../accounts/utils/signTransaction.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../errors/account.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type { GetTransactionRequestKzgParameter } from '../../types/kzg.js'\nimport type { RpcTransactionRequest } from '../../types/rpc.js'\nimport type {\n  TransactionRequest,\n  TransactionSerializable,\n  TransactionSerialized,\n} from '../../types/transaction.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type AssertCurrentChainErrorType,\n  assertCurrentChain,\n} from '../../utils/chain/assertCurrentChain.js'\nimport type { NumberToHexErrorType } from '../../utils/encoding/toHex.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\nimport {\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type AssertRequestErrorType,\n  assertRequest,\n} from '../../utils/transaction/assertRequest.js'\nimport type { GetTransactionType } from '../../utils/transaction/getTransactionType.js'\nimport { type GetChainIdErrorType, getChainId } from '../public/getChainId.js'\n\nexport type SignTransactionRequest<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  ///\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'>\n\nexport type SignTransactionParameters<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  request extends SignTransactionRequest<\n    chain,\n    chainOverride\n  > = SignTransactionRequest<chain, chainOverride>,\n> = request &\n  GetAccountParameter<account> &\n  GetChainParameter<chain, chainOverride> &\n  GetTransactionRequestKzgParameter<request>\n\nexport type SignTransactionReturnType<\n  request extends SignTransactionRequest = SignTransactionRequest,\n> = TransactionSerialized<GetTransactionType<request>>\n\nexport type SignTransactionErrorType =\n  | ParseAccountErrorType\n  | AssertRequestErrorType\n  | GetChainIdErrorType\n  | AssertCurrentChainErrorType\n  | SignTransactionErrorType_account\n  | NumberToHexErrorType\n  | RequestErrorType\n  | ErrorType\n\n/**\n * Signs a transaction.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/signTransaction\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`eth_signTransaction`](https://ethereum.github.io/execution-apis/api-documentation/)\n *   - Local Accounts: Signs locally. No JSON-RPC request.\n *\n * @param args - {@link SignTransactionParameters}\n * @returns The signed serialized transaction. {@link SignTransactionReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { signTransaction } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signTransaction(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: 1n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { signTransaction } from 'viem/actions'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x'),\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signTransaction(client, {\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: 1n,\n * })\n */\nexport async function signTransaction<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  chainOverride extends Chain | undefined = undefined,\n  const request extends SignTransactionRequest<\n    chain,\n    chainOverride\n  > = SignTransactionRequest<chain, chainOverride>,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SignTransactionParameters<chain, account, chainOverride, request>,\n): Promise<SignTransactionReturnType<request>> {\n  const {\n    account: account_ = client.account,\n    chain = client.chain,\n    ...transaction\n  } = parameters\n\n  if (!account_)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/signTransaction',\n    })\n  const account = parseAccount(account_)\n\n  assertRequest({\n    account,\n    ...parameters,\n  })\n\n  const chainId = await getAction(client, getChainId, 'getChainId')({})\n  if (chain !== null)\n    assertCurrentChain({\n      currentChainId: chainId,\n      chain,\n    })\n\n  const formatters = chain?.formatters || client.chain?.formatters\n  const format =\n    formatters?.transactionRequest?.format || formatTransactionRequest\n\n  if (account.signTransaction)\n    return account.signTransaction(\n      {\n        ...transaction,\n        chainId,\n      } as TransactionSerializable,\n      { serializer: client.chain?.serializers?.transaction },\n    ) as Promise<SignTransactionReturnType<request>>\n\n  return await client.request(\n    {\n      method: 'eth_signTransaction',\n      params: [\n        {\n          ...format(\n            {\n              ...transaction,\n              account,\n            } as unknown as TransactionRequest,\n            'signTransaction',\n          ),\n          chainId: numberToHex(chainId),\n          from: account.address,\n        } as unknown as RpcTransactionRequest,\n      ],\n    },\n    { retryCount: 0 },\n  )\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/public-utilities/spend-permission/methods/getPermissionStatus.ts","import {\n    Callable,\n    createRpcMessage,\n    RpcRequestTransformer,\n    RpcResponse,\n    RpcResponseTransformer,\n} from '@solana/rpc-spec-types';\n\nimport type { RpcTransport } from './rpc-transport';\n\nexport type RpcApiConfig = Readonly<{\n    /**\n     * An optional function that transforms the {@link RpcRequest} before it is sent to the JSON RPC\n     * server.\n     *\n     * This is useful when the params supplied by the caller need to be transformed before\n     * forwarding the message to the server. Use cases for this include applying defaults,\n     * forwarding calls to renamed methods, and serializing complex values.\n     */\n    requestTransformer?: RpcRequestTransformer;\n    /**\n     * An optional function that transforms the {@link RpcResponse} before it is returned to the\n     * caller.\n     *\n     * Use cases for this include constructing complex data types from serialized data, and throwing\n     * exceptions.\n     */\n    responseTransformer?: RpcResponseTransformer;\n}>;\n\n/**\n * This type allows an {@link RpcApi} to describe how a particular request should be issued to the\n * JSON RPC server.\n *\n * Given a function that was called on a {@link Rpc}, this object exposes an `execute` function that\n * dictates which request will be sent, how the underlying transport will be used, and how the\n * responses will be transformed.\n *\n * This function accepts a {@link RpcTransport} and an `AbortSignal` and asynchronously returns a\n * {@link RpcResponse}. This gives us the opportunity to:\n *\n * - define the `payload` from the requested method name and parameters before passing it to the\n *   transport.\n * - call the underlying transport zero, one or multiple times depending on the use-case (e.g.\n *   caching or aggregating multiple responses).\n * - transform the response from the JSON RPC server, in case it does not match the `TResponse`\n *   specified by the {@link PendingRpcRequest | PendingRpcRequest<TResponse>} returned from that\n *   function.\n */\nexport type RpcPlan<TResponse> = {\n    execute: (\n        config: Readonly<{\n            signal?: AbortSignal;\n            transport: RpcTransport;\n        }>,\n    ) => Promise<RpcResponse<TResponse>>;\n};\n\n/**\n * For each of `TRpcMethods`, this object exposes a method with the same name that maps between its\n * input arguments and a {@link RpcPlan | RpcPlan<TResponse>} that implements the execution of a\n * JSON RPC request to fetch `TResponse`.\n */\nexport type RpcApi<TRpcMethods> = {\n    [MethodName in keyof TRpcMethods]: RpcReturnTypeMapper<TRpcMethods[MethodName]>;\n};\n\ntype RpcReturnTypeMapper<TRpcMethod> = TRpcMethod extends Callable\n    ? (...rawParams: unknown[]) => RpcPlan<ReturnType<TRpcMethod>>\n    : never;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RpcApiMethod = (...args: any) => any;\ninterface RpcApiMethods {\n    [methodName: string]: RpcApiMethod;\n}\n\n/**\n * Creates a JavaScript proxy that converts _any_ function call called on it to a {@link RpcPlan} by\n * creating an `execute` function that:\n *\n * - sets the transport payload to a JSON RPC v2 payload object with the requested `methodName` and\n *   `params` properties, optionally transformed by {@link RpcApiConfig.requestTransformer}.\n * - transforms the transport's response using the {@link RpcApiConfig.responseTransformer}\n *   function, if provided.\n *\n * @example\n * ```ts\n * // For example, given this `RpcApi`:\n * const rpcApi = createJsonRpcApi({\n *     requestTransformer: (...rawParams) => rawParams.reverse(),\n *     responseTransformer: response => response.result,\n * });\n *\n * // ...the following function call:\n * rpcApi.foo('bar', { baz: 'bat' });\n *\n * // ...will produce a `RpcPlan` that:\n * // -   Uses the following payload: { id: 1, jsonrpc: '2.0', method: 'foo', params: [{ baz: 'bat' }, 'bar'] }.\n * // -   Returns the \"result\" property of the RPC response.\n * ```\n */\nexport function createJsonRpcApi<TRpcMethods extends RpcApiMethods>(config?: RpcApiConfig): RpcApi<TRpcMethods> {\n    return new Proxy({} as RpcApi<TRpcMethods>, {\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n        get<TMethodName extends keyof RpcApi<TRpcMethods>>(\n            ...args: Parameters<NonNullable<ProxyHandler<RpcApi<TRpcMethods>>['get']>>\n        ) {\n            const [_, p] = args;\n            const methodName = p.toString() as keyof TRpcMethods as string;\n            return function (\n                ...rawParams: Parameters<\n                    TRpcMethods[TMethodName] extends CallableFunction ? TRpcMethods[TMethodName] : never\n                >\n            ): RpcPlan<ReturnType<TRpcMethods[TMethodName]>> {\n                const rawRequest = Object.freeze({ methodName, params: rawParams });\n                const request = config?.requestTransformer ? config?.requestTransformer(rawRequest) : rawRequest;\n                return Object.freeze(<RpcPlan<ReturnType<TRpcMethods[TMethodName]>>>{\n                    execute: async ({ signal, transport }) => {\n                        const payload = createRpcMessage(request);\n                        const response = await transport({ payload, signal });\n                        if (!config?.responseTransformer) {\n                            return response;\n                        }\n                        return config.responseTransformer(response, request);\n                    },\n                });\n            };\n        },\n    });\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, SolanaError } from '@solana/errors';\n\nimport { isTransactionModifyingSigner, TransactionModifyingSigner } from './transaction-modifying-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\nimport { isTransactionSendingSigner, TransactionSendingSigner } from './transaction-sending-signer';\n\n/**\n * Defines a signer capable of signing transactions.\n *\n * @see {@link TransactionModifyingSigner} For signers that can modify transactions before signing them.\n * @see {@link TransactionPartialSigner} For signers that can be used in parallel.\n * @see {@link TransactionSendingSigner} For signers that send transactions after signing them.\n * @see {@link isTransactionSigner}\n * @see {@link assertIsTransactionSigner}\n */\nexport type TransactionSigner<TAddress extends string = string> =\n    | TransactionModifyingSigner<TAddress>\n    | TransactionPartialSigner<TAddress>\n    | TransactionSendingSigner<TAddress>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionSigner({ address, signTransactions: async () => {} }); // true\n * isTransactionSigner({ address, modifyAndSignTransactions: async () => {} }); // true\n * isTransactionSigner({ address, signAndSendTransactions: async () => {} }); // true\n * isTransactionSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionSigner}\n */\nexport function isTransactionSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionSigner<TAddress> {\n    return (\n        isTransactionPartialSigner(value) || isTransactionModifyingSigner(value) || isTransactionSendingSigner(value)\n    );\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionSigner({ address, signTransactions: async () => {} }); // void\n * assertIsTransactionSigner({ address, modifyAndSignTransactions: async () => {} }); // void\n * assertIsTransactionSigner({ address, signAndSendTransactions: async () => {} }); // void\n * assertIsTransactionSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionSigner}\n */\nexport function assertIsTransactionSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionSigner<TAddress> {\n    if (!isTransactionSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { encodeFunctionData } from \"viem\";\n\nimport { getBaseNodeRpcUrl } from \"../../accounts/evm/getBaseNodeRpcUrl.js\";\nimport {\n  EvmUserOperationNetwork,\n  EvmUserOperationStatus,\n  CdpOpenApiClientType,\n} from \"../../openapi-client/index.js\";\n\nimport type { EvmSmartAccount } from \"../../accounts/evm/types.js\";\nimport type { Calls } from \"../../types/calls.js\";\nimport type { Address, Hex } from \"../../types/misc.js\";\n\n/**\n * Options for sending a user operation.\n *\n * @template T - Array type for the calls parameter.\n */\nexport type SendUserOperationOptions<T extends readonly unknown[]> = {\n  /** The smart account. */\n  smartAccount: EvmSmartAccount;\n  /**\n   * Array of contract calls to execute in the user operation.\n   * Each call can either be:\n   * - A direct call with `to`, `value`, and `data`.\n   * - A contract call with `to`, `abi`, `functionName`, and `args`.\n   *\n   * @example\n   * ```ts\n   * const calls = [\n   *   {\n   *     to: \"0x1234567890123456789012345678901234567890\",\n   *     value: parseEther(\"0.0000005\"),\n   *     data: \"0x\",\n   *   },\n   *   {\n   *     to: \"0x1234567890123456789012345678901234567890\",\n   *     abi: erc20Abi,\n   *     functionName: \"transfer\",\n   *     args: [to, amount],\n   *   },\n   * ]\n   * ```\n   */\n  calls: Calls<T>;\n  /** Chain ID of the network to execute on. */\n  network: EvmUserOperationNetwork;\n  /** Optional URL of the paymaster service to use for gas sponsorship. Must be ERC-7677 compliant. */\n  paymasterUrl?: string;\n  /** The idempotency key. */\n  idempotencyKey?: string;\n};\n\n/**\n * Return type for the sendUserOperation function.\n */\nexport type SendUserOperationReturnType = {\n  /** The address of the smart wallet. */\n  smartAccountAddress: Address;\n  /** The status of the user operation. */\n  status: typeof EvmUserOperationStatus.broadcast;\n  /** The hash of the user operation. This is not the transaction hash which is only available after the operation is completed.*/\n  userOpHash: Hex;\n};\n\n/**\n * Return type for the prepareAndSendUserOperation function.\n */\nexport type PrepareAndSendUserOperationReturnType = {\n  /** The address of the smart wallet. */\n  smartAccountAddress: Address;\n  /** The status of the user operation. */\n  status: typeof EvmUserOperationStatus.broadcast;\n  /** The hash of the user operation. This is not the transaction hash which is only available after the operation is completed.*/\n  userOpHash: Hex;\n};\n\n/**\n * Sends a user operation to the network.\n *\n * @example\n * ```ts\n * import { sendUserOperation } from \"@coinbase/cdp-sdk\";\n * import { parseEther } from \"viem\";\n * import { CdpClient } from \"@coinbase/cdp-sdk\";\n *\n * const client = new CdpClient({\n *   apiKeyId: \"your-api-key-id\",\n *   apiKeySecret: \"your-api-key-secret\",\n *   walletSecret: \"your-wallet-secret\",\n * });\n *\n * const ethAccount = await client.createEvmServerAccount()\n * const smartAccount = await client.createEvmSmartAccount({ owner: ethAccount })\n *\n * const result = await sendUserOperation(client, smartAccount, {\n *   calls: [\n *     {\n *       abi: erc20Abi,\n *       functionName: \"transfer\",\n *       args: [to, amount],\n *     },\n *     {\n *       to: \"0x1234567890123456789012345678901234567890\",\n *       data: \"0x\",\n *       value: parseEther(\"0.0000005\"),\n *     },\n *   ],\n *   network: \"base-sepolia\",\n *   paymasterUrl: \"https://api.developer.coinbase.com/rpc/v1/base/someapikey\",\n * });\n * ```\n *\n * @param {CdpOpenApiClientType} client - The client to use to send the user operation.\n * @param {SendUserOperationOptions<T>} options - The options for the user operation.\n * @returns {Promise<SendUserOperationReturnType>} The result of the user operation.\n */\nexport async function sendUserOperation<T extends readonly unknown[]>(\n  client: CdpOpenApiClientType,\n  options: SendUserOperationOptions<T>,\n): Promise<SendUserOperationReturnType> {\n  const { calls, network, paymasterUrl: _paymasterUrl } = options;\n\n  const paymasterUrl = await (async () => {\n    if (!_paymasterUrl && network === \"base\") {\n      return getBaseNodeRpcUrl(\"base\");\n    }\n    return _paymasterUrl;\n  })();\n\n  if (calls.length === 0) {\n    throw new Error(\"Calls array is empty\");\n  }\n\n  const encodedCalls = calls.map(call => {\n    const value = (call.value ?? BigInt(0)).toString();\n\n    if (\"abi\" in call && call.abi && \"functionName\" in call) {\n      return {\n        to: call.to,\n        data: encodeFunctionData({\n          abi: call.abi,\n          functionName: call.functionName,\n          args: call.args,\n        }),\n        value,\n        overrideGasLimit: call.overrideGasLimit,\n      };\n    }\n\n    return {\n      to: call.to,\n      data: call.data ?? \"0x\",\n      value,\n      overrideGasLimit: call.overrideGasLimit,\n    };\n  });\n\n  const createOpResponse = await client.prepareUserOperation(options.smartAccount.address, {\n    network,\n    calls: encodedCalls,\n    paymasterUrl,\n  });\n\n  const owner = options.smartAccount.owners[0];\n\n  const signature = await owner.sign({\n    hash: createOpResponse.userOpHash as Hex,\n  });\n\n  const broadcastResponse = await client.sendUserOperation(\n    options.smartAccount.address,\n    createOpResponse.userOpHash as Hex,\n    {\n      signature,\n    },\n    options.idempotencyKey,\n  );\n\n  return {\n    smartAccountAddress: options.smartAccount.address,\n    status: broadcastResponse.status,\n    userOpHash: createOpResponse.userOpHash,\n  } as SendUserOperationReturnType;\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/payment/getOrCreateSubscriptionOwnerWallet.ts","import { chainConfig } from '../../op-stack/chainConfig.js'\nimport { defineChain } from '../../utils/chain/defineChain.js'\n\nconst sourceId = 11_155_111 // sepolia\n\nexport const baseSepolia = /*#__PURE__*/ defineChain({\n  ...chainConfig,\n  id: 84532,\n  network: 'base-sepolia',\n  name: 'Base Sepolia',\n  nativeCurrency: { name: 'Sepolia Ether', symbol: 'ETH', decimals: 18 },\n  rpcUrls: {\n    default: {\n      http: ['https://sepolia.base.org'],\n    },\n  },\n  blockExplorers: {\n    default: {\n      name: 'Basescan',\n      url: 'https://sepolia.basescan.org',\n      apiUrl: 'https://api-sepolia.basescan.org/api',\n    },\n  },\n  contracts: {\n    ...chainConfig.contracts,\n    disputeGameFactory: {\n      [sourceId]: {\n        address: '0xd6E6dBf4F7EA0ac412fD8b65ED297e64BB7a06E1',\n      },\n    },\n    l2OutputOracle: {\n      [sourceId]: {\n        address: '0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254',\n      },\n    },\n    portal: {\n      [sourceId]: {\n        address: '0x49f53e41452c74589e85ca1677426ba426459e85',\n        blockCreated: 4446677,\n      },\n    },\n    l1StandardBridge: {\n      [sourceId]: {\n        address: '0xfd0Bf71F60660E2f608ed56e1659C450eB113120',\n        blockCreated: 4446677,\n      },\n    },\n    multicall3: {\n      address: '0xca11bde05977b3631167028862be2a173976ca11',\n      blockCreated: 1059647,\n    },\n  },\n  testnet: true,\n  sourceId,\n})\n\nexport const baseSepoliaPreconf = /*#__PURE__*/ defineChain({\n  ...baseSepolia,\n  experimental_preconfirmationTime: 200,\n  rpcUrls: {\n    default: {\n      http: ['https://sepolia-preconf.base.org'],\n    },\n  },\n})\n","import type { ChainFormatters } from '../types/chain.js'\nimport { hexToBigInt, hexToNumber } from '../utils/encoding/fromHex.js'\nimport { hexToBytes } from '../utils/encoding/toBytes.js'\nimport { toHex } from '../utils/encoding/toHex.js'\nimport { defineBlock } from '../utils/formatters/block.js'\nimport { formatLog } from '../utils/formatters/log.js'\nimport { defineTransaction } from '../utils/formatters/transaction.js'\nimport { defineTransactionReceipt } from '../utils/formatters/transactionReceipt.js'\nimport { defineTransactionRequest } from '../utils/formatters/transactionRequest.js'\nimport { gasPerPubdataDefault } from './constants/number.js'\nimport type { ZksyncBlock, ZksyncRpcBlock } from './types/block.js'\nimport type { ZksyncL2ToL1Log, ZksyncLog } from './types/log.js'\nimport type {\n  ZksyncRpcTransaction,\n  ZksyncRpcTransactionReceipt,\n  ZksyncRpcTransactionRequest,\n  ZksyncTransaction,\n  ZksyncTransactionReceipt,\n  ZksyncTransactionRequest,\n} from './types/transaction.js'\n\nexport const formatters = {\n  block: /*#__PURE__*/ defineBlock({\n    format(args: ZksyncRpcBlock): ZksyncBlock {\n      const transactions = args.transactions?.map((transaction) => {\n        if (typeof transaction === 'string') return transaction\n        const formatted = formatters.transaction?.format(\n          transaction as ZksyncRpcTransaction,\n        ) as ZksyncTransaction\n        if (formatted.typeHex === '0x71') formatted.type = 'eip712'\n        else if (formatted.typeHex === '0xff') formatted.type = 'priority'\n        return formatted\n      })\n      return {\n        l1BatchNumber: args.l1BatchNumber\n          ? hexToBigInt(args.l1BatchNumber)\n          : null,\n        l1BatchTimestamp: args.l1BatchTimestamp\n          ? hexToBigInt(args.l1BatchTimestamp)\n          : null,\n        transactions,\n      } as ZksyncBlock\n    },\n  }),\n  transaction: /*#__PURE__*/ defineTransaction({\n    format(args: ZksyncRpcTransaction): ZksyncTransaction {\n      const transaction = {} as ZksyncTransaction\n      if (args.type === '0x71') transaction.type = 'eip712'\n      else if (args.type === '0xff') transaction.type = 'priority'\n      return {\n        ...transaction,\n        l1BatchNumber: args.l1BatchNumber\n          ? hexToBigInt(args.l1BatchNumber)\n          : null,\n        l1BatchTxIndex: args.l1BatchTxIndex\n          ? hexToBigInt(args.l1BatchTxIndex)\n          : null,\n      } as ZksyncTransaction\n    },\n  }),\n  transactionReceipt: /*#__PURE__*/ defineTransactionReceipt({\n    format(args: ZksyncRpcTransactionReceipt): ZksyncTransactionReceipt {\n      return {\n        l1BatchNumber: args.l1BatchNumber\n          ? hexToBigInt(args.l1BatchNumber)\n          : null,\n        l1BatchTxIndex: args.l1BatchTxIndex\n          ? hexToBigInt(args.l1BatchTxIndex)\n          : null,\n        logs: args.logs.map((log) => {\n          return {\n            ...formatLog(log),\n            l1BatchNumber: log.l1BatchNumber\n              ? hexToBigInt(log.l1BatchNumber)\n              : null,\n            transactionLogIndex: hexToNumber(log.transactionLogIndex),\n            logType: log.logType,\n          }\n        }) as ZksyncLog[],\n        l2ToL1Logs: args.l2ToL1Logs.map((l2ToL1Log) => {\n          return {\n            blockNumber: hexToBigInt(l2ToL1Log.blockHash),\n            blockHash: l2ToL1Log.blockHash,\n            l1BatchNumber: l2ToL1Log.l1BatchNumber\n              ? hexToBigInt(l2ToL1Log.l1BatchNumber)\n              : null,\n            transactionIndex: hexToBigInt(l2ToL1Log.transactionIndex),\n            shardId: hexToBigInt(l2ToL1Log.shardId),\n            isService: l2ToL1Log.isService,\n            sender: l2ToL1Log.sender,\n            key: l2ToL1Log.key,\n            value: l2ToL1Log.value,\n            transactionHash: l2ToL1Log.transactionHash,\n            logIndex: hexToBigInt(l2ToL1Log.logIndex),\n          }\n        }) as ZksyncL2ToL1Log[],\n      } as ZksyncTransactionReceipt\n    },\n  }),\n  transactionRequest: /*#__PURE__*/ defineTransactionRequest({\n    exclude: [\n      'customSignature',\n      'factoryDeps',\n      'gasPerPubdata',\n      'paymaster',\n      'paymasterInput',\n    ],\n    format(args: ZksyncTransactionRequest): ZksyncRpcTransactionRequest {\n      if (\n        args.gasPerPubdata ||\n        (args.paymaster && args.paymasterInput) ||\n        args.factoryDeps ||\n        args.customSignature\n      )\n        return {\n          eip712Meta: {\n            ...(args.gasPerPubdata\n              ? { gasPerPubdata: toHex(args.gasPerPubdata) }\n              : { gasPerPubdata: toHex(gasPerPubdataDefault) }),\n            ...(args.paymaster && args.paymasterInput\n              ? {\n                  paymasterParams: {\n                    paymaster: args.paymaster,\n                    paymasterInput: Array.from(hexToBytes(args.paymasterInput)),\n                  },\n                }\n              : {}),\n            ...(args.factoryDeps\n              ? {\n                  factoryDeps: args.factoryDeps.map((dep) =>\n                    Array.from(hexToBytes(dep)),\n                  ),\n                }\n              : {}),\n            ...(args.customSignature\n              ? {\n                  customSignature: Array.from(hexToBytes(args.customSignature)),\n                }\n              : {}),\n          },\n          type: '0x71',\n        } as unknown as ZksyncRpcTransactionRequest\n      return {} as ZksyncRpcTransactionRequest\n    },\n  }),\n} as const satisfies ChainFormatters\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit floating-point numbers (`f32`).\n *\n * This encoder serializes `f32` values using 4 bytes.\n * Floating-point values may lose precision when encoded.\n *\n * For more details, see {@link getF32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number, 4>` for encoding `f32` values.\n *\n * @example\n * Encoding an `f32` value.\n * ```ts\n * const encoder = getF32Encoder();\n * const bytes = encoder.encode(-1.5); // 0x0000c0bf\n * ```\n *\n * @see {@link getF32Codec}\n */\nexport const getF32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'f32',\n        set: (view, value, le) => view.setFloat32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit floating-point numbers (`f32`).\n *\n * This decoder deserializes `f32` values from 4 bytes.\n * Some precision may be lost during decoding due to floating-point representation.\n *\n * For more details, see {@link getF32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `f32` values.\n *\n * @example\n * Decoding an `f32` value.\n * ```ts\n * const decoder = getF32Decoder();\n * const value = decoder.decode(new Uint8Array([0x00, 0x00, 0xc0, 0xbf])); // -1.5\n * ```\n *\n * @see {@link getF32Codec}\n */\nexport const getF32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat32(0, le),\n        name: 'f32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit floating-point numbers (`f32`).\n *\n * This codec serializes `f32` values using 4 bytes.\n * Due to the IEEE 754 floating-point representation, some precision loss may occur.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number, number, 4>` for encoding and decoding `f32` values.\n *\n * @example\n * Encoding and decoding an `f32` value.\n * ```ts\n * const codec = getF32Codec();\n * const bytes = codec.encode(-1.5); // 0x0000c0bf\n * const value = codec.decode(bytes); // -1.5\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getF32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-1.5); // 0xbfc00000\n * ```\n *\n * @remarks\n * `f32` values follow the IEEE 754 single-precision floating-point standard.\n * Precision loss may occur for certain values.\n *\n * - If you need higher precision, consider using {@link getF64Codec}.\n * - If you need integer values, consider using {@link getI32Codec} or {@link getU32Codec}.\n *\n * Separate {@link getF32Encoder} and {@link getF32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getF32Encoder().encode(-1.5);\n * const value = getF32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getF32Encoder}\n * @see {@link getF32Decoder}\n */\nexport const getF32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getF32Encoder(config), getF32Decoder(config));\n","/**\n * Centralized configuration for network capabilities.\n * This defines which methods are available on which networks.\n */\n\n/**\n * Network capabilities configuration.\n * Each network has a set of boolean flags indicating which methods are supported.\n */\nexport const NETWORK_CAPABILITIES = {\n  base: {\n    listTokenBalances: true,\n    requestFaucet: false,\n    quoteFund: true,\n    fund: true,\n    waitForFundOperationReceipt: true,\n    transfer: true,\n    sendTransaction: true,\n    quoteSwap: true,\n    swap: true,\n    useSpendPermission: true,\n  },\n  \"base-sepolia\": {\n    listTokenBalances: true,\n    requestFaucet: true,\n    quoteFund: false,\n    fund: false,\n    waitForFundOperationReceipt: false,\n    transfer: true,\n    sendTransaction: true,\n    quoteSwap: false,\n    swap: false,\n    useSpendPermission: true,\n  },\n  ethereum: {\n    listTokenBalances: true,\n    requestFaucet: false,\n    quoteFund: false, // Only base is supported for quoteFund\n    fund: false, // Only base is supported for fund\n    waitForFundOperationReceipt: false,\n    transfer: true,\n    sendTransaction: true,\n    quoteSwap: true,\n    swap: true,\n    useSpendPermission: true,\n  },\n  \"ethereum-sepolia\": {\n    listTokenBalances: false,\n    requestFaucet: true,\n    quoteFund: false,\n    fund: false,\n    waitForFundOperationReceipt: false,\n    transfer: true,\n    sendTransaction: true,\n    quoteSwap: false,\n    swap: false,\n    useSpendPermission: true,\n  },\n  \"ethereum-hoodi\": {\n    listTokenBalances: false,\n    requestFaucet: true,\n    quoteFund: false,\n    fund: false,\n    waitForFundOperationReceipt: false,\n    transfer: false,\n    sendTransaction: true, // Always available (uses wallet client for non-base networks)\n    quoteSwap: false,\n    swap: false,\n    useSpendPermission: false,\n  },\n  optimism: {\n    listTokenBalances: false,\n    requestFaucet: false,\n    quoteFund: false,\n    fund: false,\n    waitForFundOperationReceipt: false,\n    transfer: false,\n    sendTransaction: true, // Always available (uses wallet client for non-base networks)\n    quoteSwap: true,\n    swap: true,\n    useSpendPermission: true,\n  },\n  \"optimism-sepolia\": {\n    listTokenBalances: false,\n    requestFaucet: true,\n    quoteFund: false,\n    fund: false,\n    waitForFundOperationReceipt: false,\n    transfer: false,\n    sendTransaction: true, // Always available (uses wallet client for non-base networks)\n    quoteSwap: false,\n    swap: false,\n    useSpendPermission: true,\n  },\n  arbitrum: {\n    listTokenBalances: false,\n    requestFaucet: true,\n    quoteFund: false,\n    fund: false,\n    waitForFundOperationReceipt: false,\n    transfer: false,\n    sendTransaction: true, // Always available (uses wallet client for non-base networks)\n    quoteSwap: true,\n    swap: true,\n    useSpendPermission: true,\n  },\n  \"arbitrum-sepolia\": {\n    listTokenBalances: false,\n    requestFaucet: true,\n    quoteFund: false,\n    fund: false,\n    waitForFundOperationReceipt: false,\n    transfer: false,\n    sendTransaction: true, // Always available (uses wallet client for non-base networks)\n    quoteSwap: false,\n    swap: false,\n    useSpendPermission: true,\n  },\n  avalanche: {\n    listTokenBalances: false,\n    requestFaucet: false,\n    quoteFund: false,\n    fund: false,\n    waitForFundOperationReceipt: false,\n    transfer: false,\n    sendTransaction: true, // Always available (uses wallet client for non-base networks)\n    quoteSwap: false,\n    swap: false,\n    useSpendPermission: true,\n  },\n  binance: {\n    listTokenBalances: false,\n    requestFaucet: false,\n    quoteFund: false,\n    fund: false,\n    waitForFundOperationReceipt: false,\n    transfer: false,\n    sendTransaction: true, // Always available (uses wallet client for non-base networks)\n    quoteSwap: false,\n    swap: false,\n    useSpendPermission: true,\n  },\n  polygon: {\n    listTokenBalances: false,\n    requestFaucet: false,\n    quoteFund: false,\n    fund: false,\n    waitForFundOperationReceipt: false,\n    transfer: false,\n    sendTransaction: true, // Always available (uses wallet client for non-base networks)\n    quoteSwap: false,\n    swap: false,\n    useSpendPermission: true,\n  },\n  zora: {\n    listTokenBalances: false,\n    requestFaucet: false,\n    quoteFund: false,\n    fund: false,\n    waitForFundOperationReceipt: false,\n    transfer: false,\n    sendTransaction: true, // Always available (uses wallet client for non-base networks)\n    quoteSwap: false,\n    swap: false,\n    useSpendPermission: true,\n  },\n} as const;\n\n/**\n * Type for a network name from the capabilities configuration\n */\nexport type NetworkName = keyof typeof NETWORK_CAPABILITIES;\n\n/**\n * Type for method names\n */\nexport type MethodName = keyof (typeof NETWORK_CAPABILITIES)[NetworkName];\n\n/**\n * Helper to get networks that support a specific method\n *\n * @param method - The method name to check support for\n * @returns An array of network names that support the method\n */\nexport function getNetworksSupportingMethod(method: MethodName): NetworkName[] {\n  return (Object.keys(NETWORK_CAPABILITIES) as NetworkName[]).filter(\n    network => NETWORK_CAPABILITIES[network][method],\n  );\n}\n\n/**\n * Helper to check if a network supports a method\n *\n * @param method - The method name to check\n * @param network - The network name to check\n * @returns True if the network supports the method, false otherwise\n */\nexport function isMethodSupportedOnNetwork(method: MethodName, network: string): boolean {\n  const networkConfig = NETWORK_CAPABILITIES[network as NetworkName];\n  return networkConfig ? networkConfig[method] : false;\n}\n\n/**\n * Type helper to extract networks supporting a specific method\n */\nexport type NetworksSupporting<M extends MethodName> = {\n  [N in NetworkName]: (typeof NETWORK_CAPABILITIES)[N][M] extends true ? N : never;\n}[NetworkName];\n\n// Export specific network types for each method\nexport type ListTokenBalancesNetworks = NetworksSupporting<\"listTokenBalances\">;\nexport type RequestFaucetNetworks = NetworksSupporting<\"requestFaucet\">;\nexport type QuoteFundNetworks = NetworksSupporting<\"quoteFund\">;\nexport type FundNetworks = NetworksSupporting<\"fund\">;\nexport type TransferNetworks = NetworksSupporting<\"transfer\">;\nexport type SendTransactionNetworks = NetworksSupporting<\"sendTransaction\">;\nexport type QuoteSwapNetworks = NetworksSupporting<\"quoteSwap\">;\nexport type SwapNetworks = NetworksSupporting<\"swap\">;\n","import { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport { ED25519_ALGORITHM_IDENTIFIER } from './algorithm';\n\nfunction addPkcs8Header(bytes: ReadonlyUint8Array): ReadonlyUint8Array {\n    // prettier-ignore\n    return new Uint8Array([\n        /**\n         * PKCS#8 header\n         */\n        0x30, // ASN.1 sequence tag\n        0x2e, // Length of sequence (46 more bytes)\n\n            0x02, // ASN.1 integer tag\n            0x01, // Length of integer\n                0x00, // Version number\n\n            0x30, // ASN.1 sequence tag\n            0x05, // Length of sequence\n                0x06, // ASN.1 object identifier tag\n                0x03, // Length of object identifier\n                    // Edwards curve algorithms identifier https://oid-rep.orange-labs.fr/get/1.3.101.112\n                        0x2b, // iso(1) / identified-organization(3) (The first node is multiplied by the decimal 40 and the result is added to the value of the second node)\n                        0x65, // thawte(101)\n                    // Ed25519 identifier\n                        0x70, // id-Ed25519(112)\n\n        /**\n         * Private key payload\n         */\n        0x04, // ASN.1 octet string tag\n        0x22, // String length (34 more bytes)\n\n            // Private key bytes as octet string\n            0x04, // ASN.1 octet string tag\n            0x20, // String length (32 bytes)\n\n        ...bytes\n    ]);\n}\n\n/**\n * Given a private key represented as a 32-byte `Uint8Array`, creates an Ed25519 private key for use\n * with other methods in this package that accept\n * [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) objects.\n *\n * @param bytes 32 bytes that represent the private key\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the private\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import { createPrivateKeyFromBytes } from '@solana/keys';\n *\n * const privateKey = await createPrivateKeyFromBytes(new Uint8Array([...]));\n * const extractablePrivateKey = await createPrivateKeyFromBytes(new Uint8Array([...]), true);\n * ```\n */\nexport async function createPrivateKeyFromBytes(\n    bytes: ReadonlyUint8Array,\n    extractable: boolean = false,\n): Promise<CryptoKey> {\n    const actualLength = bytes.byteLength;\n    if (actualLength !== 32) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, {\n            actualLength,\n        });\n    }\n    const privateKeyBytesPkcs8 = addPkcs8Header(bytes);\n    return await crypto.subtle.importKey('pkcs8', privateKeyBytesPkcs8, ED25519_ALGORITHM_IDENTIFIER, extractable, [\n        'sign',\n    ]);\n}\n","import { downcastNodeToNumberIfBigint } from './request-transformer-bigint-downcast-internal';\nimport { getTreeWalkerRequestTransformer } from './tree-traversal';\n\n/**\n * Creates a transformer that downcasts all `BigInt` values to `Number`.\n *\n * @example\n * ```ts\n * import { getBigIntDowncastRequestTransformer } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getBigIntDowncastRequestTransformer();\n * ```\n *\n */\nexport function getBigIntDowncastRequestTransformer() {\n    return getTreeWalkerRequestTransformer([downcastNodeToNumberIfBigint], { keyPath: [] });\n}\n","import { Analytics } from \"../analytics.js\";\nimport { CdpOpenApiClient } from \"../openapi-client/index.js\";\nimport { version } from \"../version.js\";\nimport { CDPEndUserClient } from \"./end-user/endUser.js\";\nimport { EvmClient } from \"./evm/evm.js\";\nimport { PoliciesClient } from \"./policies/policies.js\";\nimport { SolanaClient } from \"./solana/solana.js\";\n\nexport interface CdpClientOptions {\n  /** The API key ID. */\n  apiKeyId?: string;\n  /** The API key secret. */\n  apiKeySecret?: string;\n  /** The wallet secret. */\n  walletSecret?: string;\n  /** Whether to enable debugging. */\n  debugging?: boolean;\n  /** The host URL to connect to. */\n  basePath?: string;\n}\n\n/**\n * The main client for interacting with the CDP API.\n */\nexport class CdpClient {\n  /** Namespace containing all EVM methods. */\n  public evm: EvmClient;\n\n  /** Namespace containing all Solana methods. */\n  public solana: SolanaClient;\n\n  /** Namespace containing all Policies methods. */\n  public policies: PoliciesClient;\n\n  /** Namespace containing all end user methods. */\n  public endUser: CDPEndUserClient;\n\n  /**\n   * The CdpClient is the main class for interacting with the CDP API.\n   *\n   * There are a few required parameters that are configured in the [CDP Portal](https://portal.cdp.coinbase.com/projects/api-keys):\n   * - **CDP Secret API Key** (`apiKeyId` & `apiKeySecret`): These are used to authenticate requests to the entire suite of\n   *   APIs offered on Coinbase Developer Platform.\n   *   [Read more about CDP API keys](https://docs.cdp.coinbase.com/get-started/docs/cdp-api-keys).\n   * - **Wallet Secret** (`walletSecret`): This secret is used specifically to authenticate requests to `POST`, and `DELETE`\n   *   endpoints in the EVM and Solana Account APIs.\n   *\n   * These parameters can be set as environment variables:\n   * ```\n   * CDP_API_KEY_ID=your-api-key-id\n   * CDP_API_KEY_SECRET=your-api-key-secret\n   * CDP_WALLET_SECRET=your-wallet-secret\n   * ```\n   *\n   * Or passed as options to the constructor:\n   *\n   * ```typescript\n   * const cdp = new CdpClient({\n   *   apiKeyId: \"your-api-key-id\",\n   *   apiKeySecret: \"your-api-key-secret\",\n   *   walletSecret: \"your-wallet-secret\",\n   * });\n   * ```\n   *\n   * The CdpClient is namespaced by chain type: `evm` or `solana`.\n   *\n   * As an example, to create a new EVM account, use `cdp.evm.createAccount()`.\n   *\n   * To create a new Solana account, use `cdp.solana.createAccount()`.\n   *\n   * @param {CdpClientOptions} [options] - Configuration options for the CdpClient.\n   */\n  constructor(options: CdpClientOptions = {}) {\n    if (Number(process.versions.node.split(\".\")[0]) < 19) {\n      throw new Error(\n        `\nNode.js version ${process.versions.node} is not supported. CDP SDK requires Node.js version 19 or higher. Please upgrade your Node.js version to use the CDP SDK.\nWe recommend using https://github.com/Schniz/fnm for managing your Node.js version.\n        `,\n      );\n    }\n\n    const apiKeyId = options.apiKeyId ?? process.env.CDP_API_KEY_ID ?? process.env.CDP_API_KEY_NAME;\n    const apiKeySecret = options.apiKeySecret ?? process.env.CDP_API_KEY_SECRET;\n    const walletSecret = options.walletSecret ?? process.env.CDP_WALLET_SECRET;\n\n    if (!apiKeyId || !apiKeySecret) {\n      throw new Error(`\n\\nMissing required CDP Secret API Key configuration parameters.\n\nYou can set them as environment variables:\n\nCDP_API_KEY_ID=your-api-key-id\nCDP_API_KEY_SECRET=your-api-key-secret\n\nYou can also pass them as options to the constructor:\n\nconst cdp = new CdpClient({\n  apiKeyId: \"your-api-key-id\",\n  apiKeySecret: \"your-api-key-secret\",\n});\n\nIf you're performing write operations, make sure to also set your wallet secret:\n\nCDP_WALLET_SECRET=your-wallet-secret\n\nThis is also available as an option to the constructor:\n\nconst cdp = new CdpClient({\n  apiKeyId: \"your-api-key-id\",\n  apiKeySecret: \"your-api-key-secret\",\n  walletSecret: \"your-wallet-secret\",\n});\n\nFor more information, see: https://github.com/coinbase/cdp-sdk/blob/main/typescript/README.md#api-keys.\n`);\n    }\n\n    CdpOpenApiClient.configure({\n      ...options,\n      apiKeyId,\n      apiKeySecret,\n      walletSecret,\n      source: \"sdk\",\n      sourceVersion: version,\n    });\n\n    if (\n      process.env.DISABLE_CDP_ERROR_REPORTING !== \"true\" ||\n      process.env.DISABLE_CDP_USAGE_TRACKING !== \"true\"\n    ) {\n      Analytics.identifier = apiKeyId;\n    }\n\n    if (process.env.DISABLE_CDP_ERROR_REPORTING !== \"true\") {\n      Analytics.wrapClassWithErrorTracking(CdpClient);\n      Analytics.wrapClassWithErrorTracking(EvmClient);\n      Analytics.wrapClassWithErrorTracking(SolanaClient);\n      Analytics.wrapClassWithErrorTracking(PoliciesClient);\n    }\n\n    this.evm = new EvmClient();\n    this.solana = new SolanaClient();\n    this.policies = new PoliciesClient();\n    this.endUser = new CDPEndUserClient();\n  }\n}\n","import type { Address } from '@solana/addresses';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Commitment, Slot } from '@solana/rpc-types';\n\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport { parseBase64RpcAccount, parseJsonRpcAccount } from './parse-account';\nimport type { GetAccountInfoApi, GetMultipleAccountsApi } from './rpc-api';\n\n/**\n * Optional configuration for fetching a singular account.\n *\n * @interface\n */\nexport type FetchAccountConfig = {\n    abortSignal?: AbortSignal;\n    /**\n     * Fetch the details of the account as of the highest slot that has reached this level of\n     * commitment.\n     *\n     * @defaultValue Whichever default is applied by the underlying {@link RpcApi} in use. For\n     * example, when using an API created by a `createSolanaRpc*()` helper, the default commitment\n     * is `\"confirmed\"` unless configured otherwise. Unmitigated by an API layer on the client, the\n     * default commitment applied by the server is `\"finalized\"`.\n     */\n    commitment?: Commitment;\n    /**\n     * Prevents accessing stale data by enforcing that the RPC node has processed transactions up to\n     * this slot\n     */\n    minContextSlot?: Slot;\n};\n\n/**\n * Fetches a {@link MaybeEncodedAccount} from the provided RPC client and address.\n *\n * It uses the {@link GetAccountInfoApi.getAccountInfo | getAccountInfo} RPC method under the hood\n * with base64 encoding and an additional configuration object can be provided to customize the\n * behavior of the RPC call.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * const myAddress = address('1234..5678');\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = await fetchEncodedAccount(rpc, myAddress);\n *\n * // With custom configuration.\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = await fetchEncodedAccount(rpc, myAddress, {\n *     abortSignal: myAbortController.signal,\n *     commitment: 'confirmed',\n * });\n * ```\n */\nexport async function fetchEncodedAccount<TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<MaybeEncodedAccount<TAddress>> {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc.getAccountInfo(address, { ...rpcConfig, encoding: 'base64' }).send({ abortSignal });\n    return parseBase64RpcAccount(address, response.value);\n}\n\n/**\n * Fetches a {@link MaybeAccount} from the provided RPC client and address by using\n * {@link GetAccountInfoApi.getAccountInfo | getAccountInfo} under the hood with the `jsonParsed`\n * encoding.\n *\n * It may also return a {@link MaybeEncodedAccount} if the RPC client does not know how to parse the\n * account at the requested address. In any case, the expected data type should be explicitly\n * provided as the first type parameter.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The expected type of this account's data.\n *\n * @example\n * ```ts\n * type TokenData = { mint: Address; owner: Address };\n * const myAccount = await fetchJsonParsedAccount<TokenData>(rpc, myAddress);\n * myAccount satisfies MaybeAccount<TokenData> | MaybeEncodedAccount;\n *\n * // With custom configuration.\n * const myAccount = await fetchJsonParsedAccount<TokenData>(rpc, myAddress, {\n *     abortSignal: myAbortController.signal,\n *     commitment: 'confirmed',\n * });\n * ```\n */\nexport async function fetchJsonParsedAccount<TData extends object, TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<MaybeAccount<TData, TAddress> | MaybeEncodedAccount<TAddress>> {\n    const { abortSignal, ...rpcConfig } = config;\n    const { value: account } = await rpc\n        .getAccountInfo(address, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return !!account && typeof account === 'object' && 'parsed' in account.data\n        ? parseJsonRpcAccount<TData, TAddress>(address, account as Parameters<typeof parseJsonRpcAccount>[1])\n        : parseBase64RpcAccount<TAddress>(address, account as Parameters<typeof parseBase64RpcAccount>[1]);\n}\n\n/**\n * Optional configuration for fetching multiple accounts.\n *\n * @interface\n */\nexport type FetchAccountsConfig = {\n    abortSignal?: AbortSignal;\n    /**\n     * Fetch the details of the accounts as of the highest slot that has reached this level of\n     * commitment.\n     *\n     * @defaultValue Whichever default is applied by the underlying {@link RpcApi} in use. For\n     * example, when using an API created by a `createSolanaRpc*()` helper, the default commitment\n     * is `\"confirmed\"` unless configured otherwise. Unmitigated by an API layer on the client, the\n     * default commitment applied by the server is `\"finalized\"`.\n     */\n    commitment?: Commitment;\n    /**\n     * Prevents accessing stale data by enforcing that the RPC node has processed transactions up to\n     * this slot\n     */\n    minContextSlot?: Slot;\n};\n\n/**\n * Fetches an array of {@link MaybeEncodedAccount | MaybeEncodedAccounts} from the provided RPC\n * client and an array of addresses.\n *\n * It uses the {@link GetMultipleAccountsApi#getMultipleAccounts | getMultipleAccounts} RPC method\n * under the hood with base64 encodings and an additional configuration object can be provided to\n * customize the behavior of the RPC call.\n *\n * @typeParam TAddresses - Supply an array of string literals to define accounts having particular\n * addresses.\n *\n * @example\n * ```ts\n * const myAddressA = address('1234..5678');\n * const myAddressB = address('8765..4321');\n * const [myAccountA, myAccountB] = await fetchEncodedAccounts(rpc, [myAddressA, myAddressB]);\n * myAccountA satisfies MaybeEncodedAccount<'1234..5678'>;\n * myAccountB satisfies MaybeEncodedAccount<'8765..4321'>;\n *\n * // With custom configuration.\n * const [myAccountA, myAccountB] = await fetchEncodedAccounts(rpc, [myAddressA, myAddressB], {\n *     abortSignal: myAbortController.signal,\n *     commitment: 'confirmed',\n * });\n * ```\n */\nexport async function fetchEncodedAccounts<\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'base64' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => parseBase64RpcAccount(addresses[index], account)) as {\n        [P in keyof TAddresses]: MaybeEncodedAccount<TAddresses[P]>;\n    };\n}\n\n/**\n * Fetches an array of {@link MaybeAccount | MaybeAccounts} from a provided RPC client and an array\n * of addresses.\n *\n * It uses the {@link GetMultipleAccountsApi#getMultipleAccounts | getMultipleAccounts} RPC method\n * under the hood with the `jsonParsed` encoding. It may also return a\n * {@link MaybeEncodedAccount} instead of the expected {@link MaybeAccount} if the RPC client does\n * not know how to parse some of the requested accounts. In any case, the array of expected data\n * types should be explicitly provided as the first type parameter.\n *\n * @typeParam TAddresses - Supply an array of string literals to define accounts having particular\n * addresses.\n * @typeParam TData - The expected types of these accounts' data.\n \n * @example\n * ```ts\n * type TokenData = { mint: Address; owner: Address };\n * type MintData = { supply: bigint };\n * const [myAccountA, myAccountB] = await fetchJsonParsedAccounts<[TokenData, MintData]>(rpc, [myAddressA, myAddressB]);\n * myAccountA satisfies MaybeAccount<TokenData> | MaybeEncodedAccount;\n * myAccountB satisfies MaybeAccount<MintData> | MaybeEncodedAccount;\n * ```\n */\nexport async function fetchJsonParsedAccounts<\n    TData extends object[],\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => {\n        return !!account && typeof account === 'object' && 'parsed' in account.data\n            ? parseJsonRpcAccount(addresses[index], account as Parameters<typeof parseJsonRpcAccount>[1])\n            : parseBase64RpcAccount(addresses[index], account as Parameters<typeof parseBase64RpcAccount>[1]);\n    }) as {\n        [P in keyof TAddresses]:\n            | MaybeAccount<TData[P & keyof TData], TAddresses[P]>\n            | MaybeEncodedAccount<TAddresses[P]>;\n    } & {\n        [P in keyof TData]:\n            | MaybeAccount<TData[P], TAddresses[P & keyof TAddresses]>\n            | MaybeEncodedAccount<TAddresses[P & keyof TAddresses]>;\n    };\n}\n","import { getBaseNodeRpcUrl } from \"./getBaseNodeRpcUrl.js\";\nimport { isMethodSupportedOnNetwork } from \"./networkCapabilities.js\";\nimport { getUserOperation } from \"../../actions/evm/getUserOperation.js\";\nimport { listTokenBalances } from \"../../actions/evm/listTokenBalances.js\";\nimport { requestFaucet } from \"../../actions/evm/requestFaucet.js\";\nimport { sendUserOperation } from \"../../actions/evm/sendUserOperation.js\";\nimport { UseSpendPermissionOptions } from \"../../actions/evm/spend-permissions/types.js\";\nimport { createSwapQuote } from \"../../actions/evm/swap/createSwapQuote.js\";\nimport { sendSwapOperation } from \"../../actions/evm/swap/sendSwapOperation.js\";\nimport { smartAccountTransferStrategy } from \"../../actions/evm/transfer/smartAccountTransferStrategy.js\";\nimport { transfer } from \"../../actions/evm/transfer/transfer.js\";\nimport { waitForUserOperation } from \"../../actions/evm/waitForUserOperation.js\";\nimport { Analytics } from \"../../analytics.js\";\n\nimport type {\n  EvmAccount,\n  EvmSmartAccount,\n  KnownEvmNetworks,\n  NetworkScopedEvmSmartAccount,\n  DistributedOmit,\n} from \"./types.js\";\nimport type { ListTokenBalancesOptions } from \"../../actions/evm/listTokenBalances.js\";\nimport type { RequestFaucetOptions } from \"../../actions/evm/requestFaucet.js\";\nimport type { SendUserOperationOptions } from \"../../actions/evm/sendUserOperation.js\";\nimport type {\n  SmartAccountQuoteSwapOptions,\n  SmartAccountSwapNetwork,\n  SmartAccountSwapOptions,\n} from \"../../actions/evm/swap/types.js\";\nimport type { SmartAccountTransferOptions } from \"../../actions/evm/transfer/types.js\";\nimport type { WaitForUserOperationOptions } from \"../../actions/evm/waitForUserOperation.js\";\nimport type { GetUserOperationOptions } from \"../../client/evm/evm.types.js\";\nimport type {\n  CdpOpenApiClientType,\n  EvmUserOperationNetwork,\n  ListEvmTokenBalancesNetwork,\n  SpendPermissionNetwork,\n} from \"../../openapi-client/index.js\";\n\n/**\n * Options for converting a pre-existing EvmSmartAccount and owner to a NetworkScopedEvmSmartAccount\n */\nexport type ToNetworkScopedEvmSmartAccountOptions = {\n  /** The pre-existing EvmSmartAccount. */\n  smartAccount: EvmSmartAccount;\n  /** The network to scope the smart account object to. */\n  network: KnownEvmNetworks;\n  /** The owner of the smart account. */\n  owner: EvmAccount;\n};\n\n/**\n * Creates a NetworkScopedEvmSmartAccount instance from an existing EvmSmartAccount and owner.\n * Use this to interact with previously deployed EvmSmartAccounts, rather than creating new ones.\n *\n * The owner must be the original owner of the evm smart account.\n *\n * @param {CdpOpenApiClientType} apiClient - The API client.\n * @param {ToNetworkScopedEvmSmartAccountOptions} options - Configuration options.\n * @param {EvmSmartAccount} options.smartAccount - The deployed evm smart account.\n * @param {EvmAccount} options.owner - The owner which signs for the smart account.\n * @param {KnownEvmNetworks} options.network - The network to scope the smart account to.\n * @returns {NetworkScopedEvmSmartAccount} A configured NetworkScopedEvmSmartAccount instance ready for user operation submission.\n */\nexport async function toNetworkScopedEvmSmartAccount<Network extends KnownEvmNetworks>(\n  apiClient: CdpOpenApiClientType,\n  options: ToNetworkScopedEvmSmartAccountOptions & { network: Network },\n): Promise<NetworkScopedEvmSmartAccount<Network>> {\n  const paymasterUrl = await (async () => {\n    if (options.network === \"base\") {\n      return getBaseNodeRpcUrl(options.network);\n    }\n    return undefined;\n  })();\n\n  const account = {\n    address: options.smartAccount.address,\n    network: options.network,\n    owners: [options.owner],\n    name: options.smartAccount.name,\n    type: \"evm-smart\",\n    sendUserOperation: async (\n      userOpOptions: Omit<SendUserOperationOptions<unknown[]>, \"smartAccount\" | \"network\">,\n    ) => {\n      Analytics.trackAction({\n        action: \"send_user_operation\",\n        accountType: \"evm_smart\",\n        properties: {\n          network: options.network,\n          managed: true,\n        },\n      });\n\n      return sendUserOperation(apiClient, {\n        ...userOpOptions,\n        smartAccount: options.smartAccount,\n        network: options.network as EvmUserOperationNetwork,\n        paymasterUrl: userOpOptions.paymasterUrl ?? paymasterUrl,\n      });\n    },\n    waitForUserOperation: async (\n      waitOptions: Omit<WaitForUserOperationOptions, \"smartAccountAddress\">,\n    ) => {\n      Analytics.trackAction({\n        action: \"wait_for_user_operation\",\n        accountType: \"evm_smart\",\n        properties: {\n          managed: true,\n        },\n      });\n\n      return waitForUserOperation(apiClient, {\n        ...waitOptions,\n        smartAccountAddress: options.smartAccount.address,\n      });\n    },\n    getUserOperation: async (getOptions: Omit<GetUserOperationOptions, \"smartAccount\">) => {\n      Analytics.trackAction({\n        action: \"get_user_operation\",\n        accountType: \"evm_smart\",\n        properties: {\n          managed: true,\n        },\n      });\n\n      return getUserOperation(apiClient, {\n        ...getOptions,\n        smartAccount: options.smartAccount,\n      });\n    },\n  } as NetworkScopedEvmSmartAccount<Network>;\n\n  if (isMethodSupportedOnNetwork(\"transfer\", options.network)) {\n    Object.assign(account, {\n      transfer: async (transferOptions: Omit<SmartAccountTransferOptions, \"network\">) => {\n        Analytics.trackAction({\n          action: \"transfer\",\n          accountType: \"evm_smart\",\n          properties: {\n            network: options.network,\n            managed: true,\n          },\n        });\n\n        return transfer(\n          apiClient,\n          options.smartAccount,\n          {\n            ...transferOptions,\n            network: options.network as EvmUserOperationNetwork,\n            paymasterUrl: transferOptions.paymasterUrl ?? paymasterUrl,\n          },\n          smartAccountTransferStrategy,\n        );\n      },\n    });\n  }\n\n  if (isMethodSupportedOnNetwork(\"listTokenBalances\", options.network)) {\n    Object.assign(account, {\n      listTokenBalances: async (\n        listOptions: Omit<ListTokenBalancesOptions, \"address\" | \"network\">,\n      ) => {\n        Analytics.trackAction({\n          action: \"list_token_balances\",\n          accountType: \"evm_smart\",\n          properties: {\n            network: options.network,\n            managed: true,\n          },\n        });\n\n        return listTokenBalances(apiClient, {\n          ...listOptions,\n          address: options.smartAccount.address,\n          network: options.network as ListEvmTokenBalancesNetwork,\n        });\n      },\n    });\n  }\n\n  if (isMethodSupportedOnNetwork(\"requestFaucet\", options.network)) {\n    Object.assign(account, {\n      requestFaucet: async (faucetOptions: Omit<RequestFaucetOptions, \"address\" | \"network\">) => {\n        Analytics.trackAction({\n          action: \"request_faucet\",\n          accountType: \"evm_smart\",\n          properties: {\n            network: options.network,\n            managed: true,\n          },\n        });\n\n        return requestFaucet(apiClient, {\n          ...faucetOptions,\n          address: options.smartAccount.address,\n          network: options.network as \"base-sepolia\" | \"ethereum-sepolia\",\n        });\n      },\n    });\n  }\n\n  if (isMethodSupportedOnNetwork(\"quoteSwap\", options.network)) {\n    Object.assign(account, {\n      quoteSwap: async (\n        quoteSwapOptions: DistributedOmit<SmartAccountQuoteSwapOptions, \"network\">,\n      ) => {\n        Analytics.trackAction({\n          action: \"quote_swap\",\n          accountType: \"evm_smart\",\n          properties: {\n            network: options.network,\n            managed: true,\n          },\n        });\n\n        return createSwapQuote(apiClient, {\n          ...quoteSwapOptions,\n          taker: options.smartAccount.address,\n          signerAddress: options.owner.address,\n          smartAccount: options.smartAccount,\n          network: options.network as SmartAccountSwapNetwork,\n        });\n      },\n    });\n  }\n\n  if (isMethodSupportedOnNetwork(\"swap\", options.network)) {\n    Object.assign(account, {\n      swap: async (swapOptions: DistributedOmit<SmartAccountSwapOptions, \"network\">) => {\n        Analytics.trackAction({\n          action: \"swap\",\n          accountType: \"evm_smart\",\n          properties: {\n            network: options.network,\n            managed: true,\n          },\n        });\n\n        /*\n         * For network-scoped accounts, we need to add the network parameter\n         * for inline swaps while preserving quote-based swaps as-is\n         */\n        const swapOptionsWithNetwork =\n          \"swapQuote\" in swapOptions\n            ? swapOptions // Quote-based swap, pass through\n            : { ...swapOptions, network: options.network as SmartAccountSwapNetwork }; // Inline swap, add network\n\n        return sendSwapOperation(apiClient, {\n          ...swapOptionsWithNetwork,\n          smartAccount: options.smartAccount,\n          taker: options.smartAccount.address,\n          signerAddress: options.owner.address,\n          paymasterUrl: swapOptions.paymasterUrl ?? paymasterUrl,\n        });\n      },\n    });\n  }\n\n  if (isMethodSupportedOnNetwork(\"useSpendPermission\", options.network)) {\n    Object.assign(account, {\n      useSpendPermission: async (\n        spendPermissionOptions: Omit<UseSpendPermissionOptions, \"network\">,\n      ) => {\n        Analytics.trackAction({\n          action: \"use_spend_permission\",\n          accountType: \"evm_smart\",\n          properties: {\n            managed: true,\n          },\n        });\n\n        return options.smartAccount.useSpendPermission({\n          ...spendPermissionOptions,\n          network: options.network as SpendPermissionNetwork,\n        });\n      },\n    });\n  }\n\n  return account;\n}\n","import { AbortController } from '@solana/event-target-impl';\nimport type { RpcTransport } from '@solana/rpc-spec';\nimport type { RpcResponse } from '@solana/rpc-spec-types';\n\ntype CoalescedRequest = {\n    readonly abortController: AbortController;\n    numConsumers: number;\n    readonly responsePromise: Promise<RpcResponse>;\n};\n\ntype GetDeduplicationKeyFn = (payload: unknown) => string | undefined;\n\n// This used to be a `Symbol()`, but there's a bug in Node <21 where the `undici` library passes\n// the `reason` property of the `AbortSignal` straight to `Error.captureStackTrace()` without first\n// typechecking it. `Error.captureStackTrace()` fatals when given a `Symbol`.\n// See https://github.com/nodejs/undici/pull/2597\nlet EXPLICIT_ABORT_TOKEN: ReturnType<typeof createExplicitAbortToken>;\nfunction createExplicitAbortToken() {\n    // This function is an annoying workaround to prevent `process.env.NODE_ENV` from appearing at\n    // the top level of this module and thwarting an optimizing compiler's attempt to tree-shake.\n    return process.env.NODE_ENV !== \"production\"\n        ? {\n              EXPLICIT_ABORT_TOKEN:\n                  'This object is thrown from the request that underlies a series of coalesced ' +\n                  'requests when the last request in that series aborts',\n          }\n        : {};\n}\n\nexport function getRpcTransportWithRequestCoalescing<TTransport extends RpcTransport>(\n    transport: TTransport,\n    getDeduplicationKey: GetDeduplicationKeyFn,\n): TTransport {\n    let coalescedRequestsByDeduplicationKey: Record<string, CoalescedRequest> | undefined;\n    return async function makeCoalescedHttpRequest<TResponse>(\n        request: Parameters<RpcTransport>[0],\n    ): Promise<RpcResponse<TResponse>> {\n        const { payload, signal } = request;\n        const deduplicationKey = getDeduplicationKey(payload);\n        if (deduplicationKey === undefined) {\n            return await transport(request);\n        }\n        if (!coalescedRequestsByDeduplicationKey) {\n            queueMicrotask(() => {\n                coalescedRequestsByDeduplicationKey = undefined;\n            });\n            coalescedRequestsByDeduplicationKey = {};\n        }\n        if (coalescedRequestsByDeduplicationKey[deduplicationKey] == null) {\n            const abortController = new AbortController();\n            const responsePromise = (async () => {\n                try {\n                    return await transport<TResponse>({\n                        ...request,\n                        signal: abortController.signal,\n                    });\n                } catch (e) {\n                    if (e === (EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken())) {\n                        // We triggered this error when the last subscriber aborted. Letting this\n                        // error bubble up from here would cause runtime fatals where there should\n                        // be none.\n                        return;\n                    }\n                    throw e;\n                }\n            })();\n            coalescedRequestsByDeduplicationKey[deduplicationKey] = {\n                abortController,\n                numConsumers: 0,\n                responsePromise,\n            };\n        }\n        const coalescedRequest = coalescedRequestsByDeduplicationKey[deduplicationKey];\n        coalescedRequest.numConsumers++;\n        if (signal) {\n            const responsePromise = coalescedRequest.responsePromise as Promise<RpcResponse<TResponse>>;\n            return await new Promise<RpcResponse<TResponse>>((resolve, reject) => {\n                const handleAbort = (e: AbortSignalEventMap['abort']) => {\n                    signal.removeEventListener('abort', handleAbort);\n                    coalescedRequest.numConsumers -= 1;\n                    queueMicrotask(() => {\n                        if (coalescedRequest.numConsumers === 0) {\n                            const abortController = coalescedRequest.abortController;\n                            abortController.abort((EXPLICIT_ABORT_TOKEN ||= createExplicitAbortToken()));\n                        }\n                    });\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                    reject((e.target as AbortSignal).reason);\n                };\n                signal.addEventListener('abort', handleAbort);\n                responsePromise\n                    .then(resolve)\n                    .catch(reject)\n                    .finally(() => {\n                        signal.removeEventListener('abort', handleAbort);\n                    });\n            });\n        } else {\n            return (await coalescedRequest.responsePromise) as RpcResponse<TResponse>;\n        }\n    } as TTransport;\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/builder/core/BaseAccountProvider.ts","import type { AbiItemType, AbiParameter } from '../../abi.js'\nimport { BaseError } from '../../errors.js'\nimport type { Modifier } from '../types/signatures.js'\n\nexport class InvalidAbiParameterError extends BaseError {\n  override name = 'InvalidAbiParameterError'\n\n  constructor({ param }: { param: string | object }) {\n    super('Failed to parse ABI parameter.', {\n      details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,\n      docsPath: '/api/human#parseabiparameter-1',\n    })\n  }\n}\n\nexport class InvalidAbiParametersError extends BaseError {\n  override name = 'InvalidAbiParametersError'\n\n  constructor({ params }: { params: string | object }) {\n    super('Failed to parse ABI parameters.', {\n      details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,\n      docsPath: '/api/human#parseabiparameters-1',\n    })\n  }\n}\n\nexport class InvalidParameterError extends BaseError {\n  override name = 'InvalidParameterError'\n\n  constructor({ param }: { param: string }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n    })\n  }\n}\n\nexport class SolidityProtectedKeywordError extends BaseError {\n  override name = 'SolidityProtectedKeywordError'\n\n  constructor({ param, name }: { param: string; name: string }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n      metaMessages: [\n        `\"${name}\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`,\n      ],\n    })\n  }\n}\n\nexport class InvalidModifierError extends BaseError {\n  override name = 'InvalidModifierError'\n\n  constructor({\n    param,\n    type,\n    modifier,\n  }: {\n    param: string\n    type?: AbiItemType | 'struct' | undefined\n    modifier: Modifier\n  }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n      metaMessages: [\n        `Modifier \"${modifier}\" not allowed${\n          type ? ` in \"${type}\" type` : ''\n        }.`,\n      ],\n    })\n  }\n}\n\nexport class InvalidFunctionModifierError extends BaseError {\n  override name = 'InvalidFunctionModifierError'\n\n  constructor({\n    param,\n    type,\n    modifier,\n  }: {\n    param: string\n    type?: AbiItemType | 'struct' | undefined\n    modifier: Modifier\n  }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n      metaMessages: [\n        `Modifier \"${modifier}\" not allowed${\n          type ? ` in \"${type}\" type` : ''\n        }.`,\n        `Data location can only be specified for array, struct, or mapping types, but \"${modifier}\" was given.`,\n      ],\n    })\n  }\n}\n\nexport class InvalidAbiTypeParameterError extends BaseError {\n  override name = 'InvalidAbiTypeParameterError'\n\n  constructor({\n    abiParameter,\n  }: {\n    abiParameter: AbiParameter & { indexed?: boolean | undefined }\n  }) {\n    super('Invalid ABI parameter.', {\n      details: JSON.stringify(abiParameter, null, 2),\n      metaMessages: ['ABI parameter type is invalid.'],\n    })\n  }\n}\n","import type { Address } from 'abitype'\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  AccountNotFoundError,\n  type AccountNotFoundErrorType,\n} from '../../errors/account.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  Authorization,\n  AuthorizationRequest,\n} from '../../types/authorization.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { PartialBy } from '../../types/utils.js'\nimport { isAddressEqual } from '../../utils/address/isAddressEqual.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { getChainId } from '../public/getChainId.js'\nimport { getTransactionCount } from '../public/getTransactionCount.js'\n\nexport type PrepareAuthorizationParameters<\n  account extends Account | undefined = Account | undefined,\n> = GetAccountParameter<account> &\n  PartialBy<AuthorizationRequest, 'chainId' | 'nonce'> & {\n    /**\n     * Whether the EIP-7702 Transaction will be executed by the EOA (signing this Authorization) or another Account.\n     *\n     * By default, it will be assumed that the EIP-7702 Transaction will\n     * be executed by another Account.\n     */\n    executor?: 'self' | Account | Address | undefined\n  }\n\nexport type PrepareAuthorizationReturnType = Authorization\n\nexport type PrepareAuthorizationErrorType =\n  | ParseAccountErrorType\n  | RequestErrorType\n  | AccountNotFoundErrorType\n  | ErrorType\n\n/**\n * Prepares an [EIP-7702 Authorization](https://eips.ethereum.org/EIPS/eip-7702) object for signing.\n * This Action will fill the required fields of the Authorization object if they are not provided (e.g. `nonce` and `chainId`).\n *\n * With the prepared Authorization object, you can use [`signAuthorization`](https://viem.sh/docs/eip7702/signAuthorization) to sign over the Authorization object.\n *\n * @param client - Client to use\n * @param parameters - {@link PrepareAuthorizationParameters}\n * @returns The prepared Authorization object. {@link PrepareAuthorizationReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { prepareAuthorization } from 'viem/experimental'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const authorization = await prepareAuthorization(client, {\n *   account: privateKeyToAccount('0x..'),\n *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n *\n * @example\n * // Account Hoisting\n * import { createClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { prepareAuthorization } from 'viem/experimental'\n *\n * const client = createClient({\n *   account: privateKeyToAccount('0x'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const authorization = await prepareAuthorization(client, {\n *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function prepareAuthorization<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: PrepareAuthorizationParameters<account>,\n): Promise<PrepareAuthorizationReturnType> {\n  const { account: account_ = client.account, chainId, nonce } = parameters\n\n  if (!account_)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/eip7702/prepareAuthorization',\n    })\n  const account = parseAccount(account_)\n\n  const executor = (() => {\n    if (!parameters.executor) return undefined\n    if (parameters.executor === 'self') return parameters.executor\n    return parseAccount(parameters.executor)\n  })()\n\n  const authorization = {\n    address: parameters.contractAddress ?? parameters.address,\n    chainId,\n    nonce,\n  } as Authorization\n\n  if (typeof authorization.chainId === 'undefined')\n    authorization.chainId =\n      client.chain?.id ??\n      (await getAction(client, getChainId, 'getChainId')({}))\n\n  if (typeof authorization.nonce === 'undefined') {\n    authorization.nonce = await getAction(\n      client,\n      getTransactionCount,\n      'getTransactionCount',\n    )({\n      address: account.address,\n      blockTag: 'pending',\n    })\n    if (\n      executor === 'self' ||\n      (executor?.address && isAddressEqual(executor.address, account.address))\n    )\n      authorization.nonce += 1\n  }\n\n  return authorization\n}\n","import { AccountLookupMeta, AccountMeta, AccountRole, Instruction } from '@solana/instructions';\nimport {\n    BaseTransactionMessage,\n    TransactionMessageWithFeePayer,\n    TransactionVersion,\n} from '@solana/transaction-messages';\n\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { TransactionMessageWithFeePayerSigner } from './fee-payer-signer';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\n\n/**\n * An extension of the {@link AccountMeta} type that allows us to store {@link TransactionSigner | TransactionSigners} inside it.\n *\n * Note that, because this type represents a signer, it must use one the following two roles:\n * - {@link AccountRole.READONLY_SIGNER}\n * - {@link AccountRole.WRITABLE_SIGNER}\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for the {@link TransactionSigner} to use within the account meta.\n *\n * @interface\n *\n * @example\n * ```ts\n * import { AccountRole } from '@solana/instructions';\n * import { generateKeyPairSigner, AccountSignerMeta } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * const account: AccountSignerMeta = {\n *     address: signer.address,\n *     role: AccountRole.READONLY_SIGNER,\n *     signer,\n * };\n * ```\n */\nexport interface AccountSignerMeta<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n> extends AccountMeta<TAddress> {\n    readonly role: AccountRole.READONLY_SIGNER | AccountRole.WRITABLE_SIGNER;\n    readonly signer: TSigner;\n}\n\n/**\n * A union type that supports base account metas as well as {@link AccountSignerMeta | signer account metas}.\n */\ntype AccountMetaWithSigner<TSigner extends TransactionSigner = TransactionSigner> =\n    | AccountLookupMeta\n    | AccountMeta\n    | AccountSignerMeta<string, TSigner>;\n\n/**\n * Composable type that allows {@link AccountSignerMeta | AccountSignerMetas} to be used inside the instruction's `accounts` array\n *\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n * @typeParam TAccounts - Optionally provide a narrower type for the account metas.\n *\n * @interface\n *\n * @example\n * ```ts\n * import { AccountRole, Instruction } from '@solana/instructions';\n * import { generateKeyPairSigner, InstructionWithSigners } from '@solana/signers';\n *\n * const [authority, buffer] = await Promise.all([\n *     generateKeyPairSigner(),\n *     generateKeyPairSigner(),\n * ]);\n * const instruction: Instruction & InstructionWithSigners = {\n *     programAddress: address('1234..5678'),\n *     accounts: [\n *         // The authority is a signer account.\n *         {\n *             address: authority.address,\n *             role: AccountRole.READONLY_SIGNER,\n *             signer: authority,\n *         },\n *         // The buffer is a writable account.\n *         { address: buffer.address, role: AccountRole.WRITABLE },\n *     ],\n * };\n * ```\n */\nexport type InstructionWithSigners<\n    TSigner extends TransactionSigner = TransactionSigner,\n    TAccounts extends readonly AccountMetaWithSigner<TSigner>[] = readonly AccountMetaWithSigner<TSigner>[],\n> = Pick<Instruction<string, TAccounts>, 'accounts'>;\n\n/**\n * A {@link BaseTransactionMessage} type extension that accept {@link TransactionSigner | TransactionSigners}.\n *\n * Namely, it allows:\n * - a {@link TransactionSigner} to be used as the fee payer and\n * - {@link InstructionWithSigners} to be used in its instructions.\n *\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n * @typeParam TAccounts - Optionally provide a narrower type for the account metas.\n *\n * @example\n * ```ts\n * import { Instruction } from '@solana/instructions';\n * import { BaseTransactionMessage } from '@solana/transaction-messages';\n * import { generateKeyPairSigner, InstructionWithSigners, TransactionMessageWithSigners } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * const firstInstruction: Instruction = { ... };\n * const secondInstruction: InstructionWithSigners = { ... };\n * const transactionMessage: BaseTransactionMessage & TransactionMessageWithSigners = {\n *     feePayer: signer,\n *     instructions: [firstInstruction, secondInstruction],\n * }\n * ```\n */\nexport type TransactionMessageWithSigners<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n    TAccounts extends readonly AccountMetaWithSigner<TSigner>[] = readonly AccountMetaWithSigner<TSigner>[],\n> = Partial<TransactionMessageWithFeePayer<TAddress> | TransactionMessageWithFeePayerSigner<TAddress, TSigner>> &\n    Pick<\n        BaseTransactionMessage<TransactionVersion, Instruction & InstructionWithSigners<TSigner, TAccounts>>,\n        'instructions'\n    >;\n\n/**\n * Extracts and deduplicates all {@link TransactionSigner | TransactionSigners} stored\n * inside the account metas of an {@link InstructionWithSigners | instruction}.\n *\n * Any extracted signers that share the same {@link Address} will be de-duplicated.\n *\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n *\n * @example\n * ```ts\n * import { InstructionWithSigners, getSignersFromInstruction } from '@solana/signers';\n *\n * const signerA = { address: address('1111..1111'), signTransactions: async () => {} };\n * const signerB = { address: address('2222..2222'), signTransactions: async () => {} };\n * const instructionWithSigners: InstructionWithSigners = {\n *     accounts: [\n *         { address: signerA.address, signer: signerA, ... },\n *         { address: signerB.address, signer: signerB, ... },\n *         { address: signerA.address, signer: signerA, ... },\n *     ],\n * };\n *\n * const instructionSigners = getSignersFromInstruction(instructionWithSigners);\n * // ^ [signerA, signerB]\n * ```\n */\nexport function getSignersFromInstruction<TSigner extends TransactionSigner = TransactionSigner>(\n    instruction: InstructionWithSigners<TSigner>,\n): readonly TSigner[] {\n    return deduplicateSigners(\n        (instruction.accounts ?? []).flatMap(account => ('signer' in account ? account.signer : [])),\n    );\n}\n\n/**\n * Extracts and deduplicates all {@link TransactionSigner | TransactionSigners} stored\n * inside a given {@link TransactionMessageWithSigners | transaction message}.\n *\n * This includes any {@link TransactionSigner | TransactionSigners} stored\n * as the fee payer or in the instructions of the transaction message.\n *\n * Any extracted signers that share the same {@link Address} will be de-duplicated.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import { Instruction } from '@solana/instructions';\n * import { InstructionWithSigners, TransactionMessageWithSigners, getSignersFromTransactionMessage } from '@solana/signers';\n *\n * const signerA = { address: address('1111..1111'), signTransactions: async () => {} };\n * const signerB = { address: address('2222..2222'), signTransactions: async () => {} };\n * const firstInstruction: Instruction & InstructionWithSigners = {\n *     programAddress: address('1234..5678'),\n *     accounts: [{ address: signerA.address, signer: signerA, ... }],\n * };\n * const secondInstruction: Instruction & InstructionWithSigners = {\n *     programAddress: address('1234..5678'),\n *     accounts: [{ address: signerB.address, signer: signerB, ... }],\n * };\n * const transactionMessage: TransactionMessageWithSigners = {\n *     feePayer: signerA,\n *     instructions: [firstInstruction, secondInstruction],\n * }\n *\n * const transactionSigners = getSignersFromTransactionMessage(transactionMessage);\n * // ^ [signerA, signerB]\n * ```\n */\nexport function getSignersFromTransactionMessage<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n    TTransactionMessage extends TransactionMessageWithSigners<TAddress, TSigner> = TransactionMessageWithSigners<\n        TAddress,\n        TSigner\n    >,\n>(transaction: TTransactionMessage): readonly TSigner[] {\n    return deduplicateSigners([\n        ...(transaction.feePayer && isTransactionSigner(transaction.feePayer) ? [transaction.feePayer as TSigner] : []),\n        ...transaction.instructions.flatMap(getSignersFromInstruction),\n    ]);\n}\n","import { ripemd160 as noble_ripemd160 } from '@noble/hashes/ripemd160'\nimport { keccak_256 as noble_keccak256 } from '@noble/hashes/sha3'\nimport { sha256 as noble_sha256 } from '@noble/hashes/sha256'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\n\n/**\n * Calculates the [Keccak256](https://en.wikipedia.org/wiki/SHA-3) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `keccak_256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef')\n * // @log: '0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1'\n * ```\n *\n * @example\n * ### Calculate Hash of a String\n *\n * ```ts twoslash\n * import { Hash, Hex } from 'ox'\n *\n * Hash.keccak256(Hex.fromString('hello world'))\n * // @log: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0'\n * ```\n *\n * @example\n * ### Configure Return Type\n *\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef', { as: 'Bytes' })\n * // @log: Uint8Array [...]\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Keccak256 hash.\n */\nexport function keccak256<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Hex.Hex | Bytes.Bytes,\n  options: keccak256.Options<as> = {},\n): keccak256.ReturnType<as> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const bytes = noble_keccak256(Bytes.from(value))\n  if (as === 'Bytes') return bytes as never\n  return Hex.fromBytes(bytes) as never\n}\n\nexport declare namespace keccak256 {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> = {\n    /** The return type. @default 'Hex' */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Calculates the [Ripemd160](https://en.wikipedia.org/wiki/RIPEMD) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `ripemd160` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.ripemd160('0xdeadbeef')\n * // '0x226821c2f5423e11fe9af68bd285c249db2e4b5a'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Ripemd160 hash.\n */\nexport function ripemd160<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Hex.Hex | Bytes.Bytes,\n  options: ripemd160.Options<as> = {},\n): ripemd160.ReturnType<as> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const bytes = noble_ripemd160(Bytes.from(value))\n  if (as === 'Bytes') return bytes as never\n  return Hex.fromBytes(bytes) as never\n}\n\nexport declare namespace ripemd160 {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> = {\n    /** The return type. @default 'Hex' */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Calculates the [Sha256](https://en.wikipedia.org/wiki/SHA-256) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `sha256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.sha256('0xdeadbeef')\n * // '0x5f78c33274e43fa9de5659265c1d917e25c03722dcb0b8d27db8d5feaa813953'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Sha256 hash.\n */\nexport function sha256<\n  value extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (value extends Hex.Hex ? 'Hex' : never)\n    | (value extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  value: value | Hex.Hex | Bytes.Bytes,\n  options: sha256.Options<as> = {},\n): sha256.ReturnType<as> {\n  const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options\n  const bytes = noble_sha256(Bytes.from(value))\n  if (as === 'Bytes') return bytes as never\n  return Hex.fromBytes(bytes) as never\n}\n\nexport declare namespace sha256 {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /** The return type. @default 'Hex' */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if a string is a valid hash value.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.validate('0x')\n * // @log: false\n *\n * Hash.validate('0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns Whether the value is a valid hash.\n */\nexport function validate(value: string): value is Hex.Hex {\n  return Hex.validate(value) && Hex.size(value) === 32\n}\n\nexport declare namespace validate {\n  type ErrorType =\n    | Hex.validate.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n","// eslint-disable-next-line import/no-named-as-default\nimport Axios, { AxiosInstance, AxiosRequestConfig } from \"axios\";\nimport axiosRetry, { exponentialDelay } from \"axios-retry\";\n\nimport { withAuth } from \"../auth/hooks/axios/index.js\";\nimport { ERROR_DOCS_PAGE_URL } from \"../constants.js\";\nimport { isOpenAPIError, APIError, UnknownError, NetworkError } from \"./errors.js\";\nimport { UserInputValidationError } from \"../errors.js\";\n\nimport type { Prettify } from \"../types/utils.js\";\n\n/**\n * The options for the CDP API.\n */\nexport type CdpOptions = {\n  /**\n   * The API key ID or the legacy API key name.\n   *\n   * Examples:\n   *  ID format: 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'\n   *  Legacy name format: 'organizations/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/apiKeys/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'\n   */\n  apiKeyId: string;\n\n  /**\n   * The API key secret, using the Ed25519 or legacy EC key format.\n   *\n   * Examples:\n   *  Ed25519 key: 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx=='\n   *  EC key: '-----BEGIN EC PRIVATE KEY-----\\n...\\n...\\n...==\\n-----END EC PRIVATE KEY-----\\n'\n   */\n  apiKeySecret: string;\n\n  /** The Wallet Secret. Only needed if calling certain Wallet APIs. */\n  walletSecret?: string;\n\n  /** If true, logs API requests and responses to the console. */\n  debugging?: boolean;\n\n  /** The base path for the API. */\n  basePath?: string;\n\n  /** The source for the API request, used for analytics. Defaults to `typescript-client`. */\n  source?: string;\n\n  /** The version of the source for the API request, used for analytics. */\n  sourceVersion?: string;\n\n  /** Optional expiration time in seconds (defaults to 120) */\n  expiresIn?: number;\n};\n\nlet axiosInstance: AxiosInstance;\n\nexport let config: Prettify<Omit<CdpOptions, \"basePath\"> & { basePath: string }> | undefined =\n  undefined;\n\n/**\n * Configures the CDP client with the given options.\n *\n * @param {CdpOptions} options - The CDP options.\n */\nexport const configure = (options: CdpOptions) => {\n  const baseURL = options.basePath || \"https://api.cdp.coinbase.com/platform\";\n\n  config = {\n    ...options,\n    basePath: baseURL,\n  };\n\n  axiosInstance = Axios.create({\n    baseURL,\n  });\n\n  axiosRetry(axiosInstance, {\n    retryDelay: exponentialDelay,\n  });\n\n  axiosInstance = withAuth(axiosInstance, {\n    apiKeyId: options.apiKeyId,\n    apiKeySecret: options.apiKeySecret,\n    source: options.source || \"sdk-openapi-client\",\n    sourceVersion: options.sourceVersion,\n    walletSecret: options.walletSecret,\n    expiresIn: options.expiresIn,\n    debug: options.debugging,\n  });\n};\n\n/**\n * Adds an idempotency key to request config if provided\n *\n * @param config - The Axios request configuration.\n * @param idempotencyKey - The idempotency key.\n * @returns The Axios request configuration with the idempotency key.\n */\nconst addIdempotencyKey = (\n  config: AxiosRequestConfig,\n  idempotencyKey?: string,\n): AxiosRequestConfig => {\n  if (!idempotencyKey) {\n    return config;\n  }\n\n  return {\n    ...config,\n    headers: {\n      ...(config.headers || {}),\n      \"X-Idempotency-Key\": idempotencyKey,\n    },\n  };\n};\n\n/**\n * Mutates the given Axios request configuration to add the CDP API key signature\n * to the request headers.\n *\n * @param {AxiosRequestConfig} config - The Axios request configuration.\n * @param idempotencyKey - The idempotency key.\n * @returns {Promise<T>} A promise that resolves to the response data.\n * @throws {APIError} If the request fails.\n */\nexport const cdpApiClient = async <T>(\n  config: AxiosRequestConfig,\n  idempotencyKey?: string,\n): Promise<T> => {\n  validateCall(config);\n\n  // Add idempotency key to the request headers if provided\n  const configWithIdempotencyKey = addIdempotencyKey(config, idempotencyKey);\n\n  try {\n    const response = await axiosInstance(configWithIdempotencyKey);\n    return response.data as T;\n  } catch (error) {\n    if (error instanceof UserInputValidationError) {\n      throw error;\n    }\n\n    // eslint-disable-next-line import/no-named-as-default-member\n    if (Axios.isAxiosError(error) && !error.response) {\n      // Network-level errors (no response received)\n      const errorMessage = (error.message || \"\").toLowerCase();\n      const errorCode = error.code?.toLowerCase();\n\n      // Categorize network errors based on error messages and codes\n      if (errorCode === \"econnrefused\" || errorMessage.includes(\"connection refused\")) {\n        throw new NetworkError(\n          \"network_connection_failed\",\n          \"Unable to connect to CDP service. The service may be unavailable.\",\n          { code: error.code, message: error.message, retryable: true },\n          error.cause,\n        );\n      } else if (\n        errorCode === \"etimedout\" ||\n        errorCode === \"econnaborted\" ||\n        errorMessage.includes(\"timeout\")\n      ) {\n        throw new NetworkError(\n          \"network_timeout\",\n          \"Request timed out. Please try again.\",\n          { code: error.code, message: error.message, retryable: true },\n          error.cause,\n        );\n      } else if (errorCode === \"enotfound\" || errorMessage.includes(\"getaddrinfo\")) {\n        throw new NetworkError(\n          \"network_dns_failure\",\n          \"DNS resolution failed. Please check your network connection.\",\n          { code: error.code, message: error.message, retryable: false },\n          error.cause,\n        );\n      } else if (errorMessage.includes(\"network error\") || errorMessage.includes(\"econnreset\")) {\n        throw new NetworkError(\n          \"network_connection_failed\",\n          \"Network error occurred. Please check your connection and try again.\",\n          { code: error.code, message: error.message, retryable: true },\n          error.cause,\n        );\n      } else {\n        // Generic network error\n        throw new NetworkError(\n          \"unknown\",\n          error.cause instanceof Error ? error.cause.message : error.message,\n          { code: error.code, message: error.message, retryable: true },\n          error.cause,\n        );\n      }\n    }\n\n    // eslint-disable-next-line import/no-named-as-default-member\n    if (Axios.isAxiosError(error) && error.response) {\n      if (isOpenAPIError(error.response.data)) {\n        throw new APIError(\n          error.response.status,\n          error.response.data.errorType,\n          error.response.data.errorMessage,\n          error.response.data.correlationId,\n          error.response.data.errorLink,\n          error.cause,\n        );\n      } else {\n        const statusCode = error.response.status;\n        const responseData = error.response.data;\n\n        // Check for gateway-level errors that might indicate network issues\n        const isGatewayError =\n          responseData &&\n          typeof responseData === \"string\" &&\n          (responseData.toLowerCase().includes(\"forbidden\") ||\n            responseData.toLowerCase().includes(\"ip\") ||\n            responseData.toLowerCase().includes(\"blocked\") ||\n            responseData.toLowerCase().includes(\"gateway\"));\n\n        switch (statusCode) {\n          case 401:\n            throw new APIError(\n              statusCode,\n              \"unauthorized\",\n              \"Unauthorized.\",\n              undefined,\n              `${ERROR_DOCS_PAGE_URL}#unauthorized`,\n              error.cause,\n            );\n          case 403:\n            // Special handling for IP blocklist and other gateway-level 403s\n            if (isGatewayError) {\n              throw new NetworkError(\n                \"network_ip_blocked\",\n                \"Access denied. Your IP address may be blocked or restricted.\",\n                {\n                  code: \"IP_BLOCKED\",\n                  message:\n                    typeof responseData === \"string\" ? responseData : JSON.stringify(responseData),\n                  retryable: false,\n                },\n                error.cause,\n              );\n            }\n            // Regular 403 forbidden error\n            throw new APIError(\n              statusCode,\n              \"unauthorized\",\n              \"Forbidden. You don't have permission to access this resource.\",\n              undefined,\n              `${ERROR_DOCS_PAGE_URL}#forbidden`,\n              error.cause,\n            );\n          case 404:\n            throw new APIError(\n              statusCode,\n              \"not_found\",\n              \"API not found.\",\n              undefined,\n              `${ERROR_DOCS_PAGE_URL}#not_found`,\n              error.cause,\n            );\n          case 502:\n            throw new APIError(\n              statusCode,\n              \"bad_gateway\",\n              \"Bad gateway.\",\n              undefined,\n              `${ERROR_DOCS_PAGE_URL}`,\n              error.cause,\n            );\n          case 503:\n            throw new APIError(\n              statusCode,\n              \"service_unavailable\",\n              \"Service unavailable. Please try again later.\",\n              undefined,\n              `${ERROR_DOCS_PAGE_URL}`,\n              error.cause,\n            );\n          default: {\n            let errorText = \"\";\n\n            if (error.response.data) {\n              try {\n                errorText = JSON.stringify(error.response.data);\n              } catch {\n                errorText = String(error.response.data);\n              }\n            }\n\n            const errorMessage = errorText\n              ? `An unexpected error occurred: ${errorText}`\n              : \"An unexpected error occurred.\";\n\n            throw new APIError(\n              statusCode,\n              \"unexpected_error\",\n              errorMessage,\n              undefined,\n              `${ERROR_DOCS_PAGE_URL}`,\n              error.cause,\n            );\n          }\n        }\n      }\n    }\n\n    throw new UnknownError(\n      \"Something went wrong. Please reach out at https://discord.com/channels/1220414409550336183/1271495764580896789 for help.\",\n      error instanceof Error ? error : undefined,\n    );\n  }\n};\n\n/**\n * Validates the call to the cdpApiClient.\n *\n * @param {AxiosRequestConfig} config - The Axios request configuration.\n * @throws {Error} If the call is not valid.\n */\nconst validateCall = (config: AxiosRequestConfig) => {\n  if (!axiosInstance.getUri() || axiosInstance.getUri() === \"\") {\n    throw new Error(\"CDP client URI not configured. Call configure() first.\");\n  }\n\n  if (!config.url || config.url === \"\") {\n    throw new Error(\"AxiosRequestConfig URL is empty. This should never happen.\");\n  }\n\n  if (!config.method || config.method === \"\") {\n    throw new Error(\"AxiosRequestConfig method is empty. This should never happen.\");\n  }\n};\n","/**\n * Describes the purpose for which an account participates in a transaction.\n *\n * Every account that participates in a transaction can be read from, but only ones that you mark as\n * writable may be written to, and only ones that you indicate must sign the transaction will gain\n * the privileges associated with signers at runtime.\n *\n * |                               | `isSigner` | `isWritable` |\n * | ----------------------------- | ---------- | ------------ |\n * | `AccountRole.READONLY`        | &#x274c;   | &#x274c;     |\n * | `AccountRole.WRITABLE`        | &#x274c;   | &#x2705;     |\n * | `AccountRole.READONLY_SIGNER` | &#x2705;   | &#x274c;     |\n * | `AccountRole.WRITABLE_SIGNER` | &#x2705;   | &#x2705;     |\n */\nexport enum AccountRole {\n    // Bitflag guide: is signer  is writable\n    WRITABLE_SIGNER = /* 3 */ 0b11, // prettier-ignore\n    READONLY_SIGNER = /* 2 */ 0b10, // prettier-ignore\n    WRITABLE =        /* 1 */ 0b01, // prettier-ignore\n    READONLY =        /* 0 */ 0b00, // prettier-ignore\n}\n\n// Quick primer on bitwise operations: https://stackoverflow.com/a/1436448/802047\nconst IS_SIGNER_BITMASK = 0b10;\nconst IS_WRITABLE_BITMASK = 0b01;\n\n/**\n * @returns An {@link AccountRole} representing the non-signer variant of the supplied role.\n */\nexport function downgradeRoleToNonSigner(role: AccountRole.READONLY_SIGNER): AccountRole.READONLY;\nexport function downgradeRoleToNonSigner(role: AccountRole.WRITABLE_SIGNER): AccountRole.WRITABLE;\nexport function downgradeRoleToNonSigner(role: AccountRole): AccountRole;\nexport function downgradeRoleToNonSigner(role: AccountRole): AccountRole {\n    return role & ~IS_SIGNER_BITMASK;\n}\n\n/**\n * @returns An {@link AccountRole} representing the read-only variant of the supplied role.\n */\nexport function downgradeRoleToReadonly(role: AccountRole.WRITABLE): AccountRole.READONLY;\nexport function downgradeRoleToReadonly(role: AccountRole.WRITABLE_SIGNER): AccountRole.READONLY_SIGNER;\nexport function downgradeRoleToReadonly(role: AccountRole): AccountRole;\nexport function downgradeRoleToReadonly(role: AccountRole): AccountRole {\n    return role & ~IS_WRITABLE_BITMASK;\n}\n\n/**\n * Returns `true` if the {@link AccountRole} given represents that of a signer. Also refines the\n * TypeScript type of the supplied role.\n */\nexport function isSignerRole(role: AccountRole): role is AccountRole.READONLY_SIGNER | AccountRole.WRITABLE_SIGNER {\n    return role >= AccountRole.READONLY_SIGNER;\n}\n\n/**\n * Returns `true` if the {@link AccountRole} given represents that of a writable account. Also\n * refines the TypeScript type of the supplied role.\n */\nexport function isWritableRole(role: AccountRole): role is AccountRole.WRITABLE | AccountRole.WRITABLE_SIGNER {\n    return (role & IS_WRITABLE_BITMASK) !== 0;\n}\n\n/**\n * Given two {@link AccountRole | AccountRoles}, will return the {@link AccountRole} that grants the\n * highest privileges of both.\n *\n * @example\n * ```ts\n * // Returns `AccountRole.WRITABLE_SIGNER`\n * mergeRoles(AccountRole.READONLY_SIGNER, AccountRole.WRITABLE);\n * ```\n */\nexport function mergeRoles(roleA: AccountRole.WRITABLE, roleB: AccountRole.READONLY_SIGNER): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY_SIGNER, roleB: AccountRole.WRITABLE): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.WRITABLE_SIGNER): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.WRITABLE_SIGNER, roleB: AccountRole): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.READONLY_SIGNER): AccountRole.READONLY_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY_SIGNER, roleB: AccountRole): AccountRole.READONLY_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.WRITABLE): AccountRole.WRITABLE; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.WRITABLE, roleB: AccountRole): AccountRole.WRITABLE; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY, roleB: AccountRole.READONLY): AccountRole.READONLY; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole): AccountRole; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole): AccountRole {\n    return roleA | roleB;\n}\n\n/**\n * @returns An {@link AccountRole} representing the signer variant of the supplied role.\n */\nexport function upgradeRoleToSigner(role: AccountRole.READONLY): AccountRole.READONLY_SIGNER;\nexport function upgradeRoleToSigner(role: AccountRole.WRITABLE): AccountRole.WRITABLE_SIGNER;\nexport function upgradeRoleToSigner(role: AccountRole): AccountRole;\nexport function upgradeRoleToSigner(role: AccountRole): AccountRole {\n    return role | IS_SIGNER_BITMASK;\n}\n\n/**\n * @returns An {@link AccountRole} representing the writable variant of the supplied role.\n */\nexport function upgradeRoleToWritable(role: AccountRole.READONLY): AccountRole.WRITABLE;\nexport function upgradeRoleToWritable(role: AccountRole.READONLY_SIGNER): AccountRole.WRITABLE_SIGNER;\nexport function upgradeRoleToWritable(role: AccountRole): AccountRole;\nexport function upgradeRoleToWritable(role: AccountRole): AccountRole {\n    return role | IS_WRITABLE_BITMASK;\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/store/store.ts","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/payment/prepareCharge.ts","import {\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Defines an offset in bytes.\n */\nexport type Offset = number;\n\n/**\n * An object that can encode a value of type {@link TFrom} into a {@link ReadonlyUint8Array}.\n *\n * This is a common interface for {@link FixedSizeEncoder} and {@link VariableSizeEncoder}.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n */\ntype BaseEncoder<TFrom> = {\n    /** Encode the provided value and return the encoded bytes directly. */\n    readonly encode: (value: TFrom) => ReadonlyUint8Array;\n    /**\n     * Writes the encoded value into the provided byte array at the given offset.\n     * Returns the offset of the next byte after the encoded value.\n     */\n    readonly write: (value: TFrom, bytes: Uint8Array, offset: Offset) => Offset;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a fixed-size {@link ReadonlyUint8Array}.\n *\n * See {@link Encoder} to learn more about creating and composing encoders.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const encoder: FixedSizeEncoder<number, 4>;\n * const bytes = encoder.encode(42);\n * const size = encoder.fixedSize; // 4\n * ```\n *\n * @see {@link Encoder}\n * @see {@link VariableSizeEncoder}\n */\nexport type FixedSizeEncoder<TFrom, TSize extends number = number> = BaseEncoder<TFrom> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a variable-size {@link ReadonlyUint8Array}.\n *\n * See {@link Encoder} to learn more about creating and composing encoders.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n *\n * @example\n * ```ts\n * const encoder: VariableSizeEncoder<string>;\n * const bytes = encoder.encode('hello');\n * const size = encoder.getSizeFromValue('hello');\n * ```\n *\n * @see {@link Encoder}\n * @see {@link FixedSizeEncoder}\n */\nexport type VariableSizeEncoder<TFrom> = BaseEncoder<TFrom> & {\n    /** Returns the size of the encoded value in bytes for a given input. */\n    readonly getSizeFromValue: (value: TFrom) => number;\n    /** The maximum possible size of an encoded value in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a {@link ReadonlyUint8Array}.\n *\n * An `Encoder` can be either:\n * - A {@link FixedSizeEncoder}, where all encoded values have the same fixed size.\n * - A {@link VariableSizeEncoder}, where encoded values can vary in size.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @example\n * Encoding a value into a new byte array.\n * ```ts\n * const encoder: Encoder<string>;\n * const bytes = encoder.encode('hello');\n * ```\n *\n * @example\n * Writing the encoded value into an existing byte array.\n * ```ts\n * const encoder: Encoder<string>;\n * const bytes = new Uint8Array(100);\n * const nextOffset = encoder.write('hello', bytes, 20);\n * ```\n *\n * @remarks\n * You may create `Encoders` manually using the {@link createEncoder} function but it is more common\n * to compose multiple `Encoders` together using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create an `Encoder` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructEncoder, addEncoderSizePrefix, getUtf8Encoder, getU32Encoder } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonEncoder = (): Encoder<Person> =>\n *     getStructEncoder([\n *         ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n *         ['age', getU32Encoder()],\n *     ]);\n * ```\n *\n * Note that composed `Encoder` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Encoder()` is\n * a fixed-size encoder, while `addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())`\n * is a variable-size encoder. This makes the final `Person` encoder a variable-size encoder.\n *\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n * @see {@link createEncoder}\n */\nexport type Encoder<TFrom> = FixedSizeEncoder<TFrom> | VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can decode a byte array into a value of type {@link TTo}.\n *\n * This is a common interface for {@link FixedSizeDecoder} and {@link VariableSizeDecoder}.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n */\ntype BaseDecoder<TTo> = {\n    /** Decodes the provided byte array at the given offset (or zero) and returns the value directly. */\n    readonly decode: (bytes: ReadonlyUint8Array | Uint8Array, offset?: Offset) => TTo;\n    /**\n     * Reads the encoded value from the provided byte array at the given offset.\n     * Returns the decoded value and the offset of the next byte after the encoded value.\n     */\n    readonly read: (bytes: ReadonlyUint8Array | Uint8Array, offset: Offset) => [TTo, Offset];\n};\n\n/**\n * An object that can decode a fixed-size byte array into a value of type {@link TTo}.\n *\n * See {@link Decoder} to learn more about creating and composing decoders.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const decoder: FixedSizeDecoder<number, 4>;\n * const value = decoder.decode(bytes);\n * const size = decoder.fixedSize; // 4\n * ```\n *\n * @see {@link Decoder}\n * @see {@link VariableSizeDecoder}\n */\nexport type FixedSizeDecoder<TTo, TSize extends number = number> = BaseDecoder<TTo> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\n/**\n * An object that can decode a variable-size byte array into a value of type {@link TTo}.\n *\n * See {@link Decoder} to learn more about creating and composing decoders.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const decoder: VariableSizeDecoder<number>;\n * const value = decoder.decode(bytes);\n * ```\n *\n * @see {@link Decoder}\n * @see {@link VariableSizeDecoder}\n */\nexport type VariableSizeDecoder<TTo> = BaseDecoder<TTo> & {\n    /** The maximum possible size of an encoded value in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can decode a byte array into a value of type {@link TTo}.\n *\n * An `Decoder` can be either:\n * - A {@link FixedSizeDecoder}, where all byte arrays have the same fixed size.\n * - A {@link VariableSizeDecoder}, where byte arrays can vary in size.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * Getting the decoded value from a byte array.\n * ```ts\n * const decoder: Decoder<string>;\n * const value = decoder.decode(bytes);\n * ```\n *\n * @example\n * Reading the decoded value from a byte array at a specific offset\n * and getting the offset of the next byte to read.\n * ```ts\n * const decoder: Decoder<string>;\n * const [value, nextOffset] = decoder.read('hello', bytes, 20);\n * ```\n *\n * @remarks\n * You may create `Decoders` manually using the {@link createDecoder} function but it is more common\n * to compose multiple `Decoders` together using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create an `Decoder` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructDecoder, addDecoderSizePrefix, getUtf8Decoder, getU32Decoder } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonDecoder = (): Decoder<Person> =>\n *     getStructDecoder([\n *         ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *         ['age', getU32Decoder()],\n *     ]);\n * ```\n *\n * Note that composed `Decoder` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Decoder()` is\n * a fixed-size decoder, while `addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())`\n * is a variable-size decoder. This makes the final `Person` decoder a variable-size decoder.\n *\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n * @see {@link createDecoder}\n */\nexport type Decoder<TTo> = FixedSizeDecoder<TTo> | VariableSizeDecoder<TTo>;\n\n/**\n * An object that can encode and decode a value to and from a fixed-size byte array.\n *\n * See {@link Codec} to learn more about creating and composing codecs.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const codec: FixedSizeCodec<number | bigint, bigint, 8>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * const size = codec.fixedSize; // 8\n * ```\n *\n * @see {@link Codec}\n * @see {@link VariableSizeCodec}\n */\nexport type FixedSizeCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number> = FixedSizeDecoder<\n    TTo,\n    TSize\n> &\n    FixedSizeEncoder<TFrom, TSize>;\n\n/**\n * An object that can encode and decode a value to and from a variable-size byte array.\n *\n * See {@link Codec} to learn more about creating and composing codecs.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const codec: VariableSizeCodec<number | bigint, bigint>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * const size = codec.getSizeFromValue(42);\n * ```\n *\n * @see {@link Codec}\n * @see {@link FixedSizeCodec}\n */\nexport type VariableSizeCodec<TFrom, TTo extends TFrom = TFrom> = VariableSizeDecoder<TTo> & VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can encode and decode a value to and from a byte array.\n *\n * A `Codec` can be either:\n * - A {@link FixedSizeCodec}, where all encoded values have the same fixed size.\n * - A {@link VariableSizeCodec}, where encoded values can vary in size.\n *\n * @example\n * ```ts\n * const codec: Codec<string>;\n * const bytes = codec.encode('hello');\n * const value = codec.decode(bytes); // 'hello'\n * ```\n *\n * @remarks\n * For convenience, codecs can encode looser types than they decode.\n * That is, type {@link TFrom} can be a superset of type {@link TTo}.\n * For instance, a `Codec<bigint | number, bigint>` can encode both\n * `bigint` and `number` values, but will always decode to a `bigint`.\n *\n * ```ts\n * const codec: Codec<bigint | number, bigint>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * It is worth noting that codecs are the union of encoders and decoders.\n * This means that a `Codec<TFrom, TTo>` can be combined from an `Encoder<TFrom>`\n * and a `Decoder<TTo>` using the {@link combineCodec} function. This is particularly\n * useful for library authors who want to expose all three types of objects to their users.\n *\n * ```ts\n * const encoder: Encoder<bigint | number>;\n * const decoder: Decoder<bigint>;\n * const codec: Codec<bigint | number, bigint> = combineCodec(encoder, decoder);\n * ```\n *\n * Aside from combining encoders and decoders, codecs can also be created from scratch using\n * the {@link createCodec} function but it is more common to compose multiple codecs together\n * using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create a `Codec` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructCodec, addCodecSizePrefix, getUtf8Codec, getU32Codec } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonCodec = (): Codec<Person> =>\n *     getStructCodec([\n *         ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n *         ['age', getU32Codec()],\n *     ]);\n * ```\n *\n * Note that composed `Codec` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Codec()` is\n * a fixed-size codec, while `addCodecSizePrefix(getUtf8Codec(), getU32Codec())`\n * is a variable-size codec. This makes the final `Person` codec a variable-size codec.\n *\n * @see {@link FixedSizeCodec}\n * @see {@link VariableSizeCodec}\n * @see {@link combineCodec}\n * @see {@link createCodec}\n */\nexport type Codec<TFrom, TTo extends TFrom = TFrom> = FixedSizeCodec<TFrom, TTo> | VariableSizeCodec<TFrom, TTo>;\n\n/**\n * Gets the encoded size of a given value in bytes using the provided encoder.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @param value - The value to be encoded.\n * @param encoder - The encoder used to determine the encoded size.\n * @returns The size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const fixedSizeEncoder = { fixedSize: 4 };\n * getEncodedSize(123, fixedSizeEncoder); // Returns 4.\n *\n * const variableSizeEncoder = { getSizeFromValue: (value: string) => value.length };\n * getEncodedSize(\"hello\", variableSizeEncoder); // Returns 5.\n * ```\n *\n * @see {@link Encoder}\n */\nexport function getEncodedSize<TFrom>(\n    value: TFrom,\n    encoder: { fixedSize: number } | { getSizeFromValue: (value: TFrom) => number },\n): number {\n    return 'fixedSize' in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\n\n/**\n * Creates an `Encoder` by filling in the missing `encode` function using the provided `write` function and\n * either the `fixedSize` property (for {@link FixedSizeEncoder | FixedSizeEncoders}) or\n * the `getSizeFromValue` function (for {@link VariableSizeEncoder | VariableSizeEncoders}).\n *\n * Instead of manually implementing `encode`, this utility leverages the existing `write` function\n * and the size helpers to generate a complete encoder. The provided `encode` method will allocate\n * a new `Uint8Array` of the correct size and use `write` to populate it.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size encoders).\n *\n * @param encoder - An encoder object that implements `write`, but not `encode`.\n * - If the encoder has a `fixedSize` property, it is treated as a {@link FixedSizeEncoder}.\n * - Otherwise, it is treated as a {@link VariableSizeEncoder}.\n *\n * @returns A fully functional `Encoder` with both `write` and `encode` methods.\n *\n * @example\n * Creating a custom fixed-size encoder.\n * ```ts\n * const encoder = createEncoder({\n *     fixedSize: 4,\n *     write: (value: number, bytes, offset) => {\n *         bytes.set(new Uint8Array([value]), offset);\n *         return offset + 4;\n *     },\n * });\n *\n * const bytes = encoder.encode(42);\n * // 0x2a000000\n * ```\n *\n * @example\n * Creating a custom variable-size encoder:\n * ```ts\n * const encoder = createEncoder({\n *     getSizeFromValue: (value: string) => value.length,\n *     write: (value: string, bytes, offset) => {\n *         const encodedValue = new TextEncoder().encode(value);\n *         bytes.set(encodedValue, offset);\n *         return offset + encodedValue.length;\n *     },\n * });\n *\n * const bytes = encoder.encode(\"hello\");\n * // 0x68656c6c6f\n * ```\n *\n * @remarks\n * Note that, while `createEncoder` is useful for defining more complex encoders, it is more common to compose\n * encoders together using the various helpers and primitives of the `@solana/codecs` package.\n *\n * Here are some alternative examples using codec primitives instead of `createEncoder`.\n *\n * ```ts\n * // Fixed-size encoder for unsigned 32-bit integers.\n * const encoder = getU32Encoder();\n * const bytes = encoder.encode(42);\n * // 0x2a000000\n *\n * // Variable-size encoder for 32-bytes prefixed UTF-8 strings.\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * const bytes = encoder.encode(\"hello\");\n * // 0x0500000068656c6c6f\n *\n * // Variable-size encoder for custom objects.\n * type Person = { name: string; age: number };\n * const encoder: Encoder<Person> = getStructEncoder([\n *     ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n *     ['age', getU32Encoder()],\n * ]);\n * const bytes = encoder.encode({ name: \"Bob\", age: 42 });\n * // 0x03000000426f622a000000\n * ```\n *\n * @see {@link Encoder}\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n * @see {@link getStructEncoder}\n * @see {@link getU32Encoder}\n * @see {@link getUtf8Encoder}\n * @see {@link addEncoderSizePrefix}\n */\nexport function createEncoder<TFrom, TSize extends number>(\n    encoder: Omit<FixedSizeEncoder<TFrom, TSize>, 'encode'>,\n): FixedSizeEncoder<TFrom, TSize>;\nexport function createEncoder<TFrom>(encoder: Omit<VariableSizeEncoder<TFrom>, 'encode'>): VariableSizeEncoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom> {\n    return Object.freeze({\n        ...encoder,\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/**\n * Creates a `Decoder` by filling in the missing `decode` function using the provided `read` function.\n *\n * Instead of manually implementing `decode`, this utility leverages the existing `read` function\n * and the size properties to generate a complete decoder. The provided `decode` method will read\n * from a `Uint8Array` at the given offset and return the decoded value.\n *\n * If the `fixedSize` property is provided, a {@link FixedSizeDecoder} will be created, otherwise\n * a {@link VariableSizeDecoder} will be created.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size decoders).\n *\n * @param decoder - A decoder object that implements `read`, but not `decode`.\n * - If the decoder has a `fixedSize` property, it is treated as a {@link FixedSizeDecoder}.\n * - Otherwise, it is treated as a {@link VariableSizeDecoder}.\n *\n * @returns A fully functional `Decoder` with both `read` and `decode` methods.\n *\n * @example\n * Creating a custom fixed-size decoder.\n * ```ts\n * const decoder = createDecoder({\n *     fixedSize: 4,\n *     read: (bytes, offset) => {\n *         const value = bytes[offset];\n *         return [value, offset + 4];\n *     },\n * });\n *\n * const value = decoder.decode(new Uint8Array([42, 0, 0, 0]));\n * // 42\n * ```\n *\n * @example\n * Creating a custom variable-size decoder:\n * ```ts\n * const decoder = createDecoder({\n *     read: (bytes, offset) => {\n *         const decodedValue = new TextDecoder().decode(bytes.subarray(offset));\n *         return [decodedValue, bytes.length];\n *     },\n * });\n *\n * const value = decoder.decode(new Uint8Array([104, 101, 108, 108, 111]));\n * // \"hello\"\n * ```\n *\n * @remarks\n * Note that, while `createDecoder` is useful for defining more complex decoders, it is more common to compose\n * decoders together using the various helpers and primitives of the `@solana/codecs` package.\n *\n * Here are some alternative examples using codec primitives instead of `createDecoder`.\n *\n * ```ts\n * // Fixed-size decoder for unsigned 32-bit integers.\n * const decoder = getU32Decoder();\n * const value = decoder.decode(new Uint8Array([42, 0, 0, 0]));\n * // 42\n *\n * // Variable-size decoder for 32-bytes prefixed UTF-8 strings.\n * const decoder = addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder());\n * const value = decoder.decode(new Uint8Array([5, 0, 0, 0, 104, 101, 108, 108, 111]));\n * // \"hello\"\n *\n * // Variable-size decoder for custom objects.\n * type Person = { name: string; age: number };\n * const decoder: Decoder<Person> = getStructDecoder([\n *     ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *     ['age', getU32Decoder()],\n * ]);\n * const value = decoder.decode(new Uint8Array([3, 0, 0, 0, 66, 111, 98, 42, 0, 0, 0]));\n * // { name: \"Bob\", age: 42 }\n * ```\n *\n * @see {@link Decoder}\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n * @see {@link getStructDecoder}\n * @see {@link getU32Decoder}\n * @see {@link getUtf8Decoder}\n * @see {@link addDecoderSizePrefix}\n */\nexport function createDecoder<TTo, TSize extends number>(\n    decoder: Omit<FixedSizeDecoder<TTo, TSize>, 'decode'>,\n): FixedSizeDecoder<TTo, TSize>;\nexport function createDecoder<TTo>(decoder: Omit<VariableSizeDecoder<TTo>, 'decode'>): VariableSizeDecoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo> {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0],\n    });\n}\n\n/**\n * Creates a `Codec` by filling in the missing `encode` and `decode` functions using the provided `write` and `read` functions.\n *\n * This utility combines the behavior of {@link createEncoder} and {@link createDecoder} to produce a fully functional `Codec`.\n * The `encode` method is derived from the `write` function, while the `decode` method is derived from the `read` function.\n *\n * If the `fixedSize` property is provided, a {@link FixedSizeCodec} will be created, otherwise\n * a {@link VariableSizeCodec} will be created.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size codecs).\n *\n * @param codec - A codec object that implements `write` and `read`, but not `encode` or `decode`.\n * - If the codec has a `fixedSize` property, it is treated as a {@link FixedSizeCodec}.\n * - Otherwise, it is treated as a {@link VariableSizeCodec}.\n *\n * @returns A fully functional `Codec` with `write`, `read`, `encode`, and `decode` methods.\n *\n * @example\n * Creating a custom fixed-size codec.\n * ```ts\n * const codec = createCodec({\n *     fixedSize: 4,\n *     read: (bytes, offset) => {\n *         const value = bytes[offset];\n *         return [value, offset + 4];\n *     },\n *     write: (value: number, bytes, offset) => {\n *         bytes.set(new Uint8Array([value]), offset);\n *         return offset + 4;\n *     },\n * });\n *\n * const bytes = codec.encode(42);\n * // 0x2a000000\n * const value = codec.decode(bytes);\n * // 42\n * ```\n *\n * @example\n * Creating a custom variable-size codec:\n * ```ts\n * const codec = createCodec({\n *     getSizeFromValue: (value: string) => value.length,\n *     read: (bytes, offset) => {\n *         const decodedValue = new TextDecoder().decode(bytes.subarray(offset));\n *         return [decodedValue, bytes.length];\n *     },\n *     write: (value: string, bytes, offset) => {\n *         const encodedValue = new TextEncoder().encode(value);\n *         bytes.set(encodedValue, offset);\n *         return offset + encodedValue.length;\n *     },\n * });\n *\n * const bytes = codec.encode(\"hello\");\n * // 0x68656c6c6f\n * const value = codec.decode(bytes);\n * // \"hello\"\n * ```\n *\n * @remarks\n * This function effectively combines the behavior of {@link createEncoder} and {@link createDecoder}.\n * If you only need to encode or decode (but not both), consider using those functions instead.\n *\n * Here are some alternative examples using codec primitives instead of `createCodec`.\n *\n * ```ts\n * // Fixed-size codec for unsigned 32-bit integers.\n * const codec = getU32Codec();\n * const bytes = codec.encode(42);\n * // 0x2a000000\n * const value = codec.decode(bytes);\n * // 42\n *\n * // Variable-size codec for 32-bytes prefixed UTF-8 strings.\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const bytes = codec.encode(\"hello\");\n * // 0x0500000068656c6c6f\n * const value = codec.decode(bytes);\n * // \"hello\"\n *\n * // Variable-size codec for custom objects.\n * type Person = { name: string; age: number };\n * const codec: Codec<PersonInput, Person> = getStructCodec([\n *     ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n *     ['age', getU32Codec()],\n * ]);\n * const bytes = codec.encode({ name: \"Bob\", age: 42 });\n * // 0x03000000426f622a000000\n * const value = codec.decode(bytes);\n * // { name: \"Bob\", age: 42 }\n * ```\n *\n * @see {@link Codec}\n * @see {@link FixedSizeCodec}\n * @see {@link VariableSizeCodec}\n * @see {@link createEncoder}\n * @see {@link createDecoder}\n * @see {@link getStructCodec}\n * @see {@link getU32Codec}\n * @see {@link getUtf8Codec}\n * @see {@link addCodecSizePrefix}\n */\nexport function createCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number>(\n    codec: Omit<FixedSizeCodec<TFrom, TTo, TSize>, 'decode' | 'encode'>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec: Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo> {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/**\n * Determines whether the given codec, encoder, or decoder is fixed-size.\n *\n * A fixed-size object is identified by the presence of a `fixedSize` property.\n * If this property exists, the object is considered a {@link FixedSizeCodec},\n * {@link FixedSizeEncoder}, or {@link FixedSizeDecoder}.\n * Otherwise, it is assumed to be a {@link VariableSizeCodec},\n * {@link VariableSizeEncoder}, or {@link VariableSizeDecoder}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @returns `true` if the object is fixed-size, `false` otherwise.\n *\n * @example\n * Checking a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * isFixedSize(encoder); // true\n * ```\n *\n * @example\n * Checking a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * isFixedSize(encoder); // false\n * ```\n *\n * @remarks\n * This function is commonly used to distinguish between fixed-size and variable-size objects at runtime.\n * If you need to enforce this distinction with type assertions, consider using {@link assertIsFixedSize}.\n *\n * @see {@link assertIsFixedSize}\n */\nexport function isFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function isFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): decoder is FixedSizeDecoder<TTo, TSize>;\nexport function isFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function isFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): codec is { fixedSize: TSize };\nexport function isFixedSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { fixedSize: number } {\n    return 'fixedSize' in codec && typeof codec.fixedSize === 'number';\n}\n\n/**\n * Asserts that the given codec, encoder, or decoder is fixed-size.\n *\n * If the object is not fixed-size (i.e., it lacks a `fixedSize` property),\n * this function throws a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @throws {SolanaError} If the object is not fixed-size.\n *\n * @example\n * Asserting a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * assertIsFixedSize(encoder); // Passes\n * ```\n *\n * @example\n * Attempting to assert a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * assertIsFixedSize(encoder); // Throws SolanaError\n * ```\n *\n * @remarks\n * This function is the assertion-based counterpart of {@link isFixedSize}.\n * If you only need to check whether an object is fixed-size without throwing an error, use {@link isFixedSize} instead.\n *\n * @see {@link isFixedSize}\n */\nexport function assertIsFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): asserts encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function assertIsFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): asserts decoder is FixedSizeDecoder<TTo, TSize>;\nexport function assertIsFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): asserts codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function assertIsFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): asserts codec is { fixedSize: TSize };\nexport function assertIsFixedSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { fixedSize: number } {\n    if (!isFixedSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\n\n/**\n * Determines whether the given codec, encoder, or decoder is variable-size.\n *\n * A variable-size object is identified by the absence of a `fixedSize` property.\n * If this property is missing, the object is considered a {@link VariableSizeCodec},\n * {@link VariableSizeEncoder}, or {@link VariableSizeDecoder}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @returns `true` if the object is variable-size, `false` otherwise.\n *\n * @example\n * Checking a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * isVariableSize(encoder); // true\n * ```\n *\n * @example\n * Checking a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * isVariableSize(encoder); // false\n * ```\n *\n * @remarks\n * This function is the inverse of {@link isFixedSize}.\n *\n * @see {@link isFixedSize}\n * @see {@link assertIsVariableSize}\n */\nexport function isVariableSize<TFrom>(encoder: Encoder<TFrom>): encoder is VariableSizeEncoder<TFrom>;\nexport function isVariableSize<TTo>(decoder: Decoder<TTo>): decoder is VariableSizeDecoder<TTo>;\nexport function isVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): codec is VariableSizeCodec<TFrom, TTo>;\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number };\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number } {\n    return !isFixedSize(codec);\n}\n\n/**\n * Asserts that the given codec, encoder, or decoder is variable-size.\n *\n * If the object is not variable-size (i.e., it has a `fixedSize` property),\n * this function throws a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @throws {SolanaError} If the object is not variable-size.\n *\n * @example\n * Asserting a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * assertIsVariableSize(encoder); // Passes\n * ```\n *\n * @example\n * Attempting to assert a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * assertIsVariableSize(encoder); // Throws SolanaError\n * ```\n *\n * @remarks\n * This function is the assertion-based counterpart of {@link isVariableSize}.\n * If you only need to check whether an object is variable-size without throwing an error, use {@link isVariableSize} instead.\n *\n * Also note that this function is the inverse of {@link assertIsFixedSize}.\n *\n * @see {@link isVariableSize}\n * @see {@link assertIsFixedSize}\n */\nexport function assertIsVariableSize<TFrom>(encoder: Encoder<TFrom>): asserts encoder is VariableSizeEncoder<TFrom>;\nexport function assertIsVariableSize<TTo>(decoder: Decoder<TTo>): asserts decoder is VariableSizeDecoder<TTo>;\nexport function assertIsVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): asserts codec is VariableSizeCodec<TFrom, TTo>;\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number };\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number } {\n    if (!isVariableSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\n","import { encodeAbiParameters, encodePacked, hashTypedData, sliceHex } from \"viem\";\n\nimport type { EvmSmartAccount } from \"../../accounts/evm/types.js\";\nimport type {\n  CdpOpenApiClientType,\n  EIP712Message as OpenApiEIP712Message,\n} from \"../../openapi-client/index.js\";\nimport type { EIP712Message, Hex } from \"../../types/misc.js\";\n\n/**\n * Options for signing and wrapping EIP-712 typed data with a smart account.\n */\nexport interface SignAndWrapTypedDataForSmartAccountOptions {\n  /** The smart account to sign with. */\n  smartAccount: EvmSmartAccount;\n  /** The chain ID for the signature (used for replay protection). */\n  chainId: bigint;\n  /** The EIP-712 typed data message to sign. */\n  typedData: EIP712Message;\n  /** The index of the owner to sign with (defaults to 0). */\n  ownerIndex?: bigint;\n  /** Optional idempotency key for the signing request. */\n  idempotencyKey?: string;\n}\n\n/**\n * Result of signing and wrapping typed data for a smart account.\n */\nexport interface SignAndWrapTypedDataForSmartAccountResult {\n  /** The signature ready for smart contract use. */\n  signature: Hex;\n}\n\n/**\n * Signs and wraps an EIP-712 message for a smart account using the required Coinbase Smart Wallet signature format.\n *\n * **Important: Coinbase Smart Wallet Contract Requirements**\n *\n * Due to the Coinbase Smart Wallet contract implementation (ERC-1271), CDP Smart Wallets have\n * specific requirements for EIP-712 message signing:\n *\n * 1. **Replay-Safe Hashing**: All typed messages must be wrapped in a replay-safe hash that\n *    includes the chain ID and smart account address. This prevents the same signature from\n *    being valid across different chains or accounts.\n *\n * 2. **Signature Wrapping**: The resulting signature must be wrapped in a `SignatureWrapper`\n *    struct that identifies which owner signed and contains the signature data in the format\n *    expected by the smart contract's `isValidSignature()` method.\n *\n * This function handles both requirements automatically, making it safe and convenient for\n * developers to sign EIP-712 messages with CDP Smart Wallets.\n *\n * @param {CdpOpenApiClientType} client - The CDP API client\n * @param {SignAndWrapTypedDataForSmartAccountOptions} options - Parameters for signing and wrapping the EIP-712 message.\n * @returns A promise that resolves to the signature that can be used with smart contracts.\n *\n * @example\n * ```ts\n * const result = await signAndWrapTypedDataForSmartAccount(client, {\n *   smartAccount: smartAccount,\n *   chainId: 1n,\n *   typedData: {\n *     domain: {\n *       name: \"Permit2\",\n *       chainId: 1,\n *       verifyingContract: \"0x000000000022D473030F116dDEE9F6B43aC78BA3\",\n *     },\n *     types: {\n *       EIP712Domain: [\n *         { name: \"name\", type: \"string\" },\n *         { name: \"chainId\", type: \"uint256\" },\n *         { name: \"verifyingContract\", type: \"address\" },\n *       ],\n *       PermitTransferFrom: [\n *         { name: \"permitted\", type: \"TokenPermissions\" },\n *         { name: \"spender\", type: \"address\" },\n *         { name: \"nonce\", type: \"uint256\" },\n *         { name: \"deadline\", type: \"uint256\" },\n *       ],\n *       TokenPermissions: [\n *         { name: \"token\", type: \"address\" },\n *         { name: \"amount\", type: \"uint256\" },\n *       ],\n *     },\n *     primaryType: \"PermitTransferFrom\",\n *     message: {\n *       permitted: {\n *         token: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n *         amount: \"1000000\",\n *       },\n *       spender: \"0xFfFfFfFFfFFfFFfFFfFFFFFffFFFffffFfFFFfFf\",\n *       nonce: \"0\",\n *       deadline: \"1717123200\",\n *     },\n *   },\n * });\n *\n * // Use result.signature for smart contract calls\n * console.log(`Signature: ${result.signature}`);\n * ```\n */\nexport async function signAndWrapTypedDataForSmartAccount(\n  client: CdpOpenApiClientType,\n  options: SignAndWrapTypedDataForSmartAccountOptions,\n): Promise<SignAndWrapTypedDataForSmartAccountResult> {\n  const { smartAccount, chainId, typedData, ownerIndex = 0n } = options;\n\n  // Create the replay-safe typed data\n  const replaySafeTypedData = createReplaySafeTypedData({\n    typedData,\n    chainId,\n    smartAccountAddress: smartAccount.address as Hex,\n  });\n\n  // Sign the replay-safe typed data with the smart account owner\n  const owner = smartAccount.owners[Number(ownerIndex)];\n  const signature = await client.signEvmTypedData(\n    owner.address,\n    replaySafeTypedData,\n    options.idempotencyKey,\n  );\n\n  // Wrap the signature in the format expected by the smart contract\n  const wrappedSignature = createSmartAccountSignatureWrapper({\n    signatureHex: signature.signature as Hex,\n    ownerIndex,\n  });\n\n  return {\n    signature: wrappedSignature as Hex,\n  };\n}\n\n/**\n * Creates a replay-safe EIP-712 typed data structure by wrapping the original typed data with\n * chain ID and smart account address.\n *\n * **Coinbase Smart Wallet Requirement**: Due to the Coinbase Smart Wallet contract's ERC-1271\n * implementation, all EIP-712 messages must be wrapped in a replay-safe hash before signing.\n * This prevents signature replay attacks across different chains or smart account addresses.\n *\n * The smart contract's `isValidSignature()` method expects signatures to be validated against\n * this replay-safe hash, not the original message hash.\n *\n * @param params - The replay-safe hash parameters\n * @param params.typedData - The original EIP-712 typed data to make replay-safe\n * @param params.chainId - The chain ID for replay protection\n * @param params.smartAccountAddress - The smart account address for additional context\n * @returns The EIP-712 typed data structure for the replay-safe hash\n */\nexport function createReplaySafeTypedData({\n  typedData,\n  chainId,\n  smartAccountAddress,\n}: {\n  typedData: EIP712Message;\n  chainId: bigint;\n  smartAccountAddress: Hex;\n}): OpenApiEIP712Message {\n  // First hash the original typed data\n  const originalHash = hashTypedData(typedData);\n\n  // Create and return the replay-safe typed data structure\n  return {\n    domain: {\n      name: \"Coinbase Smart Wallet\",\n      version: \"1\",\n      chainId: Number(chainId),\n      verifyingContract: smartAccountAddress,\n    },\n    types: {\n      EIP712Domain: [\n        { name: \"name\", type: \"string\" },\n        { name: \"version\", type: \"string\" },\n        { name: \"chainId\", type: \"uint256\" },\n        { name: \"verifyingContract\", type: \"address\" },\n      ],\n      CoinbaseSmartWalletMessage: [{ name: \"hash\", type: \"bytes32\" }],\n    },\n    primaryType: \"CoinbaseSmartWalletMessage\" as const,\n    message: {\n      hash: originalHash,\n    },\n  };\n}\n\n/**\n * Builds a signature wrapper for Coinbase Smart Wallets by decomposing a hex signature\n * into r, s, v components and encoding them in the format expected by the smart contract.\n *\n * All signatures on Coinbase Smart Wallets must be wrapped in this format to identify\n * which owner signed and provide the signature data.\n *\n * @param params - The signature parameters\n * @param params.signatureHex - The hex signature to wrap (65 bytes: r + s + v)\n * @param params.ownerIndex - The index of the owner that signed (from MultiOwnable.ownerAtIndex)\n * @returns The encoded signature wrapper in the format expected by the smart contract\n */\nexport function createSmartAccountSignatureWrapper({\n  signatureHex,\n  ownerIndex,\n}: {\n  signatureHex: Hex;\n  ownerIndex: bigint;\n}): Hex {\n  // Decompose 65-byte hex signature into r (32 bytes), s (32 bytes), v (1 byte)\n  const r = sliceHex(signatureHex, 0, 32);\n  const s = sliceHex(signatureHex, 32, 64);\n  const v = Number(`0x${signatureHex.slice(130, 132)}`); // 130 = 2 + 64 + 64\n\n  const signatureData = encodePacked([\"bytes32\", \"bytes32\", \"uint8\"], [r, s, v]);\n\n  return encodeAbiParameters(\n    [SignatureWrapperStruct],\n    [\n      {\n        ownerIndex: Number(ownerIndex),\n        signatureData,\n      },\n    ],\n  ) as Hex;\n}\n\n/**\n * The ABI structure for the SignatureWrapper struct expected by Coinbase Smart Wallets.\n * This matches the struct defined in the smart contract:\n *\n * struct SignatureWrapper {\n *   uint256 ownerIndex;\n *   bytes signatureData;\n * }\n */\nconst SignatureWrapperStruct = {\n  components: [\n    {\n      name: \"ownerIndex\",\n      type: \"uint8\",\n    },\n    {\n      name: \"signatureData\",\n      type: \"bytes\",\n    },\n  ],\n  name: \"SignatureWrapper\",\n  type: \"tuple\",\n} as const;\n","import { RpcResponse } from '@solana/rpc-spec-types';\n\ntype Config = Readonly<{\n    /** A value of arbitrary type to be sent to a RPC server */\n    payload: unknown;\n    /**\n     * An optional `AbortSignal` on which the `'abort'` event will be fired if the request should be\n     * cancelled.\n     */\n    signal?: AbortSignal;\n}>;\n\n/**\n * A function that can act as a transport for a {@link Rpc}. It need only return a promise for a\n * response given the supplied config.\n */\nexport type RpcTransport = {\n    <TResponse>(config: Config): Promise<RpcResponse<TResponse>>;\n};\n\n/**\n * Returns `true` if the given payload is a JSON RPC v2 payload.\n *\n * This means, the payload is an object such that:\n *\n * - It has a `jsonrpc` property with a value of `'2.0'`.\n * - It has a `method` property that is a string.\n * - It has a `params` property of any type.\n *\n * @example\n * ```ts\n * import { isJsonRpcPayload } from '@solana/rpc-spec';\n *\n * if (isJsonRpcPayload(payload)) {\n *     const payloadMethod: string = payload.method;\n *     const payloadParams: unknown = payload.params;\n * }\n * ```\n */\nexport function isJsonRpcPayload(payload: unknown): payload is Readonly<{\n    jsonrpc: '2.0';\n    method: string;\n    params: unknown;\n}> {\n    if (payload == null || typeof payload !== 'object' || Array.isArray(payload)) {\n        return false;\n    }\n    return (\n        'jsonrpc' in payload &&\n        payload.jsonrpc === '2.0' &&\n        'method' in payload &&\n        typeof payload.method === 'string' &&\n        'params' in payload\n    );\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/payment/charge.ts","import { SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, SolanaError } from '@solana/errors';\n\n/**\n * A union of all possible commitment statuses -- each a measure of the network confirmation and\n * stake levels on a particular block.\n *\n * Read more about the statuses themselves, [here](https://docs.solana.com/cluster/commitments).\n */\nexport type Commitment = 'confirmed' | 'finalized' | 'processed';\n\nfunction getCommitmentScore(commitment: Commitment): number {\n    switch (commitment) {\n        case 'finalized':\n            return 2;\n        case 'confirmed':\n            return 1;\n        case 'processed':\n            return 0;\n        default:\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                unexpectedValue: commitment satisfies never,\n            });\n    }\n}\n\nexport function commitmentComparator(a: Commitment, b: Commitment): -1 | 0 | 1 {\n    if (a === b) {\n        return 0;\n    }\n    return getCommitmentScore(a) < getCommitmentScore(b) ? -1 : 1;\n}\n","import { concat, numberToHex, size } from \"viem\";\n\nimport { createSwapQuote } from \"./createSwapQuote.js\";\nimport { createDeterministicUuidV4 } from \"../../../utils/uuidV4.js\";\nimport { sendTransaction } from \"../sendTransaction.js\";\n\nimport type { SendSwapTransactionOptions, SendSwapTransactionResult } from \"./types.js\";\nimport type {\n  CreateSwapQuoteResult,\n  CreateSwapQuoteOptions,\n  SwapUnavailableResult,\n} from \"../../../client/evm/evm.types.js\";\nimport type {\n  CdpOpenApiClientType,\n  SendEvmTransactionBodyNetwork,\n} from \"../../../openapi-client/index.js\";\nimport type { Hex } from \"../../../types/misc.js\";\nimport type { TransactionRequestEIP1559 } from \"viem\";\n\n/**\n * Sends a swap transaction to the blockchain.\n * Handles any permit2 signatures required for the swap.\n *\n * If you encounter token allowance issues, you'll need to perform a token approval transaction first to allow\n * the Permit2 contract to spend the appropriate amount of your fromToken.\n * See `examples/typescript/evm/account.sendSwapTransaction.ts` for example code on handling token approvals.\n *\n * @param {CdpOpenApiClientType} client - The client to use for sending the swap.\n * @param {SendSwapTransactionOptions} options - The options for the swap submission.\n *\n * @returns {Promise<SendSwapTransactionResult>} A promise that resolves to the transaction hash.\n *\n * @throws {Error} If liquidity is not available for the swap.\n * @throws {Error} If there are insufficient token allowances. In this case, you need to approve the\n *                 Permit2 contract to spend your tokens before attempting the swap. The error message\n *                 will include the current allowance and the spender address that needs approval.\n * @throws {Error} If no transaction data is found in the swap result.\n *\n * @example **Sending a swap with pre-created swap quote object**\n * ```ts\n * // First create a swap quote\n * const swapQuote = await cdp.evm.createSwapQuote({\n *   network: \"base\",\n *   toToken: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\", // USDC\n *   fromToken: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\", // WETH\n *   fromAmount: BigInt(\"1000000000000000000\"), // 1 WETH in wei\n *   taker: account.address\n * });\n *\n * // Check if liquidity is available\n * if (!swapQuote.liquidityAvailable) {\n *   console.error(\"Insufficient liquidity for swap\");\n *   return;\n * }\n *\n * // Send the swap\n * const result = await sendSwapTransaction(client, {\n *   address: account.address,\n *   swapQuote: swapQuote\n * });\n *\n * console.log(`Swap sent with transaction hash: ${result.transactionHash}`);\n * ```\n *\n * @example **Sending a swap with inline options (all-in-one)**\n * ```ts\n * // Send swap in one call\n * const result = await sendSwapTransaction(client, {\n *   address: account.address,\n *   network: \"base\",\n *   toToken: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\", // USDC\n *   fromToken: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\", // WETH\n *   fromAmount: BigInt(\"1000000000000000000\"), // 1 WETH in wei\n *   taker: account.address\n * });\n *\n * console.log(`Swap sent with transaction hash: ${result.transactionHash}`);\n * ```\n */\nexport async function sendSwapTransaction(\n  client: CdpOpenApiClientType,\n  options: SendSwapTransactionOptions,\n): Promise<SendSwapTransactionResult> {\n  const { address, idempotencyKey } = options;\n\n  let swapResult: CreateSwapQuoteResult | SwapUnavailableResult;\n\n  // Determine if we need to create the swap quote or use the provided one\n  if (\"swapQuote\" in options) {\n    // Use the provided swap quote\n    swapResult = options.swapQuote;\n  } else {\n    // Create the swap quote using the provided options (InlineSendSwapTransactionOptions)\n    /**\n     * Deterministically derive a new idempotency key from the provided idempotency key for swap quote creation to avoid key reuse.\n     */\n    const swapQuoteIdempotencyKey = idempotencyKey\n      ? createDeterministicUuidV4(idempotencyKey, \"createSwapQuote\")\n      : undefined;\n\n    swapResult = await createSwapQuote(client, {\n      network: options.network as CreateSwapQuoteOptions[\"network\"],\n      toToken: options.toToken,\n      fromToken: options.fromToken,\n      fromAmount: options.fromAmount,\n      taker: options.taker,\n      signerAddress: options.signerAddress,\n      gasPrice: options.gasPrice,\n      slippageBps: options.slippageBps,\n      idempotencyKey: swapQuoteIdempotencyKey,\n    });\n  }\n\n  // Check if liquidity is available\n  if (!swapResult.liquidityAvailable) {\n    throw new Error(\"Insufficient liquidity for swap\");\n  }\n\n  // At this point, we know that swapResult is CreateSwapQuoteResult\n  const swap = swapResult as CreateSwapQuoteResult;\n\n  // Check for allowance issues\n  if (swap.issues?.allowance) {\n    const { currentAllowance, spender } = swap.issues.allowance;\n    throw new Error(\n      `Insufficient token allowance for swap. Current allowance: ${currentAllowance}. ` +\n        `Please approve the Permit2 contract (${spender}) to spend your tokens.`,\n    );\n  }\n\n  // If the transaction doesn't exist, throw an error\n  if (!swap.transaction) {\n    throw new Error(\"No transaction data found in the swap\");\n  }\n\n  // Get the transaction data and modify it if needed for Permit2\n  let txData = swap.transaction.data as Hex;\n\n  if (swap.permit2?.eip712) {\n    /**\n     * Sign the Permit2 EIP-712 message.\n     * Deterministically derive a new idempotency key from the provided idempotency key for permit2 signing to avoid key reuse.\n     */\n    const permit2IdempotencyKey = idempotencyKey\n      ? createDeterministicUuidV4(idempotencyKey, \"permit2\")\n      : undefined;\n\n    const signature = await client.signEvmTypedData(\n      address,\n      {\n        domain: swap.permit2.eip712.domain,\n        types: swap.permit2.eip712.types,\n        primaryType: swap.permit2.eip712.primaryType,\n        message: swap.permit2.eip712.message,\n      },\n      permit2IdempotencyKey,\n    );\n\n    // Calculate the signature length as a 32-byte hex value\n    const signatureLengthInHex = numberToHex(size(signature.signature as Hex), {\n      signed: false,\n      size: 32,\n    });\n\n    // Append the signature length and signature to the transaction data\n    txData = concat([txData, signatureLengthInHex, signature.signature as Hex]);\n  }\n\n  // Create a transaction object\n  const transaction: TransactionRequestEIP1559 = {\n    to: swap.transaction.to as `0x${string}`,\n    data: txData,\n    // Only include these properties if they exist\n    ...(swap.transaction.value ? { value: BigInt(swap.transaction.value) } : {}),\n    ...(swap.transaction.gas ? { gas: BigInt(swap.transaction.gas) } : {}),\n  };\n\n  // Use sendTransaction instead of directly calling client.sendEvmTransaction\n  const result = await sendTransaction(client, {\n    address,\n    network: swap.network as SendEvmTransactionBodyNetwork,\n    transaction,\n    idempotencyKey,\n  });\n\n  return {\n    transactionHash: result.transactionHash,\n  };\n}\n","import { Abi, Address } from \"abitype/zod\";\nimport { z } from \"zod\";\n\n/**\n * Enum for EthValueOperator values\n */\nexport const EthValueOperatorEnum = z.enum([\">\", \">=\", \"<\", \"<=\", \"==\"]);\n/**\n * Type representing the operators that can be used for ETH value comparisons.\n * These operators determine how transaction values are compared against thresholds.\n */\nexport type EthValueOperator = z.infer<typeof EthValueOperatorEnum>;\n\n/**\n * Enum for EvmAddressOperator values\n */\nexport const EvmAddressOperatorEnum = z.enum([\"in\", \"not in\"]);\n/**\n * Type representing the operators that can be used for EVM address comparisons.\n * These operators determine how transaction recipient addresses are evaluated against a list.\n */\nexport type EvmAddressOperator = z.infer<typeof EvmAddressOperatorEnum>;\n\n/**\n * Enum for EvmNetworkOperator values\n */\nexport const EvmNetworkOperatorEnum = z.enum([\"in\", \"not in\"]);\n/**\n * Type representing the operators that can be used for EVM network comparisons.\n * These operators determine how the transaction's network is evaluated against a list.\n */\nexport type EvmNetworkOperator = z.infer<typeof EvmNetworkOperatorEnum>;\n\n/**\n * Schema for ETH value criterions\n */\nexport const EthValueCriterionSchema = z.object({\n  /** The type of criterion, must be \"ethValue\" for Ethereum value-based rules. */\n  type: z.literal(\"ethValue\"),\n  /**\n   * The ETH value amount in wei to compare against, as a string.\n   * Must contain only digits.\n   */\n  ethValue: z.string().regex(/^[0-9]+$/),\n  /** The comparison operator to use for evaluating transaction values against the threshold. */\n  operator: EthValueOperatorEnum,\n});\nexport type EthValueCriterion = z.infer<typeof EthValueCriterionSchema>;\n\n/**\n * Schema for EVM address criterions\n */\nexport const EvmAddressCriterionSchema = z.object({\n  /** The type of criterion, must be \"evmAddress\" for EVM address-based rules. */\n  type: z.literal(\"evmAddress\"),\n  /**\n   * Array of EVM addresses to compare against.\n   * Each address must be a 0x-prefixed 40-character hexadecimal string.\n   * Limited to a maximum of 300 addresses per criterion.\n   */\n  addresses: z.array(Address).max(300),\n  /**\n   * The operator to use for evaluating transaction addresses.\n   * \"in\" checks if an address is in the provided list.\n   * \"not in\" checks if an address is not in the provided list.\n   */\n  operator: EvmAddressOperatorEnum,\n});\nexport type EvmAddressCriterion = z.infer<typeof EvmAddressCriterionSchema>;\n\n/**\n * Enum for  PrepareUserOperation EVM Network values\n */\nexport const PrepareUserOperationEvmNetworkEnum = z.enum([\n  \"base-sepolia\",\n  \"base\",\n  \"arbitrum\",\n  \"optimism\",\n  \"zora\",\n  \"polygon\",\n  \"bnb\",\n  \"avalanche\",\n  \"ethereum\",\n  \"ethereum-sepolia\",\n]);\n\nexport type PrepareUserOperationEvmNetwork = z.infer<typeof PrepareUserOperationEvmNetworkEnum>;\n\n/**\n * Enum for SendEvmTransaction EVM Network values\n */\nexport const SendEvmTransactionEvmNetworkEnum = z.enum([\n  \"base\",\n  \"base-sepolia\",\n  \"ethereum\",\n  \"ethereum-sepolia\",\n  \"avalanche\",\n  \"polygon\",\n  \"optimism\",\n  \"arbitrum\",\n]);\n\n/**\n * Type representing the valid networks used with CDP transaction API's.\n */\nexport type EvmNetwork = z.ZodUnion<\n  [typeof SendEvmTransactionEvmNetworkEnum, typeof PrepareUserOperationEvmNetworkEnum]\n>;\n\n/**\n * Schema for EVM network criterions\n */\nexport const SendEvmTransactionEvmNetworkCriterionSchema = z.object({\n  /** The type of criterion, must be \"evmAddress\" for EVM address-based rules. */\n  type: z.literal(\"evmNetwork\"),\n  /**\n   * Array of EVM network identifiers to compare against.\n   * Either \"base\", \"base-sepolia\", \"ethereum\", \"ethereum-sepolia\", \"avalanche\", \"polygon\", \"optimism\", \"arbitrum\"\n   */\n  networks: z.array(SendEvmTransactionEvmNetworkEnum),\n  /**\n   * The operator to use for evaluating transaction network.\n   * \"in\" checks if a network is in the provided list.\n   * \"not in\" checks if a network is not in the provided list.\n   */\n  operator: EvmNetworkOperatorEnum,\n});\n\nexport const PrepareUserOperationEvmNetworkCriterionSchema = z.object({\n  /** The type of criterion, must be \"evmAddress\" for EVM address-based rules. */\n  type: z.literal(\"evmNetwork\"),\n  /**\n   * Array of EVM network identifiers to compare against.\n   * Either \"base-sepolia\", \"base\", \"arbitrum\", \"optimism\", \"zora\", \"polygon\", \"bnb\", \"avalanche\", \"ethereum\", \"ethereum-sepolia\"\n   */\n  networks: z.array(PrepareUserOperationEvmNetworkEnum),\n  /**\n   * The operator to use for evaluating transaction network.\n   * \"in\" checks if a network is in the provided list.\n   * \"not in\" checks if a network is not in the provided list.\n   */\n  operator: EvmNetworkOperatorEnum,\n});\n\nexport const EvmNetworkCriterionSchema = z.union([\n  SendEvmTransactionEvmNetworkCriterionSchema,\n  PrepareUserOperationEvmNetworkCriterionSchema,\n]);\n\nexport type EvmNetworkCriterion = z.ZodUnion<\n  [\n    typeof SendEvmTransactionEvmNetworkCriterionSchema,\n    typeof PrepareUserOperationEvmNetworkCriterionSchema,\n  ]\n>;\n\n/**\n * Schema for EVM message criterions\n */\nexport const EvmMessageCriterionSchema = z.object({\n  /** The type of criterion, must be \"evmMessage\" for EVM message-based rules. */\n  type: z.literal(\"evmMessage\"),\n  /**\n   * A regular expression the message is matched against.\n   * Accepts valid regular expression syntax described by [RE2](https://github.com/google/re2/wiki/Syntax).\n   */\n  match: z.string().min(1),\n});\nexport type EvmMessageCriterion = z.infer<typeof EvmMessageCriterionSchema>;\n\n/**\n * Schema for Net USD change criterion\n */\nexport const NetUSDChangeCriterionSchema = z.object({\n  /** The type of criterion, must be \"netUSDChange\" for USD denominated asset transfer rules. */\n  type: z.literal(\"netUSDChange\"),\n  /**\n   * The amount of USD, in cents, that the total USD value of a transaction's asset transfer and exposure should be compared to.\n   */\n  changeCents: z.number().int().nonnegative(),\n  /**\n   * The operator to use for the comparison. The total value of a transaction's asset transfer and exposure in USD will be on the left-hand side of the operator, and the `changeCents` field will be on the right-hand side.\n   */\n  operator: EthValueOperatorEnum,\n});\nexport type NetUSDChangeCriterion = z.infer<typeof NetUSDChangeCriterionSchema>;\n\n/**\n * Schema for EVM typed address conditions\n */\nexport const EvmTypedAddressConditionSchema = z.object({\n  /**\n   * Array of EVM addresses to compare against.\n   * Each address must be a 0x-prefixed 40-character hexadecimal string.\n   * Limited to a maximum of 300 addresses per condition.\n   */\n  addresses: z.array(Address).max(300),\n  /**\n   * The operator to use for evaluating addresses.\n   * \"in\" checks if an address is in the provided list.\n   * \"not in\" checks if an address is not in the provided list.\n   */\n  operator: EvmAddressOperatorEnum,\n  /**\n   * The path to the field to compare against this criterion.\n   * To reference deeply nested fields, use dot notation (e.g., \"order.buyer\").\n   */\n  path: z.string().min(1),\n});\nexport type EvmTypedAddressCondition = z.infer<typeof EvmTypedAddressConditionSchema>;\n\n/**\n * Schema for EVM typed numerical conditions\n */\nexport const EvmTypedNumericalConditionSchema = z.object({\n  /**\n   * The numerical value to compare against, as a string.\n   * Must contain only digits.\n   */\n  value: z.string().regex(/^[0-9]+$/),\n  /**\n   * The comparison operator to use.\n   */\n  operator: EthValueOperatorEnum,\n  /**\n   * The path to the field to compare against this criterion.\n   * To reference deeply nested fields, use dot notation (e.g., \"order.price\").\n   */\n  path: z.string().min(1),\n});\nexport type EvmTypedNumericalCondition = z.infer<typeof EvmTypedNumericalConditionSchema>;\n\n/**\n * Schema for EVM typed string conditions\n */\nexport const EvmTypedStringConditionSchema = z.object({\n  /**\n   * A regular expression the string field is matched against.\n   * Accepts valid regular expression syntax described by [RE2](https://github.com/google/re2/wiki/Syntax).\n   */\n  match: z.string().min(1),\n  /**\n   * The path to the field to compare against this criterion.\n   * To reference deeply nested fields, use dot notation (e.g., \"metadata.description\").\n   */\n  path: z.string().min(1),\n});\nexport type EvmTypedStringCondition = z.infer<typeof EvmTypedStringConditionSchema>;\n\n/**\n * Schema for SignEvmTypedData field criterion\n */\nexport const SignEvmTypedDataFieldCriterionSchema = z.object({\n  /** The type of criterion, must be \"evmTypedDataField\" for typed data field-based rules. */\n  type: z.literal(\"evmTypedDataField\"),\n  /**\n   * The EIP-712 type definitions for the typed data.\n   * Must include at minimum the primary type being signed.\n   */\n  types: z.object({\n    /**\n     * EIP-712 compliant map of model names to model definitions.\n     */\n    types: z.record(\n      z.array(\n        z.object({\n          name: z.string(),\n          type: z.string(),\n        }),\n      ),\n    ),\n    /**\n     * The name of the root EIP-712 type. This value must be included in the `types` object.\n     */\n    primaryType: z.string(),\n  }),\n  /**\n   * Array of conditions to apply against typed data fields.\n   * Each condition specifies how to validate a specific field within the typed data.\n   */\n  conditions: z\n    .array(\n      z.union([\n        EvmTypedAddressConditionSchema,\n        EvmTypedNumericalConditionSchema,\n        EvmTypedStringConditionSchema,\n      ]),\n    )\n    .min(1),\n});\nexport type SignEvmTypedDataFieldCriterion = z.infer<typeof SignEvmTypedDataFieldCriterionSchema>;\n\n/**\n * Schema for SignEvmTypedData verifying contract criterion\n */\nexport const SignEvmTypedDataVerifyingContractCriterionSchema = z.object({\n  /** The type of criterion, must be \"evmTypedDataVerifyingContract\" for verifying contract-based rules. */\n  type: z.literal(\"evmTypedDataVerifyingContract\"),\n  /**\n   * Array of EVM addresses allowed or disallowed as verifying contracts.\n   * Each address must be a 0x-prefixed 40-character hexadecimal string.\n   * Limited to a maximum of 300 addresses per criterion.\n   */\n  addresses: z.array(Address).max(300),\n  /**\n   * The operator to use for evaluating verifying contract addresses.\n   * \"in\" checks if the verifying contract is in the provided list.\n   * \"not in\" checks if the verifying contract is not in the provided list.\n   */\n  operator: EvmAddressOperatorEnum,\n});\nexport type SignEvmTypedDataVerifyingContractCriterion = z.infer<\n  typeof SignEvmTypedDataVerifyingContractCriterionSchema\n>;\n\n/**\n * Schema for criteria used in SignEvmTypedData operations\n */\nexport const SignEvmTypedDataCriteriaSchema = z\n  .array(\n    z.discriminatedUnion(\"type\", [\n      SignEvmTypedDataFieldCriterionSchema,\n      SignEvmTypedDataVerifyingContractCriterionSchema,\n    ]),\n  )\n  .max(10)\n  .min(1);\n/**\n * Type representing a set of criteria for the signEvmTypedData operation.\n * Can contain up to 10 individual criterion objects for typed data field or verifying contract checks.\n */\nexport type SignEvmTypedDataCriteria = z.infer<typeof SignEvmTypedDataCriteriaSchema>;\n\n/**\n * A list of comparables to apply against encoded arguments in the transaction's `data` field.\n */\nexport const EvmDataParameterConditionListSchema = z.object({\n  /**\n   * The name of the parameter to check against a transaction's calldata.\n   * If name is unknown, or is not named, you may supply an array index, e.g., `0` for first parameter.\n   */\n  name: z.union([z.string().min(1), z.string().regex(/^\\d+$/)]),\n  /**\n   * The operator to use for the comparison. The value resolved at the `name` will be on the\n   * left-hand side of the operator, and the `values` field will be on the right-hand side.\n   */\n  operator: z.enum([\"in\", \"not in\"]),\n  /**\n   * Values to compare against the resolved `name` value.\n   * All values are encoded as strings. Refer to the table in the documentation for how values\n   * should be encoded, and which operators are supported for each type.\n   */\n  values: z.array(z.string()),\n});\nexport type EvmDataParameterConditionList = z.infer<typeof EvmDataParameterConditionListSchema>;\n\n/**\n * A single condition to apply against encoded arguments in the transaction's `data` field.\n */\nexport const EvmDataParameterConditionSchema = z.object({\n  /**\n   * The name of the parameter to check against a transaction's calldata.\n   * If name is unknown, or is not named, you may supply an array index, e.g., `0` for first parameter.\n   */\n  name: z.union([z.string().min(1), z.string().regex(/^\\d+$/)]),\n  /**\n   * The operator to use for the comparison. The value resolved at the `name` will be on the\n   * left-hand side of the operator, and the `value` field will be on the right-hand side.\n   */\n  operator: EthValueOperatorEnum,\n  /**\n   * A single value to compare the value resolved at `name` to.\n   * All values are encoded as strings. Refer to the table in the documentation for how values\n   * should be encoded, and which operators are supported for each type.\n   */\n  value: z.string(),\n});\nexport type EvmDataParameterCondition = z.infer<typeof EvmDataParameterConditionSchema>;\n\n/**\n * A single condition to apply against the function and encoded arguments in the transaction's `data` field.\n * Each `parameter` configuration must be successfully evaluated against the corresponding function argument\n * in order for a policy to be accepted.\n */\nexport const EvmDataConditionSchema = z.object({\n  /**\n   * The name of a smart contract function being called.\n   */\n  function: z.string().min(1),\n  /**\n   * An optional list of parameter conditions to apply against encoded arguments in the transaction's `data` field.\n   */\n  params: z\n    .array(z.union([EvmDataParameterConditionSchema, EvmDataParameterConditionListSchema]))\n    .min(1)\n    .optional(),\n});\nexport type EvmDataCondition = z.infer<typeof EvmDataConditionSchema>;\n\n/**\n * Schema for EVM data criterion\n */\nexport const EvmDataCriterionSchema = z.object({\n  /** The type of criterion, must be \"evmData\" for EVM transaction rules. */\n  type: z.literal(\"evmData\"),\n  /**\n   * The ABI of the smart contract being called. This can be a partial structure with only specific functions.\n   */\n  abi: z.union([z.enum([\"erc20\", \"erc721\", \"erc1155\"]), Abi]),\n  /**\n   * A list of conditions to apply against the function and encoded arguments in the transaction's `data` field.\n   * Each condition must be met in order for this policy to be accepted or rejected.\n   */\n  conditions: z.array(EvmDataConditionSchema).min(1),\n});\nexport type EvmDataCriterion = z.infer<typeof EvmDataCriterionSchema>;\n\n/**\n * Schema for criteria used in SignEvmTransaction operations\n */\nexport const SignEvmTransactionCriteriaSchema = z\n  .array(\n    z.discriminatedUnion(\"type\", [\n      EthValueCriterionSchema,\n      EvmAddressCriterionSchema,\n      EvmDataCriterionSchema,\n      NetUSDChangeCriterionSchema,\n    ]),\n  )\n  .max(10)\n  .min(1);\n/**\n * Type representing a set of criteria for the signEvmTransaction operation.\n * Can contain up to 10 individual criterion objects of ETH value or EVM address types.\n */\nexport type SignEvmTransactionCriteria = z.infer<typeof SignEvmTransactionCriteriaSchema>;\n\n/**\n * Schema for criteria used in SignEvmMessage operations\n */\nexport const SignEvmMessageCriteriaSchema = z\n  .array(z.discriminatedUnion(\"type\", [EvmMessageCriterionSchema]))\n  .max(10)\n  .min(1);\n/**\n * Type representing a set of criteria for the signEvmMessage operation.\n * Can contain up to 10 individual EVM message criterion objects.\n */\nexport type SignEvmMessageCriteria = z.infer<typeof SignEvmMessageCriteriaSchema>;\n\n/**\n * Schema for criteria used in SendEvmTransaction operations\n */\nexport const SendEvmTransactionCriteriaSchema = z\n  .array(\n    z.discriminatedUnion(\"type\", [\n      EthValueCriterionSchema,\n      EvmAddressCriterionSchema,\n      SendEvmTransactionEvmNetworkCriterionSchema,\n      EvmDataCriterionSchema,\n      NetUSDChangeCriterionSchema,\n    ]),\n  )\n  .max(10)\n  .min(1);\n\n// Type representing a set of criteria for the sendEvmTransaction operation. Can contain up to 10 individual criterion objects of ETH value or EVM address types.\nexport type SendEvmTransactionCriteria = z.infer<typeof SendEvmTransactionCriteriaSchema>;\n\n/**\n * Schema for criteria used in PrepareUserOperation operations\n */\nexport const PrepareUserOperationCriteriaSchema = z\n  .array(\n    z.discriminatedUnion(\"type\", [\n      EthValueCriterionSchema,\n      EvmAddressCriterionSchema,\n      PrepareUserOperationEvmNetworkCriterionSchema,\n      EvmDataCriterionSchema,\n      NetUSDChangeCriterionSchema,\n    ]),\n  )\n  .max(10)\n  .min(1);\n/**\n * Type representing a set of criteria for the prepareUserOperation operation.\n * Can contain up to 10 individual criterion objects of ETH value, EVM address, EVM network, or EVM data types.\n */\nexport type PrepareUserOperationCriteria = z.infer<typeof PrepareUserOperationCriteriaSchema>;\n\n/**\n * Schema for criteria used in SendUserOperation operations\n */\nexport const SendUserOperationCriteriaSchema = z\n  .array(\n    z.discriminatedUnion(\"type\", [\n      EthValueCriterionSchema,\n      EvmAddressCriterionSchema,\n      EvmDataCriterionSchema,\n      NetUSDChangeCriterionSchema,\n    ]),\n  )\n  .max(10)\n  .min(1);\n/**\n * Type representing a set of criteria for the sendUserOperation operation.\n * Can contain up to 10 individual criterion objects of ETH value, EVM address, or EVM data types.\n */\nexport type SendUserOperationCriteria = z.infer<typeof SendUserOperationCriteriaSchema>;\n\n/**\n * Enum for Evm Operation types\n */\nexport const EvmOperationEnum = z.enum([\n  \"signEvmTransaction\",\n  \"sendEvmTransaction\",\n  \"signEvmMessage\",\n  \"signEvmTypedData\",\n  \"signEvmHash\",\n  \"prepareUserOperation\",\n  \"sendUserOperation\",\n]);\n/**\n * Type representing the operations that can be governed by a policy.\n * Defines what EVM operations the policy applies to.\n */\nexport type EvmOperation = z.infer<typeof EvmOperationEnum>;\n\n/**\n * Enum for Action types\n */\nexport const ActionEnum = z.enum([\"reject\", \"accept\"]);\n/**\n * Type representing the possible policy actions.\n * Determines whether matching the rule will cause a request to be accepted or rejected.\n */\nexport type Action = z.infer<typeof ActionEnum>;\n\n/**\n * Type representing a 'signEvmTransaction' policy rule that can accept or reject specific operations\n * based on a set of criteria.\n */\nexport const SignEvmTransactionRuleSchema = z.object({\n  /**\n   * Determines whether matching the rule will cause a request to be rejected or accepted.\n   * \"accept\" will allow the transaction, \"reject\" will block it.\n   */\n  action: ActionEnum,\n  /**\n   * The operation to which this rule applies.\n   * Must be \"signEvmTransaction\".\n   */\n  operation: z.literal(\"signEvmTransaction\"),\n  /**\n   * The set of criteria that must be matched for this rule to apply.\n   * Must be compatible with the specified operation type.\n   */\n  criteria: SignEvmTransactionCriteriaSchema,\n});\nexport type SignEvmTransactionRule = z.infer<typeof SignEvmTransactionRuleSchema>;\n\n/**\n * Type representing a 'signEvmHash' policy rule that can accept or reject specific operations\n * based on a set of criteria.\n */\nexport const SignEvmHashRuleSchema = z.object({\n  /**\n   * Determines whether matching the rule will cause a request to be rejected or accepted.\n   * \"accept\" will allow the signing, \"reject\" will block it.\n   */\n  action: ActionEnum,\n  /**\n   * The operation to which this rule applies.\n   * Must be \"signEvmHash\".\n   */\n  operation: z.literal(\"signEvmHash\"),\n});\nexport type SignEvmHashRule = z.infer<typeof SignEvmHashRuleSchema>;\n\n/**\n * Type representing a 'signEvmMessage' policy rule that can accept or reject specific operations\n * based on a set of criteria.\n */\nexport const SignEvmMessageRuleSchema = z.object({\n  /**\n   * Determines whether matching the rule will cause a request to be rejected or accepted.\n   * \"accept\" will allow the signing, \"reject\" will block it.\n   */\n  action: ActionEnum,\n  /**\n   * The operation to which this rule applies.\n   * Must be \"signEvmMessage\".\n   */\n  operation: z.literal(\"signEvmMessage\"),\n  /**\n   * The set of criteria that must be matched for this rule to apply.\n   * Must be compatible with the specified operation type.\n   */\n  criteria: SignEvmMessageCriteriaSchema,\n});\nexport type SignEvmMessageRule = z.infer<typeof SignEvmMessageRuleSchema>;\n\n/**\n * Type representing a 'signEvmTypedData' policy rule that can accept or reject specific operations\n * based on a set of criteria.\n */\nexport const SignEvmTypedDataRuleSchema = z.object({\n  /**\n   * Determines whether matching the rule will cause a request to be rejected or accepted.\n   * \"accept\" will allow the signing, \"reject\" will block it.\n   */\n  action: ActionEnum,\n  /**\n   * The operation to which this rule applies.\n   * Must be \"signEvmTypedData\".\n   */\n  operation: z.literal(\"signEvmTypedData\"),\n  /**\n   * The set of criteria that must be matched for this rule to apply.\n   * Must be compatible with the specified operation type.\n   */\n  criteria: SignEvmTypedDataCriteriaSchema,\n});\nexport type SignEvmTypedDataRule = z.infer<typeof SignEvmTypedDataRuleSchema>;\n\n/**\n * Type representing a 'sendEvmTransaction' policy rule that can accept or reject specific operations\n * based on a set of criteria.\n */\nexport const SendEvmTransactionRuleSchema = z.object({\n  /**\n   * Determines whether matching the rule will cause a request to be rejected or accepted.\n   * \"accept\" will allow the transaction, \"reject\" will block it.\n   */\n  action: ActionEnum,\n  /**\n   * The operation to which this rule applies.\n   * Must be \"sendEvmTransaction\".\n   */\n  operation: z.literal(\"sendEvmTransaction\"),\n  /**\n   * The set of criteria that must be matched for this rule to apply.\n   * Must be compatible with the specified operation type.\n   */\n  criteria: SendEvmTransactionCriteriaSchema,\n});\nexport type SendEvmTransactionRule = z.infer<typeof SendEvmTransactionRuleSchema>;\n\n/**\n * Type representing a 'prepareUserOperation' policy rule that can accept or reject specific operations\n * based on a set of criteria.\n */\nexport const PrepareUserOperationRuleSchema = z.object({\n  /**\n   * Determines whether matching the rule will cause a request to be rejected or accepted.\n   * \"accept\" will allow the operation, \"reject\" will block it.\n   */\n  action: ActionEnum,\n  /**\n   * The operation to which this rule applies.\n   * Must be \"prepareUserOperation\".\n   */\n  operation: z.literal(\"prepareUserOperation\"),\n  /**\n   * The set of criteria that must be matched for this rule to apply.\n   * Must be compatible with the specified operation type.\n   */\n  criteria: PrepareUserOperationCriteriaSchema,\n});\nexport type PrepareUserOperationRule = z.infer<typeof PrepareUserOperationRuleSchema>;\n\n/**\n * Type representing a 'sendUserOperation' policy rule that can accept or reject specific operations\n * based on a set of criteria.\n */\nexport const SendUserOperationRuleSchema = z.object({\n  /**\n   * Determines whether matching the rule will cause a request to be rejected or accepted.\n   * \"accept\" will allow the operation, \"reject\" will block it.\n   */\n  action: ActionEnum,\n  /**\n   * The operation to which this rule applies.\n   * Must be \"sendUserOperation\".\n   */\n  operation: z.literal(\"sendUserOperation\"),\n  /**\n   * The set of criteria that must be matched for this rule to apply.\n   * Must be compatible with the specified operation type.\n   */\n  criteria: SendUserOperationCriteriaSchema,\n});\nexport type SendUserOperationRule = z.infer<typeof SendUserOperationRuleSchema>;\n","import { concat, numberToHex, size } from \"viem\";\n\nimport { createSwapQuote } from \"./createSwapQuote.js\";\nimport { createDeterministicUuidV4 } from \"../../../utils/uuidV4.js\";\nimport { sendUserOperation } from \"../sendUserOperation.js\";\nimport { signAndWrapTypedDataForSmartAccount } from \"../signAndWrapTypedDataForSmartAccount.js\";\n\nimport type { SendSwapOperationOptions, SendSwapOperationResult } from \"./types.js\";\nimport type { EvmSmartAccount } from \"../../../accounts/evm/types.js\";\nimport type {\n  CreateSwapQuoteResult,\n  CreateSwapQuoteOptions,\n  SwapUnavailableResult,\n} from \"../../../client/evm/evm.types.js\";\nimport type {\n  CdpOpenApiClientType,\n  EvmUserOperationNetwork,\n} from \"../../../openapi-client/index.js\";\nimport type { Hex } from \"../../../types/misc.js\";\n\n/**\n * Sends a swap operation to the blockchain via a smart account user operation.\n * Handles any permit2 signatures required for the swap.\n *\n * If you encounter token allowance issues, you'll need to perform a token approval transaction first to allow\n * the Permit2 contract to spend the appropriate amount of your fromToken.\n * See examples for code on handling token approvals.\n *\n * @param {CdpOpenApiClientType} client - The client to use for sending the swap operation.\n * @param {SendSwapOperationOptions} options - The options for the swap submission.\n *\n * @returns {Promise<SendSwapOperationResult>} A promise that resolves to the user operation result.\n *\n * @throws {Error} If liquidity is not available for the swap.\n * @throws {Error} If there are insufficient token allowances. In this case, you need to approve the\n *                 Permit2 contract to spend your tokens before attempting the swap. The error message\n *                 will include the current allowance and the spender address that needs approval.\n * @throws {Error} If no transaction data is found in the swap result.\n *\n * @example **Sending a swap with pre-created swap quote object**\n * ```ts\n * // First create a swap quote\n * const swapQuote = await cdp.evm.createSwapQuote({\n *   network: \"base\",\n *   toToken: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\", // USDC\n *   fromToken: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\", // WETH\n *   fromAmount: BigInt(\"1000000000000000000\"), // 1 WETH in wei\n *   taker: smartAccount.address\n * });\n *\n * // Check if liquidity is available\n * if (!swapQuote.liquidityAvailable) {\n *   console.error(\"Insufficient liquidity for swap\");\n *   return;\n * }\n *\n * // Send the swap operation\n * const result = await sendSwapOperation(client, {\n *   smartAccount: smartAccount,\n *   swapQuote: swapQuote\n * });\n *\n * console.log(`Swap operation sent with user op hash: ${result.userOpHash}`);\n * ```\n *\n * @example **Sending a swap with inline options (all-in-one)**\n * ```ts\n * // Send swap operation in one call\n * const result = await sendSwapOperation(client, {\n *   smartAccount: smartAccount,\n *   network: \"base\",\n *   toToken: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\", // USDC\n *   fromToken: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\", // WETH\n *   fromAmount: BigInt(\"1000000000000000000\"), // 1 WETH in wei\n *   taker: smartAccount.address\n * });\n *\n * console.log(`Swap operation sent with user op hash: ${result.userOpHash}`);\n * ```\n */\nexport async function sendSwapOperation(\n  client: CdpOpenApiClientType,\n  options: SendSwapOperationOptions,\n): Promise<SendSwapOperationResult> {\n  const { smartAccount, paymasterUrl, idempotencyKey } = options;\n\n  let swapResult: CreateSwapQuoteResult | SwapUnavailableResult;\n\n  // Determine if we need to create the swap quote or use the provided one\n  if (\"swapQuote\" in options) {\n    // Use the provided swap quote\n    swapResult = options.swapQuote;\n  } else {\n    // Create the swap quote using the provided options (inline options)\n    /**\n     * Deterministically derive a new idempotency key from the provided idempotency key for swap quote creation to avoid key reuse.\n     */\n    const swapQuoteIdempotencyKey = idempotencyKey\n      ? createDeterministicUuidV4(idempotencyKey, \"createSwapQuote\")\n      : undefined;\n\n    swapResult = await createSwapQuote(client, {\n      network: options.network as CreateSwapQuoteOptions[\"network\"],\n      toToken: options.toToken,\n      fromToken: options.fromToken,\n      fromAmount: options.fromAmount,\n      taker: options.taker,\n      signerAddress: options.signerAddress,\n      gasPrice: options.gasPrice,\n      slippageBps: options.slippageBps,\n      idempotencyKey: swapQuoteIdempotencyKey,\n    });\n  }\n\n  // Check if liquidity is available\n  if (!swapResult.liquidityAvailable) {\n    throw new Error(\"Insufficient liquidity for swap\");\n  }\n\n  // At this point, we know that swapResult is CreateSwapQuoteResult\n  const swap = swapResult as CreateSwapQuoteResult;\n\n  // Check for allowance issues\n  if (swap.issues?.allowance) {\n    const { currentAllowance, spender } = swap.issues.allowance;\n    throw new Error(\n      `Insufficient token allowance for swap. Current allowance: ${currentAllowance}. ` +\n        `Please approve the Permit2 contract (${spender}) to spend your tokens.`,\n    );\n  }\n\n  // If the transaction doesn't exist, throw an error\n  if (!swap.transaction) {\n    throw new Error(\"No transaction data found in the swap\");\n  }\n\n  // Get the transaction data and modify it if needed for Permit2\n  let txData = swap.transaction.data as Hex;\n\n  if (swap.permit2?.eip712) {\n    // Create the permit2 idempotency key\n    const permit2IdempotencyKey = idempotencyKey\n      ? createDeterministicUuidV4(idempotencyKey, \"permit2\")\n      : undefined;\n\n    // Sign and wrap the permit2 typed data according to the Coinbase Smart Wallet contract requirements for EIP-712 signatures\n    const { signature: wrappedSignature } = await signAndWrapTypedDataForSmartAccount(client, {\n      smartAccount,\n      chainId: BigInt(swap.permit2.eip712.domain.chainId || 1),\n      typedData: swap.permit2.eip712,\n      ownerIndex: 0n,\n      idempotencyKey: permit2IdempotencyKey,\n    });\n\n    // Calculate the Permit2 signature length as a 32-byte hex value\n    const permit2SignatureLengthInHex = numberToHex(size(wrappedSignature), {\n      signed: false,\n      size: 32,\n    });\n\n    // Append the Permit2 signature length and signature to the transaction data\n    txData = concat([txData, permit2SignatureLengthInHex, wrappedSignature]);\n  }\n\n  // Send the swap as a user operation\n  const result = await sendUserOperation(client, {\n    smartAccount: smartAccount as EvmSmartAccount,\n    network: swap.network as EvmUserOperationNetwork,\n    paymasterUrl,\n    idempotencyKey,\n    calls: [\n      {\n        to: swap.transaction.to,\n        data: txData,\n        // Only include value if it exists\n        ...(swap.transaction.value ? { value: BigInt(swap.transaction.value) } : {}),\n      },\n    ],\n  });\n\n  return result;\n}\n","import { Commitment } from '@solana/rpc-types';\n\nexport function applyDefaultCommitment({\n    commitmentPropertyName,\n    params,\n    optionsObjectPositionInParams,\n    overrideCommitment,\n}: Readonly<{\n    commitmentPropertyName: string;\n    optionsObjectPositionInParams: number;\n    overrideCommitment?: Commitment;\n    params: unknown[];\n}>) {\n    const paramInTargetPosition = params[optionsObjectPositionInParams];\n    if (\n        // There's no config.\n        paramInTargetPosition === undefined ||\n        // There is a config object.\n        (paramInTargetPosition && typeof paramInTargetPosition === 'object' && !Array.isArray(paramInTargetPosition))\n    ) {\n        if (\n            // The config object already has a commitment set.\n            paramInTargetPosition &&\n            commitmentPropertyName in paramInTargetPosition\n        ) {\n            if (\n                !paramInTargetPosition[commitmentPropertyName as keyof typeof paramInTargetPosition] ||\n                paramInTargetPosition[commitmentPropertyName as keyof typeof paramInTargetPosition] === 'finalized'\n            ) {\n                // Delete the commitment property; `finalized` is already the server default.\n                const nextParams = [...params];\n                const {\n                    [commitmentPropertyName as keyof typeof paramInTargetPosition]: _, // eslint-disable-line @typescript-eslint/no-unused-vars\n                    ...rest\n                } = paramInTargetPosition;\n                if (Object.keys(rest).length > 0) {\n                    nextParams[optionsObjectPositionInParams] = rest;\n                } else {\n                    if (optionsObjectPositionInParams === nextParams.length - 1) {\n                        nextParams.length--;\n                    } else {\n                        nextParams[optionsObjectPositionInParams] = undefined;\n                    }\n                }\n                return nextParams;\n            }\n        } else if (overrideCommitment !== 'finalized') {\n            // Apply the default commitment.\n            const nextParams = [...params];\n            nextParams[optionsObjectPositionInParams] = {\n                ...paramInTargetPosition,\n                [commitmentPropertyName]: overrideCommitment,\n            };\n            return nextParams;\n        }\n    }\n    return params;\n}\n","import * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as Json from './Json.js'\nimport type { Compute, ExactPartial } from './internal/types.js'\n\n/** Root type for an ECDSA Public Key. */\nexport type PublicKey<\n  compressed extends boolean = false,\n  bigintType = bigint,\n  numberType = number,\n> = Compute<\n  compressed extends true\n    ? {\n        prefix: numberType\n        x: bigintType\n        y?: undefined\n      }\n    : {\n        prefix: numberType\n        x: bigintType\n        y: bigintType\n      }\n>\n\n/**\n * Asserts that a {@link ox#PublicKey.PublicKey} is valid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @error: PublicKey.InvalidError: Value \\`{\"y\":\"1\"}\\` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nexport function assert(\n  publicKey: ExactPartial<PublicKey>,\n  options: assert.Options = {},\n): asserts publicKey is PublicKey {\n  const { compressed } = options\n  const { prefix, x, y } = publicKey\n\n  // Uncompressed\n  if (\n    compressed === false ||\n    (typeof x === 'bigint' && typeof y === 'bigint')\n  ) {\n    if (prefix !== 4)\n      throw new InvalidPrefixError({\n        prefix,\n        cause: new InvalidUncompressedPrefixError(),\n      })\n    return\n  }\n\n  // Compressed\n  if (\n    compressed === true ||\n    (typeof x === 'bigint' && typeof y === 'undefined')\n  ) {\n    if (prefix !== 3 && prefix !== 2)\n      throw new InvalidPrefixError({\n        prefix,\n        cause: new InvalidCompressedPrefixError(),\n      })\n    return\n  }\n\n  // Unknown/invalid\n  throw new InvalidError({ publicKey })\n}\n\nexport declare namespace assert {\n  type Options = {\n    /** Whether or not the public key should be compressed. */\n    compressed?: boolean\n  }\n\n  type ErrorType = InvalidError | InvalidPrefixError | Errors.GlobalErrorType\n}\n\n/**\n * Compresses a {@link ox#PublicKey.PublicKey}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const compressed = PublicKey.compress(publicKey) // [!code focus]\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The public key to compress.\n * @returns The compressed public key.\n */\nexport function compress(publicKey: PublicKey<false>): PublicKey<true> {\n  const { x, y } = publicKey\n  return {\n    prefix: y % 2n === 0n ? 2 : 3,\n    x,\n  }\n}\n\nexport declare namespace compress {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates a typed {@link ox#PublicKey.PublicKey} object from a {@link ox#PublicKey.PublicKey}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from('0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param value - The public key value to instantiate.\n * @returns The instantiated {@link ox#PublicKey.PublicKey}.\n */\nexport function from<\n  const publicKey extends\n    | CompressedPublicKey\n    | UncompressedPublicKey\n    | Hex.Hex\n    | Bytes.Bytes,\n>(value: from.Value<publicKey>): from.ReturnType<publicKey> {\n  const publicKey = (() => {\n    if (Hex.validate(value)) return fromHex(value)\n    if (Bytes.validate(value)) return fromBytes(value)\n\n    const { prefix, x, y } = value\n    if (typeof x === 'bigint' && typeof y === 'bigint')\n      return { prefix: prefix ?? 0x04, x, y }\n    return { prefix, x }\n  })()\n\n  assert(publicKey)\n\n  return publicKey as never\n}\n\n/** @internal */\ntype CompressedPublicKey = PublicKey<true>\n\n/** @internal */\ntype UncompressedPublicKey = Omit<PublicKey<false>, 'prefix'> & {\n  prefix?: PublicKey['prefix'] | undefined\n}\n\nexport declare namespace from {\n  type Value<\n    publicKey extends\n      | CompressedPublicKey\n      | UncompressedPublicKey\n      | Hex.Hex\n      | Bytes.Bytes = PublicKey,\n  > = publicKey | CompressedPublicKey | UncompressedPublicKey\n\n  type ReturnType<\n    publicKey extends\n      | CompressedPublicKey\n      | UncompressedPublicKey\n      | Hex.Hex\n      | Bytes.Bytes = PublicKey,\n  > = publicKey extends CompressedPublicKey | UncompressedPublicKey\n    ? publicKey extends UncompressedPublicKey\n      ? Compute<publicKey & { readonly prefix: 0x04 }>\n      : publicKey\n    : PublicKey\n\n  type ErrorType = assert.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nexport function fromBytes(publicKey: Bytes.Bytes): PublicKey {\n  return fromHex(Hex.fromBytes(publicKey))\n}\n\nexport declare namespace fromBytes {\n  type ErrorType =\n    | fromHex.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### Deserializing a Compressed Public Key\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x038318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed75')\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nexport function fromHex(publicKey: Hex.Hex): PublicKey {\n  if (\n    publicKey.length !== 132 &&\n    publicKey.length !== 130 &&\n    publicKey.length !== 68\n  )\n    throw new InvalidSerializedSizeError({ publicKey })\n\n  if (publicKey.length === 130) {\n    const x = BigInt(Hex.slice(publicKey, 0, 32))\n    const y = BigInt(Hex.slice(publicKey, 32, 64))\n    return {\n      prefix: 4,\n      x,\n      y,\n    } as never\n  }\n\n  if (publicKey.length === 132) {\n    const prefix = Number(Hex.slice(publicKey, 0, 1))\n    const x = BigInt(Hex.slice(publicKey, 1, 33))\n    const y = BigInt(Hex.slice(publicKey, 33, 65))\n    return {\n      prefix,\n      x,\n      y,\n    } as never\n  }\n\n  const prefix = Number(Hex.slice(publicKey, 0, 1))\n  const x = BigInt(Hex.slice(publicKey, 1, 33))\n  return {\n    prefix,\n    x,\n  } as never\n}\n\nexport declare namespace fromHex {\n  type ErrorType = Hex.slice.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const bytes = PublicKey.toBytes(publicKey) // [!code focus]\n * // @log: Uint8Array [128, 3, 131, ...]\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nexport function toBytes(\n  publicKey: PublicKey<boolean>,\n  options: toBytes.Options = {},\n): Bytes.Bytes {\n  return Bytes.fromHex(toHex(publicKey, options))\n}\n\nexport declare namespace toBytes {\n  type Options = {\n    /**\n     * Whether to include the prefix in the serialized public key.\n     * @default true\n     */\n    includePrefix?: boolean | undefined\n  }\n\n  type ErrorType =\n    | Hex.fromNumber.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const hex = PublicKey.toHex(publicKey) // [!code focus]\n * // @log: '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5'\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nexport function toHex(\n  publicKey: PublicKey<boolean>,\n  options: toHex.Options = {},\n): Hex.Hex {\n  assert(publicKey)\n\n  const { prefix, x, y } = publicKey\n  const { includePrefix = true } = options\n\n  const publicKey_ = Hex.concat(\n    includePrefix ? Hex.fromNumber(prefix, { size: 1 }) : '0x',\n    Hex.fromNumber(x, { size: 32 }),\n    // If the public key is not compressed, add the y coordinate.\n    typeof y === 'bigint' ? Hex.fromNumber(y, { size: 32 }) : '0x',\n  )\n\n  return publicKey_\n}\n\nexport declare namespace toHex {\n  type Options = {\n    /**\n     * Whether to include the prefix in the serialized public key.\n     * @default true\n     */\n    includePrefix?: boolean | undefined\n  }\n\n  type ErrorType = Hex.fromNumber.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Validates a {@link ox#PublicKey.PublicKey}. Returns `true` if valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const valid = PublicKey.validate({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @log: false\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nexport function validate(\n  publicKey: ExactPartial<PublicKey>,\n  options: validate.Options = {},\n): boolean {\n  try {\n    assert(publicKey, options)\n    return true\n  } catch (error) {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type Options = {\n    /** Whether or not the public key should be compressed. */\n    compressed?: boolean\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Thrown when a public key is invalid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({ y: 1n })\n * // @error: PublicKey.InvalidError: Value `{\"y\":1n}` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n */\nexport class InvalidError extends Errors.BaseError {\n  override readonly name = 'PublicKey.InvalidError'\n\n  constructor({ publicKey }: { publicKey: unknown }) {\n    super(`Value \\`${Json.stringify(publicKey)}\\` is not a valid public key.`, {\n      metaMessages: [\n        'Public key must contain:',\n        '- an `x` and `prefix` value (compressed)',\n        '- an `x`, `y`, and `prefix` value (uncompressed)',\n      ],\n    })\n  }\n}\n\n/** Thrown when a public key has an invalid prefix. */\nexport class InvalidPrefixError<\n  cause extends InvalidCompressedPrefixError | InvalidUncompressedPrefixError =\n    | InvalidCompressedPrefixError\n    | InvalidUncompressedPrefixError,\n> extends Errors.BaseError<cause> {\n  override readonly name = 'PublicKey.InvalidPrefixError'\n\n  constructor({ prefix, cause }: { prefix: number | undefined; cause: cause }) {\n    super(`Prefix \"${prefix}\" is invalid.`, {\n      cause,\n    })\n  }\n}\n\n/** Thrown when the public key has an invalid prefix for a compressed public key. */\nexport class InvalidCompressedPrefixError extends Errors.BaseError {\n  override readonly name = 'PublicKey.InvalidCompressedPrefixError'\n\n  constructor() {\n    super('Prefix must be 2 or 3 for compressed public keys.')\n  }\n}\n\n/** Thrown when the public key has an invalid prefix for an uncompressed public key. */\nexport class InvalidUncompressedPrefixError extends Errors.BaseError {\n  override readonly name = 'PublicKey.InvalidUncompressedPrefixError'\n\n  constructor() {\n    super('Prefix must be 4 for uncompressed public keys.')\n  }\n}\n\n/** Thrown when the public key has an invalid serialized size. */\nexport class InvalidSerializedSizeError extends Errors.BaseError {\n  override readonly name = 'PublicKey.InvalidSerializedSizeError'\n\n  constructor({ publicKey }: { publicKey: Hex.Hex | Bytes.Bytes }) {\n    super(`Value \\`${publicKey}\\` is an invalid public key size.`, {\n      metaMessages: [\n        'Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).',\n        `Received ${Hex.size(Hex.from(publicKey))} bytes.`,\n      ],\n    })\n  }\n}\n","import { Address } from '@solana/addresses';\nimport { Instruction, isSignerRole } from '@solana/instructions';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\nimport { AccountSignerMeta, InstructionWithSigners, TransactionMessageWithSigners } from './account-signer-meta';\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\n\n/**\n * Attaches the provided {@link TransactionSigner | TransactionSigners} to the\n * account metas of an instruction when applicable.\n *\n * For an account meta to match a provided signer it:\n * - Must have a signer role ({@link AccountRole.READONLY_SIGNER} or {@link AccountRole.WRITABLE_SIGNER}).\n * - Must have the same address as the provided signer.\n * - Must not have an attached signer already.\n *\n * @typeParam TInstruction - The inferred type of the instruction provided.\n *\n * @example\n * ```ts\n * import { AccountRole, Instruction } from '@solana/instructions';\n * import { addSignersToInstruction, TransactionSigner } from '@solana/signers';\n *\n * const instruction: Instruction = {\n *     accounts: [\n *         { address: '1111' as Address, role: AccountRole.READONLY_SIGNER },\n *         { address: '2222' as Address, role: AccountRole.WRITABLE_SIGNER },\n *     ],\n *     // ...\n * };\n *\n * const signerA: TransactionSigner<'1111'>;\n * const signerB: TransactionSigner<'2222'>;\n * const instructionWithSigners = addSignersToInstruction(\n *     [signerA, signerB],\n *     instruction\n * );\n *\n * // instructionWithSigners.accounts[0].signer === signerA\n * // instructionWithSigners.accounts[1].signer === signerB\n * ```\n */\nexport function addSignersToInstruction<TInstruction extends Instruction>(\n    signers: TransactionSigner[],\n    instruction: TInstruction | (InstructionWithSigners & TInstruction),\n): InstructionWithSigners & TInstruction {\n    if (!instruction.accounts || instruction.accounts.length === 0) {\n        return instruction as InstructionWithSigners & TInstruction;\n    }\n\n    const signerByAddress = new Map(deduplicateSigners(signers).map(signer => [signer.address, signer]));\n    return Object.freeze({\n        ...instruction,\n        accounts: instruction.accounts.map(account => {\n            const signer = signerByAddress.get(account.address);\n            if (!isSignerRole(account.role) || 'signer' in account || !signer) {\n                return account;\n            }\n            return Object.freeze({ ...account, signer } as AccountSignerMeta);\n        }),\n    });\n}\n\n/**\n * Attaches the provided {@link TransactionSigner | TransactionSigners} to the\n * account metas of all instructions inside a transaction message and/or\n * the transaction message fee payer, when applicable.\n *\n * For an account meta to match a provided signer it:\n * - Must have a signer role ({@link AccountRole.READONLY_SIGNER} or {@link AccountRole.WRITABLE_SIGNER}).\n * - Must have the same address as the provided signer.\n * - Must not have an attached signer already.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import { AccountRole, Instruction } from '@solana/instructions';\n * import { BaseTransactionMessage } from '@solana/transaction-messages';\n * import { addSignersToTransactionMessage, TransactionSigner } from '@solana/signers';\n *\n * const instructionA: Instruction = {\n *     accounts: [{ address: '1111' as Address, role: AccountRole.READONLY_SIGNER }],\n *     // ...\n * };\n * const instructionB: Instruction = {\n *     accounts: [{ address: '2222' as Address, role: AccountRole.WRITABLE_SIGNER }],\n *     // ...\n * };\n * const transactionMessage: BaseTransactionMessage = {\n *     instructions: [instructionA, instructionB],\n *     // ...\n * }\n *\n * const signerA: TransactionSigner<'1111'>;\n * const signerB: TransactionSigner<'2222'>;\n * const transactionMessageWithSigners = addSignersToTransactionMessage(\n *     [signerA, signerB],\n *     transactionMessage\n * );\n *\n * // transactionMessageWithSigners.instructions[0].accounts[0].signer === signerA\n * // transactionMessageWithSigners.instructions[1].accounts[0].signer === signerB\n * ```\n */\nexport function addSignersToTransactionMessage<TTransactionMessage extends BaseTransactionMessage>(\n    signers: TransactionSigner[],\n    transactionMessage: TTransactionMessage | (TransactionMessageWithSigners & TTransactionMessage),\n): TransactionMessageWithSigners & TTransactionMessage {\n    const feePayerSigner = hasAddressOnlyFeePayer(transactionMessage)\n        ? signers.find(signer => signer.address === transactionMessage.feePayer.address)\n        : undefined;\n\n    if (!feePayerSigner && transactionMessage.instructions.length === 0) {\n        return transactionMessage as TransactionMessageWithSigners & TTransactionMessage;\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        ...(feePayerSigner ? { feePayer: feePayerSigner } : null),\n        instructions: transactionMessage.instructions.map(instruction => addSignersToInstruction(signers, instruction)),\n    });\n}\n\nfunction hasAddressOnlyFeePayer(\n    message: BaseTransactionMessage & Partial<TransactionMessageWithFeePayer>,\n): message is BaseTransactionMessage & { feePayer: { address: Address } } {\n    return (\n        !!message &&\n        'feePayer' in message &&\n        !!message.feePayer &&\n        typeof message.feePayer.address === 'string' &&\n        !isTransactionSigner(message.feePayer)\n    );\n}\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/core/error/constants.ts","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getArrayDecoder,\n  getArrayEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  type Account,\n  type Address,\n  type EncodedAccount,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n} from '@solana/kit';\n\nexport type Multisig = {\n  /** Number of signers required. */\n  m: number;\n  /** Number of valid signers. */\n  n: number;\n  /** Is `true` if this structure has been initialized. */\n  isInitialized: boolean;\n  /** Signer public keys. */\n  signers: Array<Address>;\n};\n\nexport type MultisigArgs = Multisig;\n\nexport function getMultisigEncoder(): FixedSizeEncoder<MultisigArgs> {\n  return getStructEncoder([\n    ['m', getU8Encoder()],\n    ['n', getU8Encoder()],\n    ['isInitialized', getBooleanEncoder()],\n    ['signers', getArrayEncoder(getAddressEncoder(), { size: 11 })],\n  ]);\n}\n\nexport function getMultisigDecoder(): FixedSizeDecoder<Multisig> {\n  return getStructDecoder([\n    ['m', getU8Decoder()],\n    ['n', getU8Decoder()],\n    ['isInitialized', getBooleanDecoder()],\n    ['signers', getArrayDecoder(getAddressDecoder(), { size: 11 })],\n  ]);\n}\n\nexport function getMultisigCodec(): FixedSizeCodec<MultisigArgs, Multisig> {\n  return combineCodec(getMultisigEncoder(), getMultisigDecoder());\n}\n\nexport function decodeMultisig<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Multisig, TAddress>;\nexport function decodeMultisig<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Multisig, TAddress>;\nexport function decodeMultisig<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Multisig, TAddress> | MaybeAccount<Multisig, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getMultisigDecoder()\n  );\n}\n\nexport async function fetchMultisig<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Multisig, TAddress>> {\n  const maybeAccount = await fetchMaybeMultisig(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeMultisig<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Multisig, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeMultisig(maybeAccount);\n}\n\nexport async function fetchAllMultisig(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Multisig>[]> {\n  const maybeAccounts = await fetchAllMaybeMultisig(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeMultisig(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Multisig>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeMultisig(maybeAccount));\n}\n\nexport function getMultisigSize(): number {\n  return 355;\n}\n","/**\n * Transforms a value into a JSON string, whilst rendering bigints as large unsafe integers.\n */\nexport function stringifyJsonWithBigInts(value: unknown, space?: number | string): string {\n    return unwrapBigIntValueObject(\n        JSON.stringify(value, (_, v) => (typeof v === 'bigint' ? wrapBigIntValueObject(v) : v), space),\n    );\n}\n\ntype BigIntValueObject = {\n    // `$` implies 'this is a value object'.\n    // `n` implies 'interpret the value as a bigint'.\n    $n: string;\n};\n\nfunction wrapBigIntValueObject(value: bigint): BigIntValueObject {\n    return { $n: `${value}` };\n}\n\nfunction unwrapBigIntValueObject(value: string): string {\n    return value.replace(/\\{\\s*\"\\$n\"\\s*:\\s*\"(-?\\d+)\"\\s*\\}/g, '$1');\n}\n","import { SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, SolanaError } from '@solana/errors';\nimport type { RpcTransport } from '@solana/rpc-spec';\nimport type { RpcResponse } from '@solana/rpc-spec-types';\nimport type Dispatcher from 'undici-types/dispatcher';\n\nimport { HttpTransportConfig as Config } from './http-transport-config';\nimport { assertIsAllowedHttpRequestHeaders, normalizeHeaders } from './http-transport-headers';\n\nlet didWarnDispatcherWasSuppliedInNonNodeEnvironment = false;\nfunction warnDispatcherWasSuppliedInNonNodeEnvironment() {\n    if (didWarnDispatcherWasSuppliedInNonNodeEnvironment) {\n        return;\n    }\n    didWarnDispatcherWasSuppliedInNonNodeEnvironment = true;\n    console.warn(\n        'You have supplied a `Dispatcher` to `createHttpTransport()`. It has been ignored ' +\n            'because Undici dispatchers only work in Node environments. To eliminate this ' +\n            'warning, omit the `dispatcher_NODE_ONLY` property from your config when running in ' +\n            'a non-Node environment.',\n    );\n}\n\n/**\n * Creates a function you can use to make `POST` requests with headers suitable for sending JSON\n * data to a server.\n *\n * @example\n * ```ts\n * import { createHttpTransport } from '@solana/rpc-transport-http';\n *\n * const transport = createHttpTransport({ url: 'https://api.mainnet-beta.solana.com' });\n * const response = await transport({\n *     payload: { id: 1, jsonrpc: '2.0', method: 'getSlot' },\n * });\n * const data = await response.json();\n * ```\n */\nexport function createHttpTransport(config: Config): RpcTransport {\n    if (process.env.NODE_ENV !== \"production\" && !__NODEJS__ && 'dispatcher_NODE_ONLY' in config) {\n        warnDispatcherWasSuppliedInNonNodeEnvironment();\n    }\n    const { fromJson, headers, toJson, url } = config;\n    if (process.env.NODE_ENV !== \"production\" && headers) {\n        assertIsAllowedHttpRequestHeaders(headers);\n    }\n    let dispatcherConfig: { dispatcher: Dispatcher | undefined } | undefined;\n    if (__NODEJS__ && 'dispatcher_NODE_ONLY' in config) {\n        dispatcherConfig = { dispatcher: config.dispatcher_NODE_ONLY };\n    }\n    const customHeaders = headers && normalizeHeaders(headers);\n    return async function makeHttpRequest<TResponse>({\n        payload,\n        signal,\n    }: Parameters<RpcTransport>[0]): Promise<RpcResponse<TResponse>> {\n        const body = toJson ? toJson(payload) : JSON.stringify(payload);\n        const requestInfo = {\n            ...dispatcherConfig,\n            body,\n            headers: {\n                ...customHeaders,\n                // Keep these headers lowercase so they will override any user-supplied headers above.\n                accept: 'application/json',\n                'content-length': body.length.toString(),\n                'content-type': 'application/json; charset=utf-8',\n            },\n            method: 'POST',\n            signal,\n        };\n        const response = await fetch(url, requestInfo);\n        if (!response.ok) {\n            throw new SolanaError(SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, {\n                headers: response.headers,\n                message: response.statusText,\n                statusCode: response.status,\n            });\n        }\n        if (fromJson) {\n            return fromJson(await response.text(), payload) as TResponse;\n        }\n        return await response.json();\n    };\n}\n","/**!\n * noble-ed25519\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2019 Paul Miller (https://paulmillr.com)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the Software), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nconst D = 37095705934669439343138083508754565189542113879843219016388785533085940283555n;\nconst P = 57896044618658097711785492504343953926634992332820282019728792003956564819949n; // 2n ** 255n - 19n;  ed25519 is twisted edwards curve\nconst RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n; // -1\n\n// mod division\nfunction mod(a: bigint): bigint {\n    const r = a % P;\n    return r >= 0n ? r : P + r;\n}\nfunction pow2(x: bigint, power: bigint): bigint {\n    // pow2(x, 4) == x^(2^4)\n    let r = x;\n    while (power-- > 0n) {\n        r *= r;\n        r %= P;\n    }\n    return r;\n}\nfunction pow_2_252_3(x: bigint): bigint {\n    // x^(2^252-3) unrolled util for square root\n    const x2 = (x * x) % P; // x^2,       bits 1\n    const b2 = (x2 * x) % P; // x^3,       bits 11\n    const b4 = (pow2(b2, 2n) * b2) % P; // x^(2^4-1), bits 1111\n    const b5 = (pow2(b4, 1n) * x) % P; // x^(2^5-1), bits 11111\n    const b10 = (pow2(b5, 5n) * b5) % P; // x^(2^10)\n    const b20 = (pow2(b10, 10n) * b10) % P; // x^(2^20)\n    const b40 = (pow2(b20, 20n) * b20) % P; // x^(2^40)\n    const b80 = (pow2(b40, 40n) * b40) % P; // x^(2^80)\n    const b160 = (pow2(b80, 80n) * b80) % P; // x^(2^160)\n    const b240 = (pow2(b160, 80n) * b80) % P; // x^(2^240)\n    const b250 = (pow2(b240, 10n) * b10) % P; // x^(2^250)\n    const pow_p_5_8 = (pow2(b250, 2n) * x) % P; // < To pow to (p+3)/8, multiply it by x.\n    return pow_p_5_8;\n}\nfunction uvRatio(u: bigint, v: bigint): bigint | null {\n    // for sqrt comp\n    const v3 = mod(v * v * v); // v\n    const v7 = mod(v3 * v3 * v); // v\n    const pow = pow_2_252_3(u * v7); // (uv)^(p-5)/8\n    let x = mod(u * v3 * pow); // (uv)(uv)^(p-5)/8\n    const vx2 = mod(v * x * x); // vx\n    const root1 = x; // First root candidate\n    const root2 = mod(x * RM1); // Second root candidate; RM1 is -1\n    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root\n    const useRoot2 = vx2 === mod(-u); // If vx = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === mod(-u * RM1); // There is no valid root, vx = -u-1\n    if (useRoot1) x = root1;\n    if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n    if ((mod(x) & 1n) === 1n) x = mod(-x); // edIsNegative\n    if (!useRoot1 && !useRoot2) {\n        return null;\n    }\n    return x;\n}\n// https://datatracker.ietf.org/doc/html/rfc8032#section-5.1.3\nexport function pointIsOnCurve(y: bigint, lastByte: number): boolean {\n    const y2 = mod(y * y); // y\n    const u = mod(y2 - 1n); // u=y-1\n    const v = mod(D * y2 + 1n);\n    const x = uvRatio(u, v); // (uv)(uv)^(p-5)/8; square root\n    if (x === null) {\n        return false;\n    }\n    const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n    if (x === 0n && isLastByteOdd) {\n        return false;\n    }\n    return true;\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit floating-point numbers (`f64`).\n *\n * This encoder serializes `f64` values using 8 bytes.\n * Floating-point values may lose precision when encoded.\n *\n * For more details, see {@link getF64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number, 8>` for encoding `f64` values.\n *\n * @example\n * Encoding an `f64` value.\n * ```ts\n * const encoder = getF64Encoder();\n * const bytes = encoder.encode(-1.5); // 0x000000000000f8bf\n * ```\n *\n * @see {@link getF64Codec}\n */\nexport const getF64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'f64',\n        set: (view, value, le) => view.setFloat64(0, Number(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit floating-point numbers (`f64`).\n *\n * This decoder deserializes `f64` values from 8 bytes.\n * Some precision may be lost during decoding due to floating-point representation.\n *\n * For more details, see {@link getF64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 8>` for decoding `f64` values.\n *\n * @example\n * Decoding an `f64` value.\n * ```ts\n * const decoder = getF64Decoder();\n * const value = decoder.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xbf])); // -1.5\n * ```\n *\n * @see {@link getF64Codec}\n */\nexport const getF64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat64(0, le),\n        name: 'f64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit floating-point numbers (`f64`).\n *\n * This codec serializes `f64` values using 8 bytes.\n * Due to the IEEE 754 floating-point representation, some precision loss may occur.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number, number, 8>` for encoding and decoding `f64` values.\n *\n * @example\n * Encoding and decoding an `f64` value.\n * ```ts\n * const codec = getF64Codec();\n * const bytes = codec.encode(-1.5); // 0x000000000000f8bf\n * const value = codec.decode(bytes); // -1.5\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getF64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-1.5); // 0xbff8000000000000\n * ```\n *\n * @remarks\n * `f64` values follow the IEEE 754 double-precision floating-point standard.\n * Precision loss may still occur but is significantly lower than `f32`.\n *\n * - If you need smaller floating-point values, consider using {@link getF32Codec}.\n * - If you need integer values, consider using {@link getI64Codec} or {@link getU64Codec}.\n *\n * Separate {@link getF64Encoder} and {@link getF64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getF64Encoder().encode(-1.5);\n * const value = getF64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getF64Encoder}\n * @see {@link getF64Decoder}\n */\nexport const getF64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 8> =>\n    combineCodec(getF64Encoder(config), getF64Decoder(config));\n","import { equalBytes } from '@noble/curves/abstract/utils'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Json from './Json.js'\nimport * as internal_bytes from './internal/bytes.js'\nimport * as internal from './internal/hex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) =>\n  i.toString(16).padStart(2, '0'),\n)\n\n/** Root type for a Hex string. */\nexport type Hex = `0x${string}`\n\n/**\n * Asserts if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('abc')\n * // @error: InvalidHexValueTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid hex type.\n * // @error: Hex types must be represented as `\"0x\\${string}\"`.\n * ```\n *\n * @param value - The value to assert.\n * @param options - Options.\n */\nexport function assert(\n  value: unknown,\n  options: assert.Options = {},\n): asserts value is Hex {\n  const { strict = false } = options\n  if (!value) throw new InvalidHexTypeError(value)\n  if (typeof value !== 'string') throw new InvalidHexTypeError(value)\n  if (strict) {\n    if (!/^0x[0-9a-fA-F]*$/.test(value)) throw new InvalidHexValueError(value)\n  }\n  if (!value.startsWith('0x')) throw new InvalidHexValueError(value)\n}\n\nexport declare namespace assert {\n  type Options = {\n    /** Checks if the {@link ox#Hex.Hex} value contains invalid hexadecimal characters. @default false */\n    strict?: boolean | undefined\n  }\n\n  type ErrorType =\n    | InvalidHexTypeError\n    | InvalidHexValueError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Concatenates two or more {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.concat('0x123', '0x456')\n * // @log: '0x123456'\n * ```\n *\n * @param values - The {@link ox#Hex.Hex} values to concatenate.\n * @returns The concatenated {@link ox#Hex.Hex} value.\n */\nexport function concat(...values: readonly Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce((acc, x) => acc + x.replace('0x', ''), '')}`\n}\n\nexport declare namespace concat {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates a {@link ox#Hex.Hex} value from a hex string or {@link ox#Bytes.Bytes} value.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Hex.fromBoolean`\n *\n * - `Hex.fromString`\n *\n * - `Hex.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.from('0x48656c6c6f20576f726c6421')\n * // @log: '0x48656c6c6f20576f726c6421'\n *\n * Hex.from(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function from(value: Hex | Bytes.Bytes | readonly number[]): Hex {\n  if (value instanceof Uint8Array) return fromBytes(value)\n  if (Array.isArray(value)) return fromBytes(new Uint8Array(value))\n  return value as never\n}\n\nexport declare namespace from {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a boolean into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromBoolean(true)\n * // @log: '0x1'\n *\n * Hex.fromBoolean(false)\n * // @log: '0x0'\n *\n * Hex.fromBoolean(true, { size: 32 })\n * // @log: '0x0000000000000000000000000000000000000000000000000000000000000001'\n * ```\n *\n * @param value - The boolean value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromBoolean(\n  value: boolean,\n  options: fromBoolean.Options = {},\n): Hex {\n  const hex: Hex = `0x${Number(value)}`\n  if (typeof options.size === 'number') {\n    internal.assertSize(hex, options.size)\n    return padLeft(hex, options.size)\n  }\n  return hex\n}\n\nexport declare namespace fromBoolean {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | padLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.fromBytes(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromBytes(\n  value: Bytes.Bytes,\n  options: fromBytes.Options = {},\n): Hex {\n  let string = ''\n  for (let i = 0; i < value.length; i++) string += hexes[value[i]!]\n  const hex = `0x${string}` as const\n\n  if (typeof options.size === 'number') {\n    internal.assertSize(hex, options.size)\n    return padRight(hex, options.size)\n  }\n  return hex\n}\n\nexport declare namespace fromBytes {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | padRight.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a number or bigint into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420)\n * // @log: '0x1a4'\n *\n * Hex.fromNumber(420, { size: 32 })\n * // @log: '0x00000000000000000000000000000000000000000000000000000000000001a4'\n * ```\n *\n * @param value - The number or bigint value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromNumber(\n  value: number | bigint,\n  options: fromNumber.Options = {},\n): Hex {\n  const { signed, size } = options\n\n  const value_ = BigInt(value)\n\n  let maxValue: bigint | number | undefined\n  if (size) {\n    if (signed) maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n\n    else maxValue = 2n ** (BigInt(size) * 8n) - 1n\n  } else if (typeof value === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER)\n  }\n\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0\n\n  if ((maxValue && value_ > maxValue) || value_ < minValue) {\n    const suffix = typeof value === 'bigint' ? 'n' : ''\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value}${suffix}`,\n    })\n  }\n\n  const stringValue = (\n    signed && value_ < 0 ? (1n << BigInt(size * 8)) + BigInt(value_) : value_\n  ).toString(16)\n\n  const hex = `0x${stringValue}` as Hex\n  if (size) return padLeft(hex, size) as Hex\n  return hex\n}\n\nexport declare namespace fromNumber {\n  type Options =\n    | {\n        /** Whether or not the number of a signed representation. */\n        signed?: boolean | undefined\n        /** The size (in bytes) of the output hex value. */\n        size: number\n      }\n    | {\n        signed?: undefined\n        /** The size (in bytes) of the output hex value. */\n        size?: number | undefined\n      }\n\n  type ErrorType =\n    | IntegerOutOfRangeError\n    | padLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a string into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n * Hex.fromString('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * Hex.fromString('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n * ```\n *\n * @param value - The string value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nexport function fromString(\n  value: string,\n  options: fromString.Options = {},\n): Hex {\n  return fromBytes(encoder.encode(value), options)\n}\n\nexport declare namespace fromString {\n  type Options = {\n    /** The size (in bytes) of the output hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Checks if two {@link ox#Hex.Hex} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.isEqual('0xdeadbeef', '0xdeadbeef')\n * // @log: true\n *\n * Hex.isEqual('0xda', '0xba')\n * // @log: false\n * ```\n *\n * @param hexA - The first {@link ox#Hex.Hex} value.\n * @param hexB - The second {@link ox#Hex.Hex} value.\n * @returns `true` if the two {@link ox#Hex.Hex} values are equal, `false` otherwise.\n */\nexport function isEqual(hexA: Hex, hexB: Hex) {\n  return equalBytes(Bytes.fromHex(hexA), Bytes.fromHex(hexB))\n}\n\nexport declare namespace isEqual {\n  type ErrorType = Bytes.fromHex.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Pads a {@link ox#Hex.Hex} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1234', 4)\n * // @log: '0x00001234'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nexport function padLeft(\n  value: Hex,\n  size?: number | undefined,\n): padLeft.ReturnType {\n  return internal.pad(value, { dir: 'left', size })\n}\n\nexport declare namespace padLeft {\n  type ReturnType = Hex\n  type ErrorType = internal.pad.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Pads a {@link ox#Hex.Hex} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts\n * import { Hex } from 'ox'\n *\n * Hex.padRight('0x1234', 4)\n * // @log: '0x12340000'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nexport function padRight(\n  value: Hex,\n  size?: number | undefined,\n): padRight.ReturnType {\n  return internal.pad(value, { dir: 'right', size })\n}\n\nexport declare namespace padRight {\n  type ReturnType = Hex\n  type ErrorType = internal.pad.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Generates a random {@link ox#Hex.Hex} value of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const hex = Hex.random(32)\n * // @log: '0x...'\n * ```\n *\n * @returns Random {@link ox#Hex.Hex} value.\n */\nexport function random(length: number): Hex {\n  return fromBytes(Bytes.random(length))\n}\n\nexport declare namespace random {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 1, 4)\n * // @log: '0x234567'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to slice.\n * @param start - The start offset (in bytes).\n * @param end - The end offset (in bytes).\n * @param options - Options.\n * @returns The sliced {@link ox#Hex.Hex} value.\n */\nexport function slice(\n  value: Hex,\n  start?: number | undefined,\n  end?: number | undefined,\n  options: slice.Options = {},\n): Hex {\n  const { strict } = options\n  internal.assertStartOffset(value, start)\n  const value_ = `0x${value\n    .replace('0x', '')\n    .slice((start ?? 0) * 2, (end ?? value.length) * 2)}` as const\n  if (strict) internal.assertEndOffset(value_, start, end)\n  return value_\n}\n\nexport declare namespace slice {\n  type Options = {\n    /** Asserts that the sliced value is the same size as the given start/end offsets. */\n    strict?: boolean | undefined\n  }\n\n  type ErrorType =\n    | internal.assertStartOffset.ErrorType\n    | internal.assertEndOffset.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Retrieves the size of a {@link ox#Hex.Hex} value (in bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.size('0xdeadbeef')\n * // @log: 4\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to get the size of.\n * @returns The size of the {@link ox#Hex.Hex} value (in bytes).\n */\nexport function size(value: Hex): number {\n  return Math.ceil((value.length - 2) / 2)\n}\n\nexport declare namespace size {\n  export type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Trims leading zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimLeft('0x00000000deadbeef')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nexport function trimLeft(value: Hex): trimLeft.ReturnType {\n  return internal.trim(value, { dir: 'left' })\n}\n\nexport declare namespace trimLeft {\n  type ReturnType = Hex\n\n  type ErrorType = internal.trim.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Trims trailing zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimRight('0xdeadbeef00000000')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nexport function trimRight(value: Hex): trimRight.ReturnType {\n  return internal.trim(value, { dir: 'right' })\n}\n\nexport declare namespace trimRight {\n  type ReturnType = Hex\n\n  type ErrorType = internal.trim.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a BigInt.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBigInt('0x1a4')\n * // @log: 420n\n *\n * Hex.toBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420n\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded BigInt.\n */\nexport function toBigInt(hex: Hex, options: toBigInt.Options = {}): bigint {\n  const { signed } = options\n\n  if (options.size) internal.assertSize(hex, options.size)\n\n  const value = BigInt(hex)\n  if (!signed) return value\n\n  const size = (hex.length - 2) / 2\n\n  const max_unsigned = (1n << (BigInt(size) * 8n)) - 1n\n  const max_signed = max_unsigned >> 1n\n\n  if (value <= max_signed) return value\n  return value - max_unsigned - 1n\n}\n\nexport declare namespace toBigInt {\n  type Options = {\n    /** Whether or not the number of a signed representation. */\n    signed?: boolean | undefined\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = internal.assertSize.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0x01')\n * // @log: true\n *\n * Hex.toBoolean('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // @log: true\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded boolean.\n */\nexport function toBoolean(hex: Hex, options: toBoolean.Options = {}): boolean {\n  if (options.size) internal.assertSize(hex, options.size)\n  const hex_ = trimLeft(hex)\n  if (hex_ === '0x') return false\n  if (hex_ === '0x1') return true\n  throw new InvalidHexBooleanError(hex)\n}\n\nexport declare namespace toBoolean {\n  type Options = {\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | trimLeft.ErrorType\n    | InvalidHexBooleanError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const data = Hex.toBytes('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded {@link ox#Bytes.Bytes}.\n */\nexport function toBytes(hex: Hex, options: toBytes.Options = {}): Bytes.Bytes {\n  return Bytes.fromHex(hex, options)\n}\n\nexport declare namespace toBytes {\n  type Options = {\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType = Bytes.fromHex.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a number.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toNumber('0x1a4')\n * // @log: 420\n *\n * Hex.toNumber('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded number.\n */\nexport function toNumber(hex: Hex, options: toNumber.Options = {}): number {\n  const { signed, size } = options\n  if (!signed && !size) return Number(hex)\n  return Number(toBigInt(hex, options))\n}\n\nexport declare namespace toNumber {\n  type Options = toBigInt.Options\n\n  type ErrorType = toBigInt.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Hex.Hex} value into a string.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toString('0x48656c6c6f20576f726c6421')\n * // @log: 'Hello world!'\n *\n * Hex.toString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // @log: 'Hello world'\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded string.\n */\nexport function toString(hex: Hex, options: toString.Options = {}): string {\n  const { size } = options\n\n  let bytes = Bytes.fromHex(hex)\n  if (size) {\n    internal_bytes.assertSize(bytes, size)\n    bytes = Bytes.trimRight(bytes)\n  }\n  return new TextDecoder().decode(bytes)\n}\n\nexport declare namespace toString {\n  type Options = {\n    /** Size (in bytes) of the hex value. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal_bytes.assertSize.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Bytes.trimRight.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.validate('0xdeadbeef')\n * // @log: true\n *\n * Hex.validate(Bytes.from([1, 2, 3]))\n * // @log: false\n * ```\n *\n * @param value - The value to check.\n * @param options - Options.\n * @returns `true` if the value is a {@link ox#Hex.Hex}, `false` otherwise.\n */\nexport function validate(\n  value: unknown,\n  options: validate.Options = {},\n): value is Hex {\n  const { strict = false } = options\n  try {\n    assert(value, { strict })\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type Options = {\n    /** Checks if the {@link ox#Hex.Hex} value contains invalid hexadecimal characters. @default false */\n    strict?: boolean | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Thrown when the provided integer is out of range, and cannot be represented as a hex value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420182738912731283712937129)\n * // @error: Hex.IntegerOutOfRangeError: Number \\`4.2018273891273126e+26\\` is not in safe unsigned integer range (`0` to `9007199254740991`)\n * ```\n */\nexport class IntegerOutOfRangeError extends Errors.BaseError {\n  override readonly name = 'Hex.IntegerOutOfRangeError'\n\n  constructor({\n    max,\n    min,\n    signed,\n    size,\n    value,\n  }: {\n    max?: string | undefined\n    min: string\n    signed?: boolean | undefined\n    size?: number | undefined\n    value: string\n  }) {\n    super(\n      `Number \\`${value}\\` is not in safe${\n        size ? ` ${size * 8}-bit` : ''\n      }${signed ? ' signed' : ' unsigned'} integer range ${max ? `(\\`${min}\\` to \\`${max}\\`)` : `(above \\`${min}\\`)`}`,\n    )\n  }\n}\n\n/**\n * Thrown when the provided hex value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0xa')\n * // @error: Hex.InvalidHexBooleanError: Hex value `\"0xa\"` is not a valid boolean.\n * // @error: The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).\n * ```\n */\nexport class InvalidHexBooleanError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidHexBooleanError'\n\n  constructor(hex: Hex) {\n    super(`Hex value \\`\"${hex}\"\\` is not a valid boolean.`, {\n      metaMessages: [\n        'The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).',\n      ],\n    })\n  }\n}\n\n/**\n * Thrown when the provided value is not a valid hex type.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert(1)\n * // @error: Hex.InvalidHexTypeError: Value `1` of type `number` is an invalid hex type.\n * ```\n */\nexport class InvalidHexTypeError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidHexTypeError'\n\n  constructor(value: unknown) {\n    super(\n      `Value \\`${typeof value === 'object' ? Json.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid hex type.`,\n      {\n        metaMessages: ['Hex types must be represented as `\"0x${string}\"`.'],\n      },\n    )\n  }\n}\n\n/**\n * Thrown when the provided hex value is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('0x0123456789abcdefg')\n * // @error: Hex.InvalidHexValueError: Value `0x0123456789abcdefg` is an invalid hex value.\n * // @error: Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).\n * ```\n */\nexport class InvalidHexValueError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidHexValueError'\n\n  constructor(value: unknown) {\n    super(`Value \\`${value}\\` is an invalid hex value.`, {\n      metaMessages: [\n        'Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).',\n      ],\n    })\n  }\n}\n\n/**\n * Thrown when the provided hex value is an odd length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromHex('0xabcde')\n * // @error: Hex.InvalidLengthError: Hex value `\"0xabcde\"` is an odd length (5 nibbles).\n * ```\n */\nexport class InvalidLengthError extends Errors.BaseError {\n  override readonly name = 'Hex.InvalidLengthError'\n\n  constructor(value: Hex) {\n    super(\n      `Hex value \\`\"${value}\"\\` is an odd length (${value.length - 2} nibbles).`,\n      {\n        metaMessages: ['It must be an even length.'],\n      },\n    )\n  }\n}\n\n/**\n * Thrown when the size of the value exceeds the expected max size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromString('Hello World!', { size: 8 })\n * // @error: Hex.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nexport class SizeOverflowError extends Errors.BaseError {\n  override readonly name = 'Hex.SizeOverflowError'\n\n  constructor({ givenSize, maxSize }: { givenSize: number; maxSize: number }) {\n    super(\n      `Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`,\n    )\n  }\n}\n\n/**\n * Thrown when the slice offset exceeds the bounds of the value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 6)\n * // @error: Hex.SliceOffsetOutOfBoundsError: Slice starting at offset `6` is out-of-bounds (size: `5`).\n * ```\n */\nexport class SliceOffsetOutOfBoundsError extends Errors.BaseError {\n  override readonly name = 'Hex.SliceOffsetOutOfBoundsError'\n\n  constructor({\n    offset,\n    position,\n    size,\n  }: { offset: number; position: 'start' | 'end'; size: number }) {\n    super(\n      `Slice ${\n        position === 'start' ? 'starting' : 'ending'\n      } at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`,\n    )\n  }\n}\n\n/**\n * Thrown when the size of the value exceeds the pad size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1a4e12a45a21323123aaa87a897a897a898a6567a578a867a98778a667a85a875a87a6a787a65a675a6a9', 32)\n * // @error: Hex.SizeExceedsPaddingSizeError: Hex size (`43`) exceeds padding size (`32`).\n * ```\n */\nexport class SizeExceedsPaddingSizeError extends Errors.BaseError {\n  override readonly name = 'Hex.SizeExceedsPaddingSizeError'\n\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'Hex' | 'Bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`,\n    )\n  }\n}\n","import type { BaseError } from '../../../errors/base.js'\nimport type { ExactPartial } from '../../../types/utils.js'\nimport {\n  AccountNotDeployedError,\n  type AccountNotDeployedErrorType,\n  ExecutionRevertedError,\n  type ExecutionRevertedErrorType,\n  FailedToSendToBeneficiaryError,\n  type FailedToSendToBeneficiaryErrorType,\n  GasValuesOverflowError,\n  type GasValuesOverflowErrorType,\n  HandleOpsOutOfGasError,\n  type HandleOpsOutOfGasErrorType,\n  InitCodeFailedError,\n  type InitCodeFailedErrorType,\n  InitCodeMustCreateSenderError,\n  type InitCodeMustCreateSenderErrorType,\n  InitCodeMustReturnSenderError,\n  type InitCodeMustReturnSenderErrorType,\n  InsufficientPrefundError,\n  type InsufficientPrefundErrorType,\n  InternalCallOnlyError,\n  type InternalCallOnlyErrorType,\n  InvalidAccountNonceError,\n  type InvalidAccountNonceErrorType,\n  InvalidAggregatorError,\n  type InvalidAggregatorErrorType,\n  InvalidBeneficiaryError,\n  type InvalidBeneficiaryErrorType,\n  InvalidFieldsError,\n  type InvalidFieldsErrorType,\n  InvalidPaymasterAndDataError,\n  type InvalidPaymasterAndDataErrorType,\n  PaymasterDepositTooLowError,\n  type PaymasterDepositTooLowErrorType,\n  PaymasterFunctionRevertedError,\n  type PaymasterFunctionRevertedErrorType,\n  PaymasterNotDeployedError,\n  type PaymasterNotDeployedErrorType,\n  PaymasterPostOpFunctionRevertedError,\n  type PaymasterPostOpFunctionRevertedErrorType,\n  PaymasterRateLimitError,\n  type PaymasterRateLimitErrorType,\n  PaymasterStakeTooLowError,\n  type PaymasterStakeTooLowErrorType,\n  SenderAlreadyConstructedError,\n  type SenderAlreadyConstructedErrorType,\n  SignatureCheckFailedError,\n  type SignatureCheckFailedErrorType,\n  SmartAccountFunctionRevertedError,\n  type SmartAccountFunctionRevertedErrorType,\n  UnknownBundlerError,\n  type UnknownBundlerErrorType,\n  UnsupportedSignatureAggregatorError,\n  type UnsupportedSignatureAggregatorErrorType,\n  UserOperationExpiredError,\n  type UserOperationExpiredErrorType,\n  UserOperationOutOfTimeRangeError,\n  type UserOperationOutOfTimeRangeErrorType,\n  UserOperationPaymasterExpiredError,\n  type UserOperationPaymasterExpiredErrorType,\n  UserOperationPaymasterSignatureError,\n  type UserOperationPaymasterSignatureErrorType,\n  UserOperationRejectedByEntryPointError,\n  type UserOperationRejectedByEntryPointErrorType,\n  UserOperationRejectedByOpCodeError,\n  type UserOperationRejectedByOpCodeErrorType,\n  UserOperationRejectedByPaymasterError,\n  type UserOperationRejectedByPaymasterErrorType,\n  UserOperationSignatureError,\n  type UserOperationSignatureErrorType,\n  VerificationGasLimitExceededError,\n  type VerificationGasLimitExceededErrorType,\n  VerificationGasLimitTooLowError,\n  type VerificationGasLimitTooLowErrorType,\n} from '../../errors/bundler.js'\nimport type { UserOperation } from '../../types/userOperation.js'\n\nconst bundlerErrors = [\n  ExecutionRevertedError,\n  InvalidFieldsError,\n  PaymasterDepositTooLowError,\n  PaymasterRateLimitError,\n  PaymasterStakeTooLowError,\n  SignatureCheckFailedError,\n  UnsupportedSignatureAggregatorError,\n  UserOperationOutOfTimeRangeError,\n  UserOperationRejectedByEntryPointError,\n  UserOperationRejectedByPaymasterError,\n  UserOperationRejectedByOpCodeError,\n]\n\nexport type GetBundlerErrorParameters = ExactPartial<UserOperation>\n\nexport type GetBundlerErrorReturnType =\n  | AccountNotDeployedErrorType\n  | ExecutionRevertedErrorType\n  | FailedToSendToBeneficiaryErrorType\n  | GasValuesOverflowErrorType\n  | HandleOpsOutOfGasErrorType\n  | InitCodeFailedErrorType\n  | InitCodeMustCreateSenderErrorType\n  | InitCodeMustReturnSenderErrorType\n  | InsufficientPrefundErrorType\n  | InternalCallOnlyErrorType\n  | InvalidAccountNonceErrorType\n  | InvalidAggregatorErrorType\n  | InvalidBeneficiaryErrorType\n  | InvalidFieldsErrorType\n  | InvalidPaymasterAndDataErrorType\n  | PaymasterDepositTooLowErrorType\n  | PaymasterFunctionRevertedErrorType\n  | PaymasterNotDeployedErrorType\n  | PaymasterPostOpFunctionRevertedErrorType\n  | PaymasterRateLimitErrorType\n  | PaymasterStakeTooLowErrorType\n  | SignatureCheckFailedErrorType\n  | SenderAlreadyConstructedErrorType\n  | SmartAccountFunctionRevertedErrorType\n  | UnsupportedSignatureAggregatorErrorType\n  | UserOperationOutOfTimeRangeErrorType\n  | UserOperationRejectedByEntryPointErrorType\n  | UserOperationRejectedByOpCodeErrorType\n  | UserOperationRejectedByPaymasterErrorType\n  | UnknownBundlerErrorType\n  | UserOperationExpiredErrorType\n  | UserOperationPaymasterExpiredErrorType\n  | UserOperationPaymasterSignatureErrorType\n  | UserOperationSignatureErrorType\n  | VerificationGasLimitExceededErrorType\n  | VerificationGasLimitTooLowErrorType\n\nexport function getBundlerError(\n  err: BaseError,\n  args: GetBundlerErrorParameters,\n): GetBundlerErrorReturnType {\n  const message = (err.details || '').toLowerCase()\n\n  if (AccountNotDeployedError.message.test(message))\n    return new AccountNotDeployedError({\n      cause: err,\n    }) as any\n  if (FailedToSendToBeneficiaryError.message.test(message))\n    return new FailedToSendToBeneficiaryError({\n      cause: err,\n    }) as any\n  if (GasValuesOverflowError.message.test(message))\n    return new GasValuesOverflowError({\n      cause: err,\n    }) as any\n  if (HandleOpsOutOfGasError.message.test(message))\n    return new HandleOpsOutOfGasError({\n      cause: err,\n    }) as any\n  if (InitCodeFailedError.message.test(message))\n    return new InitCodeFailedError({\n      cause: err,\n      factory: args.factory,\n      factoryData: args.factoryData,\n      initCode: args.initCode,\n    }) as any\n  if (InitCodeMustCreateSenderError.message.test(message))\n    return new InitCodeMustCreateSenderError({\n      cause: err,\n      factory: args.factory,\n      factoryData: args.factoryData,\n      initCode: args.initCode,\n    }) as any\n  if (InitCodeMustReturnSenderError.message.test(message))\n    return new InitCodeMustReturnSenderError({\n      cause: err,\n      factory: args.factory,\n      factoryData: args.factoryData,\n      initCode: args.initCode,\n      sender: args.sender,\n    }) as any\n  if (InsufficientPrefundError.message.test(message))\n    return new InsufficientPrefundError({\n      cause: err,\n    }) as any\n  if (InternalCallOnlyError.message.test(message))\n    return new InternalCallOnlyError({\n      cause: err,\n    }) as any\n  if (InvalidAccountNonceError.message.test(message))\n    return new InvalidAccountNonceError({\n      cause: err,\n      nonce: args.nonce,\n    }) as any\n  if (InvalidAggregatorError.message.test(message))\n    return new InvalidAggregatorError({\n      cause: err,\n    }) as any\n  if (InvalidBeneficiaryError.message.test(message))\n    return new InvalidBeneficiaryError({\n      cause: err,\n    }) as any\n  if (InvalidPaymasterAndDataError.message.test(message))\n    return new InvalidPaymasterAndDataError({\n      cause: err,\n    }) as any\n  if (PaymasterDepositTooLowError.message.test(message))\n    return new PaymasterDepositTooLowError({\n      cause: err,\n    }) as any\n  if (PaymasterFunctionRevertedError.message.test(message))\n    return new PaymasterFunctionRevertedError({\n      cause: err,\n    }) as any\n  if (PaymasterNotDeployedError.message.test(message))\n    return new PaymasterNotDeployedError({\n      cause: err,\n    }) as any\n  if (PaymasterPostOpFunctionRevertedError.message.test(message))\n    return new PaymasterPostOpFunctionRevertedError({\n      cause: err,\n    }) as any\n  if (SmartAccountFunctionRevertedError.message.test(message))\n    return new SmartAccountFunctionRevertedError({\n      cause: err,\n    }) as any\n  if (SenderAlreadyConstructedError.message.test(message))\n    return new SenderAlreadyConstructedError({\n      cause: err,\n      factory: args.factory,\n      factoryData: args.factoryData,\n      initCode: args.initCode,\n    }) as any\n  if (UserOperationExpiredError.message.test(message))\n    return new UserOperationExpiredError({\n      cause: err,\n    }) as any\n  if (UserOperationPaymasterExpiredError.message.test(message))\n    return new UserOperationPaymasterExpiredError({\n      cause: err,\n    }) as any\n  if (UserOperationPaymasterSignatureError.message.test(message))\n    return new UserOperationPaymasterSignatureError({\n      cause: err,\n    }) as any\n  if (UserOperationSignatureError.message.test(message))\n    return new UserOperationSignatureError({\n      cause: err,\n    }) as any\n  if (VerificationGasLimitExceededError.message.test(message))\n    return new VerificationGasLimitExceededError({\n      cause: err,\n    }) as any\n  if (VerificationGasLimitTooLowError.message.test(message))\n    return new VerificationGasLimitTooLowError({\n      cause: err,\n    }) as any\n\n  const error = err.walk((e) =>\n    bundlerErrors.some((error) => error.code === (e as { code: number }).code),\n  ) as BaseError & { code: number; data: any }\n\n  if (error) {\n    if (error.code === ExecutionRevertedError.code)\n      return new ExecutionRevertedError({\n        cause: err,\n        data: error.data,\n        message: error.details,\n      }) as any\n    if (error.code === InvalidFieldsError.code)\n      return new InvalidFieldsError({\n        cause: err,\n      }) as any\n    if (error.code === PaymasterDepositTooLowError.code)\n      return new PaymasterDepositTooLowError({\n        cause: err,\n      }) as any\n    if (error.code === PaymasterRateLimitError.code)\n      return new PaymasterRateLimitError({\n        cause: err,\n      }) as any\n    if (error.code === PaymasterStakeTooLowError.code)\n      return new PaymasterStakeTooLowError({\n        cause: err,\n      }) as any\n    if (error.code === SignatureCheckFailedError.code)\n      return new SignatureCheckFailedError({\n        cause: err,\n      }) as any\n    if (error.code === UnsupportedSignatureAggregatorError.code)\n      return new UnsupportedSignatureAggregatorError({\n        cause: err,\n      }) as any\n    if (error.code === UserOperationOutOfTimeRangeError.code)\n      return new UserOperationOutOfTimeRangeError({\n        cause: err,\n      }) as any\n    if (error.code === UserOperationRejectedByEntryPointError.code)\n      return new UserOperationRejectedByEntryPointError({\n        cause: err,\n      }) as any\n    if (error.code === UserOperationRejectedByPaymasterError.code)\n      return new UserOperationRejectedByPaymasterError({\n        cause: err,\n      }) as any\n    if (error.code === UserOperationRejectedByOpCodeError.code)\n      return new UserOperationRejectedByOpCodeError({\n        cause: err,\n      }) as any\n  }\n\n  return new UnknownBundlerError({\n    cause: err,\n  }) as any\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    Codec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\n\n/**\n * Combines an `Encoder` and a `Decoder` into a `Codec`.\n *\n * That is, given a `Encoder<TFrom>` and a `Decoder<TTo>`, this function returns a `Codec<TFrom, TTo>`.\n *\n * This allows for modular composition by keeping encoding and decoding logic separate\n * while still offering a convenient way to bundle them into a single `Codec`.\n * This is particularly useful for library maintainers who want to expose `Encoders`,\n * `Decoders`, and `Codecs` separately, enabling tree-shaking of unused logic.\n *\n * The provided `Encoder` and `Decoder` must be compatible in terms of:\n * - **Fixed Size:** If both are fixed-size, they must have the same `fixedSize` value.\n * - **Variable Size:** If either has a `maxSize` attribute, it must match the other.\n *\n * If these conditions are not met, a {@link SolanaError} will be thrown.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size codecs).\n *\n * @param encoder - The `Encoder` to combine.\n * @param decoder - The `Decoder` to combine.\n * @returns A `Codec` that provides both `encode` and `decode` methods.\n *\n * @throws {SolanaError}\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH`\n *   Thrown if the encoder and decoder have mismatched size types (fixed vs. variable).\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH`\n *   Thrown if both are fixed-size but have different `fixedSize` values.\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH`\n *   Thrown if the `maxSize` attributes do not match.\n *\n * @example\n * Creating a fixed-size `Codec` from an encoder and a decoder.\n * ```ts\n * const encoder = getU32Encoder();\n * const decoder = getU32Decoder();\n * const codec = combineCodec(encoder, decoder);\n *\n * const bytes = codec.encode(42); // 0x2a000000\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Creating a variable-size `Codec` from an encoder and a decoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * const decoder = addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder());\n * const codec = combineCodec(encoder, decoder);\n *\n * const bytes = codec.encode(\"hello\"); // 0x0500000068656c6c6f\n * const value = codec.decode(bytes); // \"hello\"\n * ```\n *\n * @remarks\n * The recommended pattern for defining codecs in libraries is to expose separate functions for the encoder, decoder, and codec.\n * This allows users to import only what they need, improving tree-shaking efficiency.\n *\n * ```ts\n * type MyType = \\/* ... *\\/;\n * const getMyTypeEncoder = (): Encoder<MyType> => { \\/* ... *\\/ };\n * const getMyTypeDecoder = (): Decoder<MyType> => { \\/* ... *\\/ };\n * const getMyTypeCodec = (): Codec<MyType> =>\n *     combineCodec(getMyTypeEncoder(), getMyTypeDecoder());\n * ```\n *\n * @see {@link Codec}\n * @see {@link Encoder}\n * @see {@link Decoder}\n */\nexport function combineCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: VariableSizeEncoder<TFrom>,\n    decoder: VariableSizeDecoder<TTo>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo> {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize,\n        });\n    }\n\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize,\n        });\n    }\n\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write,\n    };\n}\n","import { Address } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\n\nimport { Account } from './account';\n\n/**\n * Represents an account that may or may not exist on-chain.\n *\n * When the account exists, it is represented as an {@link Account} type with an additional `exists`\n * attribute set to `true`. When it does not exist, it is represented by an object containing only\n * the address of the account and an `exists` attribute set to `false`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * // Account exists\n * const myExistingAccount: MaybeAccount<MyAccountData, '1234..5678'> = {\n *     exists: true,\n *     address: address('1234..5678'),\n *     data: { name: 'Alice', age: 30 },\n *     // ...\n * };\n *\n * // Account does not exist\n * const myMissingAccount: MaybeAccount<MyAccountData, '8765..4321'> = {\n *     exists: false,\n *     address: address('8765..4321'),\n * };\n * ```\n */\nexport type MaybeAccount<TData extends Uint8Array | object, TAddress extends string = string> =\n    | { readonly address: Address<TAddress>; readonly exists: false }\n    | (Account<TData, TAddress> & { readonly exists: true });\n\n/**\n * Represents an encoded account that may or may not exist on-chain.\n *\n * When the account exists, it is represented as an {@link Account} type having its `TData` type\n * parameter set to `Uint8Array` with an additional `exists` attribute set to `true`. When it does\n * not exist, it is represented by an object containing only the address of the account and an\n * `exists` attribute set to `false`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * // Encoded account exists\n * const myExistingAccount: MaybeEncodedAccount<'1234..5678'> = {\n *     exists: true,\n *     address: address('1234..5678'),\n *     data: new Uint8Array([1, 2, 3]),\n *     // ...\n * };\n *\n * // Encoded account does not exist\n * const myMissingAccount: MaybeEncodedAccount<'8765..4321'> = {\n *     exists: false,\n *     address: address('8765..4321'),\n * };\n * ```\n */\nexport type MaybeEncodedAccount<TAddress extends string = string> = MaybeAccount<Uint8Array, TAddress>;\n\n/**\n * Given a {@link MaybeAccount}, asserts that the account exists and allows it to be used as an\n * {@link Account} type going forward.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * const myAccount: MaybeEncodedAccount<'1234..5678'>;\n * assertAccountExists(myAccount);\n *\n * // Now we can use myAccount as an `EncodedAccount`\n * myAccount satisfies EncodedAccount<'1234..5678'>;\n * ```\n */\nexport function assertAccountExists<TData extends Uint8Array | object, TAddress extends string = string>(\n    account: MaybeAccount<TData, TAddress>,\n): asserts account is Account<TData, TAddress> & { exists: true } {\n    if (!account.exists) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND, { address: account.address });\n    }\n}\n\n/**\n * Given an array of {@link MaybeAccount | MaybeAccounts}, asserts that all the accounts exist and\n * allows them to be used as an array of {@link Account | Accounts} going forward.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * const myAccounts: MaybeEncodedAccount<Address>[];\n * assertAccountsExist(myAccounts);\n *\n * // Now we can use them as an array of `EncodedAccounts`\n * for (const a of myAccounts) {\n *     a satisfies EncodedAccount<Address>;\n * }\n * ```\n */\nexport function assertAccountsExist<TData extends Uint8Array | object, TAddress extends string = string>(\n    accounts: MaybeAccount<TData, TAddress>[],\n): asserts accounts is (Account<TData, TAddress> & { exists: true })[] {\n    const missingAccounts = accounts.filter(a => !a.exists);\n    if (missingAccounts.length > 0) {\n        const missingAddresses = missingAccounts.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND, { addresses: missingAddresses });\n    }\n}\n","import {\n    BaseTransactionMessage,\n    compileTransactionMessage,\n    getCompiledTransactionMessageEncoder,\n    isTransactionMessageWithBlockhashLifetime,\n    isTransactionMessageWithDurableNonceLifetime,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\n\nimport type { TransactionWithLifetime } from './lifetime';\nimport type { SignaturesMap, TransactionFromTransactionMessage, TransactionMessageBytes } from './transaction';\n\n/**\n * Returns a {@link Transaction} object for a given {@link TransactionMessage}.\n *\n * This includes the compiled bytes of the transaction message, and a map of signatures. This map\n * will have a key for each address that is required to sign the transaction. The transaction will\n * not yet have signatures for any of these addresses.\n *\n * Whether a transaction message is ready to be compiled or not is enforced for you at the type\n * level. In order to be signable, a transaction message must:\n *\n * - have a version and a list of zero or more instructions (ie. conform to\n *   {@link BaseTransactionMessage})\n * - have a fee payer set (ie. conform to {@link TransactionMessageWithFeePayer})\n * - have a lifetime specified (ie. conform to {@link TransactionMessageWithBlockhashLifetime} or\n *   {@link TransactionMessageWithDurableNonceLifetime})\n */\nexport function compileTransaction<TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer>(\n    transactionMessage: TTransactionMessage,\n): Readonly<TransactionFromTransactionMessage<TTransactionMessage>> {\n    type ReturnType = Readonly<TransactionFromTransactionMessage<TTransactionMessage>>;\n\n    const compiledMessage = compileTransactionMessage(transactionMessage);\n    const messageBytes = getCompiledTransactionMessageEncoder().encode(compiledMessage) as TransactionMessageBytes;\n\n    const transactionSigners = compiledMessage.staticAccounts.slice(0, compiledMessage.header.numSignerAccounts);\n    const signatures: SignaturesMap = {};\n    for (const signerAddress of transactionSigners) {\n        signatures[signerAddress] = null;\n    }\n\n    let lifetimeConstraint: TransactionWithLifetime['lifetimeConstraint'] | undefined;\n    if (isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        lifetimeConstraint = {\n            blockhash: transactionMessage.lifetimeConstraint.blockhash,\n            lastValidBlockHeight: transactionMessage.lifetimeConstraint.lastValidBlockHeight,\n        };\n    } else if (isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {\n        lifetimeConstraint = {\n            nonce: transactionMessage.lifetimeConstraint.nonce,\n            nonceAccountAddress: transactionMessage.instructions[0].accounts[0].address,\n        };\n    }\n\n    return Object.freeze({\n        ...(lifetimeConstraint ? { lifetimeConstraint } : undefined),\n        messageBytes: messageBytes,\n        signatures: Object.freeze(signatures),\n    }) as ReturnType;\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 128-bit signed integers (`i128`).\n *\n * This encoder serializes `i128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI128Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 16>` for encoding `i128` values.\n *\n * @example\n * Encoding an `i128` value.\n * ```ts\n * const encoder = getI128Encoder();\n * const bytes = encoder.encode(-42n); // 0xd6ffffffffffffffffffffffffffffff\n * ```\n *\n * @see {@link getI128Codec}\n */\nexport const getI128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'i128',\n        range: [-BigInt('0x7fffffffffffffffffffffffffffffff') - 1n, BigInt('0x7fffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\n/**\n * Returns a decoder for 128-bit signed integers (`i128`).\n *\n * This decoder deserializes `i128` values from 16 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getI128Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 16>` for decoding `i128` values.\n *\n * @example\n * Decoding an `i128` value.\n * ```ts\n * const decoder = getI128Decoder();\n * const value = decoder.decode(new Uint8Array([\n *   0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n *   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n * ])); // -42n\n * ```\n *\n * @see {@link getI128Codec}\n */\nexport const getI128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'i128',\n        size: 16,\n    });\n\n/**\n * Returns a codec for encoding and decoding 128-bit signed integers (`i128`).\n *\n * This codec serializes `i128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 16>` for encoding and decoding `i128` values.\n *\n * @example\n * Encoding and decoding an `i128` value.\n * ```ts\n * const codec = getI128Codec();\n * const bytes = codec.encode(-42n); // 0xd6ffffffffffffffffffffffffffffff\n * const value = codec.decode(bytes); // -42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI128Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42n); // 0xffffffffffffffffffffffffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^127` and `2^127 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller signed integer, consider using {@link getI64Codec} or {@link getI32Codec}.\n * - If you need a larger signed integer, consider using a custom codec.\n * - If you need unsigned integers, consider using {@link getU128Codec}.\n *\n * Separate {@link getI128Encoder} and {@link getI128Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI128Encoder().encode(-42);\n * const value = getI128Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI128Encoder}\n * @see {@link getI128Decoder}\n */\nexport const getI128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getI128Encoder(config), getI128Decoder(config));\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n} from '@solana/codecs-core';\nimport { getU64Decoder, getU64Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * Represents an integer value denominated in Lamports (ie. $1 \\times 10^{-9}$ ).\n *\n * It is represented as a `bigint` in client code and an `u64` in server code.\n */\nexport type Lamports = Brand<bigint, 'Lamports'>;\n\n// Largest possible value to be represented by a u64\nconst maxU64Value = 18446744073709551615n; // 2n ** 64n - 1n\n\nlet memoizedU64Encoder: FixedSizeEncoder<bigint | number, 8> | undefined;\nlet memoizedU64Decoder: FixedSizeDecoder<bigint, 8> | undefined;\n\nfunction getMemoizedU64Encoder(): FixedSizeEncoder<bigint | number, 8> {\n    if (!memoizedU64Encoder) memoizedU64Encoder = getU64Encoder();\n    return memoizedU64Encoder;\n}\n\nfunction getMemoizedU64Decoder(): FixedSizeDecoder<bigint, 8> {\n    if (!memoizedU64Decoder) memoizedU64Decoder = getU64Decoder();\n    return memoizedU64Decoder;\n}\n\n/**\n * This is a type guard that accepts a `bigint` as input. It will both return `true` if the integer\n * conforms to the {@link Lamports} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isLamports } from '@solana/rpc-types';\n *\n * if (isLamports(lamports)) {\n *     // At this point, `lamports` has been refined to a\n *     // `Lamports` that can be used anywhere Lamports are expected.\n *     await transfer(fromAddress, toAddress, lamports);\n * } else {\n *     setError(`${lamports} is not a quantity of Lamports`);\n * }\n * ```\n */\nexport function isLamports(putativeLamports: bigint): putativeLamports is Lamports {\n    return putativeLamports >= 0 && putativeLamports <= maxU64Value;\n}\n\n/**\n * Lamport values returned from the RPC API conform to the type {@link Lamports}. You can use a\n * value of that type wherever a quantity of Lamports is expected.\n *\n * @example\n * From time to time you might acquire a number that you expect to be a quantity of Lamports, from\n * an untrusted network API or user input. To assert that such an arbitrary number is usable as a\n * quantity of Lamports, use this function.\n *\n * ```ts\n * import { assertIsLamports } from '@solana/rpc-types';\n *\n * // Imagine a function that creates a transfer instruction when a user submits a form.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `number` type.\n *     const lamports: number = parseInt(quantityInput.value, 10);\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `lamports` to `Lamports`.\n *         assertIsLamports(lamports);\n *         // At this point, `lamports` is a `Lamports` that can be used anywhere Lamports are expected.\n *         await transfer(fromAddress, toAddress, lamports);\n *     } catch (e) {\n *         // `lamports` turned out not to validate as a quantity of Lamports.\n *     }\n * }\n * ```\n */\nexport function assertIsLamports(putativeLamports: bigint): asserts putativeLamports is Lamports {\n    if (putativeLamports < 0 || putativeLamports > maxU64Value) {\n        throw new SolanaError(SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE);\n    }\n}\n\n/**\n * This helper combines _asserting_ that a number is a possible number of {@link Lamports} with\n * _coercing_ it to the {@link Lamports} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { lamports } from '@solana/rpc-types';\n *\n * await transfer(address(fromAddress), address(toAddress), lamports(100000n));\n * ```\n */\nexport function lamports(putativeLamports: bigint): Lamports {\n    assertIsLamports(putativeLamports);\n    return putativeLamports;\n}\n\ntype ExtractAdditionalProps<T, U> = Omit<T, keyof U>;\n\n/**\n * Returns an encoder that you can use to encode a 64-bit {@link Lamports} value to 8 bytes in\n * little endian order.\n */\nexport function getDefaultLamportsEncoder(): FixedSizeEncoder<Lamports, 8> {\n    return getLamportsEncoder(getMemoizedU64Encoder());\n}\n\n/**\n * Returns an encoder that you can use to encode a {@link Lamports} value to a byte array.\n *\n * You must supply a number decoder that will determine how encode the numeric value.\n *\n * @example\n * ```ts\n * import { getLamportsEncoder } from '@solana/rpc-types';\n * import { getU16Encoder } from '@solana/codecs-numbers';\n *\n * const lamports = lamports(256n);\n * const lamportsEncoder = getLamportsEncoder(getU16Encoder());\n * const lamportsBytes = lamportsEncoder.encode(lamports);\n * // Uint8Array(2) [ 0, 1 ]\n * ```\n */\nexport function getLamportsEncoder<TEncoder extends NumberEncoder>(\n    innerEncoder: TEncoder,\n): Encoder<Lamports> & ExtractAdditionalProps<TEncoder, NumberEncoder> {\n    return innerEncoder;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a 64-bit little endian\n * number to a {@link Lamports} value.\n */\nexport function getDefaultLamportsDecoder(): FixedSizeDecoder<Lamports, 8> {\n    return getLamportsDecoder(getMemoizedU64Decoder());\n}\n\n/**\n * Returns a decoder that you can use to convert an array of bytes representing a number to a\n * {@link Lamports} value.\n *\n * You must supply a number decoder that will determine how many bits to use to decode the numeric\n * value.\n *\n * @example\n * ```ts\n * import { getLamportsDecoder } from '@solana/rpc-types';\n * import { getU16Decoder } from '@solana/codecs-numbers';\n *\n * const lamportsBytes = new Uint8Array([ 0, 1 ]);\n * const lamportsDecoder = getLamportsDecoder(getU16Decoder());\n * const lamports = lamportsDecoder.decode(lamportsBytes); // lamports(256n)\n * ```\n */\nexport function getLamportsDecoder<TDecoder extends NumberDecoder>(\n    innerDecoder: TDecoder,\n): Decoder<Lamports> & ExtractAdditionalProps<TDecoder, NumberDecoder> {\n    return transformDecoder<bigint | number, Lamports>(innerDecoder, value =>\n        lamports(typeof value === 'bigint' ? value : BigInt(value)),\n    ) as Decoder<Lamports> & ExtractAdditionalProps<TDecoder, NumberDecoder>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a 64-bit {@link Lamports} value.\n *\n * @see {@link getDefaultLamportsDecoder}\n * @see {@link getDefaultLamportsEncoder}\n */\nexport function getDefaultLamportsCodec(): FixedSizeCodec<Lamports, Lamports, 8> {\n    return combineCodec(getDefaultLamportsEncoder(), getDefaultLamportsDecoder());\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link Lamports} value.\n *\n * @see {@link getLamportsDecoder}\n * @see {@link getLamportsEncoder}\n */\nexport function getLamportsCodec<TCodec extends NumberCodec>(\n    innerCodec: TCodec,\n): Codec<Lamports, Lamports> & ExtractAdditionalProps<TCodec, NumberCodec> {\n    return combineCodec(getLamportsEncoder(innerCodec), getLamportsDecoder(innerCodec)) as Codec<Lamports, Lamports> &\n        ExtractAdditionalProps<TCodec, NumberCodec>;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU32Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedAdvanceNonceAccountInstruction,\n  type ParsedAllocateInstruction,\n  type ParsedAllocateWithSeedInstruction,\n  type ParsedAssignInstruction,\n  type ParsedAssignWithSeedInstruction,\n  type ParsedAuthorizeNonceAccountInstruction,\n  type ParsedCreateAccountInstruction,\n  type ParsedCreateAccountWithSeedInstruction,\n  type ParsedInitializeNonceAccountInstruction,\n  type ParsedTransferSolInstruction,\n  type ParsedTransferSolWithSeedInstruction,\n  type ParsedUpgradeNonceAccountInstruction,\n  type ParsedWithdrawNonceAccountInstruction,\n} from '../instructions';\n\nexport const SYSTEM_PROGRAM_ADDRESS =\n  '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n\nexport enum SystemAccount {\n  Nonce,\n}\n\nexport enum SystemInstruction {\n  CreateAccount,\n  Assign,\n  TransferSol,\n  CreateAccountWithSeed,\n  AdvanceNonceAccount,\n  WithdrawNonceAccount,\n  InitializeNonceAccount,\n  AuthorizeNonceAccount,\n  Allocate,\n  AllocateWithSeed,\n  AssignWithSeed,\n  TransferSolWithSeed,\n  UpgradeNonceAccount,\n}\n\nexport function identifySystemInstruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): SystemInstruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU32Encoder().encode(0), 0)) {\n    return SystemInstruction.CreateAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(1), 0)) {\n    return SystemInstruction.Assign;\n  }\n  if (containsBytes(data, getU32Encoder().encode(2), 0)) {\n    return SystemInstruction.TransferSol;\n  }\n  if (containsBytes(data, getU32Encoder().encode(3), 0)) {\n    return SystemInstruction.CreateAccountWithSeed;\n  }\n  if (containsBytes(data, getU32Encoder().encode(4), 0)) {\n    return SystemInstruction.AdvanceNonceAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(5), 0)) {\n    return SystemInstruction.WithdrawNonceAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(6), 0)) {\n    return SystemInstruction.InitializeNonceAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(7), 0)) {\n    return SystemInstruction.AuthorizeNonceAccount;\n  }\n  if (containsBytes(data, getU32Encoder().encode(8), 0)) {\n    return SystemInstruction.Allocate;\n  }\n  if (containsBytes(data, getU32Encoder().encode(9), 0)) {\n    return SystemInstruction.AllocateWithSeed;\n  }\n  if (containsBytes(data, getU32Encoder().encode(10), 0)) {\n    return SystemInstruction.AssignWithSeed;\n  }\n  if (containsBytes(data, getU32Encoder().encode(11), 0)) {\n    return SystemInstruction.TransferSolWithSeed;\n  }\n  if (containsBytes(data, getU32Encoder().encode(12), 0)) {\n    return SystemInstruction.UpgradeNonceAccount;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a system instruction.'\n  );\n}\n\nexport type ParsedSystemInstruction<\n  TProgram extends string = '11111111111111111111111111111111',\n> =\n  | ({\n      instructionType: SystemInstruction.CreateAccount;\n    } & ParsedCreateAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.Assign;\n    } & ParsedAssignInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.TransferSol;\n    } & ParsedTransferSolInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.CreateAccountWithSeed;\n    } & ParsedCreateAccountWithSeedInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.AdvanceNonceAccount;\n    } & ParsedAdvanceNonceAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.WithdrawNonceAccount;\n    } & ParsedWithdrawNonceAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.InitializeNonceAccount;\n    } & ParsedInitializeNonceAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.AuthorizeNonceAccount;\n    } & ParsedAuthorizeNonceAccountInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.Allocate;\n    } & ParsedAllocateInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.AllocateWithSeed;\n    } & ParsedAllocateWithSeedInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.AssignWithSeed;\n    } & ParsedAssignWithSeedInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.TransferSolWithSeed;\n    } & ParsedTransferSolWithSeedInstruction<TProgram>)\n  | ({\n      instructionType: SystemInstruction.UpgradeNonceAccount;\n    } & ParsedUpgradeNonceAccountInstruction<TProgram>);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/**\n * Returns an encoder for base-16 (hexadecimal) strings.\n *\n * This encoder serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-16 strings.\n *\n * @example\n * Encoding a base-16 string.\n * ```ts\n * const encoder = getBase16Encoder();\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-16 (hexadecimal) strings.\n *\n * This decoder deserializes base-16 encoded strings from a byte array.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-16 strings.\n *\n * @example\n * Decoding a base-16 string.\n * ```ts\n * const decoder = getBase16Decoder();\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-16 (hexadecimal) strings.\n *\n * This codec serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-16 strings.\n *\n * @example\n * Encoding and decoding a base-16 string.\n * ```ts\n * const codec = getBase16Codec();\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-16 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase16Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-16 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase16Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase16Encoder} and {@link getBase16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase16Encoder().encode('deadface');\n * const value = getBase16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase16Encoder}\n * @see {@link getBase16Decoder}\n */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","unable to read source [project]/Desktop/Web3-Projects/quantum-mints-mini/node_modules/@base-org/account/src/interface/public-utilities/spend-permission/methods/prepareSpendCallData.ts","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from '@solana/codecs-core';\n\n/**\n * Defines the configuration options for bit array codecs.\n *\n * A bit array codec encodes an array of booleans into bits, packing them into bytes.\n * This configuration allows adjusting the bit ordering.\n *\n * @see {@link getBitArrayEncoder}\n * @see {@link getBitArrayDecoder}\n * @see {@link getBitArrayCodec}\n */\nexport type BitArrayCodecConfig = {\n    /**\n     * Determines whether the bits should be read in reverse order.\n     *\n     * - `false` (default): The first boolean is stored in the most significant bit (MSB-first).\n     * - `true`: The first boolean is stored in the least significant bit (LSB-first).\n     *\n     * @defaultValue `false`\n     */\n    backward?: boolean;\n};\n\n/**\n * Returns an encoder that packs an array of booleans into bits.\n *\n * This encoder converts a list of `boolean` values into a compact bit representation,\n * storing 8 booleans per byte.\n *\n * The `backward` config option determines whether the bits are stored in MSB-first (`false`)\n * or LSB-first (`true`).\n *\n * For more details, see {@link getBitArrayCodec}.\n *\n * @typeParam TSize - The number of bytes used to store the bit array.\n *\n * @param size - The number of bytes allocated for the bit array (must be sufficient for the expected boolean count).\n * @param config - Configuration options for encoding the bit array.\n * @returns A `FixedSizeEncoder<boolean[], TSize>` for encoding bit arrays.\n *\n * @example\n * Encoding a bit array.\n * ```ts\n * const encoder = getBitArrayEncoder(1);\n *\n * encoder.encode([true, false, true, false, false, false, false, false]);\n * // 0xa0 (0b10100000)\n * ```\n *\n * @see {@link getBitArrayCodec}\n */\nexport function getBitArrayEncoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeEncoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createEncoder({\n        fixedSize: size,\n        write(value: boolean[], bytes, offset) {\n            const bytesToAdd: number[] = [];\n\n            for (let i = 0; i < size; i += 1) {\n                let byte = 0;\n                for (let j = 0; j < 8; j += 1) {\n                    const feature = Number(value[i * 8 + j] ?? 0);\n                    byte |= feature << (backward ? j : 7 - j);\n                }\n                if (backward) {\n                    bytesToAdd.unshift(byte);\n                } else {\n                    bytesToAdd.push(byte);\n                }\n            }\n\n            bytes.set(bytesToAdd, offset);\n            return size;\n        },\n    });\n}\n\n/**\n * Returns a decoder that unpacks bits into an array of booleans.\n *\n * This decoder converts a compact bit representation back into a list of `boolean` values.\n * Each byte is expanded into 8 booleans.\n *\n * The `backward` config option determines whether the bits are read in MSB-first (`false`)\n * or LSB-first (`true`).\n *\n * For more details, see {@link getBitArrayCodec}.\n *\n * @typeParam TSize - The number of bytes used to store the bit array.\n *\n * @param size - The number of bytes allocated for the bit array (must be sufficient for the expected boolean count).\n * @param config - Configuration options for decoding the bit array.\n * @returns A `FixedSizeDecoder<boolean[], TSize>` for decoding bit arrays.\n *\n * @example\n * Decoding a bit array.\n * ```ts\n * const decoder = getBitArrayDecoder(1);\n *\n * decoder.decode(new Uint8Array([0xa0]));\n * // [true, false, true, false, false, false, false, false]\n * ```\n *\n * @see {@link getBitArrayCodec}\n */\nexport function getBitArrayDecoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeDecoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createDecoder({\n        fixedSize: size,\n        read(bytes, offset) {\n            assertByteArrayHasEnoughBytesForCodec('bitArray', size, bytes, offset);\n            const booleans: boolean[] = [];\n            let slice = bytes.slice(offset, offset + size);\n            slice = backward ? slice.reverse() : slice;\n\n            slice.forEach(byte => {\n                for (let i = 0; i < 8; i += 1) {\n                    if (backward) {\n                        booleans.push(Boolean(byte & 1));\n                        byte >>= 1;\n                    } else {\n                        booleans.push(Boolean(byte & 0b1000_0000));\n                        byte <<= 1;\n                    }\n                }\n            });\n\n            return [booleans, offset + size];\n        },\n    });\n}\n\n/**\n * Returns a codec that encodes and decodes boolean arrays as compact bit representations.\n *\n * This codec efficiently stores boolean arrays as bits, packing 8 values per byte.\n * The `backward` config option determines whether bits are stored in MSB-first (`false`)\n * or LSB-first (`true`).\n *\n * @typeParam TSize - The number of bytes used to store the bit array.\n *\n * @param size - The number of bytes allocated for the bit array (must be sufficient for the expected boolean count).\n * @param config - Configuration options for encoding and decoding the bit array.\n * @returns A `FixedSizeCodec<boolean[], boolean[], TSize>` for encoding and decoding bit arrays.\n *\n * @example\n * Encoding and decoding a bit array.\n * ```ts\n * const codec = getBitArrayCodec(1);\n *\n * codec.encode([true, false, true, false, false, false, false, false]);\n * // 0xa0 (0b10100000)\n *\n * codec.decode(new Uint8Array([0xa0]));\n * // [true, false, true, false, false, false, false, false]\n * ```\n *\n * @example\n * Encoding and decoding a bit array backwards.\n * ```ts\n * const codec = getBitArrayCodec(1, { backward: true });\n *\n * codec.encode([true, false, true, false, false, false, false, false]);\n * // 0x05 (0b00000101)\n *\n * codec.decode(new Uint8Array([0x05]));\n * // [true, false, true, false, false, false, false, false]\n * ```\n *\n * @remarks\n * Separate {@link getBitArrayEncoder} and {@link getBitArrayDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBitArrayEncoder(1).encode([true, false, true, false]);\n * const value = getBitArrayDecoder(1).decode(bytes);\n * ```\n *\n * @see {@link getBitArrayEncoder}\n * @see {@link getBitArrayDecoder}\n */\nexport function getBitArrayCodec<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeCodec<boolean[], boolean[], TSize> {\n    return combineCodec(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));\n}\n","import { assertSigningCapabilityIsAvailable, assertVerificationCapabilityIsAvailable } from '@solana/assertions';\nimport { Encoder, ReadonlyUint8Array } from '@solana/codecs-core';\nimport { getBase58Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\nimport { ED25519_ALGORITHM_IDENTIFIER } from './algorithm';\n\n/**\n * A 64-byte Ed25519 signature as a base58-encoded string.\n */\nexport type Signature = Brand<EncodedString<string, 'base58'>, 'Signature'>;\n/**\n * A 64-byte Ed25519 signature.\n *\n * Whenever you need to verify that a particular signature is, in fact, the one that would have been\n * produced by signing some known bytes using the private key associated with some known public key,\n * use the {@link verifySignature} function in this package.\n */\nexport type SignatureBytes = Brand<Uint8Array, 'SignatureBytes'>;\n\nlet base58Encoder: Encoder<string> | undefined;\n\n/**\n * Asserts that an arbitrary string is a base58-encoded Ed25519 signature.\n *\n * Useful when you receive a string from user input or an untrusted network API that you expect to\n * represent an Ed25519 signature (eg. of a transaction).\n *\n * @example\n * ```ts\n * import { assertIsSignature } from '@solana/keys';\n *\n * // Imagine a function that asserts whether a user-supplied signature is valid or not.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const signature: string = signatureInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `signature` to `Signature`.\n *         assertIsSignature(signature);\n *         // At this point, `signature` is a `Signature` that can be used with the RPC.\n *         const {\n *             value: [status],\n *         } = await rpc.getSignatureStatuses([signature]).send();\n *     } catch (e) {\n *         // `signature` turned out not to be a base58-encoded signature\n *     }\n * }\n * ```\n */\nexport function assertIsSignature(putativeSignature: string): asserts putativeSignature is Signature {\n    if (!base58Encoder) base58Encoder = getBase58Encoder();\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (64 bytes of zeroes)\n        putativeSignature.length < 64 ||\n        // Highest value (64 bytes of 255)\n        putativeSignature.length > 88\n    ) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeSignature.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const bytes = base58Encoder.encode(putativeSignature);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 64) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\n/**\n * A type guard that accepts a string as input. It will both return `true` if the string conforms to\n * the {@link Signature} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isSignature } from '@solana/keys';\n *\n * if (isSignature(signature)) {\n *     // At this point, `signature` has been refined to a\n *     // `Signature` that can be used with the RPC.\n *     const {\n *         value: [status],\n *     } = await rpc.getSignatureStatuses([signature]).send();\n *     setSignatureStatus(status);\n * } else {\n *     setError(`${signature} is not a transaction signature`);\n * }\n * ```\n */\nexport function isSignature(putativeSignature: string): putativeSignature is Signature {\n    if (!base58Encoder) base58Encoder = getBase58Encoder();\n\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (64 bytes of zeroes)\n        putativeSignature.length < 64 ||\n        // Highest value (64 bytes of 255)\n        putativeSignature.length > 88\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const bytes = base58Encoder.encode(putativeSignature);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 64) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * Given a private [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) and a\n * `Uint8Array` of bytes, this method will return the 64-byte Ed25519 signature of that data as a\n * `Uint8Array`.\n *\n * @example\n * ```ts\n * import { signBytes } from '@solana/keys';\n *\n * const data = new Uint8Array([1, 2, 3]);\n * const signature = await signBytes(privateKey, data);\n * ```\n */\nexport async function signBytes(key: CryptoKey, data: ReadonlyUint8Array): Promise<SignatureBytes> {\n    assertSigningCapabilityIsAvailable();\n    const signedData = await crypto.subtle.sign(ED25519_ALGORITHM_IDENTIFIER, key, data);\n    return new Uint8Array(signedData) as SignatureBytes;\n}\n\n/**\n * This helper combines _asserting_ that a string is an Ed25519 signature with _coercing_ it to the\n * {@link Signature} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { signature } from '@solana/keys';\n *\n * const signature = signature(userSuppliedSignature);\n * const {\n *     value: [status],\n * } = await rpc.getSignatureStatuses([signature]).send();\n * ```\n */\nexport function signature(putativeSignature: string): Signature {\n    assertIsSignature(putativeSignature);\n    return putativeSignature;\n}\n\n/**\n * Given a public [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey), some\n * {@link SignatureBytes}, and a `Uint8Array` of data, this method will return `true` if the\n * signature was produced by signing the data using the private key associated with the public key,\n * and `false` otherwise.\n *\n * @example\n * ```ts\n * import { verifySignature } from '@solana/keys';\n *\n * const data = new Uint8Array([1, 2, 3]);\n * if (!(await verifySignature(publicKey, signature, data))) {\n *     throw new Error('The data were *not* signed by the private key associated with `publicKey`');\n * }\n * ```\n */\nexport async function verifySignature(\n    key: CryptoKey,\n    signature: SignatureBytes,\n    data: ReadonlyUint8Array,\n): Promise<boolean> {\n    assertVerificationCapabilityIsAvailable();\n    return await crypto.subtle.verify(ED25519_ALGORITHM_IDENTIFIER, key, signature, data);\n}\n","import { isOption, isSome, None, Some } from './option';\n\n/**\n * Defines types that should not be recursively unwrapped.\n *\n * These types are preserved as-is when using {@link unwrapOptionRecursively}.\n *\n * @see {@link unwrapOptionRecursively}\n */\ntype UnUnwrappables =\n    | Date\n    | Int8Array\n    | Int16Array\n    | Int32Array\n    | Uint8Array\n    | Uint16Array\n    | Uint32Array\n    | bigint\n    | boolean\n    | number\n    | string\n    | symbol\n    | null\n    | undefined;\n\n/**\n * A type that recursively unwraps nested {@link Option} types.\n *\n * This type resolves all nested {@link Option} values, ensuring\n * that deeply wrapped values are properly extracted.\n *\n * - If `T` is an {@link Option}, it resolves to the contained value.\n * - If `T` is a known primitive or immutable type, it remains unchanged.\n * - If `T` is an object or array, it recursively unwraps any options found.\n *\n * The fallback type `U` (default: `null`) is used in place of `None` values.\n *\n * @typeParam T - The type to be unwrapped.\n * @typeParam U - The fallback type for `None` values (defaults to `null`).\n *\n * @example\n * Resolving nested `Option` types.\n * ```ts\n * UnwrappedOption<Some<Some<string>>>; // string\n * UnwrappedOption<None>;               // null\n * ```\n *\n * @example\n * Resolving options inside objects and arrays.\n * ```ts\n * UnwrappedOption<{ a: Some<number>; b: None }>; // { a: number; b: null }\n * UnwrappedOption<[Some<number>, None]>;         // [number, null]\n * ```\n *\n * @see {@link unwrapOptionRecursively}\n */\nexport type UnwrappedOption<T, U = null> =\n    T extends Some<infer TValue>\n        ? UnwrappedOption<TValue, U>\n        : T extends None\n          ? U\n          : T extends UnUnwrappables\n            ? T\n            : T extends object\n              ? { [key in keyof T]: UnwrappedOption<T[key], U> }\n              : T extends Array<infer TItem>\n                ? Array<UnwrappedOption<TItem, U>>\n                : T;\n\n/**\n * Recursively unwraps all nested {@link Option} types within a value.\n *\n * This function traverses a given value and removes all instances\n * of {@link Option}, replacing them with their contained values.\n *\n * - If an {@link Option} is encountered, its value is extracted.\n * - If an array or object is encountered, its elements are traversed recursively.\n * - If `None` is encountered, it is replaced with the fallback value (default: `null`).\n *\n * @typeParam T - The type of the input value.\n * @typeParam U - The fallback type for `None` values (defaults to `null`).\n *\n * @param input - The value to unwrap.\n * @param fallback - A function that provides a fallback value for `None` options.\n * @returns The recursively unwrapped value.\n *\n * @example\n * Recursively unwrapping nested options.\n * ```ts\n * unwrapOptionRecursively(some(some('Hello World'))); // \"Hello World\"\n * unwrapOptionRecursively(some(none<string>()));      // null\n * ```\n *\n * @example\n * Recursively unwrapping options inside objects and arrays.\n * ```ts\n * unwrapOptionRecursively({\n *   a: 'hello',\n *   b: none(),\n *   c: [{ c1: some(42) }, { c2: none() }],\n * });\n * // { a: \"hello\", b: null, c: [{ c1: 42 }, { c2: null }] }\n * ```\n *\n * @example\n * Using a fallback value for `None` options.\n * ```ts\n * unwrapOptionRecursively(\n *   {\n *     a: 'hello',\n *     b: none(),\n *     c: [{ c1: some(42) }, { c2: none() }],\n *   },\n *   () => 'Default',\n * );\n * // { a: \"hello\", b: \"Default\", c: [{ c1: 42 }, { c2: \"Default\" }] }\n * ```\n *\n * @remarks\n * This function does not mutate objects or arrays.\n *\n * @see {@link Option}\n * @see {@link UnwrappedOption}\n */\nexport function unwrapOptionRecursively<T>(input: T): UnwrappedOption<T>;\nexport function unwrapOptionRecursively<T, U>(input: T, fallback: () => U): UnwrappedOption<T, U>;\nexport function unwrapOptionRecursively<T, U = null>(input: T, fallback?: () => U): UnwrappedOption<T, U> {\n    // Types to bypass.\n    if (!input || ArrayBuffer.isView(input)) {\n        return input as UnwrappedOption<T, U>;\n    }\n\n    const next = <X>(x: X) =>\n        (fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x)) as UnwrappedOption<X, U>;\n\n    // Handle Option.\n    if (isOption(input)) {\n        if (isSome(input)) return next(input.value) as UnwrappedOption<T, U>;\n        return (fallback ? fallback() : null) as UnwrappedOption<T, U>;\n    }\n\n    // Walk.\n    if (Array.isArray(input)) {\n        return input.map(next) as UnwrappedOption<T, U>;\n    }\n    if (typeof input === 'object') {\n        return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)])) as UnwrappedOption<T, U>;\n    }\n    return input as UnwrappedOption<T, U>;\n}\n","import { getVersion } from './internal/errors.js'\n\nexport type GlobalErrorType<name extends string = 'Error'> = Error & {\n  name: name\n}\n\n/**\n * Base error class inherited by all errors thrown by ox.\n *\n * @example\n * ```ts\n * import { Errors } from 'ox'\n * throw new Errors.BaseError('An error occurred')\n * ```\n */\nexport class BaseError<\n  cause extends Error | undefined = undefined,\n> extends Error {\n  details: string\n  docs?: string | undefined\n  docsPath?: string | undefined\n  shortMessage: string\n\n  override cause: cause\n  override name = 'BaseError'\n\n  version = `ox@${getVersion()}`\n\n  constructor(shortMessage: string, options: BaseError.Options<cause> = {}) {\n    const details = (() => {\n      if (options.cause instanceof BaseError) {\n        if (options.cause.details) return options.cause.details\n        if (options.cause.shortMessage) return options.cause.shortMessage\n      }\n      if (options.cause?.message) return options.cause.message\n      return options.details!\n    })()\n    const docsPath = (() => {\n      if (options.cause instanceof BaseError)\n        return options.cause.docsPath || options.docsPath\n      return options.docsPath\n    })()\n\n    const docsBaseUrl = 'https://oxlib.sh'\n    const docs = `${docsBaseUrl}${docsPath ?? ''}`\n\n    const message = [\n      shortMessage || 'An error occurred.',\n      ...(options.metaMessages ? ['', ...options.metaMessages] : []),\n      ...(details || docsPath\n        ? [\n            '',\n            details ? `Details: ${details}` : undefined,\n            docsPath ? `See: ${docs}` : undefined,\n          ]\n        : []),\n    ]\n      .filter((x) => typeof x === 'string')\n      .join('\\n')\n\n    super(message, options.cause ? { cause: options.cause } : undefined)\n\n    this.cause = options.cause as any\n    this.details = details\n    this.docs = docs\n    this.docsPath = docsPath\n    this.shortMessage = shortMessage\n  }\n\n  walk(): Error\n  walk(fn: (err: unknown) => boolean): Error | null\n  walk(fn?: any): any {\n    return walk(this, fn)\n  }\n}\n\nexport declare namespace BaseError {\n  type Options<cause extends Error | undefined = Error | undefined> = {\n    cause?: cause | undefined\n    details?: string | undefined\n    docsPath?: string | undefined\n    metaMessages?: (string | undefined)[] | undefined\n  }\n}\n\n/** @internal */\nfunction walk(\n  err: unknown,\n  fn?: ((err: unknown) => boolean) | undefined,\n): unknown {\n  if (fn?.(err)) return err\n  if (err && typeof err === 'object' && 'cause' in err && err.cause)\n    return walk(err.cause, fn)\n  return fn ? null : err\n}\n","import type { TypedData } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { SignTypedDataErrorType as SignTypedDataErrorType_account } from '../../accounts/utils/signTypedData.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  AccountNotFoundError,\n  type AccountNotFoundErrorType,\n} from '../../errors/account.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport type { IsHexErrorType } from '../../utils/data/isHex.js'\nimport type { StringifyErrorType } from '../../utils/stringify.js'\nimport {\n  type GetTypesForEIP712DomainErrorType,\n  getTypesForEIP712Domain,\n  type SerializeTypedDataErrorType,\n  serializeTypedData,\n  type ValidateTypedDataErrorType,\n  validateTypedData,\n} from '../../utils/typedData.js'\n\nexport type SignTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  account extends Account | undefined = undefined,\n  ///\n  primaryTypes = typedData extends TypedData ? keyof typedData : string,\n> = TypedDataDefinition<typedData, primaryType, primaryTypes> &\n  GetAccountParameter<account>\n\nexport type SignTypedDataReturnType = Hex\n\nexport type SignTypedDataErrorType =\n  | AccountNotFoundErrorType\n  | ParseAccountErrorType\n  | GetTypesForEIP712DomainErrorType\n  | ValidateTypedDataErrorType\n  | StringifyErrorType\n  | SignTypedDataErrorType_account\n  | IsHexErrorType\n  | RequestErrorType\n  | SerializeTypedDataErrorType\n  | ErrorType\n\n/**\n * Signs typed data and calculates an Ethereum-specific signature in [https://eips.ethereum.org/EIPS/eip-712](https://eips.ethereum.org/EIPS/eip-712): `sign(keccak256(\"\\x19\\x01\"  domainSeparator  hashStruct(message)))`\n *\n * - Docs: https://viem.sh/docs/actions/wallet/signTypedData\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`eth_signTypedData_v4`](https://docs.metamask.io/guide/signing-data#signtypeddata-v4)\n *   - Local Accounts: Signs locally. No JSON-RPC request.\n *\n * @param client - Client to use\n * @param parameters - {@link SignTypedDataParameters}\n * @returns The signed data. {@link SignTypedDataReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { signTypedData } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signTypedData(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { signTypedData } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const signature = await signTypedData(client, {\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n */\nexport async function signTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SignTypedDataParameters<typedData, primaryType, account>,\n): Promise<SignTypedDataReturnType> {\n  const {\n    account: account_ = client.account,\n    domain,\n    message,\n    primaryType,\n  } = parameters as unknown as SignTypedDataParameters\n\n  if (!account_)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/signTypedData',\n    })\n  const account = parseAccount(account_)\n\n  const types = {\n    EIP712Domain: getTypesForEIP712Domain({ domain }),\n    ...parameters.types,\n  }\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({ domain, message, primaryType, types })\n\n  if (account.signTypedData)\n    return account.signTypedData({ domain, message, primaryType, types })\n\n  const typedData = serializeTypedData({ domain, message, primaryType, types })\n  return client.request(\n    {\n      method: 'eth_signTypedData_v4',\n      params: [account.address, typedData],\n    },\n    { retryCount: 0 },\n  )\n}\n","import { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\nimport { TransactionSigner } from './transaction-signer';\n\n/**\n * Alternative to {@link TransactionMessageWithFeePayer} that uses a {@link TransactionSigner} for the fee payer.\n *\n * @typeParam TAddress - Supply a string literal to define a fee payer having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for the {@link TransactionSigner}.\n *\n * @example\n * ```ts\n * import { BaseTransactionMessage } from '@solana/transaction-messages';\n * import { generateKeyPairSigner, TransactionMessageWithFeePayerSigner } from '@solana/signers';\n *\n * const transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayerSigner = {\n *     feePayer: await generateKeyPairSigner(),\n *     instructions: [],\n *     version: 0,\n * };\n * ```\n */\nexport interface TransactionMessageWithFeePayerSigner<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n> {\n    readonly feePayer: TSigner;\n}\n\n/**\n * Sets the fee payer of a {@link BaseTransactionMessage | transaction message}\n * using a {@link TransactionSigner}.\n *\n * @typeParam TFeePayerAddress - Supply a string literal to define a fee payer having a particular address.\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import { pipe } from '@solana/functional';\n * import { generateKeyPairSigner, setTransactionMessageFeePayerSigner } from '@solana/signers';\n * import { createTransactionMessage } from '@solana/transaction-messages';\n *\n * const feePayer = await generateKeyPairSigner();\n * const transactionMessage = pipe(\n *     createTransactionMessage({ version: 0 }),\n *     message => setTransactionMessageFeePayerSigner(signer, message),\n * );\n * ```\n */\nexport function setTransactionMessageFeePayerSigner<\n    TFeePayerAddress extends string,\n    TTransactionMessage extends BaseTransactionMessage &\n        Partial<TransactionMessageWithFeePayer | TransactionMessageWithFeePayerSigner>,\n>(\n    feePayer: TransactionSigner<TFeePayerAddress>,\n    transactionMessage: TTransactionMessage,\n): Omit<TTransactionMessage, 'feePayer'> & TransactionMessageWithFeePayerSigner<TFeePayerAddress> {\n    Object.freeze(feePayer);\n    const out = { ...transactionMessage, feePayer };\n    Object.freeze(out);\n    return out;\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SolanaError,\n} from '@solana/errors';\n\nimport { containsBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Creates an encoder that writes a `Uint8Array` sentinel after the encoded value.\n * This is useful to delimit the encoded value when being read by a decoder.\n *\n * See {@link addCodecSentinel} for more information.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link addCodecSentinel}\n */\nexport function addEncoderSentinel<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(\n    encoder: Encoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(encoder: Encoder<TFrom>, sentinel: ReadonlyUint8Array): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds\n        // and to avoid writing the sentinel as part of the encoded value.\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });\n    }\n\n    return createEncoder({\n        ...encoder,\n        ...(encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {}),\n        getSizeFromValue: value => encoder.getSizeFromValue(value) + sentinel.length,\n        write,\n    });\n}\n\n/**\n * Creates a decoder that continues reading until\n * a given `Uint8Array` sentinel is found.\n *\n * See {@link addCodecSentinel} for more information.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link addCodecSentinel}\n */\nexport function addDecoderSentinel<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): VariableSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds\n        // and ensure that the sentinel is not part of the decoded value.\n        return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });\n    }\n\n    return createDecoder({\n        ...decoder,\n        ...(decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {}),\n        read,\n    });\n}\n\n/**\n * Creates a Codec that writes a given `Uint8Array` sentinel after the encoded\n * value and, when decoding, continues reading until the sentinel is found.\n *\n * This sets a limit on variable-size codecs and tells us when to stop decoding.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const codec = addCodecSentinel(getUtf8Codec(), new Uint8Array([255, 255]));\n * codec.encode('hello');\n * // 0x68656c6c6fffff\n * //   |        -- Our sentinel.\n * //   -- Our encoded string.\n * ```\n *\n * @remarks\n * Note that the sentinel _must not_ be present in the encoded data and\n * _must_ be present in the decoded data for this to work.\n * If this is not the case, dedicated errors will be thrown.\n *\n * ```ts\n * const sentinel = new Uint8Array([108, 108]); // 'll'\n * const codec = addCodecSentinel(getUtf8Codec(), sentinel);\n *\n * codec.encode('hello'); // Throws: sentinel is in encoded data.\n * codec.decode(new Uint8Array([1, 2, 3])); // Throws: sentinel missing in decoded data.\n * ```\n *\n * Separate {@link addEncoderSentinel} and {@link addDecoderSentinel} functions are also available.\n *\n * ```ts\n * const bytes = addEncoderSentinel(getUtf8Encoder(), sentinel).encode('hello');\n * const value = addDecoderSentinel(getUtf8Decoder(), sentinel).decode(bytes);\n * ```\n *\n * @see {@link addEncoderSentinel}\n * @see {@link addDecoderSentinel}\n */\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\n\nfunction findSentinelIndex(bytes: ReadonlyUint8Array, sentinel: ReadonlyUint8Array) {\n    return bytes.findIndex((byte, index, arr) => {\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\n\nfunction hexBytes(bytes: ReadonlyUint8Array): string {\n    return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","import { Address, getAddressFromPublicKey } from '@solana/addresses';\nimport { Decoder } from '@solana/codecs-core';\nimport { getBase58Decoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { Signature, SignatureBytes, signBytes } from '@solana/keys';\nimport { NominalType } from '@solana/nominal-types';\n\nimport { TransactionWithLifetime } from './lifetime';\nimport { Transaction } from './transaction';\n\n/**\n * Represents a transaction that is signed by all of its required signers. Being fully signed is a\n * prerequisite of functions designed to land transactions on the network.\n */\nexport type FullySignedTransaction = NominalType<'transactionSignedness', 'fullySigned'>;\n\nlet base58Decoder: Decoder<string> | undefined;\n\n/**\n * Given a transaction signed by its fee payer, this method will return the {@link Signature} that\n * uniquely identifies it. This string can be used to look up transactions at a later date, for\n * example on a Solana block explorer.\n *\n * @example\n * ```ts\n * import { getSignatureFromTransaction } from '@solana/transactions';\n *\n * const signature = getSignatureFromTransaction(tx);\n * console.debug(`Inspect this transaction at https://explorer.solana.com/tx/${signature}`);\n * ```\n */\nexport function getSignatureFromTransaction(transaction: Transaction): Signature {\n    if (!base58Decoder) base58Decoder = getBase58Decoder();\n\n    // We have ordered signatures from the compiled message accounts\n    // first signature is the fee payer\n    const signatureBytes = Object.values(transaction.signatures)[0];\n    if (!signatureBytes) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING);\n    }\n    const transactionSignature = base58Decoder.decode(signatureBytes);\n    return transactionSignature as Signature;\n}\n\nfunction uint8ArraysEqual(arr1: Uint8Array, arr2: Uint8Array) {\n    return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);\n}\n\n/**\n * Given an array of `CryptoKey` objects which are private keys pertaining to addresses that are\n * required to sign a transaction, this method will return a new signed transaction of type\n * {@link Transaction}.\n *\n * Though the resulting transaction might have every signature it needs to land on the network, this\n * function will not assert that it does. A partially signed transaction cannot be landed on the\n * network, but can be serialized and deserialized.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { partiallySignTransaction } from '@solana/transactions';\n *\n * const partiallySignedTransaction = await partiallySignTransaction([myPrivateKey], tx);\n * ```\n *\n * @see {@link signTransaction} if you want to assert that the transaction has all of its required\n * signatures after signing.\n */\nexport async function partiallySignTransaction<TTransaction extends Transaction & TransactionWithLifetime>(\n    keyPairs: CryptoKeyPair[],\n    transaction: TTransaction,\n): Promise<TTransaction> {\n    let newSignatures: Record<Address, SignatureBytes> | undefined;\n    let unexpectedSigners: Set<Address> | undefined;\n\n    await Promise.all(\n        keyPairs.map(async keyPair => {\n            const address = await getAddressFromPublicKey(keyPair.publicKey);\n            const existingSignature = transaction.signatures[address];\n\n            // Check if the address is expected to sign the transaction\n            if (existingSignature === undefined) {\n                // address is not an expected signer for this transaction\n                unexpectedSigners ||= new Set();\n                unexpectedSigners.add(address);\n                return;\n            }\n\n            // Return if there are any unexpected signers already since we won't be using signatures\n            if (unexpectedSigners) {\n                return;\n            }\n\n            const newSignature = await signBytes(keyPair.privateKey, transaction.messageBytes);\n\n            if (existingSignature !== null && uint8ArraysEqual(newSignature, existingSignature)) {\n                // already have the same signature set\n                return;\n            }\n\n            newSignatures ||= {};\n            newSignatures[address] = newSignature;\n        }),\n    );\n\n    if (unexpectedSigners && unexpectedSigners.size > 0) {\n        const expectedSigners = Object.keys(transaction.signatures);\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION, {\n            expectedAddresses: expectedSigners,\n            unexpectedAddresses: [...unexpectedSigners],\n        });\n    }\n\n    if (!newSignatures) {\n        return transaction;\n    }\n\n    return Object.freeze({\n        ...transaction,\n        signatures: Object.freeze({\n            ...transaction.signatures,\n            ...newSignatures,\n        }),\n    });\n}\n\n/**\n * Given an array of `CryptoKey` objects which are private keys pertaining to addresses that are\n * required to sign a transaction, this method will return a new signed transaction of type\n * {@link FullySignedTransaction}.\n *\n * This function will throw unless the resulting transaction is fully signed.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { signTransaction } from '@solana/transactions';\n *\n * const signedTransaction = await signTransaction([myPrivateKey], tx);\n * ```\n *\n * @see {@link partiallySignTransaction} if you want to sign the transaction without asserting that\n * the resulting transaction is fully signed.\n */\nexport async function signTransaction<TTransaction extends Transaction & TransactionWithLifetime>(\n    keyPairs: CryptoKeyPair[],\n    transaction: TTransaction,\n): Promise<FullySignedTransaction & TTransaction> {\n    const out = await partiallySignTransaction(keyPairs, transaction);\n    assertIsFullySignedTransaction(out);\n    Object.freeze(out);\n    return out;\n}\n\n/**\n * Checks whether a given {@link Transaction} is fully signed.\n *\n * @example\n * ```ts\n * import { isFullySignedTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * if (isFullySignedTransaction(transaction)) {\n *   // At this point we know that the transaction is signed and can be sent to the network.\n * }\n * ```\n */\nexport function isFullySignedTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): transaction is FullySignedTransaction & TTransaction {\n    return Object.entries(transaction.signatures).every(([_, signatureBytes]) => !!signatureBytes);\n}\n\n/**\n * From time to time you might acquire a {@link Transaction}, that you expect to be fully signed,\n * from an untrusted network API or user input. Use this function to assert that such a transaction\n * is fully signed.\n *\n * @example\n * ```ts\n * import { assertIsFullySignedTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * try {\n *     // If this type assertion function doesn't throw, then Typescript will upcast `transaction`\n *     // to `FullySignedTransaction`.\n *     assertIsFullySignedTransaction(transaction);\n *     // At this point we know that the transaction is signed and can be sent to the network.\n *     await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n * } catch(e) {\n *     if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING)) {\n *         setError(`Missing signatures for ${e.context.addresses.join(', ')}`);\n *     }\n *     throw;\n * }\n * ```\n */\nexport function assertIsFullySignedTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): asserts transaction is FullySignedTransaction & TTransaction {\n    const missingSigs: Address[] = [];\n    Object.entries(transaction.signatures).forEach(([address, signatureBytes]) => {\n        if (!signatureBytes) {\n            missingSigs.push(address as Address);\n        }\n    });\n\n    if (missingSigs.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING, {\n            addresses: missingSigs,\n        });\n    }\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    type Encoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport type { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\n\ntype AddressTableLookup = ReturnType<typeof getCompiledAddressTableLookups>[number];\n\nlet memoizedAddressTableLookupEncoder: VariableSizeEncoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupEncoder(): VariableSizeEncoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupEncoder) {\n        const indexEncoder = getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() }) as Encoder<\n            readonly number[]\n        >;\n        memoizedAddressTableLookupEncoder = getStructEncoder([\n            ['lookupTableAddress', getAddressEncoder()],\n            ['writableIndexes', indexEncoder],\n            ['readonlyIndexes', indexEncoder],\n        ]);\n    }\n\n    return memoizedAddressTableLookupEncoder;\n}\n\nlet memoizedAddressTableLookupDecoder: VariableSizeDecoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupDecoder(): VariableSizeDecoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupDecoder) {\n        const indexEncoder = getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() });\n        memoizedAddressTableLookupDecoder = getStructDecoder([\n            ['lookupTableAddress', getAddressDecoder()],\n            ['writableIndexes', indexEncoder],\n            ['readonlyIndexes', indexEncoder],\n        ]);\n    }\n\n    return memoizedAddressTableLookupDecoder;\n}\n\nexport function getAddressTableLookupCodec(): VariableSizeCodec<AddressTableLookup> {\n    return combineCodec(getAddressTableLookupEncoder(), getAddressTableLookupDecoder());\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 16-bit signed integers (`i16`).\n *\n * This encoder serializes `i16` values using 2 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI16Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 2>` for encoding `i16` values.\n *\n * @example\n * Encoding an `i16` value.\n * ```ts\n * const encoder = getI16Encoder();\n * const bytes = encoder.encode(-42); // 0xd6ff\n * ```\n *\n * @see {@link getI16Codec}\n */\nexport const getI16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'i16',\n        range: [-Number('0x7fff') - 1, Number('0x7fff')],\n        set: (view, value, le) => view.setInt16(0, Number(value), le),\n        size: 2,\n    });\n\n/**\n * Returns a decoder for 16-bit signed integers (`i16`).\n *\n * This decoder deserializes `i16` values from 2 bytes.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI16Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 2>` for decoding `i16` values.\n *\n * @example\n * Decoding an `i16` value.\n * ```ts\n * const decoder = getI16Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6, 0xff])); // -42\n * ```\n *\n * @see {@link getI16Codec}\n */\nexport const getI16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt16(0, le),\n        name: 'i16',\n        size: 2,\n    });\n\n/**\n * Returns a codec for encoding and decoding 16-bit signed integers (`i16`).\n *\n * This codec serializes `i16` values using 2 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, number, 2>` for encoding and decoding `i16` values.\n *\n * @example\n * Encoding and decoding an `i16` value.\n * ```ts\n * const codec = getI16Codec();\n * const bytes = codec.encode(-42); // 0xd6ff\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI16Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42); // 0xffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^15` (`-32,768`) and `2^15 - 1` (`32,767`).\n *\n * - If you need a smaller signed integer, consider using {@link getI8Codec}.\n * - If you need a larger signed integer, consider using {@link getI32Codec}.\n * - If you need unsigned integers, consider using {@link getU16Codec}.\n *\n * Separate {@link getI16Encoder} and {@link getI16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI16Encoder().encode(-42);\n * const value = getI16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI16Encoder}\n * @see {@link getI16Decoder}\n */\nexport const getI16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getI16Encoder(config), getI16Decoder(config));\n","import type { RpcRequest, RpcRequestTransformer } from '@solana/rpc-spec-types';\nimport type { Commitment } from '@solana/rpc-types';\n\nimport { applyDefaultCommitment } from './request-transformer-default-commitment-internal';\n\n/**\n * Creates a transformer that adds the provided default commitment to the configuration object of the request when applicable.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { getDefaultCommitmentRequestTransformer, OPTIONS_OBJECT_POSITION_BY_METHOD } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getDefaultCommitmentRequestTransformer({\n *     defaultCommitment: 'confirmed',\n *     optionsObjectPositionByMethod: OPTIONS_OBJECT_POSITION_BY_METHOD,\n * });\n */\nexport function getDefaultCommitmentRequestTransformer({\n    defaultCommitment,\n    optionsObjectPositionByMethod,\n}: Readonly<{\n    defaultCommitment?: Commitment;\n    optionsObjectPositionByMethod: Record<string, number>;\n}>): RpcRequestTransformer {\n    return <TParams>(request: RpcRequest<TParams>): RpcRequest => {\n        const { params, methodName } = request;\n\n        // We only apply default commitment to array parameters.\n        if (!Array.isArray(params)) {\n            return request;\n        }\n\n        // Find the position of the options object in the parameters and abort if not found.\n        const optionsObjectPositionInParams = optionsObjectPositionByMethod[methodName];\n        if (optionsObjectPositionInParams == null) {\n            return request;\n        }\n\n        return Object.freeze({\n            methodName,\n            params: applyDefaultCommitment({\n                commitmentPropertyName: methodName === 'sendTransaction' ? 'preflightCommitment' : 'commitment',\n                optionsObjectPositionInParams,\n                overrideCommitment: defaultCommitment,\n                params,\n            }),\n        });\n    };\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, SolanaError } from '@solana/errors';\n\nimport { SignableMessage } from './signable-message';\nimport { BaseSignerConfig, SignatureDictionary } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link MessagePartialSigner#signMessages | signMessages} method.\n *\n * @see {@link BaseSignerConfig}\n */\nexport type MessagePartialSignerConfig = BaseSignerConfig;\n\n/**\n * A signer interface that signs an array of {@link SignableMessage | SignableMessages}\n * without modifying their content.\n *\n * It defines a {@link MessagePartialSigner#signMessages | signMessages} function\n * that returns a {@link SignatureDictionary} for each provided message.\n * Such signature dictionaries are expected to be merged with the existing ones if any.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: MessagePartialSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     signMessages: async (\n *         messages: SignableMessage[]\n *     ): Promise<SignatureDictionary[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Parallel**. When multiple signers sign the same message, we can\n *   perform this operation in parallel to obtain all their signatures.\n * - **Flexible order**. The order in which we use these signers\n *   for a given message doesnt matter.\n *\n * @see {@link SignableMessage}\n * @see {@link createSignableMessage}\n * @see {@link isMessagePartialSigner}\n * @see {@link assertIsMessagePartialSigner}\n */\nexport type MessagePartialSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signMessages(\n        messages: readonly SignableMessage[],\n        config?: MessagePartialSignerConfig,\n    ): Promise<readonly SignatureDictionary[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link MessagePartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isMessagePartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isMessagePartialSigner({ address, signMessages: async () => {} }); // true\n * isMessagePartialSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsMessagePartialSigner}\n */\nexport function isMessagePartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessagePartialSigner<TAddress> {\n    return 'signMessages' in value && typeof value.signMessages === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link MessagePartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsMessagePartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsMessagePartialSigner({ address, signMessages: async () => {} }); // void\n * assertIsMessagePartialSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isMessagePartialSigner}\n */\nexport function assertIsMessagePartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessagePartialSigner<TAddress> {\n    if (!isMessagePartialSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { equalBytes } from '@noble/curves/abstract/utils'\nimport * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport * as Json from './Json.js'\nimport * as internal from './internal/bytes.js'\nimport * as internal_hex from './internal/hex.js'\n\nconst decoder = /*#__PURE__*/ new TextDecoder()\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\n/** Root type for a Bytes array. */\nexport type Bytes = Uint8Array\n\n/**\n * Asserts if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.assert('abc')\n * // @error: Bytes.InvalidBytesTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid Bytes value.\n * // @error: Bytes values must be of type `Uint8Array`.\n * ```\n *\n * @param value - Value to assert.\n */\nexport function assert(value: unknown): asserts value is Bytes {\n  if (value instanceof Uint8Array) return\n  if (!value) throw new InvalidBytesTypeError(value)\n  if (typeof value !== 'object') throw new InvalidBytesTypeError(value)\n  if (!('BYTES_PER_ELEMENT' in value)) throw new InvalidBytesTypeError(value)\n  if (value.BYTES_PER_ELEMENT !== 1 || value.constructor.name !== 'Uint8Array')\n    throw new InvalidBytesTypeError(value)\n}\n\nexport declare namespace assert {\n  type ErrorType = InvalidBytesTypeError | Errors.GlobalErrorType\n}\n\n/**\n * Concatenates two or more {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.concat(\n *   Bytes.from([1]),\n *   Bytes.from([69]),\n *   Bytes.from([420, 69]),\n * )\n * // @log: Uint8Array [ 1, 69, 420, 69 ]\n * ```\n *\n * @param values - Values to concatenate.\n * @returns Concatenated {@link ox#Bytes.Bytes}.\n */\nexport function concat(...values: readonly Bytes[]): Bytes {\n  let length = 0\n  for (const arr of values) {\n    length += arr.length\n  }\n  const result = new Uint8Array(length)\n  for (let i = 0, index = 0; i < values.length; i++) {\n    const arr = values[i]\n    result.set(arr!, index)\n    index += arr!.length\n  }\n  return result\n}\n\nexport declare namespace concat {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Instantiates a {@link ox#Bytes.Bytes} value from a `Uint8Array`, a hex string, or an array of unsigned 8-bit integers.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Bytes.fromBoolean`\n *\n * - `Bytes.fromString`\n *\n * - `Bytes.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.from([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n *\n * const data = Bytes.from('0xdeadbeef')\n * // @log: Uint8Array([222, 173, 190, 239])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nexport function from(value: Hex.Hex | Bytes | readonly number[]): Bytes {\n  if (value instanceof Uint8Array) return value\n  if (typeof value === 'string') return fromHex(value)\n  return fromArray(value)\n}\n\nexport declare namespace from {\n  type ErrorType =\n    | fromHex.ErrorType\n    | fromArray.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts an array of unsigned 8-bit integers into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromArray([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nexport function fromArray(value: readonly number[] | Uint8Array): Bytes {\n  return value instanceof Uint8Array ? value : new Uint8Array(value)\n}\n\nexport declare namespace fromArray {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Encodes a boolean value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true)\n * // @log: Uint8Array([1])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true, { size: 32 })\n * // @log: Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n * ```\n *\n * @param value - Boolean value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromBoolean(value: boolean, options: fromBoolean.Options = {}) {\n  const { size } = options\n  const bytes = new Uint8Array(1)\n  bytes[0] = Number(value)\n  if (typeof size === 'number') {\n    internal.assertSize(bytes, size)\n    return padLeft(bytes, size)\n  }\n  return bytes\n}\n\nexport declare namespace fromBoolean {\n  type Options = {\n    /** Size of the output bytes. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | padLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Hex.Hex} value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Hex.Hex} value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromHex(value: Hex.Hex, options: fromHex.Options = {}): Bytes {\n  const { size } = options\n\n  let hex = value\n  if (size) {\n    internal_hex.assertSize(value, size)\n    hex = Hex.padRight(value, size)\n  }\n\n  let hexString = hex.slice(2) as string\n  if (hexString.length % 2) hexString = `0${hexString}`\n\n  const length = hexString.length / 2\n  const bytes = new Uint8Array(length)\n  for (let index = 0, j = 0; index < length; index++) {\n    const nibbleLeft = internal.charCodeToBase16(hexString.charCodeAt(j++))\n    const nibbleRight = internal.charCodeToBase16(hexString.charCodeAt(j++))\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new Errors.BaseError(\n        `Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`,\n      )\n    }\n    bytes[index] = nibbleLeft * 16 + nibbleRight\n  }\n  return bytes\n}\n\nexport declare namespace fromHex {\n  type Options = {\n    /** Size of the output bytes. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal_hex.assertSize.ErrorType\n    | Hex.padRight.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a number value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420)\n * // @log: Uint8Array([1, 164])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420, { size: 4 })\n * // @log: Uint8Array([0, 0, 1, 164])\n * ```\n *\n * @param value - Number value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromNumber(\n  value: bigint | number,\n  options?: fromNumber.Options | undefined,\n) {\n  const hex = Hex.fromNumber(value, options)\n  return fromHex(hex)\n}\n\nexport declare namespace fromNumber {\n  export type Options = Hex.fromNumber.Options\n\n  export type ErrorType =\n    | Hex.fromNumber.ErrorType\n    | fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a string into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - String to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nexport function fromString(\n  value: string,\n  options: fromString.Options = {},\n): Bytes {\n  const { size } = options\n\n  const bytes = encoder.encode(value)\n  if (typeof size === 'number') {\n    internal.assertSize(bytes, size)\n    return padRight(bytes, size)\n  }\n  return bytes\n}\n\nexport declare namespace fromString {\n  type Options = {\n    /** Size of the output bytes. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | padRight.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Checks if two {@link ox#Bytes.Bytes} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([1]))\n * // @log: true\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([2]))\n * // @log: false\n * ```\n *\n * @param bytesA - First {@link ox#Bytes.Bytes} value.\n * @param bytesB - Second {@link ox#Bytes.Bytes} value.\n * @returns `true` if the two values are equal, otherwise `false`.\n */\nexport function isEqual(bytesA: Bytes, bytesB: Bytes) {\n  return equalBytes(bytesA, bytesB)\n}\n\nexport declare namespace isEqual {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.from([1]), 4)\n * // @log: Uint8Array([0, 0, 0, 1])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nexport function padLeft(\n  value: Bytes,\n  size?: number | undefined,\n): padLeft.ReturnType {\n  return internal.pad(value, { dir: 'left', size })\n}\n\nexport declare namespace padLeft {\n  type ReturnType = internal.pad.ReturnType\n  type ErrorType = internal.pad.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padRight(Bytes.from([1]), 4)\n * // @log: Uint8Array([1, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nexport function padRight(\n  value: Bytes,\n  size?: number | undefined,\n): padRight.ReturnType {\n  return internal.pad(value, { dir: 'right', size })\n}\n\nexport declare namespace padRight {\n  type ReturnType = internal.pad.ReturnType\n  type ErrorType = internal.pad.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Generates random {@link ox#Bytes.Bytes} of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.random(32)\n * // @log: Uint8Array([... x32])\n * ```\n *\n * @param length - Length of the random {@link ox#Bytes.Bytes} to generate.\n * @returns Random {@link ox#Bytes.Bytes} of the specified length.\n */\nexport function random(length: number): Bytes {\n  return crypto.getRandomValues(new Uint8Array(length))\n}\n\nexport declare namespace random {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Retrieves the size of a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.size(Bytes.from([1, 2, 3, 4]))\n * // @log: 4\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Size of the {@link ox#Bytes.Bytes} value.\n */\nexport function size(value: Bytes): number {\n  return value.length\n}\n\nexport declare namespace size {\n  export type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(\n *   Bytes.from([1, 2, 3, 4, 5, 6, 7, 8, 9]),\n *   1,\n *   4,\n * )\n * // @log: Uint8Array([2, 3, 4])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value.\n * @param start - Start offset.\n * @param end - End offset.\n * @param options - Slice options.\n * @returns Sliced {@link ox#Bytes.Bytes} value.\n */\nexport function slice(\n  value: Bytes,\n  start?: number | undefined,\n  end?: number | undefined,\n  options: slice.Options = {},\n): Bytes {\n  const { strict } = options\n  internal.assertStartOffset(value, start)\n  const value_ = value.slice(start, end)\n  if (strict) internal.assertEndOffset(value_, start, end)\n  return value_\n}\n\nexport declare namespace slice {\n  type Options = {\n    /** Asserts that the sliced value is the same size as the given start/end offsets. */\n    strict?: boolean | undefined\n  }\n\n  export type ErrorType =\n    | internal.assertStartOffset.ErrorType\n    | internal.assertEndOffset.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a bigint.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBigInt(Bytes.from([1, 164]))\n * // @log: 420n\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded bigint.\n */\nexport function toBigInt(bytes: Bytes, options: toBigInt.Options = {}): bigint {\n  const { size } = options\n  if (typeof size !== 'undefined') internal.assertSize(bytes, size)\n  const hex = Hex.fromBytes(bytes, options)\n  return Hex.toBigInt(hex, options)\n}\n\nexport declare namespace toBigInt {\n  type Options = {\n    /** Whether or not the number of a signed representation. */\n    signed?: boolean | undefined\n    /** Size of the bytes. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Hex.toBigInt.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a boolean.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([1]))\n * // @log: true\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded boolean.\n */\nexport function toBoolean(\n  bytes: Bytes,\n  options: toBoolean.Options = {},\n): boolean {\n  const { size } = options\n  let bytes_ = bytes\n  if (typeof size !== 'undefined') {\n    internal.assertSize(bytes_, size)\n    bytes_ = trimLeft(bytes_)\n  }\n  if (bytes_.length > 1 || bytes_[0]! > 1)\n    throw new InvalidBytesBooleanError(bytes_)\n  return Boolean(bytes_[0])\n}\n\nexport declare namespace toBoolean {\n  type Options = {\n    /** Size of the bytes. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | internal.assertSize.ErrorType\n    | trimLeft.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toHex(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded {@link ox#Hex.Hex} value.\n */\nexport function toHex(value: Bytes, options: toHex.Options = {}): Hex.Hex {\n  return Hex.fromBytes(value, options)\n}\n\nexport declare namespace toHex {\n  type Options = {\n    /** Size of the bytes. */\n    size?: number | undefined\n  }\n\n  type ErrorType = Hex.fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a number.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toNumber(Bytes.from([1, 164]))\n * // @log: 420\n * ```\n */\nexport function toNumber(bytes: Bytes, options: toNumber.Options = {}): number {\n  const { size } = options\n  if (typeof size !== 'undefined') internal.assertSize(bytes, size)\n  const hex = Hex.fromBytes(bytes, options)\n  return Hex.toNumber(hex, options)\n}\n\nexport declare namespace toNumber {\n  type Options = {\n    /** Whether or not the number of a signed representation. */\n    signed?: boolean | undefined\n    /** Size of the bytes. */\n    size?: number | undefined\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Hex.toNumber.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a string.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.toString(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: 'Hello world'\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded string.\n */\nexport function toString(bytes: Bytes, options: toString.Options = {}): string {\n  const { size } = options\n\n  let bytes_ = bytes\n  if (typeof size !== 'undefined') {\n    internal.assertSize(bytes_, size)\n    bytes_ = trimRight(bytes_)\n  }\n  return decoder.decode(bytes_)\n}\n\nexport declare namespace toString {\n  export type Options = {\n    /** Size of the bytes. */\n    size?: number | undefined\n  }\n\n  export type ErrorType =\n    | internal.assertSize.ErrorType\n    | trimRight.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Trims leading zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimLeft(Bytes.from([0, 0, 0, 0, 1, 2, 3]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nexport function trimLeft(value: Bytes): Bytes {\n  return internal.trim(value, { dir: 'left' })\n}\n\nexport declare namespace trimLeft {\n  type ErrorType = internal.trim.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Trims trailing zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimRight(Bytes.from([1, 2, 3, 0, 0, 0, 0]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nexport function trimRight(value: Bytes): Bytes {\n  return internal.trim(value, { dir: 'right' })\n}\n\nexport declare namespace trimRight {\n  export type ErrorType = internal.trim.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Checks if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.validate('0x')\n * // @log: false\n *\n * Bytes.validate(Bytes.from([1, 2, 3]))\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns `true` if the value is {@link ox#Bytes.Bytes}, otherwise `false`.\n */\nexport function validate(value: unknown): value is Bytes {\n  try {\n    assert(value)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  export type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Thrown when the bytes value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([5]))\n * // @error: Bytes.InvalidBytesBooleanError: Bytes value `[5]` is not a valid boolean.\n * // @error: The bytes array must contain a single byte of either a `0` or `1` value.\n * ```\n */\nexport class InvalidBytesBooleanError extends Errors.BaseError {\n  override readonly name = 'Bytes.InvalidBytesBooleanError'\n\n  constructor(bytes: Bytes) {\n    super(`Bytes value \\`${bytes}\\` is not a valid boolean.`, {\n      metaMessages: [\n        'The bytes array must contain a single byte of either a `0` or `1` value.',\n      ],\n    })\n  }\n}\n\n/**\n * Thrown when a value cannot be converted to bytes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * Bytes.from('foo')\n * // @error: Bytes.InvalidBytesTypeError: Value `foo` of type `string` is an invalid Bytes value.\n * ```\n */\nexport class InvalidBytesTypeError extends Errors.BaseError {\n  override readonly name = 'Bytes.InvalidBytesTypeError'\n\n  constructor(value: unknown) {\n    super(\n      `Value \\`${typeof value === 'object' ? Json.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid Bytes value.`,\n      {\n        metaMessages: ['Bytes values must be of type `Bytes`.'],\n      },\n    )\n  }\n}\n\n/**\n * Thrown when a size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromString('Hello World!', { size: 8 })\n * // @error: Bytes.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nexport class SizeOverflowError extends Errors.BaseError {\n  override readonly name = 'Bytes.SizeOverflowError'\n\n  constructor({ givenSize, maxSize }: { givenSize: number; maxSize: number }) {\n    super(\n      `Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`,\n    )\n  }\n}\n\n/**\n * Thrown when a slice offset is out-of-bounds.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(Bytes.from([1, 2, 3]), 4)\n * // @error: Bytes.SliceOffsetOutOfBoundsError: Slice starting at offset `4` is out-of-bounds (size: `3`).\n * ```\n */\nexport class SliceOffsetOutOfBoundsError extends Errors.BaseError {\n  override readonly name = 'Bytes.SliceOffsetOutOfBoundsError'\n\n  constructor({\n    offset,\n    position,\n    size,\n  }: { offset: number; position: 'start' | 'end'; size: number }) {\n    super(\n      `Slice ${\n        position === 'start' ? 'starting' : 'ending'\n      } at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`,\n    )\n  }\n}\n\n/**\n * Thrown when a the padding size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.fromString('Hello World!'), 8)\n * // @error: [Bytes.SizeExceedsPaddingSizeError: Bytes size (`12`) exceeds padding size (`8`).\n * ```\n */\nexport class SizeExceedsPaddingSizeError extends Errors.BaseError {\n  override readonly name = 'Bytes.SizeExceedsPaddingSizeError'\n\n  constructor({\n    size,\n    targetSize,\n    type,\n  }: {\n    size: number\n    targetSize: number\n    type: 'Hex' | 'Bytes'\n  }) {\n    super(\n      `${type.charAt(0).toUpperCase()}${type\n        .slice(1)\n        .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`,\n    )\n  }\n}\n","import fastStableStringify from '@solana/fast-stable-stringify';\nimport { isJsonRpcPayload } from '@solana/rpc-spec';\n\nexport function getSolanaRpcPayloadDeduplicationKey(payload: unknown): string | undefined {\n    return isJsonRpcPayload(payload) ? fastStableStringify([payload.method, payload.params]) : undefined;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n} from '@solana/kit';\n\nexport enum AccountState {\n  Uninitialized,\n  Initialized,\n  Frozen,\n}\n\nexport type AccountStateArgs = AccountState;\n\nexport function getAccountStateEncoder(): FixedSizeEncoder<AccountStateArgs> {\n  return getEnumEncoder(AccountState);\n}\n\nexport function getAccountStateDecoder(): FixedSizeDecoder<AccountState> {\n  return getEnumDecoder(AccountState);\n}\n\nexport function getAccountStateCodec(): FixedSizeCodec<\n  AccountStateArgs,\n  AccountState\n> {\n  return combineCodec(getAccountStateEncoder(), getAccountStateDecoder());\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit signed integers (`i32`).\n *\n * This encoder serializes `i32` values using 4 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 4>` for encoding `i32` values.\n *\n * @example\n * Encoding an `i32` value.\n * ```ts\n * const encoder = getI32Encoder();\n * const bytes = encoder.encode(-42); // 0xd6ffffff\n * ```\n *\n * @see {@link getI32Codec}\n */\nexport const getI32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'i32',\n        range: [-Number('0x7fffffff') - 1, Number('0x7fffffff')],\n        set: (view, value, le) => view.setInt32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit signed integers (`i32`).\n *\n * This decoder deserializes `i32` values from 4 bytes.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `i32` values.\n *\n * @example\n * Decoding an `i32` value.\n * ```ts\n * const decoder = getI32Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6, 0xff, 0xff, 0xff])); // -42\n * ```\n *\n * @see {@link getI32Codec}\n */\nexport const getI32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt32(0, le),\n        name: 'i32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit signed integers (`i32`).\n *\n * This codec serializes `i32` values using 4 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, number, 4>` for encoding and decoding `i32` values.\n *\n * @example\n * Encoding and decoding an `i32` value.\n * ```ts\n * const codec = getI32Codec();\n * const bytes = codec.encode(-42); // 0xd6ffffff\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42); // 0xffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^31` (`-2,147,483,648`) and `2^31 - 1` (`2,147,483,647`).\n *\n * - If you need a smaller signed integer, consider using {@link getI16Codec} or {@link getI8Codec}.\n * - If you need a larger signed integer, consider using {@link getI64Codec}.\n * - If you need unsigned integers, consider using {@link getU32Codec}.\n *\n * Separate {@link getI32Encoder} and {@link getI32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI32Encoder().encode(-42);\n * const value = getI32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI32Encoder}\n * @see {@link getI32Decoder}\n */\nexport const getI32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getI32Encoder(config), getI32Decoder(config));\n","import { Address, getAddressFromPublicKey } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, SolanaError } from '@solana/errors';\nimport { createKeyPairFromBytes, createKeyPairFromPrivateKeyBytes, generateKeyPair, signBytes } from '@solana/keys';\nimport { partiallySignTransaction } from '@solana/transactions';\n\nimport { isMessagePartialSigner, MessagePartialSigner } from './message-partial-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\n\n/**\n * Defines a signer that uses a {@link CryptoKeyPair} to sign messages and transactions.\n *\n * It implements both the {@link MessagePartialSigner} and {@link TransactionPartialSigner}\n * interfaces and keeps track of the {@link CryptoKeyPair} instance used\n * to sign messages and transactions.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner } from '@solana/signers';\n *\n * const signer = generateKeyPairSigner();\n * signer.address; // Address;\n * signer.keyPair; // CryptoKeyPair;\n * const [messageSignatures] = await signer.signMessages([message]);\n * const [transactionSignatures] = await signer.signTransactions([transaction]);\n * ```\n *\n * @see {@link generateKeyPairSigner}\n * @see {@link createSignerFromKeyPair}\n * @see {@link createKeyPairSignerFromBytes}\n * @see {@link createKeyPairSignerFromPrivateKeyBytes}\n * @see {@link isKeyPairSigner}\n * @see {@link assertIsKeyPairSigner}\n */\nexport type KeyPairSigner<TAddress extends string = string> = MessagePartialSigner<TAddress> &\n    TransactionPartialSigner<TAddress> & { keyPair: CryptoKeyPair };\n\n/**\n * Checks whether the provided value implements the {@link KeyPairSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner, isKeyPairSigner } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * isKeyPairSigner(signer); // true\n * isKeyPairSigner({ address: address('1234..5678') }); // false\n * ```\n */\nexport function isKeyPairSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is KeyPairSigner<TAddress> {\n    return (\n        'keyPair' in value &&\n        typeof value.keyPair === 'object' &&\n        isMessagePartialSigner(value) &&\n        isTransactionPartialSigner(value)\n    );\n}\n\n/**\n * Asserts that the provided value implements the {@link KeyPairSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner, assertIsKeyPairSigner } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * assertIsKeyPairSigner(signer); // void\n * assertIsKeyPairSigner({ address: address('1234..5678') }); // Throws an error.\n * ```\n */\nexport function assertIsKeyPairSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is KeyPairSigner<TAddress> {\n    if (!isKeyPairSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n\n/**\n * Creates a {@link KeyPairSigner} from a provided {@link CryptoKeyPair}.\n *\n * The {@link MessagePartialSigner#signMessages | signMessages} and\n * {@link TransactionPartialSigner#signTransactions | signTransactions}\n * functions of the returned signer will use the private key of the provided\n * key pair to sign messages and transactions.\n *\n * Note that both the {@link MessagePartialSigner#signMessages | signMessages} and\n * {@link TransactionPartialSigner#signTransactions | signTransactions} implementations\n * are parallelized, meaning that they will sign all provided messages and transactions in parallel.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { createSignerFromKeyPair, KeyPairSigner } from '@solana/signers';\n *\n * const keyPair: CryptoKeyPair = await generateKeyPair();\n * const signer: KeyPairSigner = await createSignerFromKeyPair(keyPair);\n * ```\n */\nexport async function createSignerFromKeyPair(keyPair: CryptoKeyPair): Promise<KeyPairSigner> {\n    const address = await getAddressFromPublicKey(keyPair.publicKey);\n    const out: KeyPairSigner = {\n        address,\n        keyPair,\n        signMessages: messages =>\n            Promise.all(\n                messages.map(async message =>\n                    Object.freeze({ [address]: await signBytes(keyPair.privateKey, message.content) }),\n                ),\n            ),\n        signTransactions: transactions =>\n            Promise.all(\n                transactions.map(async transaction => {\n                    const signedTransaction = await partiallySignTransaction([keyPair], transaction);\n                    // we know that the address has signed `signedTransaction` because it comes from the keypair\n                    return Object.freeze({ [address]: signedTransaction.signatures[address]! });\n                }),\n            ),\n    };\n\n    return Object.freeze(out);\n}\n\n/**\n * Generates a signer capable of signing messages and transactions by generating\n * a {@link CryptoKeyPair} and creating a {@link KeyPairSigner} from it.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * ```\n *\n * @see {@link createSignerFromKeyPair}\n */\nexport async function generateKeyPairSigner(): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await generateKeyPair());\n}\n\n/**\n * Creates a new {@link KeyPairSigner} from a 64-bytes `Uint8Array` secret key (private key and public key).\n *\n * @example\n * ```ts\n * import fs from 'fs';\n * import { createKeyPairSignerFromBytes } from '@solana/signers';\n *\n * // Get bytes from local keypair file.\n * const keypairFile = fs.readFileSync('~/.config/solana/id.json');\n * const keypairBytes = new Uint8Array(JSON.parse(keypairFile.toString()));\n *\n * // Create a KeyPairSigner from the bytes.\n * const signer = await createKeyPairSignerFromBytes(keypairBytes);\n * ```\n *\n * @see {@link createKeyPairSignerFromPrivateKeyBytes} if you only have the 32-bytes private key instead.\n */\nexport async function createKeyPairSignerFromBytes(\n    bytes: ReadonlyUint8Array,\n    extractable?: boolean,\n): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await createKeyPairFromBytes(bytes, extractable));\n}\n\n/**\n * Creates a new {@link KeyPairSigner} from a 32-bytes `Uint8Array` private key.\n *\n * @example\n * ```ts\n * import { getUtf8Encoder } from '@solana/codecs-strings';\n * import { createKeyPairSignerFromPrivateKeyBytes } from '@solana/signers';\n *\n * const message = getUtf8Encoder().encode('Hello, World!');\n * const seed = new Uint8Array(await crypto.subtle.digest('SHA-256', message));\n *\n * const derivedSigner = await createKeyPairSignerFromPrivateKeyBytes(seed);\n * ```\n *\n * @see {@link createKeyPairSignerFromBytes} if you have the 64-bytes secret key instead (private key and public key).\n */\nexport async function createKeyPairSignerFromPrivateKeyBytes(\n    bytes: ReadonlyUint8Array,\n    extractable?: boolean,\n): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await createKeyPairFromPrivateKeyBytes(bytes, extractable));\n}\n","import { isJsonRpcPayload } from '@solana/rpc-spec';\n\nconst SOLANA_RPC_METHODS = [\n    'getAccountInfo',\n    'getBalance',\n    'getBlock',\n    'getBlockCommitment',\n    'getBlockHeight',\n    'getBlockProduction',\n    'getBlocks',\n    'getBlocksWithLimit',\n    'getBlockTime',\n    'getClusterNodes',\n    'getEpochInfo',\n    'getEpochSchedule',\n    'getFeeForMessage',\n    'getFirstAvailableBlock',\n    'getGenesisHash',\n    'getHealth',\n    'getHighestSnapshotSlot',\n    'getIdentity',\n    'getInflationGovernor',\n    'getInflationRate',\n    'getInflationReward',\n    'getLargestAccounts',\n    'getLatestBlockhash',\n    'getLeaderSchedule',\n    'getMaxRetransmitSlot',\n    'getMaxShredInsertSlot',\n    'getMinimumBalanceForRentExemption',\n    'getMultipleAccounts',\n    'getProgramAccounts',\n    'getRecentPerformanceSamples',\n    'getRecentPrioritizationFees',\n    'getSignaturesForAddress',\n    'getSignatureStatuses',\n    'getSlot',\n    'getSlotLeader',\n    'getSlotLeaders',\n    'getStakeMinimumDelegation',\n    'getSupply',\n    'getTokenAccountBalance',\n    'getTokenAccountsByDelegate',\n    'getTokenAccountsByOwner',\n    'getTokenLargestAccounts',\n    'getTokenSupply',\n    'getTransaction',\n    'getTransactionCount',\n    'getVersion',\n    'getVoteAccounts',\n    'index',\n    'isBlockhashValid',\n    'minimumLedgerSlot',\n    'requestAirdrop',\n    'sendTransaction',\n    'simulateTransaction',\n] as const;\n\n/**\n * Helper function that checks if a given `RpcRequest` comes from the Solana RPC API.\n */\nexport function isSolanaRequest(payload: unknown): payload is Readonly<{\n    jsonrpc: '2.0';\n    method: (typeof SOLANA_RPC_METHODS)[number];\n    params: unknown;\n}> {\n    return isJsonRpcPayload(payload) && (SOLANA_RPC_METHODS as readonly string[]).includes(payload.method);\n}\n","import { FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport { getStructCodec, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getU8Codec, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledMessageHeader } from '../compile/header';\n\ntype MessageHeader = ReturnType<typeof getCompiledMessageHeader>;\n\nlet memoizedU8Encoder: FixedSizeEncoder<number, 1> | undefined;\nfunction getMemoizedU8Encoder(): FixedSizeEncoder<number, 1> {\n    if (!memoizedU8Encoder) memoizedU8Encoder = getU8Encoder();\n    return memoizedU8Encoder;\n}\n\nlet memoizedU8Decoder: FixedSizeDecoder<number, 1> | undefined;\nfunction getMemoizedU8Decoder(): FixedSizeDecoder<number, 1> {\n    if (!memoizedU8Decoder) memoizedU8Decoder = getU8Decoder();\n    return memoizedU8Decoder;\n}\n\nlet memoizedU8Codec: FixedSizeCodec<number, number, 1> | undefined;\nfunction getMemoizedU8Codec(): FixedSizeCodec<number, number, 1> {\n    if (!memoizedU8Codec) memoizedU8Codec = getU8Codec();\n    return memoizedU8Codec;\n}\n\nexport function getMessageHeaderEncoder(): FixedSizeEncoder<MessageHeader, 3> {\n    return getStructEncoder([\n        ['numSignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Encoder()],\n    ]) as FixedSizeEncoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderDecoder(): FixedSizeDecoder<MessageHeader, 3> {\n    return getStructDecoder([\n        ['numSignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Decoder()],\n    ]) as FixedSizeDecoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderCodec(): FixedSizeCodec<MessageHeader, MessageHeader, 3> {\n    return getStructCodec([\n        ['numSignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlySignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Codec()],\n    ]) as FixedSizeCodec<MessageHeader, MessageHeader, 3>;\n}\n","import { pipe } from '@solana/functional';\nimport { createHttpTransport, createHttpTransportForSolanaRpc } from '@solana/rpc-transport-http';\nimport type { ClusterUrl } from '@solana/rpc-types';\n\nimport { RpcTransportFromClusterUrl } from './rpc-clusters';\nimport { getRpcTransportWithRequestCoalescing } from './rpc-request-coalescer';\nimport { getSolanaRpcPayloadDeduplicationKey } from './rpc-request-deduplication';\n\ntype RpcTransportConfig = Parameters<typeof createHttpTransport>[0];\ninterface DefaultRpcTransportConfig<TClusterUrl extends ClusterUrl> extends RpcTransportConfig {\n    url: TClusterUrl;\n}\n\nfunction normalizeHeaders<T extends Record<string, string>>(\n    headers: T,\n): { [K in string & keyof T as Lowercase<K>]: T[K] } {\n    const out: Record<string, string> = {};\n    for (const headerName in headers) {\n        // Lowercasing header names makes it easier to override user-supplied headers.\n        out[headerName.toLowerCase()] = headers[headerName];\n    }\n    return out as { [K in string & keyof T as Lowercase<K>]: T[K] };\n}\n\n/**\n * Creates a {@link RpcTransport} with some default behaviours.\n *\n * The default behaviours include:\n * - An automatically-set `Solana-Client` request header, containing the version of `@solana/kit`\n * - Logic that coalesces multiple calls in the same runloop, for the same methods with the same\n *   arguments, into a single network request.\n * - [node-only] An automatically-set `Accept-Encoding` request header asking the server to compress\n *   responses\n *\n * @param config\n */\nexport function createDefaultRpcTransport<TClusterUrl extends ClusterUrl>(\n    config: DefaultRpcTransportConfig<TClusterUrl>,\n): RpcTransportFromClusterUrl<TClusterUrl> {\n    return pipe(\n        createHttpTransportForSolanaRpc({\n            ...config,\n            headers: {\n                ...(__NODEJS__ &&\n                    ({\n                        // Keep these headers lowercase so they will be overridden by any user-supplied headers below.\n                        'accept-encoding':\n                            // Natively supported by Node LTS v20.18.0 and above.\n                            'br,gzip,deflate', // Brotli, gzip, and Deflate, in that order.\n                    } as { [overrideHeader: string]: string })),\n                ...(config.headers ? normalizeHeaders(config.headers) : undefined),\n                ...({\n                    // Keep these headers lowercase so they will override any user-supplied headers above.\n                    'solana-client': __VERSION__ ? `js/${__VERSION__}` : 'UNKNOWN',\n                } as { [overrideHeader: string]: string }),\n            },\n        }) as RpcTransportFromClusterUrl<TClusterUrl>,\n        transport => getRpcTransportWithRequestCoalescing(transport, getSolanaRpcPayloadDeduplicationKey),\n    );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n} from '@solana/kit';\n\nexport enum AuthorityType {\n  MintTokens,\n  FreezeAccount,\n  AccountOwner,\n  CloseAccount,\n}\n\nexport type AuthorityTypeArgs = AuthorityType;\n\nexport function getAuthorityTypeEncoder(): FixedSizeEncoder<AuthorityTypeArgs> {\n  return getEnumEncoder(AuthorityType);\n}\n\nexport function getAuthorityTypeDecoder(): FixedSizeDecoder<AuthorityType> {\n  return getEnumDecoder(AuthorityType);\n}\n\nexport function getAuthorityTypeCodec(): FixedSizeCodec<\n  AuthorityTypeArgs,\n  AuthorityType\n> {\n  return combineCodec(getAuthorityTypeEncoder(), getAuthorityTypeDecoder());\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit signed integers (`i64`).\n *\n * This encoder serializes `i64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 8>` for encoding `i64` values.\n *\n * @example\n * Encoding an `i64` value.\n * ```ts\n * const encoder = getI64Encoder();\n * const bytes = encoder.encode(-42n); // 0xd6ffffffffffffff\n * ```\n *\n * @see {@link getI64Codec}\n */\nexport const getI64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'i64',\n        range: [-BigInt('0x7fffffffffffffff') - 1n, BigInt('0x7fffffffffffffff')],\n        set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit signed integers (`i64`).\n *\n * This decoder deserializes `i64` values from 8 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getI64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 8>` for decoding `i64` values.\n *\n * @example\n * Decoding an `i64` value.\n * ```ts\n * const decoder = getI64Decoder();\n * const value = decoder.decode(new Uint8Array([\n *   0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n * ])); // -42n\n * ```\n *\n * @see {@link getI64Codec}\n */\nexport const getI64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigInt64(0, le),\n        name: 'i64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit signed integers (`i64`).\n *\n * This codec serializes `i64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 8>` for encoding and decoding `i64` values.\n *\n * @example\n * Encoding and decoding an `i64` value.\n * ```ts\n * const codec = getI64Codec();\n * const bytes = codec.encode(-42n); // 0xd6ffffffffffffff\n * const value = codec.decode(bytes); // -42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42n); // 0xffffffffffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^63` and `2^63 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller signed integer, consider using {@link getI32Codec} or {@link getI16Codec}.\n * - If you need a larger signed integer, consider using {@link getI128Codec}.\n * - If you need unsigned integers, consider using {@link getU64Codec}.\n *\n * Separate {@link getI64Encoder} and {@link getI64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI64Encoder().encode(-42);\n * const value = getI64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI64Encoder}\n * @see {@link getI64Decoder}\n */\nexport const getI64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getI64Encoder(config), getI64Decoder(config));\n","import { SOLANA_ERROR__MALFORMED_BIGINT_STRING, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * This type represents a `bigint` which has been encoded as a string for transit over a transport\n * that does not support `bigint` values natively. The JSON-RPC is such a transport.\n */\nexport type StringifiedBigInt = Brand<string, 'StringifiedBigInt'>;\n\n/**\n * A type guard that returns `true` if the input string parses as a `BigInt`, and refines its type\n * for use in your program.\n *\n * @example\n * ```ts\n * import { isStringifiedBigInt } from '@solana/rpc-types';\n *\n * if (isStringifiedBigInt(bigintString)) {\n *     // At this point, `bigintString` has been refined to a `StringifiedBigInt`\n *     bigintString satisfies StringifiedBigInt; // OK\n * } else {\n *     setError(`${bigintString} does not represent a BigInt`);\n * }\n * ```\n */\nexport function isStringifiedBigInt(putativeBigInt: string): putativeBigInt is StringifiedBigInt {\n    try {\n        BigInt(putativeBigInt);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * From time to time you might acquire a string, that you expect to parse as a `BigInt`, from an\n * untrusted network API or user input. Use this function to assert that such an arbitrary string\n * will in fact parse as a `BigInt`.\n *\n * @example\n * ```ts\n * import { assertIsStringifiedBigInt } from '@solana/rpc-types';\n *\n * // Imagine having received a value that you presume represents the supply of some token.\n * // At this point we know only that it conforms to the `string` type.\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `supplyString` to `StringifiedBigInt`.\n *     assertIsStringifiedBigInt(supplyString);\n *     // At this point, `supplyString` is a `StringifiedBigInt`.\n *     supplyString satisfies StringifiedBigInt;\n * } catch (e) {\n *     // `supplyString` turned out not to parse as a `BigInt`\n * }\n * ```\n */\nexport function assertIsStringifiedBigInt(putativeBigInt: string): asserts putativeBigInt is StringifiedBigInt {\n    try {\n        BigInt(putativeBigInt);\n    } catch {\n        throw new SolanaError(SOLANA_ERROR__MALFORMED_BIGINT_STRING, {\n            value: putativeBigInt,\n        });\n    }\n}\n\n/**\n * This helper combines _asserting_ that a string will parse as a `BigInt` with _coercing_ it to the\n * {@link StringifiedBigInt} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { stringifiedBigInt } from '@solana/rpc-types';\n *\n * const supplyString = stringifiedBigInt('1000000000');\n * ```\n */\nexport function stringifiedBigInt(putativeBigInt: string): StringifiedBigInt {\n    assertIsStringifiedBigInt(putativeBigInt);\n    return putativeBigInt;\n}\n","import { KeyPath, TraversalState } from './tree-traversal';\n\nexport function getIntegerOverflowNodeVisitor(onIntegerOverflow: (keyPath: KeyPath, value: bigint) => void) {\n    return <T>(value: T, { keyPath }: TraversalState): T => {\n        if (typeof value === 'bigint') {\n            if (onIntegerOverflow && (value > Number.MAX_SAFE_INTEGER || value < -Number.MAX_SAFE_INTEGER)) {\n                onIntegerOverflow(keyPath as (number | string)[], value);\n            }\n        }\n        return value;\n    };\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings using bit re-slicing.\n *\n * This encoder serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to an alphabet, and encoding the result into a byte array.\n * This approach is commonly used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding a base-X string using bit re-slicing.\n * ```ts\n * const encoder = getBaseXResliceEncoder('elho', 2);\n * const bytes = encoder.encode('hellolol'); // 0x4aee\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.floor((value.length * bits) / 8),\n        write(value: string, bytes, offset) {\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n            const charIndices = [...value].map(c => alphabet.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-X encoded strings using bit re-slicing.\n *\n * This decoder deserializes base-X encoded strings by re-slicing the bits of a byte array into\n * custom-sized chunks and mapping them to a specified alphabet.\n * This is typically used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings using bit re-slicing.\n *\n * @example\n * Decoding a base-X string using bit re-slicing.\n * ```ts\n * const decoder = getBaseXResliceDecoder('elho', 2);\n * const value = decoder.decode(new Uint8Array([0x4a, 0xee])); // \"hellolol\"\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', rawBytes.length];\n            const charIndices = reslice([...bytes], 8, bits, true);\n            return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-X strings using bit re-slicing.\n *\n * This codec serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to a given alphabet, and encoding the result into bytes.\n * It is particularly suited for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding and decoding a base-X string using bit re-slicing.\n * ```ts\n * const codec = getBaseXResliceCodec('elho', 2);\n * const bytes = codec.encode('hellolol'); // 0x4aee\n * const value = codec.decode(bytes);      // \"hellolol\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXResliceCodec('elho', 2), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXResliceCodec('elho', 2), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXResliceEncoder} and {@link getBaseXResliceDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXResliceEncoder('elho', 2).encode('hellolol');\n * const value = getBaseXResliceDecoder('elho', 2).decode(bytes);\n * ```\n *\n * @see {@link getBaseXResliceEncoder}\n * @see {@link getBaseXResliceDecoder}\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): VariableSizeCodec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","import { assertKeyGenerationIsAvailable, assertPRNGIsAvailable } from '@solana/assertions';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ED25519_ALGORITHM_IDENTIFIER } from './algorithm';\nimport { createPrivateKeyFromBytes } from './private-key';\nimport { getPublicKeyFromPrivateKey } from './public-key';\nimport { signBytes, verifySignature } from './signatures';\n\n/**\n * Generates an Ed25519 public/private key pair for use with other methods in this package that\n * accept [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) objects.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n *\n * const { privateKey, publicKey } = await generateKeyPair();\n * ```\n */\nexport async function generateKeyPair(): Promise<CryptoKeyPair> {\n    await assertKeyGenerationIsAvailable();\n    const keyPair = await crypto.subtle.generateKey(\n        /* algorithm */ ED25519_ALGORITHM_IDENTIFIER, // Native implementation status: https://github.com/WICG/webcrypto-secure-curves/issues/20\n        /* extractable */ false, // Prevents the bytes of the private key from being visible to JS.\n        /* allowed uses */ ['sign', 'verify'],\n    );\n    return keyPair;\n}\n\n/**\n * Given a 64-byte `Uint8Array` secret key, creates an Ed25519 public/private key pair for use with\n * other methods in this package that accept [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * objects.\n *\n * @param bytes 64 bytes, the first 32 of which represent the private key and the last 32 of which\n * represent its associated public key\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the private\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import fs from 'fs';\n * import { createKeyPairFromBytes } from '@solana/keys';\n *\n * // Get bytes from local keypair file.\n * const keypairFile = fs.readFileSync('~/.config/solana/id.json');\n * const keypairBytes = new Uint8Array(JSON.parse(keypairFile.toString()));\n *\n * // Create a CryptoKeyPair from the bytes.\n * const { privateKey, publicKey } = await createKeyPairFromBytes(keypairBytes);\n * ```\n */\nexport async function createKeyPairFromBytes(\n    bytes: ReadonlyUint8Array,\n    extractable: boolean = false,\n): Promise<CryptoKeyPair> {\n    assertPRNGIsAvailable();\n\n    if (bytes.byteLength !== 64) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH, { byteLength: bytes.byteLength });\n    }\n    const [publicKey, privateKey] = await Promise.all([\n        crypto.subtle.importKey('raw', bytes.slice(32), ED25519_ALGORITHM_IDENTIFIER, /* extractable */ true, [\n            'verify',\n        ]),\n        createPrivateKeyFromBytes(bytes.slice(0, 32), extractable),\n    ]);\n\n    // Verify the key pair\n    const randomBytes = new Uint8Array(32);\n    crypto.getRandomValues(randomBytes);\n    const signedData = await signBytes(privateKey, randomBytes);\n    const isValid = await verifySignature(publicKey, signedData, randomBytes);\n    if (!isValid) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY);\n    }\n\n    return { privateKey, publicKey } as CryptoKeyPair;\n}\n\n/**\n * Given a private key represented as a 32-byte `Uint8Array`, creates an Ed25519 public/private key\n * pair for use with other methods in this package that accept [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * objects.\n *\n * @param bytes 32 bytes that represent the private key\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the private\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import { createKeyPairFromPrivateKeyBytes } from '@solana/keys';\n *\n * const { privateKey, publicKey } = await createKeyPairFromPrivateKeyBytes(new Uint8Array([...]));\n * ```\n *\n * This can be useful when you have a private key but not the corresponding public key or when you\n * need to derive key pairs from seeds. For instance, the following code snippet derives a key pair\n * from the hash of a message.\n *\n * ```ts\n * import { getUtf8Encoder } from '@solana/codecs-strings';\n * import { createKeyPairFromPrivateKeyBytes } from '@solana/keys';\n *\n * const message = getUtf8Encoder().encode('Hello, World!');\n * const seed = new Uint8Array(await crypto.subtle.digest('SHA-256', message));\n *\n * const derivedKeypair = await createKeyPairFromPrivateKeyBytes(seed);\n * ```\n */\nexport async function createKeyPairFromPrivateKeyBytes(\n    bytes: ReadonlyUint8Array,\n    extractable: boolean = false,\n): Promise<CryptoKeyPair> {\n    const privateKeyPromise = createPrivateKeyFromBytes(bytes, extractable);\n\n    // Here we need the private key to be extractable in order to export\n    // it as a public key. Therefore, if the `extractable` parameter\n    // is `false`, we need to create two private keys such that:\n    //   - The extractable one is used to create the public key and\n    //   - The non-extractable one is the one we will return.\n    const [publicKey, privateKey] = await Promise.all([\n        // This nested promise makes things efficient by\n        // creating the public key in parallel with the\n        // second private key creation, if it is needed.\n        (extractable ? privateKeyPromise : createPrivateKeyFromBytes(bytes, true /* extractable */)).then(\n            async privateKey => await getPublicKeyFromPrivateKey(privateKey, true /* extractable */),\n        ),\n        privateKeyPromise,\n    ]);\n\n    return { privateKey, publicKey };\n}\n","import { ReadonlyUint8Array } from '@solana/codecs-core';\n\nimport { pointIsOnCurve } from './vendor/noble/ed25519';\n\nfunction byteToHex(byte: number): string {\n    const hexString = byte.toString(16);\n    if (hexString.length === 1) {\n        return `0${hexString}`;\n    } else {\n        return hexString;\n    }\n}\n\nfunction decompressPointBytes(bytes: ReadonlyUint8Array): bigint {\n    const hexString = bytes.reduce((acc, byte, ii) => `${byteToHex(ii === 31 ? byte & ~0x80 : byte)}${acc}`, '');\n    const integerLiteralString = `0x${hexString}`;\n    return BigInt(integerLiteralString);\n}\n\nexport function compressedPointBytesAreOnCurve(bytes: ReadonlyUint8Array): boolean {\n    if (bytes.byteLength !== 32) {\n        return false;\n    }\n    const y = decompressPointBytes(bytes);\n    return pointIsOnCurve(y, bytes[31]);\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\n/**\n * Defines the configuration options for boolean codecs.\n *\n * A boolean codec encodes `true` as `1` and `false` as `0`.\n * The `size` option allows customizing the number codec used for storage.\n *\n * @typeParam TSize - A number codec, encoder, or decoder used for boolean representation.\n *\n * @see {@link getBooleanEncoder}\n * @see {@link getBooleanDecoder}\n * @see {@link getBooleanCodec}\n */\nexport type BooleanCodecConfig<TSize extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The number codec used to store boolean values.\n     *\n     * - By default, booleans are stored as a `u8` (`1` for `true`, `0` for `false`).\n     * - A custom number codec can be provided to change the storage size.\n     *\n     * @defaultValue `u8`\n     */\n    size?: TSize;\n};\n\n/**\n * Returns an encoder for boolean values.\n *\n * This encoder converts `true` into `1` and `false` into `0`.\n * The `size` option allows customizing the number codec used for storage.\n *\n * For more details, see {@link getBooleanCodec}.\n *\n * @param config - Configuration options for encoding booleans.\n * @returns A `FixedSizeEncoder<boolean, N>` where `N` is the size of the number codec.\n *\n * @example\n * Encoding booleans.\n * ```ts\n * const encoder = getBooleanEncoder();\n *\n * encoder.encode(false); // 0x00\n * encoder.encode(true);  // 0x01\n * ```\n *\n * @see {@link getBooleanCodec}\n */\nexport function getBooleanEncoder(): FixedSizeEncoder<boolean, 1>;\nexport function getBooleanEncoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<boolean, TSize>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder>): VariableSizeEncoder<boolean>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder> = {}): Encoder<boolean> {\n    return transformEncoder(config.size ?? getU8Encoder(), (value: boolean) => (value ? 1 : 0));\n}\n\n/**\n * Returns a decoder for boolean values.\n *\n * This decoder reads a number and interprets `1` as `true` and `0` as `false`.\n * The `size` option allows customizing the number codec used for storage.\n *\n * For more details, see {@link getBooleanCodec}.\n *\n * @param config - Configuration options for decoding booleans.\n * @returns A `FixedSizeDecoder<boolean, N>` where `N` is the size of the number codec.\n *\n * @example\n * Decoding booleans.\n * ```ts\n * const decoder = getBooleanDecoder();\n *\n * decoder.decode(new Uint8Array([0x00])); // false\n * decoder.decode(new Uint8Array([0x01])); // true\n * ```\n *\n * @see {@link getBooleanCodec}\n */\nexport function getBooleanDecoder(): FixedSizeDecoder<boolean, 1>;\nexport function getBooleanDecoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<boolean, TSize>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder>): VariableSizeDecoder<boolean>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder> = {}): Decoder<boolean> {\n    return transformDecoder(config.size ?? getU8Decoder(), (value: bigint | number): boolean => Number(value) === 1);\n}\n\n/**\n * Returns a codec for encoding and decoding boolean values.\n *\n * By default, booleans are stored as a `u8` (`1` for `true`, `0` for `false`).\n * The `size` option allows customizing the number codec used for storage.\n *\n * @param config - Configuration options for encoding and decoding booleans.\n * @returns A `FixedSizeCodec<boolean, boolean, N>` where `N` is the size of the number codec.\n *\n * @example\n * Encoding and decoding booleans using a `u8` (default).\n * ```ts\n * const codec = getBooleanCodec();\n *\n * codec.encode(false); // 0x00\n * codec.encode(true);  // 0x01\n *\n * codec.decode(new Uint8Array([0x00])); // false\n * codec.decode(new Uint8Array([0x01])); // true\n * ```\n *\n * @example\n * Encoding and decoding booleans using a custom number codec.\n * ```ts\n * const codec = getBooleanCodec({ size: getU16Codec() });\n *\n * codec.encode(false); // 0x0000\n * codec.encode(true);  // 0x0100\n *\n * codec.decode(new Uint8Array([0x00, 0x00])); // false\n * codec.decode(new Uint8Array([0x01, 0x00])); // true\n * ```\n *\n * @remarks\n * Separate {@link getBooleanEncoder} and {@link getBooleanDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBooleanEncoder().encode(true);\n * const value = getBooleanDecoder().decode(bytes);\n * ```\n *\n * @see {@link getBooleanEncoder}\n * @see {@link getBooleanDecoder}\n */\nexport function getBooleanCodec(): FixedSizeCodec<boolean, boolean, 1>;\nexport function getBooleanCodec<TSize extends number>(\n    config: BooleanCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<boolean, boolean, TSize>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec>): VariableSizeCodec<boolean>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec> = {}): Codec<boolean> {\n    return combineCodec(getBooleanEncoder(config), getBooleanDecoder(config));\n}\n","import { RpcRequest } from '@solana/rpc-spec-types';\n\nimport { getIntegerOverflowNodeVisitor } from './request-transformer-integer-overflow-internal';\nimport { getTreeWalkerRequestTransformer, KeyPath } from './tree-traversal';\n\nexport type IntegerOverflowHandler = (request: RpcRequest, keyPath: KeyPath, value: bigint) => void;\n\n/**\n * Creates a transformer that traverses the request parameters and executes the provided handler\n * when an integer overflow is detected.\n *\n * @example\n * ```ts\n * import { getIntegerOverflowRequestTransformer } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getIntegerOverflowRequestTransformer((request, keyPath, value) => {\n *     throw new Error(`Integer overflow at ${keyPath.join('.')}: ${value}`);\n * });\n * ```\n */\nexport function getIntegerOverflowRequestTransformer(onIntegerOverflow: IntegerOverflowHandler) {\n    return <TParams>(request: RpcRequest<TParams>): RpcRequest => {\n        const transformer = getTreeWalkerRequestTransformer(\n            [getIntegerOverflowNodeVisitor((...args) => onIntegerOverflow(request, ...args))],\n            { keyPath: [] },\n        );\n        return transformer(request);\n    };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  isProgramError,\n  type Address,\n  type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n  type SolanaError,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\n\n/** AccountAlreadyInUse: an account with the same address already exists */\nexport const SYSTEM_ERROR__ACCOUNT_ALREADY_IN_USE = 0x0; // 0\n/** ResultWithNegativeLamports: account does not have enough SOL to perform the operation */\nexport const SYSTEM_ERROR__RESULT_WITH_NEGATIVE_LAMPORTS = 0x1; // 1\n/** InvalidProgramId: cannot assign account to this program id */\nexport const SYSTEM_ERROR__INVALID_PROGRAM_ID = 0x2; // 2\n/** InvalidAccountDataLength: cannot allocate account data of this length */\nexport const SYSTEM_ERROR__INVALID_ACCOUNT_DATA_LENGTH = 0x3; // 3\n/** MaxSeedLengthExceeded: length of requested seed is too long */\nexport const SYSTEM_ERROR__MAX_SEED_LENGTH_EXCEEDED = 0x4; // 4\n/** AddressWithSeedMismatch: provided address does not match addressed derived from seed */\nexport const SYSTEM_ERROR__ADDRESS_WITH_SEED_MISMATCH = 0x5; // 5\n/** NonceNoRecentBlockhashes: advancing stored nonce requires a populated RecentBlockhashes sysvar */\nexport const SYSTEM_ERROR__NONCE_NO_RECENT_BLOCKHASHES = 0x6; // 6\n/** NonceBlockhashNotExpired: stored nonce is still in recent_blockhashes */\nexport const SYSTEM_ERROR__NONCE_BLOCKHASH_NOT_EXPIRED = 0x7; // 7\n/** NonceUnexpectedBlockhashValue: specified nonce does not match stored nonce */\nexport const SYSTEM_ERROR__NONCE_UNEXPECTED_BLOCKHASH_VALUE = 0x8; // 8\n\nexport type SystemError =\n  | typeof SYSTEM_ERROR__ACCOUNT_ALREADY_IN_USE\n  | typeof SYSTEM_ERROR__ADDRESS_WITH_SEED_MISMATCH\n  | typeof SYSTEM_ERROR__INVALID_ACCOUNT_DATA_LENGTH\n  | typeof SYSTEM_ERROR__INVALID_PROGRAM_ID\n  | typeof SYSTEM_ERROR__MAX_SEED_LENGTH_EXCEEDED\n  | typeof SYSTEM_ERROR__NONCE_BLOCKHASH_NOT_EXPIRED\n  | typeof SYSTEM_ERROR__NONCE_NO_RECENT_BLOCKHASHES\n  | typeof SYSTEM_ERROR__NONCE_UNEXPECTED_BLOCKHASH_VALUE\n  | typeof SYSTEM_ERROR__RESULT_WITH_NEGATIVE_LAMPORTS;\n\nlet systemErrorMessages: Record<SystemError, string> | undefined;\nif (process.env.NODE_ENV !== 'production') {\n  systemErrorMessages = {\n    [SYSTEM_ERROR__ACCOUNT_ALREADY_IN_USE]: `an account with the same address already exists`,\n    [SYSTEM_ERROR__ADDRESS_WITH_SEED_MISMATCH]: `provided address does not match addressed derived from seed`,\n    [SYSTEM_ERROR__INVALID_ACCOUNT_DATA_LENGTH]: `cannot allocate account data of this length`,\n    [SYSTEM_ERROR__INVALID_PROGRAM_ID]: `cannot assign account to this program id`,\n    [SYSTEM_ERROR__MAX_SEED_LENGTH_EXCEEDED]: `length of requested seed is too long`,\n    [SYSTEM_ERROR__NONCE_BLOCKHASH_NOT_EXPIRED]: `stored nonce is still in recent_blockhashes`,\n    [SYSTEM_ERROR__NONCE_NO_RECENT_BLOCKHASHES]: `advancing stored nonce requires a populated RecentBlockhashes sysvar`,\n    [SYSTEM_ERROR__NONCE_UNEXPECTED_BLOCKHASH_VALUE]: `specified nonce does not match stored nonce`,\n    [SYSTEM_ERROR__RESULT_WITH_NEGATIVE_LAMPORTS]: `account does not have enough SOL to perform the operation`,\n  };\n}\n\nexport function getSystemErrorMessage(code: SystemError): string {\n  if (process.env.NODE_ENV !== 'production') {\n    return (systemErrorMessages as Record<SystemError, string>)[code];\n  }\n\n  return 'Error message not available in production bundles.';\n}\n\nexport function isSystemError<TProgramErrorCode extends SystemError>(\n  error: unknown,\n  transactionMessage: {\n    instructions: Record<number, { programAddress: Address }>;\n  },\n  code?: TProgramErrorCode\n): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &\n  Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {\n  return isProgramError<TProgramErrorCode>(\n    error,\n    transactionMessage,\n    SYSTEM_PROGRAM_ADDRESS,\n    code\n  );\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 8-bit signed integers (`i8`).\n *\n * This encoder serializes `i8` values using 1 byte.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI8Codec}.\n *\n * @returns A `FixedSizeEncoder<number | bigint, 1>` for encoding `i8` values.\n *\n * @example\n * Encoding an `i8` value.\n * ```ts\n * const encoder = getI8Encoder();\n * const bytes = encoder.encode(-42); // 0xd6\n * ```\n *\n * @see {@link getI8Codec}\n */\nexport const getI8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'i8',\n        range: [-Number('0x7f') - 1, Number('0x7f')],\n        set: (view, value) => view.setInt8(0, Number(value)),\n        size: 1,\n    });\n\n/**\n * Returns a decoder for 8-bit signed integers (`i8`).\n *\n * This decoder deserializes `i8` values from 1 byte.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI8Codec}.\n *\n * @returns A `FixedSizeDecoder<number, 1>` for decoding `i8` values.\n *\n * @example\n * Decoding an `i8` value.\n * ```ts\n * const decoder = getI8Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6])); // -42\n * ```\n *\n * @see {@link getI8Codec}\n */\nexport const getI8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getInt8(0),\n        name: 'i8',\n        size: 1,\n    });\n\n/**\n * Returns a codec for encoding and decoding 8-bit signed integers (`i8`).\n *\n * This codec serializes `i8` values using 1 byte.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @returns A `FixedSizeCodec<number | bigint, number, 1>` for encoding and decoding `i8` values.\n *\n * @example\n * Encoding and decoding an `i8` value.\n * ```ts\n * const codec = getI8Codec();\n * const bytes = codec.encode(-42); // 0xd6\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @remarks\n * This codec supports values between `-2^7` (`-128`) and `2^7 - 1` (`127`).\n *\n * - If you need a larger signed integer, consider using {@link getI16Codec}.\n * - If you need an unsigned integer, consider using {@link getU8Codec}.\n *\n * Separate {@link getI8Encoder} and {@link getI8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI8Encoder().encode(-42);\n * const value = getI8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI8Encoder}\n * @see {@link getI8Decoder}\n */\nexport const getI8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getI8Encoder(), getI8Decoder());\n","import {\n    addDecoderSizePrefix,\n    addEncoderSizePrefix,\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledInstructions } from '../compile/instructions';\n\ntype Instruction = ReturnType<typeof getCompiledInstructions>[number];\n\nlet memoizedGetInstructionEncoder: VariableSizeEncoder<Instruction> | undefined;\nexport function getInstructionEncoder(): VariableSizeEncoder<Instruction> {\n    if (!memoizedGetInstructionEncoder) {\n        memoizedGetInstructionEncoder = transformEncoder<Required<Instruction>, Instruction>(\n            getStructEncoder([\n                ['programAddressIndex', getU8Encoder()],\n                ['accountIndices', getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() })],\n                ['data', addEncoderSizePrefix(getBytesEncoder(), getShortU16Encoder())],\n            ]),\n            // Convert an instruction to have all fields defined\n            (instruction: Instruction): Required<Instruction> => {\n                if (instruction.accountIndices !== undefined && instruction.data !== undefined) {\n                    return instruction as Required<Instruction>;\n                }\n                return {\n                    ...instruction,\n                    accountIndices: instruction.accountIndices ?? [],\n                    data: instruction.data ?? new Uint8Array(0),\n                } as Required<Instruction>;\n            },\n        );\n    }\n\n    return memoizedGetInstructionEncoder;\n}\n\nlet memoizedGetInstructionDecoder: VariableSizeDecoder<Instruction> | undefined;\nexport function getInstructionDecoder(): VariableSizeDecoder<Instruction> {\n    if (!memoizedGetInstructionDecoder) {\n        memoizedGetInstructionDecoder = transformDecoder<Required<Instruction>, Instruction>(\n            getStructDecoder([\n                ['programAddressIndex', getU8Decoder()],\n                ['accountIndices', getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],\n                [\n                    'data',\n                    addDecoderSizePrefix(getBytesDecoder(), getShortU16Decoder()) as VariableSizeDecoder<Uint8Array>,\n                ],\n            ]),\n            // Convert an instruction to exclude optional fields if they are empty\n            (instruction: Required<Instruction>): Instruction => {\n                if (instruction.accountIndices.length && instruction.data.byteLength) {\n                    return instruction;\n                }\n                const { accountIndices, data, ...rest } = instruction;\n                return {\n                    ...rest,\n                    ...(accountIndices.length ? { accountIndices } : null),\n                    ...(data.byteLength ? { data } : null),\n                };\n            },\n        );\n    }\n    return memoizedGetInstructionDecoder;\n}\n\nexport function getInstructionCodec(): VariableSizeCodec<Instruction> {\n    return combineCodec(getInstructionEncoder(), getInstructionDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  type Account,\n  type Address,\n  type EncodedAccount,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type Option,\n  type OptionOrNullable,\n} from '@solana/kit';\nimport {\n  getAccountStateDecoder,\n  getAccountStateEncoder,\n  type AccountState,\n  type AccountStateArgs,\n} from '../types';\n\nexport type Token = {\n  /** The mint associated with this account. */\n  mint: Address;\n  /** The owner of this account. */\n  owner: Address;\n  /** The amount of tokens this account holds. */\n  amount: bigint;\n  /**\n   * If `delegate` is `Some` then `delegated_amount` represents\n   * the amount authorized by the delegate.\n   */\n  delegate: Option<Address>;\n  /** The account's state. */\n  state: AccountState;\n  /**\n   * If is_native.is_some, this is a native token, and the value logs the\n   * rent-exempt reserve. An Account is required to be rent-exempt, so\n   * the value is used by the Processor to ensure that wrapped SOL\n   * accounts do not drop below this threshold.\n   */\n  isNative: Option<bigint>;\n  /** The amount delegated. */\n  delegatedAmount: bigint;\n  /** Optional authority to close the account. */\n  closeAuthority: Option<Address>;\n};\n\nexport type TokenArgs = {\n  /** The mint associated with this account. */\n  mint: Address;\n  /** The owner of this account. */\n  owner: Address;\n  /** The amount of tokens this account holds. */\n  amount: number | bigint;\n  /**\n   * If `delegate` is `Some` then `delegated_amount` represents\n   * the amount authorized by the delegate.\n   */\n  delegate: OptionOrNullable<Address>;\n  /** The account's state. */\n  state: AccountStateArgs;\n  /**\n   * If is_native.is_some, this is a native token, and the value logs the\n   * rent-exempt reserve. An Account is required to be rent-exempt, so\n   * the value is used by the Processor to ensure that wrapped SOL\n   * accounts do not drop below this threshold.\n   */\n  isNative: OptionOrNullable<number | bigint>;\n  /** The amount delegated. */\n  delegatedAmount: number | bigint;\n  /** Optional authority to close the account. */\n  closeAuthority: OptionOrNullable<Address>;\n};\n\nexport function getTokenEncoder(): FixedSizeEncoder<TokenArgs> {\n  return getStructEncoder([\n    ['mint', getAddressEncoder()],\n    ['owner', getAddressEncoder()],\n    ['amount', getU64Encoder()],\n    [\n      'delegate',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['state', getAccountStateEncoder()],\n    [\n      'isNative',\n      getOptionEncoder(getU64Encoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['delegatedAmount', getU64Encoder()],\n    [\n      'closeAuthority',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getTokenDecoder(): FixedSizeDecoder<Token> {\n  return getStructDecoder([\n    ['mint', getAddressDecoder()],\n    ['owner', getAddressDecoder()],\n    ['amount', getU64Decoder()],\n    [\n      'delegate',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['state', getAccountStateDecoder()],\n    [\n      'isNative',\n      getOptionDecoder(getU64Decoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['delegatedAmount', getU64Decoder()],\n    [\n      'closeAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getTokenCodec(): FixedSizeCodec<TokenArgs, Token> {\n  return combineCodec(getTokenEncoder(), getTokenDecoder());\n}\n\nexport function decodeToken<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Token, TAddress>;\nexport function decodeToken<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Token, TAddress>;\nexport function decodeToken<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Token, TAddress> | MaybeAccount<Token, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getTokenDecoder()\n  );\n}\n\nexport async function fetchToken<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Token, TAddress>> {\n  const maybeAccount = await fetchMaybeToken(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeToken<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Token, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeToken(maybeAccount);\n}\n\nexport async function fetchAllToken(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Token>[]> {\n  const maybeAccounts = await fetchAllMaybeToken(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeToken(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Token>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeToken(maybeAccount));\n}\n\nexport function getTokenSize(): number {\n  return 165;\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\n/**\n * Returns an encoder for raw byte arrays.\n *\n * This encoder writes byte arrays exactly as provided without modification.\n *\n * The size of the encoded byte array is determined by the length of the input.\n * - To enforce a fixed size, consider using {@link fixEncoderSize}.\n * - To add a size prefix, use {@link addEncoderSizePrefix}.\n * - To add a sentinel value, use {@link addEncoderSentinel}.\n *\n * For more details, see {@link getBytesCodec}.\n *\n * @returns A `VariableSizeEncoder<ReadonlyUint8Array | Uint8Array>`.\n *\n * @example\n * Encoding a byte array as-is.\n * ```ts\n * const encoder = getBytesEncoder();\n *\n * encoder.encode(new Uint8Array([1, 2, 3])); // 0x010203\n * encoder.encode(new Uint8Array([255, 0, 127])); // 0xff007f\n * ```\n *\n * @see {@link getBytesCodec}\n */\nexport function getBytesEncoder(): VariableSizeEncoder<ReadonlyUint8Array | Uint8Array> {\n    return createEncoder({\n        getSizeFromValue: value => value.length,\n        write: (value, bytes, offset) => {\n            bytes.set(value, offset);\n            return offset + value.length;\n        },\n    });\n}\n\n/**\n * Returns a decoder for raw byte arrays.\n *\n * This decoder reads byte arrays exactly as provided without modification.\n *\n * The decoded byte array extends from the provided offset to the end of the input.\n * - To enforce a fixed size, consider using {@link fixDecoderSize}.\n * - To add a size prefix, use {@link addDecoderSizePrefix}.\n * - To add a sentinel value, use {@link addDecoderSentinel}.\n *\n * For more details, see {@link getBytesCodec}.\n *\n * @returns A `VariableSizeDecoder<ReadonlyUint8Array>`.\n *\n * @example\n * Decoding a byte array as-is.\n * ```ts\n * const decoder = getBytesDecoder();\n *\n * decoder.decode(new Uint8Array([1, 2, 3])); // Uint8Array([1, 2, 3])\n * decoder.decode(new Uint8Array([255, 0, 127])); // Uint8Array([255, 0, 127])\n * ```\n *\n * @see {@link getBytesCodec}\n */\nexport function getBytesDecoder(): VariableSizeDecoder<ReadonlyUint8Array> {\n    return createDecoder({\n        read: (bytes, offset) => {\n            const slice = bytes.slice(offset);\n            return [slice, offset + slice.length];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding raw byte arrays.\n *\n * This codec serializes and deserializes byte arrays without modification.\n *\n * The size of the encoded and decoded byte array is determined dynamically.\n * This means, when reading, the codec will consume all remaining bytes in the input.\n * - To enforce a fixed size, consider using {@link fixCodecSize}.\n * - To add a size prefix, use {@link addCodecSizePrefix}.\n * - To add a sentinel value, use {@link addCodecSentinel}.\n *\n * @returns A `VariableSizeCodec<ReadonlyUint8Array | Uint8Array, ReadonlyUint8Array>`.\n *\n * @example\n * Encoding and decoding a byte array.\n * ```ts\n * const codec = getBytesCodec();\n *\n * codec.encode(new Uint8Array([1, 2, 3])); // 0x010203\n * codec.decode(new Uint8Array([255, 0, 127])); // Uint8Array([255, 0, 127])\n * ```\n *\n * @remarks\n * Separate {@link getBytesEncoder} and {@link getBytesDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBytesEncoder().encode(new Uint8Array([1, 2, 3]));\n * const value = getBytesDecoder().decode(bytes);\n * ```\n *\n * @see {@link getBytesEncoder}\n * @see {@link getBytesDecoder}\n */\nexport function getBytesCodec(): VariableSizeCodec<ReadonlyUint8Array | Uint8Array, ReadonlyUint8Array> {\n    return combineCodec(getBytesEncoder(), getBytesDecoder());\n}\n","import { createSolanaRpcApi } from '@solana/rpc-api';\nimport { createRpc, RpcTransport } from '@solana/rpc-spec';\nimport { ClusterUrl } from '@solana/rpc-types';\n\nimport type { RpcFromTransport, SolanaRpcApiFromTransport } from './rpc-clusters';\nimport { DEFAULT_RPC_CONFIG } from './rpc-default-config';\nimport { createDefaultRpcTransport } from './rpc-transport';\n\ntype DefaultRpcTransportConfig<TClusterUrl extends ClusterUrl> = Parameters<\n    typeof createDefaultRpcTransport<TClusterUrl>\n>[0];\n\n/**\n * Creates a {@link Rpc} instance that exposes the Solana JSON RPC API given a cluster URL and some\n * optional transport config. See {@link createDefaultRpcTransport} for the shape of the transport\n * config.\n */\nexport function createSolanaRpc<TClusterUrl extends ClusterUrl>(\n    clusterUrl: TClusterUrl,\n    config?: Omit<DefaultRpcTransportConfig<TClusterUrl>, 'url'>,\n) {\n    return createSolanaRpcFromTransport(createDefaultRpcTransport({ url: clusterUrl, ...config }));\n}\n\n/**\n * Creates a {@link Rpc} instance that exposes the Solana JSON RPC API given the supplied\n * {@link RpcTransport}.\n */\nexport function createSolanaRpcFromTransport<TTransport extends RpcTransport>(transport: TTransport) {\n    return createRpc({\n        api: createSolanaRpcApi(DEFAULT_RPC_CONFIG),\n        transport,\n    }) as RpcFromTransport<SolanaRpcApiFromTransport<TTransport>, TTransport>;\n}\n","import { RpcTransport } from '@solana/rpc-spec';\nimport { parseJsonWithBigInts, stringifyJsonWithBigInts } from '@solana/rpc-spec-types';\n\nimport { createHttpTransport } from './http-transport';\nimport { HttpTransportConfig } from './http-transport-config';\nimport { isSolanaRequest } from './is-solana-request';\n\ntype Config = Pick<HttpTransportConfig, 'dispatcher_NODE_ONLY' | 'headers' | 'url'>;\n\n/**\n * Creates a {@link RpcTransport} that uses JSON HTTP requests  much like the\n * {@link createHttpTransport} function - except that it also uses custom `toJson` and `fromJson`\n * functions in order to allow `bigint` values to be serialized and deserialized correctly over the\n * wire.\n *\n * Since this is something specific to the Solana RPC API, these custom JSON functions are only\n * triggered when the request is recognized as a Solana RPC request. Normal RPC APIs should aim to\n * wrap their `bigint` values  e.g. `u64` or `i64`  in special value objects that represent the\n * number as a string to avoid numerical values going above `Number.MAX_SAFE_INTEGER`.\n *\n * It has the same configuration options as {@link createHttpTransport}, but without the `fromJson`\n * and `toJson` options.\n */\nexport function createHttpTransportForSolanaRpc(config: Config): RpcTransport {\n    return createHttpTransport({\n        ...config,\n        fromJson: (rawResponse: string, payload: unknown) =>\n            isSolanaRequest(payload) ? parseJsonWithBigInts(rawResponse) : JSON.parse(rawResponse),\n        toJson: (payload: unknown) =>\n            isSolanaRequest(payload) ? stringifyJsonWithBigInts(payload) : JSON.stringify(payload),\n    });\n}\n","/**\n * @module Client\n */\n\nimport {\n  PoliciesClientInterface,\n  CreatePolicyOptions,\n  ListPoliciesOptions,\n  ListPoliciesResult,\n  GetPolicyByIdOptions,\n  DeletePolicyOptions,\n  UpdatePolicyOptions,\n} from \"./policies.types.js\";\nimport { Analytics } from \"../../analytics.js\";\nimport {\n  CdpOpenApiClient,\n  CreatePolicyBody,\n  UpdatePolicyBody,\n} from \"../../openapi-client/index.js\";\nimport { Policy, CreatePolicyBodySchema, UpdatePolicyBodySchema } from \"../../policies/types.js\";\n\n/**\n * The namespace containing all Policy methods.\n */\nexport class PoliciesClient implements PoliciesClientInterface {\n  /**\n   * Lists policies belonging to the developer's CDP Project.\n   * Can be filtered by scope (project or account).\n   *\n   * @param {ListPoliciesOptions} [options] - Options for filtering and paginating the results\n   * @param {string} [options.scope] - Filter policies by scope ('project' or 'account')\n   * @param {number} [options.pageSize] - Maximum number of policies to return\n   * @param {string} [options.pageToken] - Pagination cursor for fetching next page of results\n   *\n   * @returns {Promise<ListPoliciesResult>} A paginated list of policies\n   *\n   * @example **List all policies**\n   *          ```ts\n   *          const { policies } = await cdp.policies.listPolicies();\n   *          ```\n   *\n   * @example **Filter by scope**\n   *          ```ts\n   *          const { policies } = await cdp.policies.listPolicies({\n   *            scope: 'project'\n   *          });\n   *          ```\n   *\n   * @example **With pagination**\n   *          ```ts\n   *          // Get first page\n   *          const firstPage = await cdp.policies.listPolicies({\n   *            pageSize: 10\n   *          });\n   *\n   *          // Get next page using cursor\n   *          const nextPage = await cdp.policies.listPolicies({\n   *            pageSize: 10,\n   *            pageToken: firstPage.pageToken\n   *          });\n   *          ```\n   */\n  async listPolicies(options: ListPoliciesOptions = {}): Promise<ListPoliciesResult> {\n    Analytics.trackAction({\n      action: \"list_policies\",\n      properties: {\n        scope: options.scope,\n      },\n    });\n\n    return CdpOpenApiClient.listPolicies(options) as Promise<ListPoliciesResult>;\n  }\n\n  /**\n   * Creates a new policy that can be used to govern the behavior of projects and accounts.\n   *\n   * @param {CreatePolicyOptions} options - Options for creating the policy\n   * @param {CreatePolicyBody} options.policy - The policy configuration to create\n   * @param {string} [options.policy.description] - Description of the policy's purpose\n   * @param {Rule[]} options.policy.rules - Rules that define the policy behavior\n   * @param {string} [options.idempotencyKey] - An idempotency key to prevent duplicate policy creation\n   *\n   * @returns {Promise<Policy>} The created policy\n   * @throws {ZodError<typeof CreatePolicyBodySchema>} When the policy is invalid\n   *\n   * @example **Creating a new EVM policy**\n   *          ```ts\n   *          const policy = await cdp.policies.createPolicy({\n   *            policy: {\n   *              scope: \"account\",\n   *              description: \"Limits the amount of ETH in transaction\",\n   *              rules: [\n   *                {\n   *                  action: \"reject\",\n   *                  operation: \"signEvmTransaction\",\n   *                  criteria: [\n   *                    {\n   *                      type: \"ethValue\",\n   *                      ethValue: \"1000000000000000000\",\n   *                      operator: \">\",\n   *                    },\n   *                  ],\n   *                },\n   *              ],\n   *            }\n   *          });\n   *          ```\n   *\n   * @example **Creating a new Solana policy**\n   *          ```ts\n   *          const policy = await cdp.policies.createPolicy({\n   *            policy: {\n   *              scope: \"account\",\n   *              description: \"Limits SOL transfers and SPL token operations\",\n   *              rules: [\n   *                {\n   *                  action: \"reject\",\n   *                  operation: \"signSolTransaction\",\n   *                  criteria: [\n   *                    {\n   *                      type: \"solValue\",\n   *                      solValue: \"1000000000\", // 1 SOL in lamports\n   *                      operator: \">\",\n   *                    },\n   *                    {\n   *                      type: \"solAddress\",\n   *                      addresses: [\"9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin\"],\n   *                      operator: \"in\",\n   *                    },\n   *                  ],\n   *                },\n   *                {\n   *                  action: \"accept\",\n   *                  operation: \"sendSolTransaction\",\n   *                  criteria: [\n   *                    {\n   *                      type: \"mintAddress\",\n   *                      addresses: [\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\"], // USDC mint\n   *                      operator: \"in\",\n   *                    },\n   *                  ],\n   *                },\n   *              ],\n   *            }\n   *          });\n   *          ```\n   *\n   * @example **With idempotency key**\n   *          ```ts\n   *          const idempotencyKey = uuidv4();\n   *\n   *          // First call creates the policy\n   *          const policy = await cdp.policies.createPolicy({\n   *            policy: {\n   *              scope: \"account\",\n   *              description: \"Limits the amount of ETH in transaction\",\n   *              rules: [\n   *                {\n   *                  action: \"reject\",\n   *                  operation: \"signEvmTransaction\",\n   *                  criteria: [\n   *                    {\n   *                      type: \"ethValue\",\n   *                      ethValue: \"1000000000000000000\",\n   *                      operator: \">\",\n   *                    },\n   *                  ],\n   *                },\n   *              ],\n   *            },\n   *            idempotencyKey\n   *          });\n   *\n   *          // Second call with same key returns the same policy\n   *          const samePolicy = await cdp.policies.createPolicy({\n   *            policy: { ... },\n   *            idempotencyKey\n   *          });\n   *          ```\n   */\n  async createPolicy(options: CreatePolicyOptions): Promise<Policy> {\n    Analytics.trackAction({\n      action: \"create_policy\",\n      properties: {\n        scope: options.policy.scope,\n      },\n    });\n\n    CreatePolicyBodySchema.parse(options.policy);\n    return CdpOpenApiClient.createPolicy(\n      // There are arbitrary differences between the abitype Abi and the openapi Abi\n      options.policy as CreatePolicyBody,\n\n      options.idempotencyKey,\n    ) as Promise<Policy>;\n  }\n\n  /**\n   * Retrieves a policy by its unique identifier.\n   *\n   * @param {GetPolicyByIdOptions} options - Options containing the policy ID to retrieve\n   * @param {string} options.id - The unique identifier of the policy to retrieve\n   *\n   * @returns {Promise<Policy>} The requested policy\n   *\n   * @example **Retrieving a policy by ID**\n   *          ```ts\n   *          const policy = await cdp.policies.getPolicyById({\n   *            id: \"__ID__\"\n   *          });\n   *\n   *          console.log(policy.name);\n   *          console.log(policy.rules);\n   *          ```\n   */\n  async getPolicyById(options: GetPolicyByIdOptions): Promise<Policy> {\n    Analytics.trackAction({\n      action: \"get_policy_by_id\",\n    });\n\n    return CdpOpenApiClient.getPolicyById(options.id) as Promise<Policy>;\n  }\n\n  /**\n   * Deletes a policy by its unique identifier.\n   * If a policy is referenced by an active project or account, this operation will fail.\n   *\n   * @param {DeletePolicyOptions} options - Options containing the policy ID to delete\n   * @param {string} options.id - The unique identifier of the policy to delete\n   * @param {string} [options.idempotencyKey] - An idempotency key to prevent duplicate deletion\n   *\n   * @returns {Promise<void>} Void on successful deletion\n   *\n   * @example **Deleting a policy**\n   *          ```ts\n   *          await cdp.policies.deletePolicy({\n   *            id: \"__ID__\"\n   *          });\n   *          ```\n   *\n   * @example **With idempotency key**\n   *          ```ts\n   *          const idempotencyKey = uuidv4();\n   *\n   *          // This operation is idempotent with the key\n   *          await cdp.policies.deletePolicy({\n   *            id: \"__ID__\",\n   *            idempotencyKey\n   *          });\n   *          ```\n   */\n  async deletePolicy(options: DeletePolicyOptions): Promise<void> {\n    Analytics.trackAction({\n      action: \"delete_policy\",\n    });\n\n    return CdpOpenApiClient.deletePolicy(options.id, options.idempotencyKey);\n  }\n\n  /**\n   * Updates an existing policy by its unique identifier.\n   * This will apply the updated policy to any project or accounts that are currently using it.\n   *\n   * @param {UpdatePolicyOptions} options - Options containing the policy ID and updated policy data\n   * @param {string} options.id - The unique identifier of the policy to update\n   * @param {UpdatePolicyBody} options.policy - The updated policy configuration\n   * @param {string} [options.policy.description] - Updated description of the policy's purpose\n   * @param {Rule[]} [options.policy.rules] - Updated rules that define the policy behavior\n   * @param {string} [options.idempotencyKey] - An idempotency key to prevent duplicate updates\n   *\n   * @returns {Promise<Policy>} The updated policy\n   * @throws {ZodError<typeof UpdatePolicyBodySchema>} When the updated policy is invalid\n   *\n   * @example **Updating an EVM policy**\n   *          ```ts\n   *          const updatedPolicy = await cdp.policies.updatePolicy({\n   *            id: \"__ID__\",\n   *            policy: {\n   *              description: \"Now with lower transaction limits\",\n   *              rules: [\n   *                {\n   *                  action: \"reject\",\n   *                  operation: \"signEvmTransaction\",\n   *                  criteria: [\n   *                    {\n   *                      type: \"ethValue\",\n   *                      ethValue: \"1000000000\",\n   *                      operator: \">\",\n   *                    },\n   *                  ],\n   *                },\n   *              ],\n   *            },\n   *          });\n   *          ```\n   *\n   * @example **Updating a Solana policy**\n   *          ```ts\n   *          const updatedPolicy = await cdp.policies.updatePolicy({\n   *            id: \"__ID__\",\n   *            policy: {\n   *              description: \"Updated Solana transaction limits\",\n   *              rules: [\n   *                {\n   *                  action: \"reject\",\n   *                  operation: \"signSolTransaction\",\n   *                  criteria: [\n   *                    {\n   *                      type: \"splValue\",\n   *                      splValue: \"1000000\", // SPL token amount\n   *                      operator: \">=\",\n   *                    },\n   *                    {\n   *                      type: \"mintAddress\",\n   *                      addresses: [\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\"], // USDC mint\n   *                      operator: \"in\",\n   *                    },\n   *                  ],\n   *                },\n   *              ],\n   *            },\n   *          });\n   *          ```\n   *\n   * @example **With idempotency key**\n   *          ```ts\n   *          const idempotencyKey = uuidv4();\n   *\n   *          // This operation is idempotent with the key\n   *          await cdp.policies.updatePolicy({\n   *            id: \"__ID__\",\n   *            policy: {\n   *              description: \"Modified Policy\",\n   *              rules: { ... }\n   *            },\n   *            idempotencyKey\n   *          });\n   *          ```\n   */\n  async updatePolicy(options: UpdatePolicyOptions): Promise<Policy> {\n    Analytics.trackAction({\n      action: \"update_policy\",\n    });\n\n    UpdatePolicyBodySchema.parse(options.policy);\n    return CdpOpenApiClient.updatePolicy(\n      options.id,\n      // There are arbitrary differences between the abitype Abi and the openapi Abi\n      options.policy as UpdatePolicyBody,\n      options.idempotencyKey,\n    ) as Promise<Policy>;\n  }\n}\n","import { Address, isAddress } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, SolanaError } from '@solana/errors';\n\nimport { SignableMessage } from './signable-message';\nimport { BaseSignerConfig } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link MessageModifyingSigner#modifyAndSignMessages | modifyAndSignMessages} method.\n *\n * @see {@link BaseSignerConfig}\n */\nexport type MessageModifyingSignerConfig = BaseSignerConfig;\n\n/**\n * A signer interface that _potentially_ modifies the content\n * of the provided {@link SignableMessage | SignableMessages} before signing them.\n *\n * For instance, this enables wallets to prefix or suffix nonces to the messages they sign.\n * For each message, instead of returning a {@link SignatureDictionary}, the\n * {@link MessageModifyingSigner#modifyAndSignMessages | modifyAndSignMessages} function\n * returns an updated {@link SignableMessage} with a potentially modified content and signature dictionary.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: MessageModifyingSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     modifyAndSignMessages: async (\n *         messages: SignableMessage[]\n *     ): Promise<SignableMessage[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Sequential**. Contrary to partial signers, these cannot be executed in\n *   parallel as each call can modify the content of the message.\n * - **First signers**. For a given message, a modifying signer must always be used\n *   before a partial signer as the former will likely modify the message and\n *   thus impact the outcome of the latter.\n * - **Potential conflicts**. If more than one modifying signer is provided, the second\n *   signer may invalidate the signature of the first one. However, modifying signers\n *   may decide not to modify a message based on the existence of signatures for that message.\n *\n * @see {@link SignableMessage}\n * @see {@link createSignableMessage}\n * @see {@link isMessageModifyingSigner}\n * @see {@link assertIsMessageModifyingSigner}\n */\nexport type MessageModifyingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    modifyAndSignMessages(\n        messages: readonly SignableMessage[],\n        config?: MessageModifyingSignerConfig,\n    ): Promise<readonly SignableMessage[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link MessageModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isMessageModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isMessageModifyingSigner({ address, modifyAndSignMessages: async () => {} }); // true\n * isMessageModifyingSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsMessageModifyingSigner}\n */\nexport function isMessageModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessageModifyingSigner<TAddress> {\n    return (\n        isAddress(value.address) &&\n        'modifyAndSignMessages' in value &&\n        typeof value.modifyAndSignMessages === 'function'\n    );\n}\n\n/**\n * Asserts that the provided value implements the {@link MessageModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsMessageModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsMessageModifyingSigner({ address, modifyAndSignMessages: async () => {} }); // void\n * assertIsMessageModifyingSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isMessageModifyingSigner}\n */\nexport function assertIsMessageModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessageModifyingSigner<TAddress> {\n    if (!isMessageModifyingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS, SolanaError } from '@solana/errors';\nimport type { AffinePoint } from '@solana/nominal-types';\n\nimport { type Address, getAddressCodec } from './address';\nimport { compressedPointBytesAreOnCurve } from './curve-internal';\n\n/**\n * Represents an {@link Address} that validates as being off-curve. Functions that require off-curve\n * addresses should specify their inputs in terms of this type.\n *\n * Whenever you need to validate an address as being off-curve, use the {@link offCurveAddress},\n * {@link assertIsOffCurveAddress}, or {@link isOffCurveAddress} functions in this package.\n */\nexport type OffCurveAddress<TAddress extends string = string> = AffinePoint<Address<TAddress>, 'invalid'>;\n\n/**\n * A type guard that returns `true` if the input address conforms to the {@link OffCurveAddress}\n * type, and refines its type for use in your application.\n *\n * @example\n * ```ts\n * import { isOffCurveAddress } from '@solana/addresses';\n *\n * if (isOffCurveAddress(accountAddress)) {\n *     // At this point, `accountAddress` has been refined to a\n *     // `OffCurveAddress` that can be used within your business logic.\n *     const { value: account } = await rpc.getAccountInfo(accountAddress).send();\n * } else {\n *     setError(`${accountAddress} is not off-curve`);\n * }\n * ```\n */\nexport function isOffCurveAddress<TAddress extends Address>(\n    putativeOffCurveAddress: TAddress,\n): putativeOffCurveAddress is OffCurveAddress<TAddress> {\n    const addressBytes = getAddressCodec().encode(putativeOffCurveAddress);\n    return compressedPointBytesAreOnCurve(addressBytes) === false;\n}\n\n/**\n * From time to time you might acquire an {@link Address}, that you expect to validate as an\n * off-curve address, from an untrusted source. Use this function to assert that such an address is\n * off-curve.\n *\n * @example\n * ```ts\n * import { assertIsOffCurveAddress } from '@solana/addresses';\n *\n * // Imagine a function that fetches an account's balance when a user submits a form.\n * function handleSubmit() {\n *     // We know only that the input conforms to the `string` type.\n *     const address: string = accountAddressInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `address` to `Address`.\n *         assertIsAddress(address);\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `address` to `OffCurveAddress`.\n *         assertIsOffCurveAddress(address);\n *         // At this point, `address` is an `OffCurveAddress` that can be used with the RPC.\n *         const balanceInLamports = await rpc.getBalance(address).send();\n *     } catch (e) {\n *         // `address` turned out to NOT be a base58-encoded off-curve address\n *     }\n * }\n * ```\n */\nexport function assertIsOffCurveAddress<TAddress extends Address>(\n    putativeOffCurveAddress: TAddress,\n): asserts putativeOffCurveAddress is OffCurveAddress<TAddress> {\n    if (!isOffCurveAddress(putativeOffCurveAddress)) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS);\n    }\n}\n\n/**\n * Combines _asserting_ that an {@link Address} is off-curve with _coercing_ it to the\n * {@link OffCurveAddress} type. It's most useful with untrusted input.\n */\nexport function offCurveAddress<TAddress extends Address>(\n    putativeOffCurveAddress: TAddress,\n): OffCurveAddress<TAddress> {\n    assertIsOffCurveAddress(putativeOffCurveAddress);\n    return putativeOffCurveAddress;\n}\n","import { SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * This type represents a Unix timestamp in _seconds_.\n *\n * It is represented as a `bigint` in client code and an `i64` in server code.\n */\nexport type UnixTimestamp = Brand<bigint, 'UnixTimestamp'>;\n\n// Largest possible value to be represented by an i64\nconst maxI64Value = 9223372036854775807n; // 2n ** 63n - 1n\nconst minI64Value = -9223372036854775808n; // -(2n ** 63n)\n\n/**\n * This is a type guard that accepts a `bigint` as input. It will both return `true` if the integer\n * conforms to the {@link UnixTimestamp} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isUnixTimestamp } from '@solana/rpc-types';\n *\n * if (isUnixTimestamp(timestamp)) {\n *     // At this point, `timestamp` has been refined to a\n *     // `UnixTimestamp` that can be used anywhere timestamps are expected.\n *     timestamp satisfies UnixTimestamp;\n * } else {\n *     setError(`${timestamp} is not a Unix timestamp`);\n * }\n * ```\n */\n\nexport function isUnixTimestamp(putativeTimestamp: bigint): putativeTimestamp is UnixTimestamp {\n    return putativeTimestamp >= minI64Value && putativeTimestamp <= maxI64Value;\n}\n\n/**\n * Timestamp values returned from the RPC API conform to the type {@link UnixTimestamp}. You can use\n * a value of that type wherever a timestamp is expected.\n *\n * @example\n * From time to time you might acquire a number that you expect to be a timestamp, from an untrusted\n * network API or user input. To assert that such an arbitrary number is usable as a Unix timestamp,\n * use this function.\n *\n * ```ts\n * import { assertIsUnixTimestamp } from '@solana/rpc-types';\n *\n * // Imagine having received a value that you presume represents a timestamp.\n * // At this point we know only that it conforms to the `bigint` type.\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `timestamp` to `UnixTimestamp`.\n *     assertIsUnixTimestamp(timestamp);\n *     // At this point, `timestamp` is a `UnixTimestamp`.\n *     timestamp satisfies UnixTimestamp;\n * } catch (e) {\n *     // `timestamp` turned out not to be a valid Unix timestamp\n * }\n * ```\n */\nexport function assertIsUnixTimestamp(putativeTimestamp: bigint): asserts putativeTimestamp is UnixTimestamp {\n    if (putativeTimestamp < minI64Value || putativeTimestamp > maxI64Value) {\n        throw new SolanaError(SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, {\n            value: putativeTimestamp,\n        });\n    }\n}\n\n/**\n * This helper combines _asserting_ that a `bigint` represents a Unix timestamp with _coercing_ it\n * to the {@link UnixTimestamp} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { unixTimestamp } from '@solana/rpc-types';\n *\n * const timestamp = unixTimestamp(-42n); // Wednesday, December 31, 1969 3:59:18 PM GMT-08:00\n * ```\n */\nexport function unixTimestamp(putativeTimestamp: bigint): UnixTimestamp {\n    assertIsUnixTimestamp(putativeTimestamp);\n    return putativeTimestamp;\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Offset,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\n\n/**\n * Returns an encoder for `shortU16` values.\n *\n * This encoder serializes `shortU16` values using **1 to 3 bytes**.\n * Smaller values use fewer bytes, while larger values take up more space.\n *\n * For more details, see {@link getShortU16Codec}.\n *\n * @returns A `VariableSizeEncoder<number | bigint>` for encoding `shortU16` values.\n *\n * @example\n * Encoding a `shortU16` value.\n * ```ts\n * const encoder = getShortU16Encoder();\n * encoder.encode(42);    // 0x2a\n * encoder.encode(128);   // 0x8001\n * encoder.encode(16384); // 0x808001\n * ```\n *\n * @see {@link getShortU16Codec}\n */\nexport const getShortU16Encoder = (): VariableSizeEncoder<bigint | number> =>\n    createEncoder({\n        getSizeFromValue: (value: bigint | number): number => {\n            if (value <= 0b01111111) return 1;\n            if (value <= 0b0011111111111111) return 2;\n            return 3;\n        },\n        maxSize: 3,\n        write: (value: bigint | number, bytes: Uint8Array, offset: Offset): Offset => {\n            assertNumberIsBetweenForCodec('shortU16', 0, 65535, value);\n            const shortU16Bytes = [0];\n            for (let ii = 0; ; ii += 1) {\n                // Shift the bits of the value over such that the next 7 bits are at the right edge.\n                const alignedValue = Number(value) >> (ii * 7);\n                if (alignedValue === 0) {\n                    // No more bits to consume.\n                    break;\n                }\n                // Extract those 7 bits using a mask.\n                const nextSevenBits = 0b1111111 & alignedValue;\n                shortU16Bytes[ii] = nextSevenBits;\n                if (ii > 0) {\n                    // Set the continuation bit of the previous slice.\n                    shortU16Bytes[ii - 1] |= 0b10000000;\n                }\n            }\n            bytes.set(shortU16Bytes, offset);\n            return offset + shortU16Bytes.length;\n        },\n    });\n\n/**\n * Returns a decoder for `shortU16` values.\n *\n * This decoder deserializes `shortU16` values from **1 to 3 bytes**.\n * The number of bytes used depends on the encoded value.\n *\n * For more details, see {@link getShortU16Codec}.\n *\n * @returns A `VariableSizeDecoder<number>` for decoding `shortU16` values.\n *\n * @example\n * Decoding a `shortU16` value.\n * ```ts\n * const decoder = getShortU16Decoder();\n * decoder.decode(new Uint8Array([0x2a]));             // 42\n * decoder.decode(new Uint8Array([0x80, 0x01]));       // 128\n * decoder.decode(new Uint8Array([0x80, 0x80, 0x01])); // 16384\n * ```\n *\n * @see {@link getShortU16Codec}\n */\nexport const getShortU16Decoder = (): VariableSizeDecoder<number> =>\n    createDecoder({\n        maxSize: 3,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset): [number, Offset] => {\n            let value = 0;\n            let byteCount = 0;\n            while (++byteCount) {\n                const byteIndex = byteCount - 1;\n                const currentByte = bytes[offset + byteIndex];\n                const nextSevenBits = 0b1111111 & currentByte;\n                // Insert the next group of seven bits into the correct slot of the output value.\n                value |= nextSevenBits << (byteIndex * 7);\n                if ((currentByte & 0b10000000) === 0) {\n                    // This byte does not have its continuation bit set. We're done.\n                    break;\n                }\n            }\n            return [value, offset + byteCount];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding `shortU16` values.\n *\n * It serializes unsigned integers using **1 to 3 bytes** based on the encoded value.\n * The larger the value, the more bytes it uses.\n *\n * - If the value is `<= 0x7f` (127), it is stored in a **single byte**\n *   and the first bit is set to `0` to indicate the end of the value.\n * - Otherwise, the first bit is set to `1` to indicate that the value continues in the next byte, which follows the same pattern.\n * - This process repeats until the value is fully encoded in up to 3 bytes. The third and last byte, if needed, uses all 8 bits to store the remaining value.\n *\n * In other words, the encoding scheme follows this structure:\n *\n * ```txt\n * 0XXXXXXX                   <- Values 0 to 127 (1 byte)\n * 1XXXXXXX 0XXXXXXX          <- Values 128 to 16,383 (2 bytes)\n * 1XXXXXXX 1XXXXXXX XXXXXXXX <- Values 16,384 to 4,194,303 (3 bytes)\n * ```\n *\n * @returns A `VariableSizeCodec<number | bigint, number>` for encoding and decoding `shortU16` values.\n *\n * @example\n * Encoding and decoding `shortU16` values.\n * ```ts\n * const codec = getShortU16Codec();\n * const bytes1 = codec.encode(42);    // 0x2a\n * const bytes2 = codec.encode(128);   // 0x8001\n * const bytes3 = codec.encode(16384); // 0x808001\n *\n * codec.decode(bytes1); // 42\n * codec.decode(bytes2); // 128\n * codec.decode(bytes3); // 16384\n * ```\n *\n * @remarks\n * This codec efficiently stores small numbers, making it useful for transactions and compact representations.\n *\n * If you need a fixed-size `u16` codec, consider using {@link getU16Codec}.\n *\n * Separate {@link getShortU16Encoder} and {@link getShortU16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getShortU16Encoder().encode(42);\n * const value = getShortU16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getShortU16Encoder}\n * @see {@link getShortU16Decoder}\n */\nexport const getShortU16Codec = (): VariableSizeCodec<bigint | number, number> =>\n    combineCodec(getShortU16Encoder(), getShortU16Decoder());\n","import {\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Asserts that a given byte array is not empty (after the optional provided offset).\n *\n * Returns void if the byte array is not empty but throws a {@link SolanaError} otherwise.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param bytes - The byte array to check.\n * @param offset - The offset from which to start checking the byte array.\n * If provided, the byte array is considered empty if it has no bytes after the offset.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes); // OK\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes, 1); // OK\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes, 3); // Throws\n * ```\n */\nexport function assertByteArrayIsNotEmptyForCodec(\n    codecDescription: string,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    if (bytes.length - offset <= 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription,\n        });\n    }\n}\n\n/**\n * Asserts that a given byte array has enough bytes to decode\n * (after the optional provided offset).\n *\n * Returns void if the byte array has at least the expected number\n * of bytes but throws a {@link SolanaError} otherwise.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param expected - The minimum number of bytes expected in the byte array.\n * @param bytes - The byte array to check.\n * @param offset - The offset from which to start checking the byte array.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 3, bytes); // OK\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 4, bytes); // Throws\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 2, bytes, 1); // OK\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 3, bytes, 1); // Throws\n * ```\n */\nexport function assertByteArrayHasEnoughBytesForCodec(\n    codecDescription: string,\n    expected: number,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected,\n        });\n    }\n}\n\n/**\n * Asserts that a given offset is within the byte array bounds.\n * This range is between 0 and the byte array length and is inclusive.\n * An offset equals to the byte array length is considered a valid offset\n * as it allows the post-offset of codecs to signal the end of the byte array.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param offset - The offset to check.\n * @param bytesLength - The length of the byte array from which the offset should be within bounds.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 0, bytes.length); // OK\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 3, bytes.length); // OK\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 4, bytes.length); // Throws\n * ```\n */\nexport function assertByteArrayOffsetIsNotOutOfRange(codecDescription: string, offset: number, bytesLength: number) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, SolanaError } from '@solana/errors';\n\nimport { isMessageModifyingSigner, MessageModifyingSigner } from './message-modifying-signer';\nimport { isMessagePartialSigner, MessagePartialSigner } from './message-partial-signer';\n\n/**\n * Defines a signer capable of signing messages.\n *\n * @see {@link MessageModifyingSigner} For signers that can modify messages before signing them.\n * @see {@link MessagePartialSigner} For signers that can be used in parallel.\n * @see {@link isMessageSigner}\n * @see {@link assertIsMessageSigner}\n */\nexport type MessageSigner<TAddress extends string = string> =\n    | MessageModifyingSigner<TAddress>\n    | MessagePartialSigner<TAddress>;\n\n/**\n * Checks whether the provided value implements the {@link MessageSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isMessageSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isMessageSigner({ address, signMessages: async () => {} }); // true\n * isMessageSigner({ address, modifyAndSignMessages: async () => {} }); // true\n * isMessageSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsMessageSigner}\n */\nexport function isMessageSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessageSigner<TAddress> {\n    return isMessagePartialSigner(value) || isMessageModifyingSigner(value);\n}\n\n/**\n * Asserts that the provided value implements the {@link MessageSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsMessageSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsMessageSigner({ address, signMessages: async () => {} }); // void\n * assertIsMessageSigner({ address, modifyAndSignMessages: async () => {} }); // void\n * assertIsMessageSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isMessageSigner}\n */\nexport function assertIsMessageSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessageSigner<TAddress> {\n    if (!isMessageSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","export const OPTIONS_OBJECT_POSITION_BY_METHOD: Record<string, number> = {\n    accountNotifications: 1,\n    blockNotifications: 1,\n    getAccountInfo: 1,\n    getBalance: 1,\n    getBlock: 1,\n    getBlockHeight: 0,\n    getBlockProduction: 0,\n    getBlocks: 2,\n    getBlocksWithLimit: 2,\n    getEpochInfo: 0,\n    getFeeForMessage: 1,\n    getInflationGovernor: 0,\n    getInflationReward: 1,\n    getLargestAccounts: 0,\n    getLatestBlockhash: 0,\n    getLeaderSchedule: 1,\n    getMinimumBalanceForRentExemption: 1,\n    getMultipleAccounts: 1,\n    getProgramAccounts: 1,\n    getSignaturesForAddress: 1,\n    getSlot: 0,\n    getSlotLeader: 0,\n    getStakeMinimumDelegation: 0,\n    getSupply: 0,\n    getTokenAccountBalance: 1,\n    getTokenAccountsByDelegate: 2,\n    getTokenAccountsByOwner: 2,\n    getTokenLargestAccounts: 1,\n    getTokenSupply: 1,\n    getTransaction: 1,\n    getTransactionCount: 0,\n    getVoteAccounts: 0,\n    isBlockhashValid: 1,\n    logsNotifications: 1,\n    programNotifications: 1,\n    requestAirdrop: 2,\n    sendTransaction: 1,\n    signatureNotifications: 1,\n    simulateTransaction: 1,\n};\n","import { assertDigestCapabilityIsAvailable } from '@solana/assertions';\nimport type { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED,\n    SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE,\n    SOLANA_ERROR__ADDRESSES__MALFORMED_PDA,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\nimport { Address, assertIsAddress, getAddressCodec, isAddress } from './address';\nimport { compressedPointBytesAreOnCurve } from './curve-internal';\n\n/**\n * A tuple representing a program derived address (derived from the address of some program and a\n * set of seeds) and the associated bump seed used to ensure that the address, as derived, does not\n * fall on the Ed25519 curve.\n *\n * Whenever you need to validate an arbitrary tuple as one that represents a program derived\n * address, use the {@link assertIsProgramDerivedAddress} or {@link isProgramDerivedAddress}\n * functions in this package.\n */\nexport type ProgramDerivedAddress<TAddress extends string = string> = Readonly<\n    [Address<TAddress>, ProgramDerivedAddressBump]\n>;\n\n/**\n * Represents an integer in the range [0,255] used in the derivation of a program derived address to\n * ensure that it does not fall on the Ed25519 curve.\n */\nexport type ProgramDerivedAddressBump = Brand<number, 'ProgramDerivedAddressBump'>;\n\n/**\n * A type guard that returns `true` if the input tuple conforms to the {@link ProgramDerivedAddress}\n * type, and refines its type for use in your program.\n *\n * @see The {@link isAddress} function for an example of how to use a type guard.\n */\nexport function isProgramDerivedAddress<TAddress extends string = string>(\n    value: unknown,\n): value is ProgramDerivedAddress<TAddress> {\n    return (\n        Array.isArray(value) &&\n        value.length === 2 &&\n        typeof value[0] === 'string' &&\n        typeof value[1] === 'number' &&\n        value[1] >= 0 &&\n        value[1] <= 255 &&\n        isAddress(value[0])\n    );\n}\n\n/**\n * In the event that you receive an address/bump-seed tuple from some untrusted source, use this\n * function to assert that it conforms to the {@link ProgramDerivedAddress} interface.\n *\n * @see The {@link assertIsAddress} function for an example of how to use an assertion function.\n */\nexport function assertIsProgramDerivedAddress<TAddress extends string = string>(\n    value: unknown,\n): asserts value is ProgramDerivedAddress<TAddress> {\n    const validFormat =\n        Array.isArray(value) && value.length === 2 && typeof value[0] === 'string' && typeof value[1] === 'number';\n    if (!validFormat) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MALFORMED_PDA);\n    }\n    if (value[1] < 0 || value[1] > 255) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE, {\n            bump: value[1],\n        });\n    }\n    assertIsAddress(value[0]);\n}\n\ntype ProgramDerivedAddressInput = Readonly<{\n    programAddress: Address;\n    seeds: Seed[];\n}>;\n\ntype SeedInput = Readonly<{\n    baseAddress: Address;\n    programAddress: Address;\n    seed: Seed;\n}>;\n\ntype Seed = ReadonlyUint8Array | string;\n\nconst MAX_SEED_LENGTH = 32;\nconst MAX_SEEDS = 16;\nconst PDA_MARKER_BYTES = [\n    // The string 'ProgramDerivedAddress'\n    80, 114, 111, 103, 114, 97, 109, 68, 101, 114, 105, 118, 101, 100, 65, 100, 100, 114, 101, 115, 115,\n] as const;\n\nasync function createProgramDerivedAddress({ programAddress, seeds }: ProgramDerivedAddressInput): Promise<Address> {\n    assertDigestCapabilityIsAvailable();\n    if (seeds.length > MAX_SEEDS) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED, {\n            actual: seeds.length,\n            maxSeeds: MAX_SEEDS,\n        });\n    }\n    let textEncoder: TextEncoder;\n    const seedBytes = seeds.reduce((acc, seed, ii) => {\n        const bytes = typeof seed === 'string' ? (textEncoder ||= new TextEncoder()).encode(seed) : seed;\n        if (bytes.byteLength > MAX_SEED_LENGTH) {\n            throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n                actual: bytes.byteLength,\n                index: ii,\n                maxSeedLength: MAX_SEED_LENGTH,\n            });\n        }\n        acc.push(...bytes);\n        return acc;\n    }, [] as number[]);\n    const base58EncodedAddressCodec = getAddressCodec();\n    const programAddressBytes = base58EncodedAddressCodec.encode(programAddress);\n    const addressBytesBuffer = await crypto.subtle.digest(\n        'SHA-256',\n        new Uint8Array([...seedBytes, ...programAddressBytes, ...PDA_MARKER_BYTES]),\n    );\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n    if (compressedPointBytesAreOnCurve(addressBytes)) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE);\n    }\n    return base58EncodedAddressCodec.decode(addressBytes);\n}\n\n/**\n * Given a program's {@link Address} and up to 16 {@link Seed | Seeds}, this method will return the\n * program derived address (PDA) associated with each.\n *\n * @example\n * ```ts\n * import { getAddressEncoder, getProgramDerivedAddress } from '@solana/addresses';\n *\n * const addressEncoder = getAddressEncoder();\n * const [pda, bumpSeed] = await getProgramDerivedAddress({\n *     programAddress: 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address,\n *     seeds: [\n *         // Owner\n *         addressEncoder.encode('9fYLFVoVqwH37C3dyPi6cpeobfbQ2jtLpN5HgAYDDdkm' as Address),\n *         // Token program\n *         addressEncoder.encode('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address),\n *         // Mint\n *         addressEncoder.encode('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v' as Address),\n *     ],\n * });\n * ```\n */\nexport async function getProgramDerivedAddress({\n    programAddress,\n    seeds,\n}: ProgramDerivedAddressInput): Promise<ProgramDerivedAddress> {\n    let bumpSeed = 255;\n    while (bumpSeed > 0) {\n        try {\n            const address = await createProgramDerivedAddress({\n                programAddress,\n                seeds: [...seeds, new Uint8Array([bumpSeed])],\n            });\n            return [address, bumpSeed as ProgramDerivedAddressBump];\n        } catch (e) {\n            if (isSolanaError(e, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE)) {\n                bumpSeed--;\n            } else {\n                throw e;\n            }\n        }\n    }\n    throw new SolanaError(SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED);\n}\n\n/**\n * Returns a base58-encoded address derived from some base address, some program address, and a seed\n * string or byte array.\n *\n * @example\n * ```ts\n * import { createAddressWithSeed } from '@solana/addresses';\n *\n * const derivedAddress = await createAddressWithSeed({\n *     // The private key associated with this address will be able to sign for `derivedAddress`.\n *     baseAddress: 'B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka' as Address,\n *     // Only this program will be able to write data to this account.\n *     programAddress: '445erYq578p2aERrGW9mn9KiYe3fuG6uHdcJ2LPPShGw' as Address,\n *     seed: 'data-account',\n * });\n * ```\n */\nexport async function createAddressWithSeed({ baseAddress, programAddress, seed }: SeedInput): Promise<Address> {\n    const { encode, decode } = getAddressCodec();\n\n    const seedBytes = typeof seed === 'string' ? new TextEncoder().encode(seed) : seed;\n    if (seedBytes.byteLength > MAX_SEED_LENGTH) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n            actual: seedBytes.byteLength,\n            index: 0,\n            maxSeedLength: MAX_SEED_LENGTH,\n        });\n    }\n\n    const programAddressBytes = encode(programAddress);\n    if (\n        programAddressBytes.length >= PDA_MARKER_BYTES.length &&\n        programAddressBytes.slice(-PDA_MARKER_BYTES.length).every((byte, index) => byte === PDA_MARKER_BYTES[index])\n    ) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER);\n    }\n\n    const addressBytesBuffer = await crypto.subtle.digest(\n        'SHA-256',\n        new Uint8Array([...encode(baseAddress), ...seedBytes, ...programAddressBytes]),\n    );\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n\n    return decode(addressBytes);\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/**\n * Returns an encoder for base-64 strings.\n *\n * This encoder serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-64 strings.\n *\n * @example\n * Encoding a base-64 string.\n * ```ts\n * const encoder = getBase64Encoder();\n * const bytes = encoder.encode('hello+world'); // 0x85e965a3ec28ae57\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return transformEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/**\n * Returns a decoder for base-64 strings.\n *\n * This decoder deserializes base-64 encoded strings from a byte array.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-64 strings.\n *\n * @example\n * Decoding a base-64 string.\n * ```ts\n * const decoder = getBase64Decoder();\n * const value = decoder.decode(new Uint8Array([0x85, 0xe9, 0x65, 0xa3, 0xec, 0x28, 0xae, 0x57])); // \"hello+world\"\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return transformDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/**\n * Returns a codec for encoding and decoding base-64 strings.\n *\n * This codec serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-64 strings.\n *\n * @example\n * Encoding and decoding a base-64 string.\n * ```ts\n * const codec = getBase64Codec();\n * const bytes = codec.encode('hello+world'); // 0x85e965a3ec28ae57\n * const value = codec.decode(bytes);         // \"hello+world\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-64 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase64Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-64 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase64Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase64Encoder} and {@link getBase64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase64Encoder().encode('hello+world');\n * const value = getBase64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase64Encoder}\n * @see {@link getBase64Decoder}\n */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n","import {\n    combineCodec,\n    containsBytes,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { getBase16Decoder } from '@solana/codecs-strings';\nimport { SOLANA_ERROR__CODECS__INVALID_CONSTANT, SolanaError } from '@solana/errors';\n\n/**\n * Returns an encoder that always writes a predefined constant byte sequence.\n *\n * This encoder ensures that encoding always produces the specified byte array,\n * ignoring any input values.\n *\n * For more details, see {@link getConstantCodec}.\n *\n * @typeParam TConstant - The fixed byte sequence that will be written during encoding.\n *\n * @param constant - The predefined byte array to encode.\n * @returns A `FixedSizeEncoder<void, N>` where `N` is the length of the constant.\n *\n * @example\n * Encoding a constant magic number.\n * ```ts\n * const encoder = getConstantEncoder(new Uint8Array([1, 2, 3, 4]));\n *\n * const bytes = encoder.encode();\n * // 0x01020304\n * //    The predefined 4-byte constant.\n * ```\n *\n * @see {@link getConstantCodec}\n */\nexport function getConstantEncoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeEncoder<void, TConstant['length']> {\n    return createEncoder({\n        fixedSize: constant.length,\n        write: (_, bytes, offset) => {\n            bytes.set(constant, offset);\n            return offset + constant.length;\n        },\n    });\n}\n\n/**\n * Returns a decoder that verifies a predefined constant byte sequence.\n *\n * This decoder reads the next bytes and checks that they match the provided constant.\n * If the bytes differ, it throws an error.\n *\n * For more details, see {@link getConstantCodec}.\n *\n * @typeParam TConstant - The fixed byte sequence expected during decoding.\n *\n * @param constant - The predefined byte array to verify.\n * @returns A `FixedSizeDecoder<void, N>` where `N` is the length of the constant.\n *\n * @example\n * Decoding a constant magic number.\n * ```ts\n * const decoder = getConstantDecoder(new Uint8Array([1, 2, 3]));\n *\n * decoder.decode(new Uint8Array([1, 2, 3])); // Passes\n * decoder.decode(new Uint8Array([1, 2, 4])); // Throws an error\n * ```\n *\n * @see {@link getConstantCodec}\n */\nexport function getConstantDecoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeDecoder<void, TConstant['length']> {\n    return createDecoder({\n        fixedSize: constant.length,\n        read: (bytes, offset) => {\n            const base16 = getBase16Decoder();\n            if (!containsBytes(bytes, constant, offset)) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_CONSTANT, {\n                    constant,\n                    data: bytes,\n                    hexConstant: base16.decode(constant),\n                    hexData: base16.decode(bytes),\n                    offset,\n                });\n            }\n            return [undefined, offset + constant.length];\n        },\n    });\n}\n\n/**\n * Returns a codec that encodes and decodes a predefined constant byte sequence.\n *\n * - **Encoding:** Always writes the specified byte array.\n * - **Decoding:** Asserts that the next bytes match the constant, throwing an error if they do not.\n *\n * This is useful for encoding fixed byte patterns required in a binary format or to use in\n * conjunction with other codecs such as {@link getHiddenPrefixCodec} or {@link getHiddenSuffixCodec}.\n *\n * @typeParam TConstant - The fixed byte sequence to encode and verify during decoding.\n *\n * @param constant - The predefined byte array to encode and assert during decoding.\n * @returns A `FixedSizeCodec<void, void, N>` where `N` is the length of the constant.\n *\n * @example\n * Encoding and decoding a constant magic number.\n * ```ts\n * const codec = getConstantCodec(new Uint8Array([1, 2, 3]));\n *\n * codec.encode(); // 0x010203\n * codec.decode(new Uint8Array([1, 2, 3])); // Passes\n * codec.decode(new Uint8Array([1, 2, 4])); // Throws an error\n * ```\n *\n * @remarks\n * Separate {@link getConstantEncoder} and {@link getConstantDecoder} functions are available.\n *\n * ```ts\n * const bytes = getConstantEncoder(new Uint8Array([1, 2, 3])).encode();\n * getConstantDecoder(new Uint8Array([1, 2, 3])).decode(bytes);\n * ```\n *\n * @see {@link getConstantEncoder}\n * @see {@link getConstantDecoder}\n */\nexport function getConstantCodec<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeCodec<void, void, TConstant['length']> {\n    return combineCodec(getConstantEncoder(constant), getConstantDecoder(constant));\n}\n","import { getBase64Decoder } from '@solana/codecs-strings';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\nimport { getTransactionEncoder } from './codecs';\nimport { Transaction } from './transaction';\n\n/** Represents the wire format of a transaction as a base64-encoded string. */\nexport type Base64EncodedWireTransaction = Brand<EncodedString<string, 'base64'>, 'Base64EncodedWireTransaction'>;\n\n/**\n * Given a signed transaction, this method returns the transaction as a string that conforms to the\n * {@link Base64EncodedWireTransaction} type.\n *\n * @example\n * ```ts\n * import { getBase64EncodedWireTransaction, signTransaction } from '@solana/transactions';\n *\n * const serializedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n * const signature = await rpc.sendTransaction(serializedTransaction, { encoding: 'base64' }).send();\n * ```\n */\nexport function getBase64EncodedWireTransaction(transaction: Transaction): Base64EncodedWireTransaction {\n    const wireTransactionBytes = getTransactionEncoder().encode(transaction);\n    return getBase64Decoder().decode(wireTransactionBytes) as Base64EncodedWireTransaction;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  isProgramDerivedAddress,\n  isTransactionSigner as kitIsTransactionSigner,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type ProgramDerivedAddress,\n  type TransactionSigner,\n  upgradeRoleToSigner,\n} from '@solana/kit';\n\n/**\n * Asserts that the given value is not null or undefined.\n * @internal\n */\nexport function expectSome<T>(value: T | null | undefined): T {\n  if (value === null || value === undefined) {\n    throw new Error('Expected a value but received null or undefined.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a PublicKey.\n * @internal\n */\nexport function expectAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): Address<T> {\n  if (!value) {\n    throw new Error('Expected a Address.');\n  }\n  if (typeof value === 'object' && 'address' in value) {\n    return value.address;\n  }\n  if (Array.isArray(value)) {\n    return value[0] as Address<T>;\n  }\n  return value as Address<T>;\n}\n\n/**\n * Asserts that the given value is a PDA.\n * @internal\n */\nexport function expectProgramDerivedAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): ProgramDerivedAddress<T> {\n  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {\n    throw new Error('Expected a ProgramDerivedAddress.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a TransactionSigner.\n * @internal\n */\nexport function expectTransactionSigner<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): TransactionSigner<T> {\n  if (!value || !isTransactionSigner(value)) {\n    throw new Error('Expected a TransactionSigner.');\n  }\n  return value;\n}\n\n/**\n * Defines an instruction account to resolve.\n * @internal\n */\nexport type ResolvedAccount<\n  T extends string = string,\n  U extends\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null =\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null,\n> = {\n  isWritable: boolean;\n  value: U;\n};\n\n/**\n * Defines an instruction that stores additional bytes on-chain.\n * @internal\n */\nexport type InstructionWithByteDelta = {\n  byteDelta: number;\n};\n\n/**\n * Get account metas and signers from resolved accounts.\n * @internal\n */\nexport function getAccountMetaFactory(\n  programAddress: Address,\n  optionalAccountStrategy: 'omitted' | 'programId'\n) {\n  return (\n    account: ResolvedAccount\n  ): AccountMeta | AccountSignerMeta | undefined => {\n    if (!account.value) {\n      if (optionalAccountStrategy === 'omitted') return;\n      return Object.freeze({\n        address: programAddress,\n        role: AccountRole.READONLY,\n      });\n    }\n\n    const writableRole = account.isWritable\n      ? AccountRole.WRITABLE\n      : AccountRole.READONLY;\n    return Object.freeze({\n      address: expectAddress(account.value),\n      role: isTransactionSigner(account.value)\n        ? upgradeRoleToSigner(writableRole)\n        : writableRole,\n      ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),\n    });\n  };\n}\n\nexport function isTransactionSigner<TAddress extends string = string>(\n  value:\n    | Address<TAddress>\n    | ProgramDerivedAddress<TAddress>\n    | TransactionSigner<TAddress>\n): value is TransactionSigner<TAddress> {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'address' in value &&\n    kitIsTransactionSigner(value)\n  );\n}\n","import { Address } from '@solana/addresses';\n\nimport { MessagePartialSigner } from './message-partial-signer';\nimport { TransactionPartialSigner } from './transaction-partial-signer';\n\n/**\n * Defines a Noop (No-Operation) signer that pretends to partially sign messages and transactions.\n *\n * For a given {@link Address}, a Noop Signer can be created to offer an implementation of both\n * the {@link MessagePartialSigner} and {@link TransactionPartialSigner} interfaces such that\n * they do not sign anything. Namely, signing a transaction or a message with a `NoopSigner`\n * will return an empty `SignatureDictionary`.\n *\n * @typeParam TAddress - Supply a string literal to define a Noop signer having a particular address.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { createNoopSigner } from '@solana/signers';\n *\n * const signer = createNoopSigner(address('1234..5678'));\n * const [messageSignatures] = await signer.signMessages([message]);\n * const [transactionSignatures] = await signer.signTransactions([transaction]);\n * // ^ Both messageSignatures and transactionSignatures are empty.\n * ```\n *\n * @remarks\n * This signer may be useful:\n *\n * - For testing purposes.\n * - For indicating that a given account is a signer and taking the responsibility to provide\n *   the signature for that account ourselves. For instance, if we need to send the transaction\n *   to a server that will sign it and send it for us.\n *\n * @see {@link createNoopSigner}\n */\nexport type NoopSigner<TAddress extends string = string> = MessagePartialSigner<TAddress> &\n    TransactionPartialSigner<TAddress>;\n\n/**\n * Creates a {@link NoopSigner} from the provided {@link Address}.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { createNoopSigner } from '@solana/signers';\n *\n * const signer = createNoopSigner(address('1234..5678'));\n * ```\n */\nexport function createNoopSigner<TAddress extends string = string>(address: Address<TAddress>): NoopSigner<TAddress> {\n    const out: NoopSigner<TAddress> = {\n        address,\n        signMessages: messages => Promise.resolve(messages.map(() => Object.freeze({}))),\n        signTransactions: transactions => Promise.resolve(transactions.map(() => Object.freeze({}))),\n    };\n\n    return Object.freeze(out);\n}\n","import { SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, SolanaError } from '@solana/errors';\nimport type { NominalType } from '@solana/nominal-types';\nimport type { BaseTransactionMessage, TransactionMessageWithinSizeLimit } from '@solana/transaction-messages';\n\nimport { getTransactionEncoder } from './codecs';\nimport { Transaction } from './transaction';\n\n/**\n * The maximum size of a transaction packet in bytes.\n */\nexport const TRANSACTION_PACKET_SIZE = 1280;\n\n/**\n * The size of the transaction packet header in bytes.\n * This includes the IPv6 header and the fragment header.\n */\nexport const TRANSACTION_PACKET_HEADER =\n    40 /* 40 bytes is the size of the IPv6 header. */ + 8; /* 8 bytes is the size of the fragment header. */\n\n/**\n * The maximum size of a transaction in bytes.\n *\n * Note that this excludes the transaction packet header.\n * In other words, this is how much content we can fit in a transaction packet.\n */\nexport const TRANSACTION_SIZE_LIMIT = TRANSACTION_PACKET_SIZE - TRANSACTION_PACKET_HEADER;\n\n/**\n * Gets the size of a given transaction in bytes.\n *\n * @example\n * ```ts\n * const transactionSize = getTransactionSize(transaction);\n * ```\n */\nexport function getTransactionSize(transaction: Transaction): number {\n    return getTransactionEncoder().getSizeFromValue(transaction);\n}\n\n/**\n * A type guard that checks if a transaction is within the size limit.\n */\nexport type TransactionWithinSizeLimit = NominalType<'transactionSize', 'withinLimit'>;\n\n/**\n * Helper type that adds the `TransactionWithinSizeLimit` flag to\n * a transaction if and only if the provided transaction message\n * is also within the size limit.\n */\nexport type SetTransactionWithinSizeLimitFromTransactionMessage<\n    TTransaction extends Transaction,\n    TTransactionMessage extends BaseTransactionMessage,\n> = TTransactionMessage extends TransactionMessageWithinSizeLimit\n    ? TransactionWithinSizeLimit & TTransaction\n    : TTransaction;\n\n/**\n * Checks if a transaction is within the size limit.\n *\n * @typeParam TTransaction - The type of the given transaction.\n *\n * @example\n * ```ts\n * if (isTransactionWithinSizeLimit(transaction)) {\n *    transaction satisfies TransactionWithinSizeLimit;\n * }\n * ```\n */\nexport function isTransactionWithinSizeLimit<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): transaction is TransactionWithinSizeLimit & TTransaction {\n    return getTransactionSize(transaction) <= TRANSACTION_SIZE_LIMIT;\n}\n\n/**\n * Asserts that a given transaction is within the size limit.\n *\n * Throws a {@link SolanaError} of code {@link SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT}\n * if the transaction exceeds the size limit.\n *\n * @typeParam TTransaction - The type of the given transaction.\n *\n * @example\n * ```ts\n * assertIsTransactionWithinSizeLimit(transaction);\n * transaction satisfies TransactionWithinSizeLimit;\n * ```\n */\nexport function assertIsTransactionWithinSizeLimit<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): asserts transaction is TransactionWithinSizeLimit & TTransaction {\n    const transactionSize = getTransactionSize(transaction);\n    if (transactionSize > TRANSACTION_SIZE_LIMIT) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, {\n            transactionSize,\n            transactionSizeLimit: TRANSACTION_SIZE_LIMIT,\n        });\n    }\n}\n","import {\n    SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS,\n    SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\nimport { getSignersFromTransactionMessage, TransactionMessageWithSigners } from './account-signer-meta';\nimport { isTransactionModifyingSigner } from './transaction-modifying-signer';\nimport { isTransactionPartialSigner } from './transaction-partial-signer';\nimport { isTransactionSendingSigner } from './transaction-sending-signer';\n\n/**\n * Defines a transaction message with exactly one {@link TransactionSendingSigner}.\n *\n * This type is used to narrow the type of transaction messages that have been\n * checked to have exactly one sending signer.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithSingleSendingSigner } from '@solana/signers';\n *\n * assertIsTransactionMessageWithSingleSendingSigner(transactionMessage);\n * transactionMessage satisfies TransactionMessageWithSingleSendingSigner;\n * ```\n *\n * @see {@link isTransactionMessageWithSingleSendingSigner}\n * @see {@link assertIsTransactionMessageWithSingleSendingSigner}\n */\nexport type TransactionMessageWithSingleSendingSigner = Brand<\n    TransactionMessageWithSigners,\n    'TransactionMessageWithSingleSendingSigner'\n>;\n\n/**\n * Checks whether the provided transaction has exactly one {@link TransactionSendingSigner}.\n *\n * This can be useful when using {@link signAndSendTransactionMessageWithSigners} to provide\n * a fallback strategy in case the transaction message cannot be send using this function.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import {\n *     isTransactionMessageWithSingleSendingSigner,\n *     signAndSendTransactionMessageWithSigners,\n *     signTransactionMessageWithSigners,\n * } from '@solana/signers';\n * import { getBase64EncodedWireTransaction } from '@solana/transactions';\n *\n * let transactionSignature: SignatureBytes;\n * if (isTransactionMessageWithSingleSendingSigner(transactionMessage)) {\n *     transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n * } else {\n *     const signedTransaction = await signTransactionMessageWithSigners(transactionMessage);\n *     const encodedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n *     transactionSignature = await rpc.sendTransaction(encodedTransaction).send();\n * }\n * ```\n *\n * @see {@link signAndSendTransactionMessageWithSigners}\n * @see {@link assertIsTransactionMessageWithSingleSendingSigner}\n */\nexport function isTransactionMessageWithSingleSendingSigner<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(transaction: TTransactionMessage): transaction is TransactionMessageWithSingleSendingSigner & TTransactionMessage {\n    try {\n        assertIsTransactionMessageWithSingleSendingSigner(transaction);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Asserts that the provided transaction message has exactly one {@link TransactionSendingSigner}.\n *\n * This can be useful when using the {@link signAndSendTransactionMessageWithSigners} function\n * to ensure it will be able to select the correct signer to send the transaction.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import {\n *     assertIsTransactionMessageWithSingleSendingSigner,\n *     signAndSendTransactionMessageWithSigners\n * } from '@solana/signers';\n *\n * assertIsTransactionMessageWithSingleSendingSigner(transactionMessage);\n * const transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n * ```\n *\n * @see {@link signAndSendTransactionMessageWithSigners}\n * @see {@link isTransactionMessageWithSingleSendingSigner}\n */\nexport function assertIsTransactionMessageWithSingleSendingSigner<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(\n    transaction: TTransactionMessage,\n): asserts transaction is TransactionMessageWithSingleSendingSigner & TTransactionMessage {\n    const signers = getSignersFromTransactionMessage(transaction);\n    const sendingSigners = signers.filter(isTransactionSendingSigner);\n\n    if (sendingSigners.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n    }\n\n    // When identifying if there are multiple sending signers, we only need to check for\n    // sending signers that do not implement other transaction signer interfaces as\n    // they will be used as these other signer interfaces in case of a conflict.\n    const sendingOnlySigners = sendingSigners.filter(\n        signer => !isTransactionPartialSigner(signer) && !isTransactionModifyingSigner(signer),\n    );\n\n    if (sendingOnlySigners.length > 1) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS);\n    }\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\ntype NumberEncoder = Encoder<bigint | number> | Encoder<number>;\ntype FixedSizeNumberEncoder<TSize extends number = number> =\n    | FixedSizeEncoder<bigint | number, TSize>\n    | FixedSizeEncoder<number, TSize>;\ntype NumberDecoder = Decoder<bigint> | Decoder<number>;\ntype FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\ntype NumberCodec = Codec<bigint | number, bigint> | Codec<number>;\ntype FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<number, number, TSize>;\n\n/**\n * Stores the size of the `encoder` in bytes as a prefix using the `prefix` encoder.\n *\n * See {@link addCodecSizePrefix} for more information.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link addCodecSizePrefix}\n */\nexport function addEncoderSizePrefix<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefix: FixedSizeNumberEncoder,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): VariableSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds.\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : (encoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n\n    return createEncoder({\n        ...encoder,\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: value => {\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write,\n    });\n}\n\n/**\n * Bounds the size of the nested `decoder` by reading its encoded `prefix`.\n *\n * See {@link addCodecSizePrefix} for more information.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link addCodecSizePrefix}\n */\nexport function addDecoderSizePrefix<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefix: FixedSizeNumberDecoder,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): VariableSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        // Slice the byte array to the contained size if necessary.\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec('addDecoderSizePrefix', size, bytes);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds.\n        return [decoder.decode(bytes), offset + size];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : (decoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({ ...decoder, ...(maxSize !== null ? { maxSize } : {}), read });\n}\n\n/**\n * Stores the byte size of any given codec as an encoded number prefix.\n *\n * This sets a limit on variable-size codecs and tells us when to stop decoding.\n * When encoding, the size of the encoded data is stored before the encoded data itself.\n * When decoding, the size is read first to know how many bytes to read next.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * For example, say we want to bound a variable-size base-58 string using a `u32` size prefix.\n * Heres how you can use the `addCodecSizePrefix` function to achieve that.\n *\n * ```ts\n * const getU32Base58Codec = () => addCodecSizePrefix(getBase58Codec(), getU32Codec());\n *\n * getU32Base58Codec().encode('hello world');\n * // 0x0b00000068656c6c6f20776f726c64\n * //   |       -- Our encoded base-58 string.\n * //   -- Our encoded u32 size prefix.\n * ```\n *\n * @remarks\n * Separate {@link addEncoderSizePrefix} and {@link addDecoderSizePrefix} functions are also available.\n *\n * ```ts\n * const bytes = addEncoderSizePrefix(getBase58Encoder(), getU32Encoder()).encode('hello');\n * const value = addDecoderSizePrefix(getBase58Decoder(), getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link addEncoderSizePrefix}\n * @see {@link addDecoderSizePrefix}\n */\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefix: FixedSizeNumberCodec,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n","import { pipe } from '@solana/functional';\nimport { RpcRequest, RpcRequestTransformer } from '@solana/rpc-spec-types';\nimport { Commitment } from '@solana/rpc-types';\n\nimport { getBigIntDowncastRequestTransformer } from './request-transformer-bigint-downcast';\nimport { getDefaultCommitmentRequestTransformer } from './request-transformer-default-commitment';\nimport { getIntegerOverflowRequestTransformer, IntegerOverflowHandler } from './request-transformer-integer-overflow';\nimport { OPTIONS_OBJECT_POSITION_BY_METHOD } from './request-transformer-options-object-position-config';\n\nexport type RequestTransformerConfig = Readonly<{\n    /**\n     * An optional {@link Commitment} value to use as the default when none is supplied by the\n     * caller.\n     */\n    defaultCommitment?: Commitment;\n    /**\n     * An optional function that will be called whenever a `bigint` input exceeds that which can be\n     * expressed using JavaScript numbers.\n     *\n     * This is used in the default {@link SolanaRpcSubscriptionsApi} to throw an exception rather\n     * than to allow truncated values to propagate through a program.\n     */\n    onIntegerOverflow?: IntegerOverflowHandler;\n}>;\n\n/**\n * Returns the default request transformer for the Solana RPC API.\n *\n * Under the hood, this function composes multiple\n * {@link RpcRequestTransformer | RpcRequestTransformers} together such as the\n * {@link getDefaultCommitmentTransformer}, the {@link getIntegerOverflowRequestTransformer} and the\n * {@link getBigIntDowncastRequestTransformer}.\n *\n * @example\n * ```ts\n * import { getDefaultRequestTransformerForSolanaRpc } from '@solana/rpc-transformers';\n *\n * const requestTransformer = getDefaultRequestTransformerForSolanaRpc({\n *     defaultCommitment: 'confirmed',\n *     onIntegerOverflow: (request, keyPath, value) => {\n *         throw new Error(`Integer overflow at ${keyPath.join('.')}: ${value}`);\n *     },\n * });\n * ```\n */\nexport function getDefaultRequestTransformerForSolanaRpc(config?: RequestTransformerConfig): RpcRequestTransformer {\n    const handleIntegerOverflow = config?.onIntegerOverflow;\n    return (request: RpcRequest): RpcRequest => {\n        return pipe(\n            request,\n            handleIntegerOverflow ? getIntegerOverflowRequestTransformer(handleIntegerOverflow) : r => r,\n            getBigIntDowncastRequestTransformer(),\n            getDefaultCommitmentRequestTransformer({\n                defaultCommitment: config?.defaultCommitment,\n                optionsObjectPositionByMethod: OPTIONS_OBJECT_POSITION_BY_METHOD,\n            }),\n        );\n    };\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nimport { TransactionVersion } from '../transaction-message';\n\nconst VERSION_FLAG_MASK = 0x80;\n\n/**\n * Returns an encoder that you can use to encode a {@link TransactionVersion} to a byte array.\n *\n * Legacy messages will produce an empty array and will not advance the offset. Versioned messages\n * will produce an array with a single byte.\n */\nexport function getTransactionVersionEncoder(): VariableSizeEncoder<TransactionVersion> {\n    return createEncoder({\n        getSizeFromValue: value => (value === 'legacy' ? 0 : 1),\n        maxSize: 1,\n        write: (value, bytes, offset) => {\n            if (value === 'legacy') {\n                return offset;\n            }\n            if (value < 0 || value > 127) {\n                throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, {\n                    actualVersion: value,\n                });\n            }\n            bytes.set([value | VERSION_FLAG_MASK], offset);\n            return offset + 1;\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link TransactionVersion}.\n *\n * When the byte at the current offset is determined to represent a legacy transaction, this decoder\n * will return `'legacy'` and will not advance the offset.\n */\nexport function getTransactionVersionDecoder(): VariableSizeDecoder<TransactionVersion> {\n    return createDecoder({\n        maxSize: 1,\n        read: (bytes, offset) => {\n            const firstByte = bytes[offset];\n            if ((firstByte & VERSION_FLAG_MASK) === 0) {\n                // No version flag set; it's a legacy (unversioned) transaction.\n                return ['legacy', offset];\n            } else {\n                const version = (firstByte ^ VERSION_FLAG_MASK) as TransactionVersion;\n                return [version, offset + 1];\n            }\n        },\n    });\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link TransactionVersion}\n *\n * @see {@link getTransactionVersionDecoder}\n * @see {@link getTransactionVersionEncoder}\n */\nexport function getTransactionVersionCodec(): VariableSizeCodec<TransactionVersion> {\n    return combineCodec(getTransactionVersionEncoder(), getTransactionVersionDecoder());\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 128-bit unsigned integers (`u128`).\n *\n * This encoder serializes `u128` values using sixteen bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU128Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<number | bigint, 16>` for encoding `u128` values.\n *\n * @example\n * Encoding a `u128` value.\n * ```ts\n * const encoder = getU128Encoder();\n * const bytes = encoder.encode(42n); // 0x2a000000000000000000000000000000\n * ```\n *\n * @see {@link getU128Codec}\n */\nexport const getU128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'u128',\n        range: [0n, BigInt('0xffffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\n/**\n * Returns a decoder for 128-bit unsigned integers (`u128`).\n *\n * This decoder deserializes `u128` values from sixteen bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU128Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<bigint, 16>` for decoding `u128` values.\n *\n * @example\n * Decoding a `u128` value.\n * ```ts\n * const decoder = getU128Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])); // 42n\n * ```\n *\n * @see {@link getU128Codec}\n */\nexport const getU128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'u128',\n        size: 16,\n    });\n\n/**\n * Returns a codec for encoding and decoding 128-bit unsigned integers (`u128`).\n *\n * This codec serializes `u128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 16>` for encoding and decoding `u128` values.\n *\n * @example\n * Encoding and decoding a `u128` value.\n * ```ts\n * const codec = getU128Codec();\n * const bytes = codec.encode(42); // 0x2a000000000000000000000000000000\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getU128Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x0000000000000000000000000000002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^128 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller unsigned integer, consider using {@link getU64Codec} or {@link getU32Codec}.\n * - If you need signed integers, consider using {@link getI128Codec}.\n *\n * Separate {@link getU128Encoder} and {@link getU128Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU128Encoder().encode(42);\n * const value = getU128Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU128Encoder}\n * @see {@link getU128Decoder}\n */\nexport const getU128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getU128Encoder(config), getU128Decoder(config));\n","import { assertIsFullySignedTransaction, FullySignedTransaction, isFullySignedTransaction } from './signatures';\nimport { Transaction } from './transaction';\nimport {\n    assertIsTransactionWithinSizeLimit,\n    isTransactionWithinSizeLimit,\n    TransactionWithinSizeLimit,\n} from './transaction-size';\n\n/**\n * Helper type that includes all transaction types required\n * for the transaction to be sent to the network.\n *\n * @see {@link isSendableTransaction}\n * @see {@link assertIsSendableTransaction}\n */\nexport type SendableTransaction = FullySignedTransaction & TransactionWithinSizeLimit;\n\n/**\n * Checks if a transaction has all the required\n * conditions to be sent to the network.\n *\n * @example\n * ```ts\n * import { isSendableTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * if (isSendableTransaction(transaction)) {\n *   // At this point we know that the transaction can be sent to the network.\n * }\n * ```\n *\n * @see {@link assertIsSendableTransaction}\n */\nexport function isSendableTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): transaction is SendableTransaction & TTransaction {\n    return isFullySignedTransaction(transaction) && isTransactionWithinSizeLimit(transaction);\n}\n\n/**\n * Asserts that a given transaction has all the\n * required conditions to be sent to the network.\n *\n * From time to time you might acquire a {@link Transaction}\n * from an untrusted network API or user input and you are not sure\n * that it has all the required conditions to be sent to the network\n *  such as being fully signed and within the size limit.\n * This function can be used to assert that such a transaction\n * is in fact sendable.\n *\n * @example\n * ```ts\n * import { assertIsSendableTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * try {\n *     // If this type assertion function doesn't throw, then Typescript will upcast `transaction`\n *     // to `SendableTransaction`.\n *     assertIsSendableTransaction(transaction);\n *     // At this point we know that the transaction can be sent to the network.\n *     await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n * } catch(e) {\n *     if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING)) {\n *         setError(`Missing signatures for ${e.context.addresses.join(', ')}`);\n *     } else if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT)) {\n *         setError(`Transaction exceeds size limit of ${e.context.transactionSizeLimit} bytes`);\n *     }\n *     throw;\n * }\n * ```\n */\nexport function assertIsSendableTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): asserts transaction is SendableTransaction & TTransaction {\n    assertIsFullySignedTransaction(transaction);\n    assertIsTransactionWithinSizeLimit(transaction);\n}\n","/**\n * Removes all null characters (`\\u0000`) from a string.\n *\n * This function cleans a string by stripping out any null characters,\n * which are often used as padding in fixed-size string encodings.\n *\n * @param value - The string to process.\n * @returns The input string with all null characters removed.\n *\n * @example\n * Removing null characters from a string.\n * ```ts\n * removeNullCharacters('hello\\u0000\\u0000'); // \"hello\"\n * ```\n */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/**\n * Pads a string with null characters (`\\u0000`) at the end to reach a fixed length.\n *\n * If the input string is shorter than the specified length, it is padded with null characters\n * until it reaches the desired size. If it is already long enough, it remains unchanged.\n *\n * @param value - The string to pad.\n * @param chars - The total length of the resulting string, including padding.\n * @returns The input string padded with null characters up to the specified length.\n *\n * @example\n * Padding a string with null characters.\n * ```ts\n * padNullCharacters('hello', 8); // \"hello\\u0000\\u0000\\u0000\"\n * ```\n */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\n/**\n * Infers the TypeScript type for a tuple that can be encoded using a tuple codec.\n *\n * This type maps each provided item encoder to its corresponding value type.\n *\n * @typeParam TItems - An array of encoders, each corresponding to a tuple element.\n */\ntype GetEncoderTypeFromItems<TItems extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\n/**\n * Infers the TypeScript type for a tuple that can be decoded using a tuple codec.\n *\n * This type maps each provided item decoder to its corresponding value type.\n *\n * @typeParam TItems - An array of decoders, each corresponding to a tuple element.\n */\ntype GetDecoderTypeFromItems<TItems extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Returns an encoder for tuples.\n *\n * This encoder serializes a fixed-size array (tuple) by encoding its items\n * sequentially using the provided item encoders.\n *\n * For more details, see {@link getTupleCodec}.\n *\n * @typeParam TItems - An array of encoders, each corresponding to a tuple element.\n *\n * @param items - The encoders for each item in the tuple.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding tuples.\n *\n * @example\n * Encoding a tuple with 2 items.\n * ```ts\n * const encoder = getTupleEncoder([fixCodecSize(getUtf8Encoder(), 5), getU8Encoder()]);\n *\n * const bytes = encoder.encode(['Alice', 42]);\n * // 0x416c6963652a\n * //   |          Second item (42)\n * //    First item (\"Alice\")\n * ```\n *\n * @see {@link getTupleCodec}\n */\nexport function getTupleEncoder<const TItems extends readonly FixedSizeEncoder<any>[]>(\n    items: TItems,\n): FixedSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): VariableSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): Encoder<GetEncoderTypeFromItems<TItems>> {\n    type TFrom = GetEncoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      items.map((item, index) => getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (value: TFrom, bytes, offset) => {\n            assertValidNumberOfItemsForCodec('tuple', items.length, value.length);\n            items.forEach((item, index) => {\n                offset = item.write(value[index], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder for tuples.\n *\n * This decoder deserializes a fixed-size array (tuple) by decoding its items\n * sequentially using the provided item decoders.\n *\n * For more details, see {@link getTupleCodec}.\n *\n * @typeParam TItems - An array of decoders, each corresponding to a tuple element.\n *\n * @param items - The decoders for each item in the tuple.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding tuples.\n *\n * @example\n * Decoding a tuple with 2 items.\n * ```ts\n * const decoder = getTupleDecoder([fixCodecSize(getUtf8Decoder(), 5), getU8Decoder()]);\n *\n * const tuple = decoder.decode(new Uint8Array([\n *   0x41,0x6c,0x69,0x63,0x65,0x2a\n * ]));\n * // ['Alice', 42]\n * ```\n *\n * @see {@link getTupleCodec}\n */\nexport function getTupleDecoder<const TItems extends readonly FixedSizeDecoder<any>[]>(\n    items: TItems,\n): FixedSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): VariableSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): Decoder<GetDecoderTypeFromItems<TItems>> {\n    type TTo = GetDecoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const values = [] as Array<any> & TTo;\n            items.forEach(item => {\n                const [newValue, newOffset] = item.read(bytes, offset);\n                values.push(newValue);\n                offset = newOffset;\n            });\n            return [values, offset];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding tuples.\n *\n * This codec serializes tuples by encoding and decoding each item sequentially.\n *\n * Unlike the {@link getArrayCodec} codec, each item in the tuple has its own codec\n * and, therefore, can be of a different type.\n *\n * @typeParam TItems - An array of codecs, each corresponding to a tuple element.\n *\n * @param items - The codecs for each item in the tuple.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding tuples.\n *\n * @example\n * Encoding and decoding a tuple with 2 items.\n * ```ts\n * const codec = getTupleCodec([fixCodecSize(getUtf8Codec(), 5), getU8Codec()]);\n *\n * const bytes = codec.encode(['Alice', 42]);\n * // 0x416c6963652a\n * //   |          Second item (42)\n * //    First item (\"Alice\")\n *\n * const tuple = codec.decode(bytes);\n * // ['Alice', 42]\n * ```\n *\n * @remarks\n * Separate {@link getTupleEncoder} and {@link getTupleDecoder} functions are available.\n *\n * ```ts\n * const bytes = getTupleEncoder([fixCodecSize(getUtf8Encoder(), 5), getU8Encoder()])\n *   .encode(['Alice', 42]);\n *\n * const tuple = getTupleDecoder([fixCodecSize(getUtf8Decoder(), 5), getU8Decoder()])\n *   .decode(bytes);\n * ```\n *\n * @see {@link getTupleEncoder}\n * @see {@link getTupleDecoder}\n */\nexport function getTupleCodec<const TItems extends readonly FixedSizeCodec<any>[]>(\n    items: TItems,\n): FixedSizeCodec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): VariableSizeCodec<\n    GetEncoderTypeFromItems<TItems>,\n    GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>\n>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): Codec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>> {\n    return combineCodec(\n        getTupleEncoder(items),\n        getTupleDecoder(items) as Decoder<GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>,\n    );\n}\n","import { SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, SolanaError } from '@solana/errors';\nimport type {\n    BaseTransactionMessage,\n    TransactionMessageWithFeePayer,\n    TransactionMessageWithinSizeLimit,\n} from '@solana/transaction-messages';\n\nimport { compileTransaction } from './compile-transaction';\nimport { getTransactionSize, TRANSACTION_SIZE_LIMIT } from './transaction-size';\n\n/**\n * Gets the compiled transaction size of a given transaction message in bytes.\n *\n * @example\n * ```ts\n * const transactionSize = getTransactionMessageSize(transactionMessage);\n * ```\n */\nexport function getTransactionMessageSize(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer,\n): number {\n    return getTransactionSize(compileTransaction(transactionMessage));\n}\n\n/**\n * Checks if a transaction message is within the size limit\n * when compiled into a transaction.\n *\n * @typeParam TTransactionMessage - The type of the given transaction message.\n *\n * @example\n * ```ts\n * if (isTransactionMessageWithinSizeLimit(transactionMessage)) {\n *    transactionMessage satisfies TransactionMessageWithinSizeLimit;\n * }\n * ```\n */\nexport function isTransactionMessageWithinSizeLimit<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n): transactionMessage is TransactionMessageWithinSizeLimit & TTransactionMessage {\n    return getTransactionMessageSize(transactionMessage) <= TRANSACTION_SIZE_LIMIT;\n}\n\n/**\n * Asserts that a given transaction message is within the size limit\n * when compiled into a transaction.\n *\n * Throws a {@link SolanaError} of code {@link SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT}\n * if the transaction message exceeds the size limit.\n *\n * @typeParam TTransactionMessage - The type of the given transaction message.\n *\n * @example\n * ```ts\n * assertIsTransactionMessageWithinSizeLimit(transactionMessage);\n * transactionMessage satisfies TransactionMessageWithinSizeLimit;\n * ```\n */\nexport function assertIsTransactionMessageWithinSizeLimit<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n): asserts transactionMessage is TransactionMessageWithinSizeLimit & TTransactionMessage {\n    const transactionSize = getTransactionMessageSize(transactionMessage);\n    if (transactionSize > TRANSACTION_SIZE_LIMIT) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, {\n            transactionSize,\n            transactionSizeLimit: TRANSACTION_SIZE_LIMIT,\n        });\n    }\n}\n","import { SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\nimport {\n    assertIsFullySignedTransaction,\n    compileTransaction,\n    FullySignedTransaction,\n    Transaction,\n    TransactionFromTransactionMessage,\n    TransactionWithLifetime,\n} from '@solana/transactions';\n\nimport { getSignersFromTransactionMessage, TransactionMessageWithSigners } from './account-signer-meta';\nimport { deduplicateSigners } from './deduplicate-signers';\nimport {\n    isTransactionModifyingSigner,\n    TransactionModifyingSigner,\n    TransactionModifyingSignerConfig,\n} from './transaction-modifying-signer';\nimport {\n    isTransactionPartialSigner,\n    TransactionPartialSigner,\n    TransactionPartialSignerConfig,\n} from './transaction-partial-signer';\nimport {\n    isTransactionSendingSigner,\n    TransactionSendingSigner,\n    TransactionSendingSignerConfig,\n} from './transaction-sending-signer';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\nimport { assertIsTransactionMessageWithSingleSendingSigner } from './transaction-with-single-sending-signer';\n\n/**\n * Extracts all {@link TransactionSigner | TransactionSigners} inside the provided\n * transaction message and uses them to return a signed transaction.\n *\n * It first uses all {@link TransactionModifyingSigner | TransactionModifyingSigners} sequentially before\n * using all {@link TransactionPartialSigner | TransactionPartialSigners} in parallel.\n *\n * If a composite signer implements both interfaces, it will be used as a\n * {@link TransactionModifyingSigner} if no other signer implements that interface.\n * Otherwise, it will be used as a {@link TransactionPartialSigner}.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage);\n * ```\n *\n * It also accepts an optional {@link AbortSignal} that will be propagated to all signers.\n *\n * ```ts\n * const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n * ```\n *\n * @remarks\n * Finally, note that this function ignores {@link TransactionSendingSigner | TransactionSendingSigners}\n * as it does not send the transaction. Check out the {@link signAndSendTransactionMessageWithSigners}\n * function for more details on how to use sending signers.\n *\n * @see {@link signTransactionMessageWithSigners}\n * @see {@link signAndSendTransactionMessageWithSigners}\n */\nexport async function partiallySignTransactionMessageWithSigners<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n>(\n    transactionMessage: TTransactionMessage,\n    config?: TransactionPartialSignerConfig,\n): Promise<TransactionFromTransactionMessage<TTransactionMessage>> {\n    const { partialSigners, modifyingSigners } = categorizeTransactionSigners(\n        deduplicateSigners(getSignersFromTransactionMessage(transactionMessage).filter(isTransactionSigner)),\n        { identifySendingSigner: false },\n    );\n\n    return await signModifyingAndPartialTransactionSigners(\n        transactionMessage,\n        modifyingSigners,\n        partialSigners,\n        config,\n    );\n}\n\n/**\n * Extracts all {@link TransactionSigner | TransactionSigners} inside the provided\n * transaction message and uses them to return a signed transaction before asserting\n * that all signatures required by the transaction are present.\n *\n * This function delegates to the {@link partiallySignTransactionMessageWithSigners} function\n * in order to extract signers from the transaction message and sign the transaction.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * const mySignedTransaction = await signTransactionMessageWithSigners(myTransactionMessage);\n *\n * // With additional config.\n * const mySignedTransaction = await signTransactionMessageWithSigners(myTransactionMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n *\n * // We now know the transaction is fully signed.\n * mySignedTransaction satisfies FullySignedTransaction;\n * ```\n *\n * @see {@link partiallySignTransactionMessageWithSigners}\n * @see {@link signAndSendTransactionMessageWithSigners}\n */\nexport async function signTransactionMessageWithSigners<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n>(\n    transactionMessage: TTransactionMessage,\n    config?: TransactionPartialSignerConfig,\n): Promise<FullySignedTransaction & TransactionFromTransactionMessage<TTransactionMessage>> {\n    const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage, config);\n    assertIsFullySignedTransaction(signedTransaction);\n    return signedTransaction;\n}\n\n/**\n * Extracts all {@link TransactionSigner | TransactionSigners} inside the provided\n * transaction message and uses them to sign it before sending it immediately to the blockchain.\n *\n * It returns the signature of the sent transaction (i.e. its identifier) as bytes.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import { signAndSendTransactionMessageWithSigners } from '@solana/signers';\n *\n * const transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n *\n * // With additional config.\n * const transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n * ```\n *\n * @remarks\n * Similarly to the {@link partiallySignTransactionMessageWithSigners} function, it first uses all\n * {@link TransactionModifyingSigner | TransactionModifyingSigners} sequentially before using all\n * {@link TransactionPartialSigner | TransactionPartialSigners} in parallel.\n * It then sends the transaction using the {@link TransactionSendingSigner} it identified.\n *\n * Composite transaction signers are treated such that at least one sending signer is used if any.\n * When a {@link TransactionSigner} implements more than one interface, we use it as a:\n *\n * - {@link TransactionSendingSigner}, if no other {@link TransactionSendingSigner} exists.\n * - {@link TransactionModifyingSigner}, if no other {@link TransactionModifyingSigner} exists.\n * - {@link TransactionPartialSigner}, otherwise.\n *\n * The provided transaction must contain exactly one {@link TransactionSendingSigner} inside its account metas.\n * If more than one composite signers implement the {@link TransactionSendingSigner} interface,\n * one of them will be selected as the sending signer. Otherwise, if multiple\n * {@link TransactionSendingSigner | TransactionSendingSigners} must be selected, the function will throw an error.\n *\n * If you'd like to assert that a transaction makes use of exactly one {@link TransactionSendingSigner}\n * _before_ calling this function, you may use the {@link assertIsTransactionMessageWithSingleSendingSigner} function.\n *\n * Alternatively, you may use the {@link isTransactionMessageWithSingleSendingSigner} function to provide a\n * fallback in case the transaction does not contain any sending signer.\n *\n * @see {@link assertIsTransactionMessageWithSingleSendingSigner}\n * @see {@link isTransactionMessageWithSingleSendingSigner}\n * @see {@link partiallySignTransactionMessageWithSigners}\n * @see {@link signTransactionMessageWithSigners}\n *\n */\nexport async function signAndSendTransactionMessageWithSigners<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n>(transaction: TTransactionMessage, config?: TransactionSendingSignerConfig): Promise<SignatureBytes> {\n    assertIsTransactionMessageWithSingleSendingSigner(transaction);\n\n    const abortSignal = config?.abortSignal;\n    const { partialSigners, modifyingSigners, sendingSigner } = categorizeTransactionSigners(\n        deduplicateSigners(getSignersFromTransactionMessage(transaction).filter(isTransactionSigner)),\n    );\n\n    abortSignal?.throwIfAborted();\n    const signedTransaction = await signModifyingAndPartialTransactionSigners(\n        transaction,\n        modifyingSigners,\n        partialSigners,\n        config,\n    );\n\n    if (!sendingSigner) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n    }\n\n    abortSignal?.throwIfAborted();\n    const [signature] = await sendingSigner.signAndSendTransactions([signedTransaction], config);\n    abortSignal?.throwIfAborted();\n\n    return signature;\n}\n\n/**\n * Identifies each provided TransactionSigner and categorizes them into their respective types.\n * When a signer implements multiple interface, it will try to used to most powerful interface\n * but fallback to the least powerful interface when necessary.\n * For instance, if a signer implements TransactionSendingSigner and TransactionModifyingSigner,\n * it will be categorized as a TransactionSendingSigner if and only if no other signers implement\n * the TransactionSendingSigner interface.\n */\nfunction categorizeTransactionSigners(\n    signers: readonly TransactionSigner[],\n    config: { identifySendingSigner?: boolean } = {},\n): Readonly<{\n    modifyingSigners: readonly TransactionModifyingSigner[];\n    partialSigners: readonly TransactionPartialSigner[];\n    sendingSigner: TransactionSendingSigner | null;\n}> {\n    // Identify the unique sending signer that should be used.\n    const identifySendingSigner = config.identifySendingSigner ?? true;\n    const sendingSigner = identifySendingSigner ? identifyTransactionSendingSigner(signers) : null;\n\n    // Now, focus on the other signers.\n    // I.e. the modifying or partial signers that are not the identified sending signer.\n    // Note that any other sending only signers will be discarded.\n    const otherSigners = signers.filter(\n        (signer): signer is TransactionModifyingSigner | TransactionPartialSigner =>\n            signer !== sendingSigner && (isTransactionModifyingSigner(signer) || isTransactionPartialSigner(signer)),\n    );\n\n    // Identify the modifying signers from the other signers.\n    const modifyingSigners = identifyTransactionModifyingSigners(otherSigners);\n\n    // Use any remaining signers as partial signers.\n    const partialSigners = otherSigners\n        .filter(isTransactionPartialSigner)\n        .filter(signer => !(modifyingSigners as typeof otherSigners).includes(signer));\n\n    return Object.freeze({ modifyingSigners, partialSigners, sendingSigner });\n}\n\n/** Identifies the best signer to use as a TransactionSendingSigner, if any */\nfunction identifyTransactionSendingSigner(signers: readonly TransactionSigner[]): TransactionSendingSigner | null {\n    // Ensure there are any TransactionSendingSigners in the first place.\n    const sendingSigners = signers.filter(isTransactionSendingSigner);\n    if (sendingSigners.length === 0) return null;\n\n    // Prefer sending signers that do not offer other interfaces.\n    const sendingOnlySigners = sendingSigners.filter(\n        signer => !isTransactionModifyingSigner(signer) && !isTransactionPartialSigner(signer),\n    );\n    if (sendingOnlySigners.length > 0) {\n        return sendingOnlySigners[0];\n    }\n\n    // Otherwise, choose any sending signer.\n    return sendingSigners[0];\n}\n\n/** Identifies the best signers to use as TransactionModifyingSigners, if any */\nfunction identifyTransactionModifyingSigners(\n    signers: readonly (TransactionModifyingSigner | TransactionPartialSigner)[],\n): readonly TransactionModifyingSigner[] {\n    // Ensure there are any TransactionModifyingSigner in the first place.\n    const modifyingSigners = signers.filter(isTransactionModifyingSigner);\n    if (modifyingSigners.length === 0) return [];\n\n    // Prefer modifying signers that do not offer partial signing.\n    const nonPartialSigners = modifyingSigners.filter(signer => !isTransactionPartialSigner(signer));\n    if (nonPartialSigners.length > 0) return nonPartialSigners;\n\n    // Otherwise, choose only one modifying signer (whichever).\n    return [modifyingSigners[0]];\n}\n\n/**\n * Signs a transaction using the provided TransactionModifyingSigners\n * sequentially followed by the TransactionPartialSigners in parallel.\n */\nasync function signModifyingAndPartialTransactionSigners<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n>(\n    transactionMessage: TTransactionMessage,\n    modifyingSigners: readonly TransactionModifyingSigner[] = [],\n    partialSigners: readonly TransactionPartialSigner[] = [],\n    config?: TransactionModifyingSignerConfig,\n): Promise<TransactionFromTransactionMessage<TTransactionMessage>> {\n    type ReturnType = TransactionFromTransactionMessage<TTransactionMessage>;\n\n    // serialize the transaction\n    const transaction = compileTransaction(transactionMessage);\n\n    // Handle modifying signers sequentially.\n    const modifiedTransaction = await modifyingSigners.reduce(\n        async (transaction, modifyingSigner) => {\n            config?.abortSignal?.throwIfAborted();\n            const [tx] = await modifyingSigner.modifyAndSignTransactions([await transaction], config);\n            return Object.freeze(tx);\n        },\n        Promise.resolve(transaction) as Promise<Readonly<Transaction & TransactionWithLifetime>>,\n    );\n\n    // Handle partial signers in parallel.\n    config?.abortSignal?.throwIfAborted();\n    const signatureDictionaries = await Promise.all(\n        partialSigners.map(async partialSigner => {\n            const [signatures] = await partialSigner.signTransactions([modifiedTransaction], config);\n            return signatures;\n        }),\n    );\n\n    return Object.freeze({\n        ...modifiedTransaction,\n        signatures: Object.freeze(\n            signatureDictionaries.reduce((signatures, signatureDictionary) => {\n                return { ...signatures, ...signatureDictionary };\n            }, modifiedTransaction.signatures ?? {}),\n        ),\n    }) as ReturnType;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ADVANCE_NONCE_ACCOUNT_DISCRIMINATOR = 4;\n\nexport function getAdvanceNonceAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(ADVANCE_NONCE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type AdvanceNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNonceAccount extends string | AccountMeta<string> = string,\n  TAccountRecentBlockhashesSysvar extends\n    | string\n    | AccountMeta<string> = 'SysvarRecentB1ockHashes11111111111111111111',\n  TAccountNonceAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountNonceAccount extends string\n        ? WritableAccount<TAccountNonceAccount>\n        : TAccountNonceAccount,\n      TAccountRecentBlockhashesSysvar extends string\n        ? ReadonlyAccount<TAccountRecentBlockhashesSysvar>\n        : TAccountRecentBlockhashesSysvar,\n      TAccountNonceAuthority extends string\n        ? ReadonlySignerAccount<TAccountNonceAuthority> &\n            AccountSignerMeta<TAccountNonceAuthority>\n        : TAccountNonceAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AdvanceNonceAccountInstructionData = { discriminator: number };\n\nexport type AdvanceNonceAccountInstructionDataArgs = {};\n\nexport function getAdvanceNonceAccountInstructionDataEncoder(): FixedSizeEncoder<AdvanceNonceAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU32Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: ADVANCE_NONCE_ACCOUNT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getAdvanceNonceAccountInstructionDataDecoder(): FixedSizeDecoder<AdvanceNonceAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU32Decoder()]]);\n}\n\nexport function getAdvanceNonceAccountInstructionDataCodec(): FixedSizeCodec<\n  AdvanceNonceAccountInstructionDataArgs,\n  AdvanceNonceAccountInstructionData\n> {\n  return combineCodec(\n    getAdvanceNonceAccountInstructionDataEncoder(),\n    getAdvanceNonceAccountInstructionDataDecoder()\n  );\n}\n\nexport type AdvanceNonceAccountInput<\n  TAccountNonceAccount extends string = string,\n  TAccountRecentBlockhashesSysvar extends string = string,\n  TAccountNonceAuthority extends string = string,\n> = {\n  nonceAccount: Address<TAccountNonceAccount>;\n  recentBlockhashesSysvar?: Address<TAccountRecentBlockhashesSysvar>;\n  nonceAuthority: TransactionSigner<TAccountNonceAuthority>;\n};\n\nexport function getAdvanceNonceAccountInstruction<\n  TAccountNonceAccount extends string,\n  TAccountRecentBlockhashesSysvar extends string,\n  TAccountNonceAuthority extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AdvanceNonceAccountInput<\n    TAccountNonceAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountNonceAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): AdvanceNonceAccountInstruction<\n  TProgramAddress,\n  TAccountNonceAccount,\n  TAccountRecentBlockhashesSysvar,\n  TAccountNonceAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nonceAccount: { value: input.nonceAccount ?? null, isWritable: true },\n    recentBlockhashesSysvar: {\n      value: input.recentBlockhashesSysvar ?? null,\n      isWritable: false,\n    },\n    nonceAuthority: { value: input.nonceAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.recentBlockhashesSysvar.value) {\n    accounts.recentBlockhashesSysvar.value =\n      'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.nonceAccount),\n      getAccountMeta(accounts.recentBlockhashesSysvar),\n      getAccountMeta(accounts.nonceAuthority),\n    ],\n    programAddress,\n    data: getAdvanceNonceAccountInstructionDataEncoder().encode({}),\n  } as AdvanceNonceAccountInstruction<\n    TProgramAddress,\n    TAccountNonceAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountNonceAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedAdvanceNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    nonceAccount: TAccountMetas[0];\n    recentBlockhashesSysvar: TAccountMetas[1];\n    nonceAuthority: TAccountMetas[2];\n  };\n  data: AdvanceNonceAccountInstructionData;\n};\n\nexport function parseAdvanceNonceAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedAdvanceNonceAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nonceAccount: getNextAccount(),\n      recentBlockhashesSysvar: getNextAccount(),\n      nonceAuthority: getNextAccount(),\n    },\n    data: getAdvanceNonceAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","import { KeyPath, KEYPATH_WILDCARD, TraversalState } from './tree-traversal';\n\nexport function getBigIntUpcastVisitor(allowedNumericKeyPaths: readonly KeyPath[]) {\n    return function upcastNodeToBigIntIfNumber(value: unknown, { keyPath }: TraversalState) {\n        const isInteger = (typeof value === 'number' && Number.isInteger(value)) || typeof value === 'bigint';\n        if (!isInteger) return value;\n        if (keyPathIsAllowedToBeNumeric(keyPath, allowedNumericKeyPaths)) {\n            return Number(value);\n        } else {\n            return BigInt(value);\n        }\n    };\n}\n\nfunction keyPathIsAllowedToBeNumeric(keyPath: KeyPath, allowedNumericKeyPaths: readonly KeyPath[]) {\n    return allowedNumericKeyPaths.some(prohibitedKeyPath => {\n        if (prohibitedKeyPath.length !== keyPath.length) {\n            return false;\n        }\n        for (let ii = keyPath.length - 1; ii >= 0; ii--) {\n            const keyPathPart = keyPath[ii];\n            const prohibitedKeyPathPart = prohibitedKeyPath[ii];\n            if (\n                prohibitedKeyPathPart !== keyPathPart &&\n                (prohibitedKeyPathPart !== KEYPATH_WILDCARD || typeof keyPathPart !== 'number')\n            ) {\n                return false;\n            }\n        }\n        return true;\n    });\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from '@solana/text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/**\n * Returns an encoder for UTF-8 strings.\n *\n * This encoder serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding UTF-8 strings.\n *\n * @example\n * Encoding a UTF-8 string.\n * ```ts\n * const encoder = getUtf8Encoder();\n * const bytes = encoder.encode('hello'); // 0x68656c6c6f\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Encoder = (): VariableSizeEncoder<string> => {\n    let textEncoder: TextEncoder;\n    return createEncoder({\n        getSizeFromValue: value => (textEncoder ||= new TextEncoder()).encode(value).length,\n        write: (value: string, bytes, offset) => {\n            const bytesToAdd = (textEncoder ||= new TextEncoder()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for UTF-8 strings.\n *\n * This decoder deserializes UTF-8 encoded strings from a byte array.\n * It reads all available bytes starting from the given offset.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding UTF-8 strings.\n *\n * @example\n * Decoding a UTF-8 string.\n * ```ts\n * const decoder = getUtf8Decoder();\n * const value = decoder.decode(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f])); // \"hello\"\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Decoder = (): VariableSizeDecoder<string> => {\n    let textDecoder: TextDecoder;\n    return createDecoder({\n        read(bytes, offset) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding UTF-8 strings.\n *\n * This codec serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding UTF-8 strings.\n *\n * @example\n * Encoding and decoding a UTF-8 string.\n * ```ts\n * const codec = getUtf8Codec();\n * const bytes = codec.encode('hello'); // 0x68656c6c6f\n * const value = codec.decode(bytes);   // \"hello\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size UTF-8 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 5);\n * ```\n *\n * If you need a size-prefixed UTF-8 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getUtf8Encoder} and {@link getUtf8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getUtf8Encoder().encode('hello');\n * const value = getUtf8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getUtf8Encoder}\n * @see {@link getUtf8Decoder}\n */\nexport const getUtf8Codec = (): VariableSizeCodec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 16-bit unsigned integers (`u16`).\n *\n * This encoder serializes `u16` values using two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU16Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<number | bigint, 2>` for encoding `u16` values.\n *\n * @example\n * Encoding a `u16` value.\n * ```ts\n * const encoder = getU16Encoder();\n * const bytes = encoder.encode(42); // 0x2a00\n * ```\n *\n * @see {@link getU16Codec}\n */\nexport const getU16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'u16',\n        range: [0, Number('0xffff')],\n        set: (view, value, le) => view.setUint16(0, Number(value), le),\n        size: 2,\n    });\n\n/**\n * Returns a decoder for 16-bit unsigned integers (`u16`).\n *\n * This decoder deserializes `u16` values from two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU16Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<number, 2>` for decoding `u16` values.\n *\n * @example\n * Decoding a `u16` value.\n * ```ts\n * const decoder = getU16Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @see {@link getU16Codec}\n */\nexport const getU16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint16(0, le),\n        name: 'u16',\n        size: 2,\n    });\n\n/**\n * Returns a codec for encoding and decoding 16-bit unsigned integers (`u16`).\n *\n * This codec serializes `u16` values using two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeCodec<number | bigint, number, 2>` for encoding and decoding `u16` values.\n *\n * @example\n * Encoding and decoding a `u16` value.\n * ```ts\n * const codec = getU16Codec();\n * const bytes = codec.encode(42); // 0x2a00 (little-endian)\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Storing values in big-endian format.\n * ```ts\n * const codec = getU16Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^16 - 1`.\n * If you need a larger range, consider using {@link getU32Codec} or {@link getU64Codec}.\n * For signed integers, use {@link getI16Codec}.\n *\n * Separate {@link getU16Encoder} and {@link getU16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU16Encoder().encode(42);\n * const value = getU16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU16Encoder}\n * @see {@link getU16Decoder}\n */\nexport const getU16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getU16Encoder(config), getU16Decoder(config));\n","/**\n * To add a new error, follow the instructions at\n * https://github.com/anza-xyz/kit/tree/main/packages/errors/#adding-a-new-error\n *\n * @privateRemarks\n * WARNING:\n *   - Don't change or remove members of an error's context.\n */\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_CONSTANT,\n    SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND,\n    SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR,\n    SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SOLANA_ERROR__INVALID_NONCE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__MALFORMED_BIGINT_STRING,\n    SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR,\n    SOLANA_ERROR__MALFORMED_NUMBER_STRING,\n    SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD,\n    SOLANA_ERROR__RPC__INTEGER_OVERFLOW,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS,\n    SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER,\n    SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY,\n    SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING,\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n    SolanaErrorCode,\n} from './codes';\nimport { RpcSimulateTransactionResult } from './json-rpc-error';\n\ntype BasicInstructionErrorContext<T extends SolanaErrorCode> = Readonly<{ [P in T]: { index: number } }>;\n\ntype DefaultUnspecifiedErrorContextToUndefined<T> = {\n    [P in SolanaErrorCode]: P extends keyof T ? T[P] : undefined;\n};\n\ntype TypedArrayMutableProperties = 'copyWithin' | 'fill' | 'reverse' | 'set' | 'sort';\ninterface ReadonlyUint8Array extends Omit<Uint8Array, TypedArrayMutableProperties> {\n    readonly [n: number]: number;\n}\n\n/** A amount of bytes. */\ntype Bytes = number;\n\n/**\n * A map of every {@link SolanaError} code to the type of its `context` property.\n */\nexport type SolanaErrorContext = DefaultUnspecifiedErrorContextToUndefined<\n    BasicInstructionErrorContext<\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR\n    > & {\n        [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: {\n            putativeAddress: string;\n        };\n        [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: {\n            actual: number;\n            maxSeeds: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: {\n            actual: number;\n            index: number;\n            maxSeedLength: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: {\n            bump: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: {\n            currentBlockHeight: bigint;\n            lastValidBlockHeight: bigint;\n        };\n        [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: {\n            codecDescription: string;\n        };\n        [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: {\n            stringValues: string[];\n        };\n        [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: {\n            encodedBytes: ReadonlyUint8Array;\n            hexEncodedBytes: string;\n            hexSentinel: string;\n            sentinel: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: {\n            decoderFixedSize: number;\n            encoderFixedSize: number;\n        };\n        [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: {\n            decoderMaxSize: number | undefined;\n            encoderMaxSize: number | undefined;\n        };\n        [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: {\n            discriminator: bigint | number;\n            formattedValidDiscriminators: string;\n            validDiscriminators: number[];\n        };\n        [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: {\n            bytesLength: number;\n            codecDescription: string;\n        };\n        [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: {\n            codecDescription: string;\n            expectedSize: number;\n            hexZeroValue: string;\n            zeroValue: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: {\n            bytesLength: number;\n            codecDescription: string;\n            expected: number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: {\n            constant: ReadonlyUint8Array;\n            data: ReadonlyUint8Array;\n            hexConstant: string;\n            hexData: string;\n            offset: number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: {\n            value: bigint | boolean | number | string | null | undefined;\n            variants: readonly (bigint | boolean | number | string | null | undefined)[];\n        };\n        [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: {\n            formattedNumericalValues: string;\n            numericalValues: number[];\n            stringValues: string[];\n            variant: number | string | symbol;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: {\n            value: bigint | boolean | number | string | null | undefined;\n            variants: readonly (bigint | boolean | number | string | null | undefined)[];\n        };\n        [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: {\n            actual: bigint | number;\n            codecDescription: string;\n            expected: bigint | number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: {\n            alphabet: string;\n            base: number;\n            value: string;\n        };\n        [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: {\n            discriminator: bigint | number;\n            maxRange: number;\n            minRange: number;\n        };\n        [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: {\n            codecDescription: string;\n            max: bigint | number;\n            min: bigint | number;\n            value: bigint | number;\n        };\n        [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: {\n            bytesLength: number;\n            codecDescription: string;\n            offset: number;\n        };\n        [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: {\n            decodedBytes: ReadonlyUint8Array;\n            hexDecodedBytes: string;\n            hexSentinel: string;\n            sentinel: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: {\n            maxRange: number;\n            minRange: number;\n            variant: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: {\n            encodedData: string;\n            index: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: {\n            code: number;\n            index: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: {\n            errorName: string;\n            index: number;\n            instructionErrorContext?: unknown;\n        };\n        [SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN]: {\n            transactionPlanResult: unknown;\n        };\n        [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN]: {\n            numBytesRequired: number;\n            numFreeBytes: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: {\n            data?: ReadonlyUint8Array;\n            programAddress: string;\n        };\n        [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: {\n            accountAddresses?: string[];\n            programAddress: string;\n        };\n        [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: {\n            actualProgramAddress: string;\n            expectedProgramAddress: string;\n        };\n        [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__INVALID_NONCE]: {\n            actualNonceValue: string;\n            expectedNonceValue: string;\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: {\n            cacheKey: string;\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: {\n            channelName: string;\n            supportedChannelNames: string[];\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND]: {\n            kind: string;\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND]: {\n            kind: string;\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: {\n            unexpectedValue: unknown;\n        };\n        [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE]: {\n            currentBlockHeight: bigint;\n            rewardsCompleteBlockHeight: bigint;\n            slot: bigint;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: {\n            contextSlot: bigint;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: {\n            numSlotsBehind?: number;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: Omit<\n            RpcSimulateTransactionResult,\n            'err'\n        >;\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY]: {\n            slot: bigint;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: {\n            byteLength: number;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: {\n            value: string;\n        };\n        [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: {\n            error: unknown;\n            message: string;\n        };\n        [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: {\n            value: string;\n        };\n        [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: {\n            nonceAccountAddress: string;\n        };\n        [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: {\n            notificationName: string;\n        };\n        [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: {\n            errorEvent: Event;\n        };\n        [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: {\n            method: string;\n            params: unknown[];\n        };\n        [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: {\n            argumentLabel: string;\n            keyPath: readonly (number | string | symbol)[];\n            methodName: string;\n            optionalPathLabel: string;\n            path?: string;\n            value: bigint;\n        };\n        [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: {\n            headers: Headers;\n            message: string;\n            statusCode: number;\n        };\n        [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: {\n            headers: string[];\n        };\n        [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: {\n            key: CryptoKey;\n        };\n        [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: {\n            value: bigint;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: {\n            accountIndex: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: {\n            accountIndex: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: {\n            errorName: string;\n            transactionErrorContext?: unknown;\n        };\n        [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: {\n            expectedAddresses: string[];\n            unexpectedAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]: {\n            transactionSize: Bytes;\n            transactionSizeLimit: Bytes;\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: {\n            lookupTableAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: {\n            highestKnownIndex: number;\n            highestRequestedIndex: number;\n            lookupTableAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: {\n            unitsConsumed: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: {\n            programAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: {\n            programAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: {\n            numRequiredSignatures: number;\n            signaturesLength: number;\n            signerAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: {\n            actualVersion: number;\n        };\n    }\n>;\n\nexport function decodeEncodedContext(encodedContext: string): object {\n    const decodedUrlString = __NODEJS__ ? Buffer.from(encodedContext, 'base64').toString('utf8') : atob(encodedContext);\n    return Object.fromEntries(new URLSearchParams(decodedUrlString).entries());\n}\n\nfunction encodeValue(value: unknown): string {\n    if (Array.isArray(value)) {\n        const commaSeparatedValues = value.map(encodeValue).join('%2C%20' /* \", \" */);\n        return '%5B' /* \"[\" */ + commaSeparatedValues + /* \"]\" */ '%5D';\n    } else if (typeof value === 'bigint') {\n        return `${value}n`;\n    } else {\n        return encodeURIComponent(\n            String(\n                value != null && Object.getPrototypeOf(value) === null\n                    ? // Plain objects with no prototype don't have a `toString` method.\n                      // Convert them before stringifying them.\n                      { ...(value as object) }\n                    : value,\n            ),\n        );\n    }\n}\n\nfunction encodeObjectContextEntry([key, value]: [string, unknown]): `${typeof key}=${string}` {\n    return `${key}=${encodeValue(value)}`;\n}\n\nexport function encodeContextObject(context: object): string {\n    const searchParamsString = Object.entries(context).map(encodeObjectContextEntry).join('&');\n    return __NODEJS__ ? Buffer.from(searchParamsString, 'utf8').toString('base64') : btoa(searchParamsString);\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    createEncoder,\n    Decoder,\n    fixDecoderSize,\n    fixEncoderSize,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getConstantEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getUnionEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder } from '@solana/codecs-numbers';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\n\nimport { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\nimport { CompiledTransactionMessage, CompiledTransactionMessageWithLifetime } from '../compile/message';\nimport { getAddressTableLookupDecoder, getAddressTableLookupEncoder } from './address-table-lookup';\nimport { getMessageHeaderDecoder, getMessageHeaderEncoder } from './header';\nimport { getInstructionDecoder, getInstructionEncoder } from './instruction';\nimport { getTransactionVersionDecoder, getTransactionVersionEncoder } from './transaction-version';\n\nfunction getCompiledMessageLegacyEncoder(): VariableSizeEncoder<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n> {\n    return getStructEncoder(getPreludeStructEncoderTuple()) as VariableSizeEncoder<\n        CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n    >;\n}\n\nfunction getCompiledMessageVersionedEncoder(): VariableSizeEncoder<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n> {\n    return transformEncoder(\n        getStructEncoder([\n            ...getPreludeStructEncoderTuple(),\n            ['addressTableLookups', getAddressTableLookupArrayEncoder()],\n        ]) as VariableSizeEncoder<\n            CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n        >,\n        value => {\n            if (value.version === 'legacy') {\n                return value;\n            }\n            return {\n                ...value,\n                addressTableLookups: value.addressTableLookups ?? [],\n            };\n        },\n    );\n}\n\nfunction getPreludeStructEncoderTuple() {\n    const lifetimeTokenEncoder = getUnionEncoder(\n        [\n            // Use a 32-byte constant encoder for a missing lifetime token (index 0).\n            getConstantEncoder(new Uint8Array(32)),\n            // Use a 32-byte base58 encoder for a valid lifetime token (index 1).\n            fixEncoderSize(getBase58Encoder(), 32),\n        ],\n        value => (value === undefined ? 0 : 1),\n    );\n\n    return [\n        ['version', getTransactionVersionEncoder()],\n        ['header', getMessageHeaderEncoder()],\n        ['staticAccounts', getArrayEncoder(getAddressEncoder(), { size: getShortU16Encoder() })],\n        ['lifetimeToken', lifetimeTokenEncoder],\n        ['instructions', getArrayEncoder(getInstructionEncoder(), { size: getShortU16Encoder() })],\n    ] as const;\n}\n\nfunction getPreludeStructDecoderTuple() {\n    return [\n        ['version', getTransactionVersionDecoder() as Decoder<number>],\n        ['header', getMessageHeaderDecoder()],\n        ['staticAccounts', getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() })],\n        ['lifetimeToken', fixDecoderSize(getBase58Decoder(), 32)],\n        ['instructions', getArrayDecoder(getInstructionDecoder(), { size: getShortU16Decoder() })],\n        ['addressTableLookups', getAddressTableLookupArrayDecoder()],\n    ] as const;\n}\n\nfunction getAddressTableLookupArrayEncoder() {\n    return getArrayEncoder(getAddressTableLookupEncoder(), { size: getShortU16Encoder() });\n}\n\nfunction getAddressTableLookupArrayDecoder() {\n    return getArrayDecoder(getAddressTableLookupDecoder(), { size: getShortU16Decoder() });\n}\n\n/**\n * Returns an encoder that you can use to encode a {@link CompiledTransactionMessage} to a byte\n * array.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. The byte array produced by this encoder is the message part.\n */\nexport function getCompiledTransactionMessageEncoder(): VariableSizeEncoder<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n> {\n    return createEncoder({\n        getSizeFromValue: compiledMessage => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().getSizeFromValue(compiledMessage);\n            } else {\n                return getCompiledMessageVersionedEncoder().getSizeFromValue(compiledMessage);\n            }\n        },\n        write: (compiledMessage, bytes, offset) => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().write(compiledMessage, bytes, offset);\n            } else {\n                return getCompiledMessageVersionedEncoder().write(compiledMessage, bytes, offset);\n            }\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link CompiledTransactionMessage}.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. You can use this decoder to decode the message part.\n */\nexport function getCompiledTransactionMessageDecoder(): VariableSizeDecoder<\n    CompiledTransactionMessage & CompiledTransactionMessageWithLifetime\n> {\n    return transformDecoder(\n        getStructDecoder(getPreludeStructDecoderTuple()) as VariableSizeDecoder<\n            CompiledTransactionMessage &\n                CompiledTransactionMessageWithLifetime & {\n                    addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups>;\n                }\n        >,\n        ({ addressTableLookups, ...restOfMessage }) => {\n            if (restOfMessage.version === 'legacy' || !addressTableLookups?.length) {\n                return restOfMessage;\n            }\n            return { ...restOfMessage, addressTableLookups };\n        },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link CompiledTransactionMessage}\n *\n * @see {@link getCompiledTransactionMessageDecoder}\n * @see {@link getCompiledTransactionMessageEncoder}\n */\nexport function getCompiledTransactionMessageCodec(): VariableSizeCodec<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime),\n    CompiledTransactionMessage & CompiledTransactionMessageWithLifetime\n> {\n    return combineCodec(getCompiledTransactionMessageEncoder(), getCompiledTransactionMessageDecoder());\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport { fixBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    Offset,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n/**\n * Creates a fixed-size encoder from a given encoder.\n *\n * The resulting encoder ensures that encoded values always have the specified number of bytes.\n * If the original encoded value is larger than `fixedBytes`, it is truncated.\n * If it is smaller, it is padded with trailing zeroes.\n *\n * For more details, see {@link fixCodecSize}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param encoder - The encoder to wrap into a fixed-size encoder.\n * @param fixedBytes - The fixed number of bytes to write.\n * @returns A `FixedSizeEncoder` that ensures a consistent output size.\n *\n * @example\n * ```ts\n * const encoder = fixEncoderSize(getUtf8Encoder(), 4);\n * encoder.encode(\"Hello\"); // 0x48656c6c (truncated)\n * encoder.encode(\"Hi\");    // 0x48690000 (padded)\n * encoder.encode(\"Hiya\");  // 0x48697961 (same length)\n * ```\n *\n * @remarks\n * If you need a full codec with both encoding and decoding, use {@link fixCodecSize}.\n *\n * @see {@link fixCodecSize}\n * @see {@link fixDecoderSize}\n */\nexport function fixEncoderSize<TFrom, TSize extends number>(\n    encoder: Encoder<TFrom>,\n    fixedBytes: TSize,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value: TFrom, bytes: Uint8Array, offset: Offset) => {\n            // Here we exceptionally use the `encode` function instead of the `write`\n            // function as using the nested `write` function on a fixed-sized byte\n            // array may result in a out-of-bounds error on the nested encoder.\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray =\n                variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        },\n    });\n}\n\n/**\n * Creates a fixed-size decoder from a given decoder.\n *\n * The resulting decoder always reads exactly `fixedBytes` bytes from the input.\n * If the nested decoder is also fixed-size, the bytes are truncated or padded as needed.\n *\n * For more details, see {@link fixCodecSize}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param decoder - The decoder to wrap into a fixed-size decoder.\n * @param fixedBytes - The fixed number of bytes to read.\n * @returns A `FixedSizeDecoder` that ensures a consistent input size.\n *\n * @example\n * ```ts\n * const decoder = fixDecoderSize(getUtf8Decoder(), 4);\n * decoder.decode(new Uint8Array([72, 101, 108, 108, 111])); // \"Hell\" (truncated)\n * decoder.decode(new Uint8Array([72, 105, 0, 0]));          // \"Hi\" (zeroes ignored)\n * decoder.decode(new Uint8Array([72, 105, 121, 97]));       // \"Hiya\" (same length)\n * ```\n *\n * @remarks\n * If you need a full codec with both encoding and decoding, use {@link fixCodecSize}.\n *\n * @see {@link fixCodecSize}\n * @see {@link fixEncoderSize}\n */\nexport function fixDecoderSize<TTo, TSize extends number>(\n    decoder: Decoder<TTo>,\n    fixedBytes: TSize,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset) => {\n            assertByteArrayHasEnoughBytesForCodec('fixCodecSize', fixedBytes, bytes, offset);\n            // Slice the byte array to the fixed size if necessary.\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            // If the nested decoder is fixed-size, pad and truncate the byte array accordingly.\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            // Decode the value using the nested decoder.\n            const [value] = decoder.read(bytes, 0);\n            return [value, offset + fixedBytes];\n        },\n    });\n}\n\n/**\n * Creates a fixed-size codec from a given codec.\n *\n * The resulting codec ensures that both encoding and decoding operate on a fixed number of bytes.\n * When encoding:\n * - If the encoded value is larger than `fixedBytes`, it is truncated.\n * - If it is smaller, it is padded with trailing zeroes.\n * - If it is exactly `fixedBytes`, it remains unchanged.\n *\n * When decoding:\n * - Exactly `fixedBytes` bytes are read from the input.\n * - If the nested decoder has a smaller fixed size, bytes are truncated or padded as necessary.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param codec - The codec to wrap into a fixed-size codec.\n * @param fixedBytes - The fixed number of bytes to read/write.\n * @returns A `FixedSizeCodec` that ensures both encoding and decoding conform to a fixed size.\n *\n * @example\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 4);\n *\n * const bytes1 = codec.encode(\"Hello\"); // 0x48656c6c (truncated)\n * const value1 = codec.decode(bytes1);  // \"Hell\"\n *\n * const bytes2 = codec.encode(\"Hi\");    // 0x48690000 (padded)\n * const value2 = codec.decode(bytes2);  // \"Hi\"\n *\n * const bytes3 = codec.encode(\"Hiya\");  // 0x48697961 (same length)\n * const value3 = codec.decode(bytes3);  // \"Hiya\"\n * ```\n *\n * @remarks\n * If you only need to enforce a fixed size for encoding, use {@link fixEncoderSize}.\n * If you only need to enforce a fixed size for decoding, use {@link fixDecoderSize}.\n *\n * ```ts\n * const bytes = fixEncoderSize(getUtf8Encoder(), 4).encode(\"Hiya\");\n * const value = fixDecoderSize(getUtf8Decoder(), 4).decode(bytes);\n * ```\n *\n * @see {@link fixEncoderSize}\n * @see {@link fixDecoderSize}\n */\nexport function fixCodecSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: Codec<TFrom, TTo>,\n    fixedBytes: TSize,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU8Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedCreateAssociatedTokenIdempotentInstruction,\n  type ParsedCreateAssociatedTokenInstruction,\n  type ParsedRecoverNestedAssociatedTokenInstruction,\n} from '../instructions';\n\nexport const ASSOCIATED_TOKEN_PROGRAM_ADDRESS =\n  'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;\n\nexport enum AssociatedTokenInstruction {\n  CreateAssociatedToken,\n  CreateAssociatedTokenIdempotent,\n  RecoverNestedAssociatedToken,\n}\n\nexport function identifyAssociatedTokenInstruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): AssociatedTokenInstruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU8Encoder().encode(0), 0)) {\n    return AssociatedTokenInstruction.CreateAssociatedToken;\n  }\n  if (containsBytes(data, getU8Encoder().encode(1), 0)) {\n    return AssociatedTokenInstruction.CreateAssociatedTokenIdempotent;\n  }\n  if (containsBytes(data, getU8Encoder().encode(2), 0)) {\n    return AssociatedTokenInstruction.RecoverNestedAssociatedToken;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a associatedToken instruction.'\n  );\n}\n\nexport type ParsedAssociatedTokenInstruction<\n  TProgram extends string = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',\n> =\n  | ({\n      instructionType: AssociatedTokenInstruction.CreateAssociatedToken;\n    } & ParsedCreateAssociatedTokenInstruction<TProgram>)\n  | ({\n      instructionType: AssociatedTokenInstruction.CreateAssociatedTokenIdempotent;\n    } & ParsedCreateAssociatedTokenIdempotentInstruction<TProgram>)\n  | ({\n      instructionType: AssociatedTokenInstruction.RecoverNestedAssociatedToken;\n    } & ParsedRecoverNestedAssociatedTokenInstruction<TProgram>);\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit unsigned integers (`u32`).\n *\n * This encoder serializes `u32` values using four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU32Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<bigint | number, 4>` for encoding `u32` values.\n *\n * @example\n * Encoding a `u32` value.\n * ```ts\n * const encoder = getU32Encoder();\n * const bytes = encoder.encode(42); // 0x2a000000\n * ```\n *\n * @see {@link getU32Codec}\n */\nexport const getU32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'u32',\n        range: [0, Number('0xffffffff')],\n        set: (view, value, le) => view.setUint32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit unsigned integers (`u32`).\n *\n * This decoder deserializes `u32` values from four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU32Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `u32` values.\n *\n * @example\n * Decoding a `u32` value.\n * ```ts\n * const decoder = getU32Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @see {@link getU32Codec}\n */\nexport const getU32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint32(0, le),\n        name: 'u32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit unsigned integers (`u32`).\n *\n * This codec serializes `u32` values using four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeCodec<bigint | number, number, 4>` for encoding and decoding `u32` values.\n *\n * @example\n * Encoding and decoding a `u32` value.\n * ```ts\n * const codec = getU32Codec();\n * const bytes = codec.encode(42); // 0x2a000000 (little-endian)\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Storing values in big-endian format.\n * ```ts\n * const codec = getU32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x0000002a\n * ```\n *\n * @remarks\n * This codec only supports values between `0` and `2^32 - 1`.\n * If you need a larger range, consider using {@link getU64Codec} or {@link getU128Codec}.\n * For signed integers, use {@link getI32Codec}.\n *\n * Separate {@link getU32Encoder} and {@link getU32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU32Encoder().encode(42);\n * const value = getU32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU32Encoder}\n * @see {@link getU32Decoder}\n */\nexport const getU32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getU32Encoder(config), getU32Decoder(config));\n","import { getBigIntUpcastVisitor } from './response-transformer-bigint-upcast-internal';\nimport { getTreeWalkerResponseTransformer, KeyPath } from './tree-traversal';\n\n/**\n * Returns a transformer that upcasts all `Number` values to `BigInts` unless they match within the\n * provided {@link KeyPath | KeyPaths}. In other words, the provided {@link KeyPath | KeyPaths} will\n * remain as `Number` values, any other numeric value will be upcasted to a `BigInt`.\n *\n * Note that you can use {@link KEYPATH_WILDCARD} to match any key within a {@link KeyPath}.\n *\n * @example\n * ```ts\n * import { getBigIntUpcastResponseTransformer } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getBigIntUpcastResponseTransformer([\n *     ['index'],\n *     ['instructions', KEYPATH_WILDCARD, 'accounts', KEYPATH_WILDCARD],\n *     ['instructions', KEYPATH_WILDCARD, 'programIdIndex'],\n *     ['instructions', KEYPATH_WILDCARD, 'stackHeight'],\n * ]);\n * ```\n */\nexport function getBigIntUpcastResponseTransformer(allowedNumericKeyPaths: readonly KeyPath[]) {\n    return getTreeWalkerResponseTransformer([getBigIntUpcastVisitor(allowedNumericKeyPaths)], { keyPath: [] });\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nimport { DrainOuterGeneric, getMaxSize, maxCodecSizes } from './utils';\n\n/**\n * Infers the TypeScript type for values that can be encoded using a union codec.\n *\n * This type maps the provided variant encoders to their corresponding value types.\n *\n * @typeParam TVariants - An array of encoders, each corresponding to a union variant.\n */\ntype GetEncoderTypeFromVariants<TVariants extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>[number];\n\n/**\n * Infers the TypeScript type for values that can be decoded using a union codec.\n *\n * This type maps the provided variant decoders to their corresponding value types.\n *\n * @typeParam TVariants - An array of decoders, each corresponding to a union variant.\n */\ntype GetDecoderTypeFromVariants<TVariants extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Decoder<infer TFrom> ? TFrom : never;\n}>[number];\n\ntype UnionEncoder<TVariants extends readonly Encoder<unknown>[]> = TVariants extends readonly FixedSizeEncoder<any>[]\n    ? FixedSizeEncoder<GetEncoderTypeFromVariants<TVariants>>\n    : Encoder<GetEncoderTypeFromVariants<TVariants>>;\n\ntype UnionDecoder<TVariants extends readonly Decoder<unknown>[]> = TVariants extends readonly FixedSizeDecoder<any>[]\n    ? FixedSizeDecoder<GetDecoderTypeFromVariants<TVariants>>\n    : Decoder<GetDecoderTypeFromVariants<TVariants>>;\n\ntype UnionCodec<TVariants extends readonly Codec<unknown>[]> = TVariants extends readonly FixedSizeCodec<any>[]\n    ? FixedSizeCodec<\n          GetEncoderTypeFromVariants<TVariants>,\n          GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n      >\n    : Codec<\n          GetEncoderTypeFromVariants<TVariants>,\n          GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n      >;\n\n/**\n * Returns an encoder for union types.\n *\n * This encoder serializes values by selecting the correct variant encoder\n * based on the `getIndexFromValue` function.\n *\n * Unlike other codecs, this encoder does not store the variant index.\n * It is the user's responsibility to manage discriminators separately.\n *\n * For more details, see {@link getUnionCodec}.\n *\n * @typeParam TVariants - An array of encoders, each corresponding to a union variant.\n *\n * @param variants - The encoders for each variant of the union.\n * @param getIndexFromValue - A function that determines the variant index from the provided value.\n * @returns An `Encoder` for encoding union values.\n *\n * @example\n * Encoding a union of numbers and booleans.\n * ```ts\n * const encoder = getUnionEncoder(\n *   [getU16Encoder(), getBooleanEncoder()],\n *   value => (typeof value === 'number' ? 0 : 1)\n * );\n *\n * encoder.encode(42);\n * // 0x2a00\n * //    Encoded number (42) as `u16`\n *\n * encoder.encode(true);\n * // 0x01\n * //    Encoded boolean (`true`) as `u8`\n * ```\n *\n * @see {@link getUnionCodec}\n */\nexport function getUnionEncoder<const TVariants extends readonly Encoder<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n): UnionEncoder<TVariants> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const write: Encoder<TFrom>['write'] = (variant, bytes, offset) => {\n        const index = getIndexFromValue(variant);\n        assertValidVariantIndex(variants, index);\n        return variants[index].write(variant, bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createEncoder({ fixedSize, write }) as UnionEncoder<TVariants>;\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createEncoder({\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: variant => {\n            const index = getIndexFromValue(variant);\n            assertValidVariantIndex(variants, index);\n            return getEncodedSize(variant, variants[index]);\n        },\n        write,\n    }) as UnionEncoder<TVariants>;\n}\n\n/**\n * Returns a decoder for union types.\n *\n * This decoder deserializes values by selecting the correct variant decoder\n * based on the `getIndexFromBytes` function.\n *\n * Unlike other codecs, this decoder does not assume a stored discriminator.\n * It is the user's responsibility to manage discriminators separately.\n *\n * For more details, see {@link getUnionCodec}.\n *\n * @typeParam TVariants - An array of decoders, each corresponding to a union variant.\n *\n * @param variants - The decoders for each variant of the union.\n * @param getIndexFromBytes - A function that determines the variant index from the byte array.\n * @returns A `Decoder` for decoding union values.\n *\n * @example\n * Decoding a union of numbers and booleans.\n * ```ts\n * const decoder = getUnionDecoder(\n *   [getU16Decoder(), getBooleanDecoder()],\n *   (bytes, offset) => (bytes.length - offset > 1 ? 0 : 1)\n * );\n *\n * decoder.decode(new Uint8Array([0x2a, 0x00])); // 42\n * decoder.decode(new Uint8Array([0x01]));       // true\n * // Type is inferred as `number | boolean`\n * ```\n *\n * @see {@link getUnionCodec}\n */\nexport function getUnionDecoder<const TVariants extends readonly Decoder<any>[]>(\n    variants: TVariants,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): UnionDecoder<TVariants> {\n    type TTo = GetDecoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const read: Decoder<TTo>['read'] = (bytes, offset) => {\n        const index = getIndexFromBytes(bytes, offset);\n        assertValidVariantIndex(variants, index);\n        return variants[index].read(bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createDecoder({ fixedSize, read }) as UnionDecoder<TVariants>;\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createDecoder({ ...(maxSize !== null ? { maxSize } : {}), read }) as UnionDecoder<TVariants>;\n}\n\n/**\n * Returns a codec for encoding and decoding union types.\n *\n * This codec serializes and deserializes union values by selecting the correct variant\n * based on the provided index functions.\n *\n * Unlike the {@link getDiscriminatedUnionCodec}, this codec does not assume a stored\n * discriminator and must be used with an explicit mechanism for managing discriminators.\n *\n * @typeParam TVariants - An array of codecs, each corresponding to a union variant.\n *\n * @param variants - The codecs for each variant of the union.\n * @param getIndexFromValue - A function that determines the variant index from the provided value.\n * @param getIndexFromBytes - A function that determines the variant index from the byte array.\n * @returns A `Codec` for encoding and decoding union values.\n *\n * @example\n * Encoding and decoding a union of numbers and booleans.\n * ```ts\n * const codec = getUnionCodec(\n *   [getU16Codec(), getBooleanCodec()],\n *   value => (typeof value === 'number' ? 0 : 1),\n *   (bytes, offset) => (bytes.length - offset > 1 ? 0 : 1)\n * );\n *\n * const bytes1 = codec.encode(42); // 0x2a00\n * const value1: number | boolean = codec.decode(bytes1); // 42\n *\n * const bytes2 = codec.encode(true); // 0x01\n * const value2: number | boolean = codec.decode(bytes2); // true\n * ```\n *\n * @remarks\n * If you need a codec that includes a stored discriminator,\n * consider using {@link getDiscriminatedUnionCodec}.\n *\n * Separate {@link getUnionEncoder} and {@link getUnionDecoder} functions are also available.\n *\n * ```ts\n * const bytes = getUnionEncoder(variantEncoders, getIndexFromValue).encode(42);\n * const value = getUnionDecoder(variantDecoders, getIndexFromBytes).decode(bytes);\n * ```\n *\n * @see {@link getUnionEncoder}\n * @see {@link getUnionDecoder}\n * @see {@link getDiscriminatedUnionCodec}\n */\nexport function getUnionCodec<const TVariants extends readonly Codec<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): UnionCodec<TVariants> {\n    return combineCodec(\n        getUnionEncoder(variants, getIndexFromValue),\n        getUnionDecoder(variants as readonly Decoder<any>[], getIndexFromBytes) as Decoder<\n            GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n        >,\n    ) as UnionCodec<TVariants>;\n}\n\nfunction assertValidVariantIndex(variants: readonly unknown[], index: number) {\n    if (typeof variants[index] === 'undefined') {\n        throw new SolanaError(SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {\n            maxRange: variants.length - 1,\n            minRange: 0,\n            variant: index,\n        });\n    }\n}\n\nfunction getUnionFixedSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    if (variants.length === 0) return 0;\n    if (!isFixedSize(variants[0])) return null;\n    const variantSize = variants[0].fixedSize;\n    const sameSizedVariants = variants.every(variant => isFixedSize(variant) && variant.fixedSize === variantSize);\n    return sameSizedVariants ? variantSize : null;\n}\n\nfunction getUnionMaxSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    return maxCodecSizes(variants.map(variant => getMaxSize(variant)));\n}\n","import { getSolanaErrorFromJsonRpcError } from '@solana/errors';\nimport { RpcResponseTransformer } from '@solana/rpc-spec-types';\n\ntype JsonRpcResponse = { error: Parameters<typeof getSolanaErrorFromJsonRpcError>[0] } | { result: unknown };\n\n/**\n * Returns a transformer that throws a {@link SolanaError} with the appropriate RPC error code if\n * the body of the RPC response contains an error.\n *\n * @example\n * ```ts\n * import { getThrowSolanaErrorResponseTransformer } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getThrowSolanaErrorResponseTransformer();\n * ```\n */\nexport function getThrowSolanaErrorResponseTransformer(): RpcResponseTransformer {\n    return json => {\n        const jsonRpcResponse = json as JsonRpcResponse;\n        if ('error' in jsonRpcResponse) {\n            throw getSolanaErrorFromJsonRpcError(jsonRpcResponse.error);\n        }\n        return jsonRpcResponse;\n    };\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit unsigned integers (`u64`).\n *\n * This encoder serializes `u64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getU64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 8>` for encoding `u64` values.\n *\n * @example\n * Encoding a `u64` value.\n * ```ts\n * const encoder = getU64Encoder();\n * const bytes = encoder.encode(42); // 0x2a00000000000000\n * ```\n *\n * @see {@link getU64Codec}\n */\nexport const getU64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'u64',\n        range: [0n, BigInt('0xffffffffffffffff')],\n        set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit unsigned integers (`u64`).\n *\n * This decoder deserializes `u64` values from 8 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getU64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 8>` for decoding `u64` values.\n *\n * @example\n * Decoding a `u64` value.\n * ```ts\n * const decoder = getU64Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])); // 42n\n * ```\n *\n * @see {@link getU64Codec}\n */\nexport const getU64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigUint64(0, le),\n        name: 'u64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit unsigned integers (`u64`).\n *\n * This codec serializes `u64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 8>` for encoding and decoding `u64` values.\n *\n * @example\n * Encoding and decoding a `u64` value.\n * ```ts\n * const codec = getU64Codec();\n * const bytes = codec.encode(42); // 0x2a00000000000000\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getU64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x000000000000002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^64 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller unsigned integer, consider using {@link getU32Codec} or {@link getU16Codec}.\n * - If you need a larger unsigned integer, consider using {@link getU128Codec}.\n * - If you need signed integers, consider using {@link getI64Codec}.\n *\n * Separate {@link getU64Encoder} and {@link getU64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU64Encoder().encode(42);\n * const value = getU64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU64Encoder}\n * @see {@link getU64Decoder}\n */\nexport const getU64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getU64Encoder(config), getU64Decoder(config));\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU8Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedAmountToUiAmountInstruction,\n  type ParsedApproveCheckedInstruction,\n  type ParsedApproveInstruction,\n  type ParsedBurnCheckedInstruction,\n  type ParsedBurnInstruction,\n  type ParsedCloseAccountInstruction,\n  type ParsedFreezeAccountInstruction,\n  type ParsedGetAccountDataSizeInstruction,\n  type ParsedInitializeAccount2Instruction,\n  type ParsedInitializeAccount3Instruction,\n  type ParsedInitializeAccountInstruction,\n  type ParsedInitializeImmutableOwnerInstruction,\n  type ParsedInitializeMint2Instruction,\n  type ParsedInitializeMintInstruction,\n  type ParsedInitializeMultisig2Instruction,\n  type ParsedInitializeMultisigInstruction,\n  type ParsedMintToCheckedInstruction,\n  type ParsedMintToInstruction,\n  type ParsedRevokeInstruction,\n  type ParsedSetAuthorityInstruction,\n  type ParsedSyncNativeInstruction,\n  type ParsedThawAccountInstruction,\n  type ParsedTransferCheckedInstruction,\n  type ParsedTransferInstruction,\n  type ParsedUiAmountToAmountInstruction,\n} from '../instructions';\n\nexport const TOKEN_PROGRAM_ADDRESS =\n  'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n\nexport enum TokenAccount {\n  Mint,\n  Token,\n  Multisig,\n}\n\nexport function identifyTokenAccount(\n  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): TokenAccount {\n  const data = 'data' in account ? account.data : account;\n  if (data.length === 82) {\n    return TokenAccount.Mint;\n  }\n  if (data.length === 165) {\n    return TokenAccount.Token;\n  }\n  if (data.length === 355) {\n    return TokenAccount.Multisig;\n  }\n  throw new Error(\n    'The provided account could not be identified as a token account.'\n  );\n}\n\nexport enum TokenInstruction {\n  InitializeMint,\n  InitializeAccount,\n  InitializeMultisig,\n  Transfer,\n  Approve,\n  Revoke,\n  SetAuthority,\n  MintTo,\n  Burn,\n  CloseAccount,\n  FreezeAccount,\n  ThawAccount,\n  TransferChecked,\n  ApproveChecked,\n  MintToChecked,\n  BurnChecked,\n  InitializeAccount2,\n  SyncNative,\n  InitializeAccount3,\n  InitializeMultisig2,\n  InitializeMint2,\n  GetAccountDataSize,\n  InitializeImmutableOwner,\n  AmountToUiAmount,\n  UiAmountToAmount,\n}\n\nexport function identifyTokenInstruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): TokenInstruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU8Encoder().encode(0), 0)) {\n    return TokenInstruction.InitializeMint;\n  }\n  if (containsBytes(data, getU8Encoder().encode(1), 0)) {\n    return TokenInstruction.InitializeAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(2), 0)) {\n    return TokenInstruction.InitializeMultisig;\n  }\n  if (containsBytes(data, getU8Encoder().encode(3), 0)) {\n    return TokenInstruction.Transfer;\n  }\n  if (containsBytes(data, getU8Encoder().encode(4), 0)) {\n    return TokenInstruction.Approve;\n  }\n  if (containsBytes(data, getU8Encoder().encode(5), 0)) {\n    return TokenInstruction.Revoke;\n  }\n  if (containsBytes(data, getU8Encoder().encode(6), 0)) {\n    return TokenInstruction.SetAuthority;\n  }\n  if (containsBytes(data, getU8Encoder().encode(7), 0)) {\n    return TokenInstruction.MintTo;\n  }\n  if (containsBytes(data, getU8Encoder().encode(8), 0)) {\n    return TokenInstruction.Burn;\n  }\n  if (containsBytes(data, getU8Encoder().encode(9), 0)) {\n    return TokenInstruction.CloseAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(10), 0)) {\n    return TokenInstruction.FreezeAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(11), 0)) {\n    return TokenInstruction.ThawAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(12), 0)) {\n    return TokenInstruction.TransferChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(13), 0)) {\n    return TokenInstruction.ApproveChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(14), 0)) {\n    return TokenInstruction.MintToChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(15), 0)) {\n    return TokenInstruction.BurnChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(16), 0)) {\n    return TokenInstruction.InitializeAccount2;\n  }\n  if (containsBytes(data, getU8Encoder().encode(17), 0)) {\n    return TokenInstruction.SyncNative;\n  }\n  if (containsBytes(data, getU8Encoder().encode(18), 0)) {\n    return TokenInstruction.InitializeAccount3;\n  }\n  if (containsBytes(data, getU8Encoder().encode(19), 0)) {\n    return TokenInstruction.InitializeMultisig2;\n  }\n  if (containsBytes(data, getU8Encoder().encode(20), 0)) {\n    return TokenInstruction.InitializeMint2;\n  }\n  if (containsBytes(data, getU8Encoder().encode(21), 0)) {\n    return TokenInstruction.GetAccountDataSize;\n  }\n  if (containsBytes(data, getU8Encoder().encode(22), 0)) {\n    return TokenInstruction.InitializeImmutableOwner;\n  }\n  if (containsBytes(data, getU8Encoder().encode(23), 0)) {\n    return TokenInstruction.AmountToUiAmount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(24), 0)) {\n    return TokenInstruction.UiAmountToAmount;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a token instruction.'\n  );\n}\n\nexport type ParsedTokenInstruction<\n  TProgram extends string = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n> =\n  | ({\n      instructionType: TokenInstruction.InitializeMint;\n    } & ParsedInitializeMintInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.InitializeAccount;\n    } & ParsedInitializeAccountInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.InitializeMultisig;\n    } & ParsedInitializeMultisigInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.Transfer;\n    } & ParsedTransferInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.Approve;\n    } & ParsedApproveInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.Revoke;\n    } & ParsedRevokeInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.SetAuthority;\n    } & ParsedSetAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.MintTo;\n    } & ParsedMintToInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.Burn;\n    } & ParsedBurnInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.CloseAccount;\n    } & ParsedCloseAccountInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.FreezeAccount;\n    } & ParsedFreezeAccountInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.ThawAccount;\n    } & ParsedThawAccountInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.TransferChecked;\n    } & ParsedTransferCheckedInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.ApproveChecked;\n    } & ParsedApproveCheckedInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.MintToChecked;\n    } & ParsedMintToCheckedInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.BurnChecked;\n    } & ParsedBurnCheckedInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.InitializeAccount2;\n    } & ParsedInitializeAccount2Instruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.SyncNative;\n    } & ParsedSyncNativeInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.InitializeAccount3;\n    } & ParsedInitializeAccount3Instruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.InitializeMultisig2;\n    } & ParsedInitializeMultisig2Instruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.InitializeMint2;\n    } & ParsedInitializeMint2Instruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.GetAccountDataSize;\n    } & ParsedGetAccountDataSizeInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.InitializeImmutableOwner;\n    } & ParsedInitializeImmutableOwnerInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.AmountToUiAmount;\n    } & ParsedAmountToUiAmountInstruction<TProgram>)\n  | ({\n      instructionType: TokenInstruction.UiAmountToAmount;\n    } & ParsedUiAmountToAmountInstruction<TProgram>);\n","import { pipe } from '@solana/functional';\nimport { RpcRequest, RpcResponse, RpcResponseTransformer } from '@solana/rpc-spec-types';\n\nimport { AllowedNumericKeypaths } from './response-transformer-allowed-numeric-values';\nimport { getBigIntUpcastResponseTransformer } from './response-transformer-bigint-upcast';\nimport { getResultResponseTransformer } from './response-transformer-result';\nimport { getThrowSolanaErrorResponseTransformer } from './response-transformer-throw-solana-error';\n\nexport type ResponseTransformerConfig<TApi> = Readonly<{\n    /**\n     * An optional map from the name of an API method to an array of {@link KeyPath | KeyPaths}\n     * pointing to values in the response that should materialize in the application as `Number`\n     * instead of `BigInt`.\n     */\n    allowedNumericKeyPaths?: AllowedNumericKeypaths<TApi>;\n}>;\n\n/**\n * Returns the default response transformer for the Solana RPC API.\n *\n * Under the hood, this function composes multiple\n * {@link RpcResponseTransformer | RpcResponseTransformers} together such as the\n * {@link getThrowSolanaErrorResponseTransformer}, the {@link getResultResponseTransformer} and the\n * {@link getBigIntUpcastResponseTransformer}.\n *\n * @example\n * ```ts\n * import { getDefaultResponseTransformerForSolanaRpc } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getDefaultResponseTransformerForSolanaRpc({\n *     allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n * });\n * ```\n */\nexport function getDefaultResponseTransformerForSolanaRpc<TApi>(\n    config?: ResponseTransformerConfig<TApi>,\n): RpcResponseTransformer {\n    return (response: RpcResponse, request: RpcRequest): RpcResponse => {\n        const methodName = request.methodName as keyof TApi;\n        const keyPaths =\n            config?.allowedNumericKeyPaths && methodName ? config.allowedNumericKeyPaths[methodName] : undefined;\n        return pipe(\n            response,\n            r => getThrowSolanaErrorResponseTransformer()(r, request),\n            r => getResultResponseTransformer()(r, request),\n            r => getBigIntUpcastResponseTransformer(keyPaths ?? [])(r, request),\n        );\n    };\n}\n\n/**\n * Returns the default response transformer for the Solana RPC Subscriptions API.\n *\n * Under the hood, this function composes the {@link getBigIntUpcastResponseTransformer}.\n *\n * @example\n * ```ts\n * import { getDefaultResponseTransformerForSolanaRpcSubscriptions } from '@solana/rpc-transformers';\n *\n * const responseTransformer = getDefaultResponseTransformerForSolanaRpcSubscriptions({\n *     allowedNumericKeyPaths: getAllowedNumericKeypaths(),\n * });\n * ```\n */\nexport function getDefaultResponseTransformerForSolanaRpcSubscriptions<TApi>(\n    config?: ResponseTransformerConfig<TApi>,\n): RpcResponseTransformer {\n    return (response: RpcResponse, request: RpcRequest): RpcResponse => {\n        const methodName = request.methodName as keyof TApi;\n        const keyPaths =\n            config?.allowedNumericKeyPaths && methodName ? config.allowedNumericKeyPaths[methodName] : undefined;\n        return pipe(response, r => getBigIntUpcastResponseTransformer(keyPaths ?? [])(r, request));\n    };\n}\n","/* eslint-disable sort-keys-fix/sort-keys-fix */\n/**\n * To add a new error, follow the instructions at\n * https://github.com/anza-xyz/kit/tree/main/packages/errors#adding-a-new-error\n *\n * WARNING:\n *   - Don't change the meaning of an error message.\n */\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED,\n    SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY,\n    SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE,\n    SOLANA_ERROR__ADDRESSES__MALFORMED_PDA,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_CONSTANT,\n    SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE,\n    SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND,\n    SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR,\n    SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SOLANA_ERROR__INVALID_NONCE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE,\n    SOLANA_ERROR__MALFORMED_BIGINT_STRING,\n    SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR,\n    SOLANA_ERROR__MALFORMED_NUMBER_STRING,\n    SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD,\n    SOLANA_ERROR__RPC__INTEGER_OVERFLOW,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID,\n    SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS,\n    SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER,\n    SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS,\n    SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING,\n    SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT,\n    SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING,\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES,\n    SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE,\n    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED,\n    SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP,\n    SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE,\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT,\n    SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED,\n    SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED,\n    SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE,\n    SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE,\n    SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT,\n    SolanaErrorCode,\n} from './codes';\n\n/**\n * A map of every {@link SolanaError} code to the error message shown to developers in development\n * mode.\n */\nexport const SolanaErrorMessages: Readonly<{\n    // This type makes this data structure exhaustive with respect to `SolanaErrorCode`.\n    // TypeScript will fail to build this project if add an error code without a message.\n    [P in SolanaErrorCode]: string;\n}> = {\n    [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: 'Account not found at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]:\n        'Not all accounts were decoded. Encoded accounts found at addresses: $addresses.',\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: 'Expected decoded account at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: 'Failed to decode account data at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: 'Accounts not found at addresses: $addresses',\n    [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]:\n        'Unable to find a viable program address bump seed.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: '$putativeAddress is not a base58-encoded address.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]:\n        'Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: 'The `CryptoKey` must be an `Ed25519` public key.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]:\n        '$putativeOffCurveAddress is not a base58-encoded off-curve address.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: 'Invalid seeds; point must fall off the Ed25519 curve.',\n    [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]:\n        'Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].',\n    [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]:\n        'A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.',\n    [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]:\n        'The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.',\n    [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]:\n        'Expected program derived address bump to be in the range [0, 255], got: $bump.',\n    [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: 'Program address cannot end with PDA marker.',\n    [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]:\n        'The network has progressed past the last block for which this transaction could have been committed.',\n    [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]:\n        'Codec [$codecDescription] cannot decode empty byte arrays.',\n    [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]:\n        'Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.',\n    [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]:\n        'Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]:\n        'Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]:\n        'Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]:\n        'Encoder and decoder must either both be fixed-size or variable-size.',\n    [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]:\n        'Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.',\n    [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: 'Expected a fixed-size codec, got a variable-size one.',\n    [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]:\n        'Codec [$codecDescription] expected a positive byte length, got $bytesLength.',\n    [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: 'Expected a variable-size codec, got a fixed-size one.',\n    [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]:\n        'Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].',\n    [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]:\n        'Codec [$codecDescription] expected $expected bytes, got $bytesLength.',\n    [SOLANA_ERROR__CODECS__INVALID_CONSTANT]:\n        'Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].',\n    [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]:\n        'Invalid discriminated union variant. Expected one of [$variants], got $value.',\n    [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]:\n        'Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.',\n    [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]:\n        'Invalid literal union variant. Expected one of [$variants], got $value.',\n    [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]:\n        'Expected [$codecDescription] to have $expected items, got $actual.',\n    [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: 'Invalid value $value for base $base with alphabet $alphabet.',\n    [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]:\n        'Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.',\n    [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]:\n        'Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.',\n    [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]:\n        'Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.',\n    [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]:\n        'Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].',\n    [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]:\n        'Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.',\n    [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: 'No random values implementation could be found.',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: 'instruction requires an uninitialized account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]:\n        'instruction tries to borrow reference for an account which is already borrowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]:\n        'instruction left account with an outstanding borrowed reference',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]:\n        \"program other than the account's owner changed the size of the account data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: 'account data too small for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: 'instruction expected an executable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]:\n        'An account does not have enough lamports to be rent-exempt',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: 'Program arithmetic overflowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: 'Failed to serialize or deserialize account data: $encodedData',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]:\n        'Builtin programs must consume compute units',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: 'Cross-program invocation call depth too deep',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: 'Computational budget exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: 'custom program error: #$code',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: 'instruction contains duplicate accounts',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]:\n        'instruction modifications of multiply-passed account differ',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: 'executable accounts must be rent exempt',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: 'instruction changed executable accounts data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]:\n        'instruction changed the balance of an executable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: 'instruction changed executable bit of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]:\n        'instruction modified data of an account it does not own',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]:\n        'instruction spent from the balance of an account it does not own',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: 'generic instruction error',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: 'Provided owner is not allowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: 'Account is immutable',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: 'Incorrect authority provided',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: 'incorrect program id for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: 'insufficient funds for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: 'invalid account data for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: 'Invalid account owner',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: 'invalid program argument',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: 'program returned invalid error code',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: 'invalid instruction data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: 'Failed to reallocate account data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: 'Provided seeds do not result in a valid address',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]:\n        'Accounts data allocations exceeded the maximum allowed per transaction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: 'Max accounts exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: 'Max instruction trace length exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]:\n        'Length of the seed is too long for address generation',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: 'An account required by the instruction is missing',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: 'missing required signature for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]:\n        'instruction illegally modified the program id of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: 'insufficient account keys for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]:\n        'Cross-program invocation with unauthorized signer or writable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]:\n        'Failed to create program execution environment',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: 'Program failed to compile',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: 'Program failed to complete',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: 'instruction modified data of a read-only account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]:\n        'instruction changed the balance of a read-only account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]:\n        'Cross-program invocation reentrancy not allowed for this instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: 'instruction modified rent epoch of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]:\n        'sum of account balances before and after instruction do not match',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: 'instruction requires an initialized account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: '',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: 'Unsupported program id',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: 'Unsupported sysvar',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND]: 'Invalid instruction plan kind: $kind.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN]: 'The provided instruction plan is empty.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN]:\n        'The provided transaction plan failed to execute. See the `transactionPlanResult` attribute and the `cause` error for more details.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN]:\n        'The provided message has insufficient capacity to accommodate the next instruction(s) in this plan. Expected at least $numBytesRequired free byte(s), got $numFreeBytes byte(s).',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND]: 'Invalid transaction plan kind: $kind.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE]:\n        'No more instructions to pack; the message packer has completed the instruction plan.',\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: 'The instruction does not have any accounts.',\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: 'The instruction does not have any data.',\n    [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]:\n        'Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.',\n    [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]:\n        'Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__INVALID_NONCE]:\n        'The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]:\n        'Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It ' +\n        'should be impossible to hit this error; please file an issue at ' +\n        'https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]:\n        'Invariant violation: This data publisher does not publish to the channel named ' +\n        '`$channelName`. Supported channels include $supportedChannelNames.',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]:\n        'Invariant violation: WebSocket message iterator state is corrupt; iterated without first ' +\n        'resolving existing message promise. It should be impossible to hit this error; please ' +\n        'file an issue at https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]:\n        'Invariant violation: WebSocket message iterator is missing state storage. It should be ' +\n        'impossible to hit this error; please file an issue at https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]:\n        'Invariant violation: Switch statement non-exhaustive. Received unexpected value ' +\n        '`$unexpectedValue`. It should be impossible to hit this error; please file an issue at ' +\n        'https://sola.na/web3invariant',\n    [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: 'JSON-RPC error: Internal JSON-RPC error ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: 'JSON-RPC error: Invalid method parameter(s) ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]:\n        'JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]:\n        'JSON-RPC error: The method does not exist / is not available ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]:\n        'JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE]:\n        'Epoch rewards period still active at slot $slot',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE]:\n        'Failed to query long-term storage; please try again',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: 'Minimum context slot has not been reached',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: 'Node is unhealthy; behind by $numSlotsBehind slots',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: 'No snapshot',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: 'Transaction simulation failed',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY]:\n        \"Rewards cannot be found because slot $slot is not the epoch boundary. This may be due to gap in the queried node's local ledger or long-term storage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]:\n        'Transaction history is not available from this node',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: 'Transaction signature length mismatch',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]:\n        'Transaction signature verification failure',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: '$__serverMessage',\n    [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: 'Key pair bytes must be of length 64, got $byteLength.',\n    [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]:\n        'Expected private key bytes with length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]:\n        'Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.',\n    [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]:\n        'The provided private key does not match the provided public key.',\n    [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.',\n    [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: 'Lamports value must be in the range [0, 2e64-1]',\n    [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: '`$value` cannot be parsed as a `BigInt`',\n    [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: '$message',\n    [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: '`$value` cannot be parsed as a `Number`',\n    [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: 'No nonce account could be found at address `$nonceAccountAddress`',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]:\n        \"The notification name must end in 'Notifications' and the API must supply a \" +\n        \"subscription plan creator function for the notification '$notificationName'.\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]:\n        'WebSocket was closed before payload could be added to the send buffer',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: 'WebSocket connection closed',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: 'WebSocket failed to connect',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]:\n        'Failed to obtain a subscription id from the server',\n    [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: 'Could not find an API plan for RPC method: `$method`',\n    [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]:\n        'The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was ' +\n        '`$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds ' +\n        '`Number.MAX_SAFE_INTEGER`.',\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: 'HTTP error ($statusCode): $message',\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]:\n        'HTTP header(s) forbidden: $headers. Learn more at ' +\n        'https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.',\n    [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]:\n        'Multiple distinct signers were identified for address `$address`. Please ensure that ' +\n        'you are using the same signer instance for each address.',\n    [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]:\n        'The provided value does not implement the `KeyPairSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]:\n        'The provided value does not implement the `MessageModifyingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]:\n        'The provided value does not implement the `MessagePartialSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]:\n        'The provided value does not implement any of the `MessageSigner` interfaces',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]:\n        'The provided value does not implement the `TransactionModifyingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]:\n        'The provided value does not implement the `TransactionPartialSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]:\n        'The provided value does not implement the `TransactionSendingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]:\n        'The provided value does not implement any of the `TransactionSigner` interfaces',\n    [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]:\n        'More than one `TransactionSendingSigner` was identified.',\n    [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]:\n        'No `TransactionSendingSigner` was identified. Please provide a valid ' +\n        '`TransactionWithSingleSendingSigner` transaction.',\n    [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]:\n        'Wallet account signers do not support signing multiple messages/transactions in a single operation',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: 'Cannot export a non-extractable key.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: 'No digest implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]:\n        'Cryptographic operations are only allowed in secure browser contexts. Read more ' +\n        'here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]:\n        'This runtime does not support the generation of Ed25519 key pairs.\\n\\nInstall ' +\n        '@solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in ' +\n        'environments that do not support Ed25519.\\n\\nFor a list of runtimes that ' +\n        'currently support Ed25519 operations, visit ' +\n        'https://github.com/WICG/webcrypto-secure-curves/issues/20.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]:\n        'No signature verification implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: 'No key generation implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: 'No signing implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: 'No key export implementation could be found.',\n    [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]:\n        'Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]:\n        'Transaction processing left an account with an outstanding borrowed reference',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: 'Account in use',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: 'Account loaded twice',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]:\n        'Attempt to debit an account but found no record of a prior credit.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]:\n        \"Transaction loads an address table account that doesn't exist\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: 'This transaction has already been processed',\n    [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: 'Blockhash not found',\n    [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: 'Loader call chain is too deep',\n    [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]:\n        'Transactions are currently disabled due to cluster maintenance',\n    [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]:\n        'Transaction contains a duplicate instruction ($index) that is not allowed',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: 'Insufficient funds for fee',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]:\n        'Transaction results in an account ($accountIndex) with insufficient funds for rent',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: 'This account may not be used to pay transaction fees',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: 'Transaction contains an invalid account reference',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]:\n        'Transaction loads an address table account with invalid data',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]:\n        'Transaction address table lookup uses an invalid index',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]:\n        'Transaction loads an address table account with an invalid owner',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]:\n        'LoadedAccountsDataSizeLimit set for transaction must be greater than 0.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]:\n        'This program may not be used for executing instructions',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]:\n        'Transaction leaves an account with a lower balance than rent-exempt minimum',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]:\n        'Transaction loads a writable account that cannot be written',\n    [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]:\n        'Transaction exceeded max loaded accounts data size cap',\n    [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]:\n        'Transaction requires a fee but has no signature present',\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: 'Attempt to load a program that does not exist',\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]:\n        'Execution of the program referenced by account at index $accountIndex is temporarily restricted.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: 'ResanitizationNeeded',\n    [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: 'Transaction failed to sanitize accounts offsets correctly',\n    [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: 'Transaction did not pass signature verification',\n    [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: 'Transaction locked too many accounts',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]:\n        'Sum of account balances before and after transaction do not match',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: 'The transaction failed with the error `$errorName`',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: 'Transaction version is unsupported',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]:\n        'Transaction would exceed account data limit within the block',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]:\n        'Transaction would exceed total account data limit',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]:\n        'Transaction would exceed max account limit within the block',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]:\n        'Transaction would exceed max Block Cost Limit',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: 'Transaction would exceed max Vote Cost Limit',\n    [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]:\n        'Attempted to sign a transaction with an address that is not a signer for it',\n    [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: 'Transaction is missing an address at index: $index.',\n    [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]:\n        'Transaction has no expected signers therefore it cannot be encoded',\n    [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]:\n        'Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes',\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: 'Transaction does not have a blockhash lifetime',\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: 'Transaction is not a durable nonce transaction',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]:\n        'Contents of these address lookup tables unknown: $lookupTableAddresses',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]:\n        'Lookup of address at index $highestRequestedIndex failed for lookup table ' +\n        '`$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table ' +\n        'may have been extended since its contents were retrieved',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: 'No fee payer set in CompiledTransaction',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]:\n        'Could not find program address at index $index',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]:\n        'Failed to estimate the compute unit consumption for this transaction message. This is ' +\n        'likely because simulating the transaction failed. Inspect the `cause` property of this ' +\n        'error to learn more',\n    [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]:\n        'Transaction failed when it was simulated in order to estimate the compute unit consumption. ' +\n        'The compute unit estimate provided is for a transaction that failed when simulated and may not ' +\n        'be representative of the compute units this transaction would consume if successful. Inspect the ' +\n        '`cause` property of this error to learn more',\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: 'Transaction is missing a fee payer.',\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]:\n        \"Could not determine this transaction's signature. Make sure that the transaction has \" +\n        'been signed by its fee payer.',\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]:\n        'Transaction first instruction is not advance nonce account instruction.',\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]:\n        'Transaction with no instructions cannot be durable nonce transaction.',\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]:\n        'This transaction includes an address (`$programAddress`) which is both ' +\n        'invoked and set as the fee payer. Program addresses may not pay fees',\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]:\n        'This transaction includes an address (`$programAddress`) which is both invoked and ' +\n        'marked writable. Program addresses may not be writable',\n    [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]:\n        'The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.',\n    [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: 'Transaction is missing signatures for addresses: $addresses.',\n    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]:\n        'Transaction version must be in the range [0, 127]. `$actualVersion` given',\n};\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 8-bit unsigned integers (`u8`).\n *\n * This encoder serializes `u8` values using a single byte.\n *\n * For more details, see {@link getU8Codec}.\n *\n * @returns A `FixedSizeEncoder<number | bigint, 1>` for encoding `u8` values.\n *\n * @example\n * Encoding a `u8` value.\n * ```ts\n * const encoder = getU8Encoder();\n * const bytes = encoder.encode(42); // 0x2a\n * ```\n *\n * @see {@link getU8Codec}\n */\nexport const getU8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'u8',\n        range: [0, Number('0xff')],\n        set: (view, value) => view.setUint8(0, Number(value)),\n        size: 1,\n    });\n\n/**\n * Returns a decoder for 8-bit unsigned integers (`u8`).\n *\n * This decoder deserializes `u8` values from a single byte.\n *\n * For more details, see {@link getU8Codec}.\n *\n * @returns A `FixedSizeDecoder<number, 1>` for decoding `u8` values.\n *\n * @example\n * Decoding a `u8` value.\n * ```ts\n * const decoder = getU8Decoder();\n * const value = decoder.decode(new Uint8Array([0xff])); // 255\n * ```\n *\n * @see {@link getU8Codec}\n */\nexport const getU8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getUint8(0),\n        name: 'u8',\n        size: 1,\n    });\n\n/**\n * Returns a codec for encoding and decoding 8-bit unsigned integers (`u8`).\n *\n * This codec serializes `u8` values using a single byte.\n *\n * @returns A `FixedSizeCodec<number | bigint, number, 1>` for encoding and decoding `u8` values.\n *\n * @example\n * Encoding and decoding a `u8` value.\n * ```ts\n * const codec = getU8Codec();\n * const bytes = codec.encode(255); // 0xff\n * const value = codec.decode(bytes); // 255\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^8 - 1` (0 to 255).\n * If you need larger integers, consider using {@link getU16Codec}, {@link getU32Codec}, or {@link getU64Codec}.\n * For signed integers, use {@link getI8Codec}.\n *\n * Separate {@link getU8Encoder} and {@link getU8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU8Encoder().encode(42);\n * const value = getU8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU8Encoder}\n * @see {@link getU8Decoder}\n */\nexport const getU8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getU8Encoder(), getU8Decoder());\n","import { assertByteArrayOffsetIsNotOutOfRange } from './assertions';\nimport { Codec, createDecoder, createEncoder, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Configuration object for modifying the offset of an encoder, decoder, or codec.\n *\n * This type defines optional functions for adjusting the **pre-offset** (before encoding/decoding)\n * and the **post-offset** (after encoding/decoding). These functions allow precise control\n * over where data is written or read within a byte array.\n *\n * @property preOffset - A function that modifies the offset before encoding or decoding.\n * @property postOffset - A function that modifies the offset after encoding or decoding.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * };\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const config: OffsetConfig = {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * };\n * ```\n *\n * @example\n * Using both pre-offset and post-offset together.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n *     postOffset: ({ postOffset }) => postOffset + 4,\n * };\n * ```\n *\n * @see {@link offsetEncoder}\n * @see {@link offsetDecoder}\n * @see {@link offsetCodec}\n */\ntype OffsetConfig = {\n    postOffset?: PostOffsetFunction;\n    preOffset?: PreOffsetFunction;\n};\n\n/**\n * Scope provided to the `preOffset` and `postOffset` functions,\n * containing contextual information about the current encoding or decoding process.\n *\n * The pre-offset function modifies where encoding or decoding begins,\n * while the post-offset function modifies where the next operation continues.\n *\n * @property bytes - The entire byte array being encoded or decoded.\n * @property preOffset - The original offset before encoding or decoding starts.\n * @property wrapBytes - A helper function that wraps offsets around the byte array length.\n *\n * @example\n * Using `wrapBytes` to wrap a negative offset to the end of the byte array.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves to last 4 bytes\n * };\n * ```\n *\n * @example\n * Adjusting the offset dynamically based on the byte array size.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ bytes }) => bytes.length > 10 ? 4 : 2,\n * };\n * ```\n *\n * @see {@link PreOffsetFunction}\n * @see {@link PostOffsetFunction}\n */\ntype PreOffsetFunctionScope = {\n    /** The entire byte array. */\n    bytes: ReadonlyUint8Array | Uint8Array;\n    /** The original offset prior to encode or decode. */\n    preOffset: Offset;\n    /** Wraps the offset to the byte array length. */\n    wrapBytes: (offset: Offset) => Offset;\n};\n\n/**\n * A function that modifies the pre-offset before encoding or decoding.\n *\n * This function is used to adjust the starting position before writing\n * or reading data in a byte array.\n *\n * @param scope - The current encoding or decoding context.\n * @returns The new offset at which encoding or decoding should start.\n *\n * @example\n * Skipping the first 2 bytes before writing or reading.\n * ```ts\n * const preOffset: PreOffsetFunction = ({ preOffset }) => preOffset + 2;\n * ```\n *\n * @example\n * Wrapping the offset to ensure it stays within bounds.\n * ```ts\n * const preOffset: PreOffsetFunction = ({ wrapBytes, preOffset }) => wrapBytes(preOffset + 10);\n * ```\n *\n * @see {@link OffsetConfig}\n * @see {@link PreOffsetFunctionScope}\n */\ntype PreOffsetFunction = (scope: PreOffsetFunctionScope) => Offset;\n\n/**\n * A function that modifies the post-offset after encoding or decoding.\n *\n * This function adjusts where the next encoder or decoder should start\n * after the current operation has completed.\n *\n * @param scope - The current encoding or decoding context, including the modified pre-offset\n * and the original post-offset.\n * @returns The new offset at which the next operation should begin.\n *\n * @example\n * Moving the post-offset forward by 4 bytes.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ postOffset }) => postOffset + 4;\n * ```\n *\n * @example\n * Wrapping the post-offset within the byte array length.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ wrapBytes, postOffset }) => wrapBytes(postOffset);\n * ```\n *\n * @example\n * Ensuring a minimum spacing of 8 bytes between values.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ postOffset, newPreOffset }) =>\n *     Math.max(postOffset, newPreOffset + 8);\n * ```\n *\n * @see {@link OffsetConfig}\n * @see {@link PreOffsetFunctionScope}\n */\ntype PostOffsetFunction = (\n    scope: PreOffsetFunctionScope & {\n        /** The modified offset used to encode or decode. */\n        newPreOffset: Offset;\n        /** The original offset returned by the encoder or decoder. */\n        postOffset: Offset;\n    },\n) => Offset;\n\n/**\n * Moves the offset of a given encoder before and/or after encoding.\n *\n * This function allows an encoder to write its encoded value at a different offset\n * than the one originally provided. It supports both pre-offset adjustments\n * (before encoding) and post-offset adjustments (after encoding).\n *\n * The pre-offset function determines where encoding should start, while the\n * post-offset function adjusts where the next encoder should continue writing.\n *\n * For more details, see {@link offsetCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new encoder with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * encoder.write(42, bytes, 0); // Actually written at offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * const nextOffset = encoder.write(42, bytes, 0); // Next encoder starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to ensure an offset wraps around the byte array length.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes of the array\n * });\n * const bytes = new Uint8Array(10);\n * encoder.write(42, bytes, 0); // Writes at bytes.length - 4\n * ```\n *\n * @remarks\n * If you need both encoding and decoding offsets to be adjusted, use {@link offsetCodec}.\n *\n * @see {@link offsetCodec}\n * @see {@link offsetDecoder}\n */\nexport function offsetEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, config: OffsetConfig): TEncoder {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPostOffset, bytes.length);\n            return newPostOffset;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Moves the offset of a given decoder before and/or after decoding.\n *\n * This function allows a decoder to read its input from a different offset\n * than the one originally provided. It supports both pre-offset adjustments\n * (before decoding) and post-offset adjustments (after decoding).\n *\n * The pre-offset function determines where decoding should start, while the\n * post-offset function adjusts where the next decoder should continue reading.\n *\n * For more details, see {@link offsetCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new decoder with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array([0, 0, 42, 0]); // Value starts at offset 2\n * decoder.read(bytes, 0); // Actually reads from offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array([42, 0, 0, 0]);\n * const [value, nextOffset] = decoder.read(bytes, 0); // Next decoder starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to read from the last 4 bytes of an array.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes of the array\n * });\n * const bytes = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 42]); // Value stored at the last 4 bytes\n * decoder.read(bytes, 0); // Reads from bytes.length - 4\n * ```\n *\n * @remarks\n * If you need both encoding and decoding offsets to be adjusted, use {@link offsetCodec}.\n *\n * @see {@link offsetCodec}\n * @see {@link offsetEncoder}\n */\nexport function offsetDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, config: OffsetConfig): TDecoder {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPostOffset, bytes.length);\n            return [value, newPostOffset];\n        },\n    }) as TDecoder;\n}\n\n/**\n * Moves the offset of a given codec before and/or after encoding and decoding.\n *\n * This function allows a codec to encode and decode values at custom offsets\n * within a byte array. It modifies both the **pre-offset** (where encoding/decoding starts)\n * and the **post-offset** (where the next operation should continue).\n *\n * This is particularly useful when working with structured binary formats\n * that require skipping reserved bytes, inserting padding, or aligning fields at\n * specific locations.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new codec with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes when encoding and decoding.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0); // Actually written at offset 2\n * codec.read(bytes, 0);      // Actually read from offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes when encoding and decoding.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0);\n * // Next encoding starts at offset 6 instead of 4\n * codec.read(bytes, 0);\n * // Next decoding starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to loop around negative offsets.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0); // Writes at bytes.length - 4\n * codec.read(bytes, 0); // Reads from bytes.length - 4\n * ```\n *\n * @remarks\n * If you only need to adjust offsets for encoding, use {@link offsetEncoder}.\n * If you only need to adjust offsets for decoding, use {@link offsetDecoder}.\n *\n * ```ts\n * const bytes = new Uint8Array(10);\n * offsetEncoder(getU32Encoder(), { preOffset: ({ preOffset }) => preOffset + 2 }).write(42, bytes, 0);\n * const [value] = offsetDecoder(getU32Decoder(), { preOffset: ({ preOffset }) => preOffset + 2 }).read(bytes, 0);\n * ```\n *\n * @see {@link offsetEncoder}\n * @see {@link offsetDecoder}\n */\nexport function offsetCodec<TCodec extends AnyCodec>(codec: TCodec, config: OffsetConfig): TCodec {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config)) as TCodec;\n}\n\n/** A modulo function that handles negative dividends and zero divisors. */\nfunction modulo(dividend: number, divisor: number) {\n    if (divisor === 0) return 0;\n    return ((dividend % divisor) + divisor) % divisor;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ALLOCATE_DISCRIMINATOR = 8;\n\nexport function getAllocateDiscriminatorBytes() {\n  return getU32Encoder().encode(ALLOCATE_DISCRIMINATOR);\n}\n\nexport type AllocateInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNewAccount extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountNewAccount extends string\n        ? WritableSignerAccount<TAccountNewAccount> &\n            AccountSignerMeta<TAccountNewAccount>\n        : TAccountNewAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AllocateInstructionData = { discriminator: number; space: bigint };\n\nexport type AllocateInstructionDataArgs = { space: number | bigint };\n\nexport function getAllocateInstructionDataEncoder(): FixedSizeEncoder<AllocateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['space', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: ALLOCATE_DISCRIMINATOR })\n  );\n}\n\nexport function getAllocateInstructionDataDecoder(): FixedSizeDecoder<AllocateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['space', getU64Decoder()],\n  ]);\n}\n\nexport function getAllocateInstructionDataCodec(): FixedSizeCodec<\n  AllocateInstructionDataArgs,\n  AllocateInstructionData\n> {\n  return combineCodec(\n    getAllocateInstructionDataEncoder(),\n    getAllocateInstructionDataDecoder()\n  );\n}\n\nexport type AllocateInput<TAccountNewAccount extends string = string> = {\n  newAccount: TransactionSigner<TAccountNewAccount>;\n  space: AllocateInstructionDataArgs['space'];\n};\n\nexport function getAllocateInstruction<\n  TAccountNewAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AllocateInput<TAccountNewAccount>,\n  config?: { programAddress?: TProgramAddress }\n): AllocateInstruction<TProgramAddress, TAccountNewAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    newAccount: { value: input.newAccount ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.newAccount)],\n    programAddress,\n    data: getAllocateInstructionDataEncoder().encode(\n      args as AllocateInstructionDataArgs\n    ),\n  } as AllocateInstruction<TProgramAddress, TAccountNewAccount>;\n\n  return instruction;\n}\n\nexport type ParsedAllocateInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    newAccount: TAccountMetas[0];\n  };\n  data: AllocateInstructionData;\n};\n\nexport function parseAllocateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedAllocateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      newAccount: getNextAccount(),\n    },\n    data: getAllocateInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","import { KeyPath, KEYPATH_WILDCARD } from './tree-traversal';\n\nexport type AllowedNumericKeypaths<TApi> = Partial<Record<keyof TApi, readonly KeyPath[]>>;\n\n// Numeric values nested in `jsonParsed` accounts\nexport const jsonParsedTokenAccountsConfigs = [\n    // parsed Token/Token22 token account\n    ['data', 'parsed', 'info', 'tokenAmount', 'decimals'],\n    ['data', 'parsed', 'info', 'tokenAmount', 'uiAmount'],\n    ['data', 'parsed', 'info', 'rentExemptReserve', 'decimals'],\n    ['data', 'parsed', 'info', 'rentExemptReserve', 'uiAmount'],\n    ['data', 'parsed', 'info', 'delegatedAmount', 'decimals'],\n    ['data', 'parsed', 'info', 'delegatedAmount', 'uiAmount'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'olderTransferFee', 'transferFeeBasisPoints'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'newerTransferFee', 'transferFeeBasisPoints'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'preUpdateAverageRate'],\n    ['data', 'parsed', 'info', 'extensions', KEYPATH_WILDCARD, 'state', 'currentRate'],\n];\nexport const jsonParsedAccountsConfigs = [\n    ...jsonParsedTokenAccountsConfigs,\n    // parsed AddressTableLookup account\n    ['data', 'parsed', 'info', 'lastExtendedSlotStartIndex'],\n    // parsed Config account\n    ['data', 'parsed', 'info', 'slashPenalty'],\n    ['data', 'parsed', 'info', 'warmupCooldownRate'],\n    // parsed Token/Token22 mint account\n    ['data', 'parsed', 'info', 'decimals'],\n    // parsed Token/Token22 multisig account\n    ['data', 'parsed', 'info', 'numRequiredSigners'],\n    ['data', 'parsed', 'info', 'numValidSigners'],\n    // parsed Stake account\n    ['data', 'parsed', 'info', 'stake', 'delegation', 'warmupCooldownRate'],\n    // parsed Sysvar rent account\n    ['data', 'parsed', 'info', 'exemptionThreshold'],\n    ['data', 'parsed', 'info', 'burnPercent'],\n    // parsed Vote account\n    ['data', 'parsed', 'info', 'commission'],\n    ['data', 'parsed', 'info', 'votes', KEYPATH_WILDCARD, 'confirmationCount'],\n];\nexport const innerInstructionsConfigs = [\n    ['index'],\n    ['instructions', KEYPATH_WILDCARD, 'accounts', KEYPATH_WILDCARD],\n    ['instructions', KEYPATH_WILDCARD, 'programIdIndex'],\n    ['instructions', KEYPATH_WILDCARD, 'stackHeight'],\n];\nexport const messageConfig = [\n    ['addressTableLookups', KEYPATH_WILDCARD, 'writableIndexes', KEYPATH_WILDCARD],\n    ['addressTableLookups', KEYPATH_WILDCARD, 'readonlyIndexes', KEYPATH_WILDCARD],\n    ['header', 'numReadonlySignedAccounts'],\n    ['header', 'numReadonlyUnsignedAccounts'],\n    ['header', 'numRequiredSignatures'],\n    ['instructions', KEYPATH_WILDCARD, 'accounts', KEYPATH_WILDCARD],\n    ['instructions', KEYPATH_WILDCARD, 'programIdIndex'],\n    ['instructions', KEYPATH_WILDCARD, 'stackHeight'],\n] as const;\n","import { assertKeyExporterIsAvailable } from '@solana/assertions';\nimport { SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY, SolanaError } from '@solana/errors';\n\nimport { Address, getAddressDecoder, getAddressEncoder } from './address';\n\n/**\n * Given a public {@link CryptoKey}, this method will return its associated {@link Address}.\n *\n * @example\n * ```ts\n * import { getAddressFromPublicKey } from '@solana/addresses';\n *\n * const address = await getAddressFromPublicKey(publicKey);\n * ```\n */\nexport async function getAddressFromPublicKey(publicKey: CryptoKey): Promise<Address> {\n    assertKeyExporterIsAvailable();\n    if (publicKey.type !== 'public' || publicKey.algorithm.name !== 'Ed25519') {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY);\n    }\n    const publicKeyBytes = await crypto.subtle.exportKey('raw', publicKey);\n    return getAddressDecoder().decode(new Uint8Array(publicKeyBytes));\n}\n\n/**\n * Given an {@link Address}, return a {@link CryptoKey} that can be used to verify signatures.\n *\n * @example\n * ```ts\n * import { getAddressFromPublicKey } from '@solana/addresses';\n *\n * const publicKey = await getPublicKeyFromAddress(address);\n * ```\n */\nexport async function getPublicKeyFromAddress(address: Address) {\n    const addressBytes = getAddressEncoder().encode(address);\n    return await crypto.subtle.importKey('raw', addressBytes, { name: 'Ed25519' }, true /* extractable */, ['verify']);\n}\n","import { TextEncoder } from '@solana/text-encoding-impl';\n\nimport { SignatureDictionary } from './types';\n\n/**\n * Defines a message that needs signing and its current set of signatures if any.\n *\n * This interface allows {@link MessageModifyingSigner | MessageModifyingSigners}\n * to decide on whether or not they should modify the provided message depending\n * on whether or not signatures already exist for such message.\n *\n * It also helps create a more consistent API by providing a structure analogous\n * to transactions which also keep track of their {@link SignatureDictionary}.\n *\n * @example\n * ```ts\n * import { createSignableMessage } from '@solana/signers';\n *\n * const message = createSignableMessage(new Uint8Array([1, 2, 3]));\n * message.content; // The content of the message as bytes.\n * message.signatures; // The current set of signatures for this message.\n * ```\n *\n * @see {@link createSignableMessage}\n */\nexport type SignableMessage = Readonly<{\n    content: Uint8Array;\n    signatures: SignatureDictionary;\n}>;\n\n/**\n * Creates a {@link SignableMessage} from a `Uint8Array` or a UTF-8 string.\n *\n * It optionally accepts a signature dictionary if the message already contains signatures.\n *\n * @example\n * ```ts\n * const message = createSignableMessage(new Uint8Array([1, 2, 3]));\n * const messageFromText = createSignableMessage('Hello world!');\n * const messageWithSignatures = createSignableMessage('Hello world!', {\n *     [address('1234..5678')]: new Uint8Array([1, 2, 3]) as SignatureBytes,\n * });\n * ```\n */\nexport function createSignableMessage(\n    content: Uint8Array | string,\n    signatures: SignatureDictionary = {},\n): SignableMessage {\n    return Object.freeze({\n        content: typeof content === 'string' ? new TextEncoder().encode(content) : content,\n        signatures: Object.freeze({ ...signatures }),\n    });\n}\n","import { SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Updates the size of a given encoder.\n *\n * This function modifies the size of an encoder using a provided transformation function.\n * For fixed-size encoders, it updates the `fixedSize` property, and for variable-size\n * encoders, it adjusts the size calculation based on the encoded value.\n *\n * If the new size is negative, an error will be thrown.\n *\n * For more details, see {@link resizeCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The original fixed size of the encoded value.\n * @typeParam TNewSize - The new fixed size after resizing.\n *\n * @param encoder - The encoder whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new encoder with the updated size.\n *\n * @example\n * Increasing the size of a `u16` encoder by 2 bytes.\n * ```ts\n * const encoder = resizeEncoder(getU16Encoder(), size => size + 2);\n * encoder.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * ```\n *\n * @example\n * Shrinking a `u32` encoder to only use 2 bytes.\n * ```ts\n * const encoder = resizeEncoder(getU32Encoder(), () => 2);\n * encoder.fixedSize; // 2\n * ```\n *\n * @see {@link resizeCodec}\n * @see {@link resizeDecoder}\n */\nexport function resizeEncoder<TFrom, TSize extends number, TNewSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeEncoder<TFrom, TNewSize>;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeEncoder',\n            });\n        }\n        return createEncoder({ ...encoder, fixedSize }) as TEncoder;\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: value => {\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: 'resizeEncoder',\n                });\n            }\n            return newSize;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Updates the size of a given decoder.\n *\n * This function modifies the size of a decoder using a provided transformation function.\n * For fixed-size decoders, it updates the `fixedSize` property to reflect the new size.\n * Variable-size decoders remain unchanged, as their size is determined dynamically.\n *\n * If the new size is negative, an error will be thrown.\n *\n * For more details, see {@link resizeCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The original fixed size of the decoded value.\n * @typeParam TNewSize - The new fixed size after resizing.\n *\n * @param decoder - The decoder whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new decoder with the updated size.\n *\n * @example\n * Expanding a `u16` decoder to read 4 bytes instead of 2.\n * ```ts\n * const decoder = resizeDecoder(getU16Decoder(), size => size + 2);\n * decoder.fixedSize; // 4\n * ```\n *\n * @example\n * Shrinking a `u32` decoder to only read 2 bytes.\n * ```ts\n * const decoder = resizeDecoder(getU32Decoder(), () => 2);\n * decoder.fixedSize; // 2\n * ```\n *\n * @see {@link resizeCodec}\n * @see {@link resizeEncoder}\n */\nexport function resizeDecoder<TFrom, TSize extends number, TNewSize extends number>(\n    decoder: FixedSizeDecoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeDecoder<TFrom, TNewSize>;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeDecoder',\n            });\n        }\n        return createDecoder({ ...decoder, fixedSize }) as TDecoder;\n    }\n    return decoder;\n}\n\n/**\n * Updates the size of a given codec.\n *\n * This function modifies the size of both the codec using a provided\n * transformation function. It is useful for adjusting the allocated byte size for\n * encoding and decoding without altering the underlying data structure.\n *\n * If the new size is negative, an error will be thrown.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The original fixed size of the encoded/decoded value (for fixed-size codecs).\n * @typeParam TNewSize - The new fixed size after resizing (for fixed-size codecs).\n *\n * @param codec - The codec whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new codec with the updated size.\n *\n * @example\n * Expanding a `u16` codec from 2 to 4 bytes.\n * ```ts\n * const codec = resizeCodec(getU16Codec(), size => size + 2);\n * const bytes = codec.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * const value = codec.decode(bytes);  // 0xffff (reads original two bytes)\n * ```\n *\n * @example\n * Shrinking a `u32` codec to only use 2 bytes.\n * ```ts\n * const codec = resizeCodec(getU32Codec(), () => 2);\n * codec.fixedSize; // 2\n * ```\n *\n * @remarks\n * If you only need to resize an encoder, use {@link resizeEncoder}.\n * If you only need to resize a decoder, use {@link resizeDecoder}.\n *\n * ```ts\n * const bytes = resizeEncoder(getU32Encoder(), (size) => size + 2).encode(0xffff);\n * const value = resizeDecoder(getU32Decoder(), (size) => size + 2).decode(bytes);\n * ```\n *\n * @see {@link resizeEncoder}\n * @see {@link resizeDecoder}\n */\nexport function resizeCodec<TFrom, TTo extends TFrom, TSize extends number, TNewSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeCodec<TFrom, TTo, TNewSize>;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize)) as TCodec;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n} from '@solana/codecs-core';\nimport { getU8Decoder, getU8Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, SolanaError } from '@solana/errors';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { DrainOuterGeneric } from './utils';\n\n/**\n * Represents a discriminated union using a specific discriminator property.\n *\n * A discriminated union is a TypeScript-friendly way to represent Rust-like enums.\n * Each variant in the union is distinguished by a shared discriminator property.\n *\n * @typeParam TDiscriminatorProperty - The name of the discriminator property.\n * @typeParam TDiscriminatorValue - The type of the discriminator value.\n *\n * @example\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant\n * ```\n */\nexport type DiscriminatedUnion<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorValue extends string = string,\n> = {\n    [P in TDiscriminatorProperty]: TDiscriminatorValue;\n};\n\n/**\n * Extracts a variant from a discriminated union based on its discriminator value.\n *\n * @typeParam TUnion - The discriminated union type.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n * @typeParam TDiscriminatorValue - The specific variant to extract.\n *\n * @example\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' }\n *   | { __kind: 'Write'; fields: [string] }\n *   | { __kind: 'Move'; x: number; y: number };\n *\n * type ClickEvent = GetDiscriminatedUnionVariant<Message, '__kind', 'Move'>;\n * // -> { __kind: 'Move'; x: number; y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariant<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Extract<TUnion, DiscriminatedUnion<TDiscriminatorProperty, TDiscriminatorValue>>;\n\n/**\n * Extracts a variant from a discriminated union without its discriminator property.\n *\n * @typeParam TUnion - The discriminated union type.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n * @typeParam TDiscriminatorValue - The specific variant to extract.\n *\n * @example\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' }\n *   | { __kind: 'Write'; fields: [string] }\n *   | { __kind: 'Move'; x: number; y: number };\n *\n * type MoveContent = GetDiscriminatedUnionVariantContent<Message, '__kind', 'Move'>;\n * // -> { x: number; y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariantContent<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Omit<GetDiscriminatedUnionVariant<TUnion, TDiscriminatorProperty, TDiscriminatorValue>, TDiscriminatorProperty>;\n\n/**\n * Defines the configuration for discriminated union codecs.\n *\n * This configuration controls how the discriminator is stored and named.\n *\n * @typeParam TDiscriminatorProperty - The property name of the discriminator.\n * @typeParam TDiscriminatorSize - The codec used for the discriminator prefix.\n */\nexport type DiscriminatedUnionCodecConfig<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorSize = NumberCodec | NumberDecoder | NumberEncoder,\n> = {\n    /**\n     * The property name of the discriminator.\n     * @defaultValue `__kind`\n     */\n    discriminator?: TDiscriminatorProperty;\n    /**\n     * The codec used to encode/decode the discriminator prefix.\n     * @defaultValue `u8` prefix\n     */\n    size?: TDiscriminatorSize;\n};\n\ntype DiscriminatorValue = bigint | boolean | number | string | null | undefined;\ntype Variants<T> = readonly (readonly [DiscriminatorValue, T])[];\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\ntype GetEncoderTypeFromVariants<\n    TVariants extends Variants<Encoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Encoder<infer TFrom>\n        ? TFrom extends object\n            ? TFrom\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\ntype GetDecoderTypeFromVariants<\n    TVariants extends Variants<Decoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Decoder<infer TTo>\n        ? TTo extends object\n            ? TTo\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\ntype UnionEncoder<TVariants extends Variants<Encoder<unknown>>, TDiscriminatorProperty extends string> =\n    TVariants extends Variants<FixedSizeEncoder<any>>\n        ? FixedSizeEncoder<GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>>\n        : Encoder<GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>>;\n\ntype UnionDecoder<TVariants extends Variants<Decoder<unknown>>, TDiscriminatorProperty extends string> =\n    TVariants extends Variants<FixedSizeDecoder<any>>\n        ? FixedSizeDecoder<GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty>>\n        : Decoder<GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty>>;\n\ntype UnionCodec<TVariants extends Variants<Codec<unknown, unknown>>, TDiscriminatorProperty extends string> =\n    TVariants extends Variants<FixedSizeCodec<any, any>>\n        ? FixedSizeCodec<\n              GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>,\n              GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                  GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n          >\n        : Codec<\n              GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>,\n              GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                  GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n          >;\n\n/**\n * Returns an encoder for discriminated unions.\n *\n * This encoder serializes objects that follow the discriminated union pattern\n * by prefixing them with a numerical discriminator that represents their variant.\n *\n * Unlike {@link getUnionEncoder}, this encoder automatically extracts and processes\n * the discriminator property (default: `__kind`) from each variant.\n *\n * For more details, see {@link getDiscriminatedUnionCodec}.\n *\n * @typeParam TVariants - The variants of the discriminated union.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n *\n * @param variants - The variant encoders as `[discriminator, encoder]` pairs.\n * @param config - Configuration options for encoding.\n * @returns An `Encoder` for encoding discriminated union objects.\n *\n * @example\n * Encoding a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant.\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant.\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant.\n *\n * const messageEncoder = getDiscriminatedUnionEncoder([\n *   ['Quit', getUnitEncoder()],\n *   ['Write', getStructEncoder([['fields', getTupleEncoder([addCodecSizePrefix(getUtf8Encoder(), getU32Encoder())])]])],\n *   ['Move', getStructEncoder([['x', getI32Encoder()], ['y', getI32Encoder()]])]\n * ]);\n *\n * messageEncoder.encode({ __kind: 'Move', x: 5, y: 6 });\n * // 0x020500000006000000\n * //   | |        Field y (6)\n * //   |  Field x (5)\n * //    1-byte discriminator (Index 2  the \"Move\" variant)\n * ```\n *\n * @see {@link getDiscriminatedUnionCodec}\n */\nexport function getDiscriminatedUnionEncoder<\n    const TVariants extends Variants<Encoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberEncoder> = {},\n): UnionEncoder<TVariants, TDiscriminatorProperty> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>;\n    const discriminatorProperty = (config.discriminator ?? '__kind') as TDiscriminatorProperty;\n    const prefix = config.size ?? getU8Encoder();\n    return getUnionEncoder(\n        variants.map(([, variant], index) =>\n            transformEncoder(getTupleEncoder([prefix, variant]), (value: TFrom): [number, TFrom] => [index, value]),\n        ),\n        value => getVariantDiscriminator(variants, value[discriminatorProperty]),\n    ) as UnionEncoder<TVariants, TDiscriminatorProperty>;\n}\n\n/**\n * Returns a decoder for discriminated unions.\n *\n * This decoder deserializes objects that follow the discriminated union pattern\n * by **reading a numerical discriminator** and mapping it to the corresponding variant.\n *\n * Unlike {@link getUnionDecoder}, this decoder automatically inserts the discriminator\n * property (default: `__kind`) into the decoded object.\n *\n * For more details, see {@link getDiscriminatedUnionCodec}.\n *\n * @typeParam TVariants - The variants of the discriminated union.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n *\n * @param variants - The variant decoders as `[discriminator, decoder]` pairs.\n * @param config - Configuration options for decoding.\n * @returns A `Decoder` for decoding discriminated union objects.\n *\n * @example\n * Decoding a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant.\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant.\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant.\n *\n * const messageDecoder = getDiscriminatedUnionDecoder([\n *   ['Quit', getUnitDecoder()],\n *   ['Write', getStructDecoder([['fields', getTupleDecoder([addCodecSizePrefix(getUtf8Decoder(), getU32Decoder())])]])],\n *   ['Move', getStructDecoder([['x', getI32Decoder()], ['y', getI32Decoder()]])]\n * ]);\n *\n * messageDecoder.decode(new Uint8Array([0x02,0x05,0x00,0x00,0x00,0x06,0x00,0x00,0x00]));\n * // { __kind: 'Move', x: 5, y: 6 }\n * ```\n *\n * @see {@link getDiscriminatedUnionCodec}\n */\nexport function getDiscriminatedUnionDecoder<\n    const TVariants extends Variants<Decoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberDecoder> = {},\n): UnionDecoder<TVariants, TDiscriminatorProperty> {\n    const discriminatorProperty = config.discriminator ?? '__kind';\n    const prefix = config.size ?? getU8Decoder();\n    return getUnionDecoder(\n        variants.map(([discriminator, variant]) =>\n            transformDecoder(getTupleDecoder([prefix, variant]), ([, value]) => ({\n                [discriminatorProperty]: discriminator,\n                ...value,\n            })),\n        ),\n        (bytes, offset) => Number(prefix.read(bytes, offset)[0]),\n    ) as UnionDecoder<TVariants, TDiscriminatorProperty>;\n}\n\n/**\n * Returns a codec for encoding and decoding {@link DiscriminatedUnion}.\n *\n * A {@link DiscriminatedUnion} is a TypeScript representation of Rust-like enums, where\n * each variant is distinguished by a discriminator field (default: `__kind`).\n *\n * This codec inserts a numerical prefix to represent the variant index.\n *\n * @typeParam TVariants - The variants of the discriminated union.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n *\n * @param variants - The variant codecs as `[discriminator, codec]` pairs.\n * @param config - Configuration options for encoding/decoding.\n * @returns A `Codec` for encoding and decoding discriminated union objects.\n *\n * @example\n * Encoding and decoding a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant.\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant.\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant.\n *\n * const messageCodec = getDiscriminatedUnionCodec([\n *   ['Quit', getUnitCodec()],\n *   ['Write', getStructCodec([['fields', getTupleCodec([addCodecSizePrefix(getUtf8Codec(), getU32Codec())])]])],\n *   ['Move', getStructCodec([['x', getI32Codec()], ['y', getI32Codec()]])]\n * ]);\n *\n * messageCodec.encode({ __kind: 'Move', x: 5, y: 6 });\n * // 0x020500000006000000\n * //   | |        Field y (6)\n * //   |  Field x (5)\n * //    1-byte discriminator (Index 2  the \"Move\" variant)\n *\n * const value = messageCodec.decode(bytes);\n * // { __kind: 'Move', x: 5, y: 6 }\n * ```\n *\n * @example\n * Using a `u32` discriminator instead of `u8`.\n * ```ts\n * const codec = getDiscriminatedUnionCodec([...], { size: getU32Codec() });\n *\n * codec.encode({ __kind: 'Quit' });\n * // 0x00000000\n * //   ------ 4-byte discriminator (Index 0)\n *\n * codec.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00]));\n * // { __kind: 'Quit' }\n * ```\n *\n * @example\n * Customizing the discriminator property.\n * ```ts\n * const codec = getDiscriminatedUnionCodec([...], { discriminator: 'message' });\n *\n * codec.encode({ message: 'Quit' }); // 0x00\n * codec.decode(new Uint8Array([0x00])); // { message: 'Quit' }\n * ```\n *\n * @remarks\n * Separate `getDiscriminatedUnionEncoder` and `getDiscriminatedUnionDecoder` functions are available.\n *\n * ```ts\n * const bytes = getDiscriminatedUnionEncoder(variantEncoders).encode({ __kind: 'Quit' });\n * const message = getDiscriminatedUnionDecoder(variantDecoders).decode(bytes);\n * ```\n *\n * @see {@link getDiscriminatedUnionEncoder}\n * @see {@link getDiscriminatedUnionDecoder}\n */\nexport function getDiscriminatedUnionCodec<\n    const TVariants extends Variants<Codec<any, any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberCodec> = {},\n): UnionCodec<TVariants, TDiscriminatorProperty> {\n    return combineCodec(\n        getDiscriminatedUnionEncoder(variants, config) as Encoder<\n            GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n        >,\n        getDiscriminatedUnionDecoder(variants, config) as Decoder<\n            GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n        >,\n    ) as UnionCodec<TVariants, TDiscriminatorProperty>;\n}\n\nfunction getVariantDiscriminator<const TVariants extends Variants<Decoder<any> | Encoder<any>>>(\n    variants: TVariants,\n    discriminatorValue: DiscriminatorValue,\n) {\n    const discriminator = variants.findIndex(([key]) => discriminatorValue === key);\n    if (discriminator < 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, {\n            value: discriminatorValue,\n            variants: variants.map(([key]) => key),\n        });\n    }\n    return discriminator;\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SolanaError,\n} from '@solana/errors';\nimport {\n    AccountLookupMeta,\n    AccountMeta,\n    AccountRole,\n    Instruction,\n    isSignerRole,\n    isWritableRole,\n    mergeRoles,\n    ReadonlyAccount,\n    ReadonlyAccountLookup,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableAccountLookup,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nexport const enum AddressMapEntryType {\n    FEE_PAYER,\n    LOOKUP_TABLE,\n    STATIC,\n}\n\ntype AddressMap = {\n    [address: string]: FeePayerAccountEntry | LookupTableAccountEntry | StaticAccountEntry;\n};\ntype FeePayerAccountEntry = Omit<WritableSignerAccount, 'address'> & {\n    [TYPE]: AddressMapEntryType.FEE_PAYER;\n};\ntype LookupTableAccountEntry = Omit<ReadonlyAccountLookup | WritableAccountLookup, 'address'> & {\n    [TYPE]: AddressMapEntryType.LOOKUP_TABLE;\n};\nexport type OrderedAccounts = Brand<(AccountLookupMeta | AccountMeta)[], 'OrderedAccounts'>;\ntype StaticAccountEntry = Omit<\n    ReadonlyAccount | ReadonlySignerAccount | WritableAccount | WritableSignerAccount,\n    'address'\n> & { [TYPE]: AddressMapEntryType.STATIC };\n\nfunction upsert(\n    addressMap: AddressMap,\n    address: Address,\n    update: (\n        entry: FeePayerAccountEntry | LookupTableAccountEntry | Record<never, never> | StaticAccountEntry,\n    ) => AddressMap[Address],\n) {\n    addressMap[address] = update(addressMap[address] ?? { role: AccountRole.READONLY });\n}\n\nconst TYPE = Symbol('AddressMapTypeProperty');\nexport const ADDRESS_MAP_TYPE_PROPERTY: typeof TYPE = TYPE;\n\nexport function getAddressMapFromInstructions(feePayer: Address, instructions: readonly Instruction[]): AddressMap {\n    const addressMap: AddressMap = {\n        [feePayer]: { [TYPE]: AddressMapEntryType.FEE_PAYER, role: AccountRole.WRITABLE_SIGNER },\n    };\n    const addressesOfInvokedPrograms = new Set<Address>();\n    for (const instruction of instructions) {\n        upsert(addressMap, instruction.programAddress, entry => {\n            addressesOfInvokedPrograms.add(instruction.programAddress);\n            if (TYPE in entry) {\n                if (isWritableRole(entry.role)) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES, {\n                                programAddress: instruction.programAddress,\n                            });\n                        default:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, {\n                                programAddress: instruction.programAddress,\n                            });\n                    }\n                }\n                if (entry[TYPE] === AddressMapEntryType.STATIC) {\n                    return entry;\n                }\n            }\n            return { [TYPE]: AddressMapEntryType.STATIC, role: AccountRole.READONLY };\n        });\n        let addressComparator: ReturnType<typeof getAddressComparator>;\n        if (!instruction.accounts) {\n            continue;\n        }\n        for (const account of instruction.accounts) {\n            upsert(addressMap, account.address, entry => {\n                const {\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    address: _,\n                    ...accountMeta\n                } = account;\n                if (TYPE in entry) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            // The fee payer already has the highest rank -- it is by definition\n                            // writable-signer. Return it, no matter how `account` is configured\n                            return entry;\n                        case AddressMapEntryType.LOOKUP_TABLE: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if ('lookupTableAddress' in accountMeta) {\n                                const shouldReplaceEntry =\n                                    // Consider using the new LOOKUP_TABLE if its address is different...\n                                    entry.lookupTableAddress !== accountMeta.lookupTableAddress &&\n                                    // ...and sorts before the existing one.\n                                    (addressComparator ||= getAddressComparator())(\n                                        accountMeta.lookupTableAddress,\n                                        entry.lookupTableAddress,\n                                    ) < 0;\n                                if (shouldReplaceEntry) {\n                                    return {\n                                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                        ...accountMeta,\n                                        role: nextRole,\n                                    } as LookupTableAccountEntry;\n                                }\n                            } else if (isSignerRole(accountMeta.role)) {\n                                // Upgrade this LOOKUP_TABLE entry to a static entry if it must sign.\n                                return {\n                                    [TYPE]: AddressMapEntryType.STATIC,\n                                    role: nextRole,\n                                } as StaticAccountEntry;\n                            }\n                            if (entry.role !== nextRole) {\n                                return {\n                                    ...entry,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                return entry;\n                            }\n                        }\n                        case AddressMapEntryType.STATIC: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if (\n                                // Check to see if this address represents a program that is invoked\n                                // in this transaction.\n                                addressesOfInvokedPrograms.has(account.address)\n                            ) {\n                                if (isWritableRole(accountMeta.role)) {\n                                    throw new SolanaError(\n                                        SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n                                        {\n                                            programAddress: account.address,\n                                        },\n                                    );\n                                }\n                                if (entry.role !== nextRole) {\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            } else if (\n                                'lookupTableAddress' in accountMeta &&\n                                // Static accounts can be 'upgraded' to lookup table accounts as\n                                // long as they are not require to sign the transaction.\n                                !isSignerRole(entry.role)\n                            ) {\n                                return {\n                                    ...accountMeta,\n                                    [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                if (entry.role !== nextRole) {\n                                    // The account's role ranks higher than the current entry's.\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            }\n                        }\n                    }\n                }\n                if ('lookupTableAddress' in accountMeta) {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                    };\n                } else {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.STATIC,\n                    };\n                }\n            });\n        }\n    }\n    return addressMap;\n}\n\nexport function getOrderedAccountsFromAddressMap(addressMap: AddressMap): OrderedAccounts {\n    let addressComparator: ReturnType<typeof getAddressComparator>;\n    const orderedAccounts: (AccountLookupMeta | AccountMeta)[] = Object.entries(addressMap)\n        .sort(([leftAddress, leftEntry], [rightAddress, rightEntry]) => {\n            // STEP 1: Rapid precedence check. Fee payer, then static addresses, then lookups.\n            if (leftEntry[TYPE] !== rightEntry[TYPE]) {\n                if (leftEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return 1;\n                } else if (leftEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return 1;\n                }\n            }\n            // STEP 2: Sort by signer-writability.\n            const leftIsSigner = isSignerRole(leftEntry.role);\n            if (leftIsSigner !== isSignerRole(rightEntry.role)) {\n                return leftIsSigner ? -1 : 1;\n            }\n            const leftIsWritable = isWritableRole(leftEntry.role);\n            if (leftIsWritable !== isWritableRole(rightEntry.role)) {\n                return leftIsWritable ? -1 : 1;\n            }\n            // STEP 3: Sort by address.\n            addressComparator ||= getAddressComparator();\n            if (\n                leftEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                rightEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                leftEntry.lookupTableAddress !== rightEntry.lookupTableAddress\n            ) {\n                return addressComparator(leftEntry.lookupTableAddress, rightEntry.lookupTableAddress);\n            } else {\n                return addressComparator(leftAddress, rightAddress);\n            }\n        })\n        .map(([address, addressMeta]) => ({\n            address: address as Address<typeof address>,\n            ...addressMeta,\n        }));\n    return orderedAccounts as unknown as OrderedAccounts;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ALLOCATE_WITH_SEED_DISCRIMINATOR = 9;\n\nexport function getAllocateWithSeedDiscriminatorBytes() {\n  return getU32Encoder().encode(ALLOCATE_WITH_SEED_DISCRIMINATOR);\n}\n\nexport type AllocateWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNewAccount extends string | AccountMeta<string> = string,\n  TAccountBaseAccount extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountNewAccount extends string\n        ? WritableAccount<TAccountNewAccount>\n        : TAccountNewAccount,\n      TAccountBaseAccount extends string\n        ? ReadonlySignerAccount<TAccountBaseAccount> &\n            AccountSignerMeta<TAccountBaseAccount>\n        : TAccountBaseAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AllocateWithSeedInstructionData = {\n  discriminator: number;\n  base: Address;\n  seed: string;\n  space: bigint;\n  programAddress: Address;\n};\n\nexport type AllocateWithSeedInstructionDataArgs = {\n  base: Address;\n  seed: string;\n  space: number | bigint;\n  programAddress: Address;\n};\n\nexport function getAllocateWithSeedInstructionDataEncoder(): Encoder<AllocateWithSeedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['base', getAddressEncoder()],\n      ['seed', addEncoderSizePrefix(getUtf8Encoder(), getU64Encoder())],\n      ['space', getU64Encoder()],\n      ['programAddress', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: ALLOCATE_WITH_SEED_DISCRIMINATOR })\n  );\n}\n\nexport function getAllocateWithSeedInstructionDataDecoder(): Decoder<AllocateWithSeedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['base', getAddressDecoder()],\n    ['seed', addDecoderSizePrefix(getUtf8Decoder(), getU64Decoder())],\n    ['space', getU64Decoder()],\n    ['programAddress', getAddressDecoder()],\n  ]);\n}\n\nexport function getAllocateWithSeedInstructionDataCodec(): Codec<\n  AllocateWithSeedInstructionDataArgs,\n  AllocateWithSeedInstructionData\n> {\n  return combineCodec(\n    getAllocateWithSeedInstructionDataEncoder(),\n    getAllocateWithSeedInstructionDataDecoder()\n  );\n}\n\nexport type AllocateWithSeedInput<\n  TAccountNewAccount extends string = string,\n  TAccountBaseAccount extends string = string,\n> = {\n  newAccount: Address<TAccountNewAccount>;\n  baseAccount: TransactionSigner<TAccountBaseAccount>;\n  base: AllocateWithSeedInstructionDataArgs['base'];\n  seed: AllocateWithSeedInstructionDataArgs['seed'];\n  space: AllocateWithSeedInstructionDataArgs['space'];\n  programAddress: AllocateWithSeedInstructionDataArgs['programAddress'];\n};\n\nexport function getAllocateWithSeedInstruction<\n  TAccountNewAccount extends string,\n  TAccountBaseAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AllocateWithSeedInput<TAccountNewAccount, TAccountBaseAccount>,\n  config?: { programAddress?: TProgramAddress }\n): AllocateWithSeedInstruction<\n  TProgramAddress,\n  TAccountNewAccount,\n  TAccountBaseAccount\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    newAccount: { value: input.newAccount ?? null, isWritable: true },\n    baseAccount: { value: input.baseAccount ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.newAccount),\n      getAccountMeta(accounts.baseAccount),\n    ],\n    programAddress,\n    data: getAllocateWithSeedInstructionDataEncoder().encode(\n      args as AllocateWithSeedInstructionDataArgs\n    ),\n  } as AllocateWithSeedInstruction<\n    TProgramAddress,\n    TAccountNewAccount,\n    TAccountBaseAccount\n  >;\n\n  return instruction;\n}\n\nexport type ParsedAllocateWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    newAccount: TAccountMetas[0];\n    baseAccount: TAccountMetas[1];\n  };\n  data: AllocateWithSeedInstructionData;\n};\n\nexport function parseAllocateWithSeedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedAllocateWithSeedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      newAccount: getNextAccount(),\n      baseAccount: getNextAccount(),\n    },\n    data: getAllocateWithSeedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * Defines the \"lookup object\" of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * ```\n */\nexport type EnumLookupObject = { [key: string]: number | string };\n\n/**\n * Returns the allowed input for an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionInput = GetEnumFrom<Direction>; // \"Left\" | \"Right\" | 0 | 1\n * ```\n */\nexport type GetEnumFrom<TEnum extends EnumLookupObject> = TEnum[keyof TEnum] | keyof TEnum;\n\n/**\n * Returns all the available variants of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionOutput = GetEnumTo<Direction>; // 0 | 1\n * ```\n */\nexport type GetEnumTo<TEnum extends EnumLookupObject> = TEnum[keyof TEnum];\n\nexport function getEnumStats(constructor: EnumLookupObject) {\n    const numericalValues = [...new Set(Object.values(constructor).filter(v => typeof v === 'number'))].sort();\n    const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length)) as Record<\n        string,\n        number | string\n    >;\n    const enumKeys = Object.keys(enumRecord);\n    const enumValues = Object.values(enumRecord);\n    const stringValues: string[] = [\n        ...new Set([...enumKeys, ...enumValues.filter((v): v is string => typeof v === 'string')]),\n    ];\n\n    return { enumKeys, enumRecord, enumValues, numericalValues, stringValues };\n}\n\nexport function getEnumIndexFromVariant({\n    enumKeys,\n    enumValues,\n    variant,\n}: {\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    variant: number | string | symbol;\n}): number {\n    const valueIndex = findLastIndex(enumValues, value => value === variant);\n    if (valueIndex >= 0) return valueIndex;\n    return enumKeys.findIndex(key => key === variant);\n}\n\nexport function getEnumIndexFromDiscriminator({\n    discriminator,\n    enumKeys,\n    enumValues,\n    useValuesAsDiscriminators,\n}: {\n    discriminator: number;\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    useValuesAsDiscriminators: boolean;\n}): number {\n    if (!useValuesAsDiscriminators) {\n        return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;\n    }\n    return findLastIndex(enumValues, value => value === discriminator);\n}\n\nfunction findLastIndex<T>(array: Array<T>, predicate: (value: T, index: number, obj: T[]) => boolean): number {\n    let l = array.length;\n    while (l--) {\n        if (predicate(array[l], l, array)) return l;\n    }\n    return -1;\n}\n\nexport function formatNumericalValues(values: number[]): string {\n    if (values.length === 0) return '';\n    let range: [number, number] = [values[0], values[0]];\n    const ranges: string[] = [];\n    for (let index = 1; index < values.length; index++) {\n        const value = values[index];\n        if (range[1] + 1 === value) {\n            range[1] = value;\n        } else {\n            ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n            range = [value, value];\n        }\n    }\n    ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n    return ranges.join(', ');\n}\n","import { Codec, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { offsetDecoder, offsetEncoder } from './offset-codec';\nimport { resizeDecoder, resizeEncoder } from './resize-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Adds left padding to the given encoder, shifting the encoded value forward\n * by `offset` bytes whilst increasing the size of the encoder accordingly.\n *\n * For more details, see {@link padLeftCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to pad.\n * @param offset - The number of padding bytes to add before encoding.\n * @returns A new encoder with left padding applied.\n *\n * @example\n * ```ts\n * const encoder = padLeftEncoder(getU16Encoder(), 2);\n * const bytes = encoder.encode(0xffff); // 0x0000ffff (0xffff written at offset 2)\n * ```\n *\n * @see {@link padLeftCodec}\n * @see {@link padLeftDecoder}\n */\nexport function padLeftEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given encoder, extending the encoded value by `offset`\n * bytes whilst increasing the size of the encoder accordingly.\n *\n * For more details, see {@link padRightCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to pad.\n * @param offset - The number of padding bytes to add after encoding.\n * @returns A new encoder with right padding applied.\n *\n * @example\n * ```ts\n * const encoder = padRightEncoder(getU16Encoder(), 2);\n * const bytes = encoder.encode(0xffff); // 0xffff0000 (two extra bytes added at the end)\n * ```\n *\n * @see {@link padRightCodec}\n * @see {@link padRightDecoder}\n */\nexport function padRightEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given decoder, shifting the decoding position forward\n * by `offset` bytes whilst increasing the size of the decoder accordingly.\n *\n * For more details, see {@link padLeftCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to pad.\n * @param offset - The number of padding bytes to skip before decoding.\n * @returns A new decoder with left padding applied.\n *\n * @example\n * ```ts\n * const decoder = padLeftDecoder(getU16Decoder(), 2);\n * const value = decoder.decode(new Uint8Array([0, 0, 0x12, 0x34])); // 0xffff (reads from offset 2)\n * ```\n *\n * @see {@link padLeftCodec}\n * @see {@link padLeftEncoder}\n */\nexport function padLeftDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given decoder, extending the post-offset by `offset`\n * bytes whilst increasing the size of the decoder accordingly.\n *\n * For more details, see {@link padRightCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to pad.\n * @param offset - The number of padding bytes to skip after decoding.\n * @returns A new decoder with right padding applied.\n *\n * @example\n * ```ts\n * const decoder = padRightDecoder(getU16Decoder(), 2);\n * const value = decoder.decode(new Uint8Array([0x12, 0x34, 0, 0])); // 0xffff (ignores trailing bytes)\n * ```\n *\n * @see {@link padRightCodec}\n * @see {@link padRightEncoder}\n */\nexport function padRightDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given codec, shifting the encoding and decoding positions\n * forward by `offset` bytes whilst increasing the size of the codec accordingly.\n *\n * This ensures that values are read and written at a later position in the byte array,\n * while the padding bytes remain unused.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to pad.\n * @param offset - The number of padding bytes to add before encoding and decoding.\n * @returns A new codec with left padding applied.\n *\n * @example\n * ```ts\n * const codec = padLeftCodec(getU16Codec(), 2);\n * const bytes = codec.encode(0xffff); // 0x0000ffff (0xffff written at offset 2)\n * const value = codec.decode(bytes);  // 0xffff (reads from offset 2)\n * ```\n *\n * @remarks\n * If you only need to apply padding for encoding, use {@link padLeftEncoder}.\n * If you only need to apply padding for decoding, use {@link padLeftDecoder}.\n *\n * ```ts\n * const bytes = padLeftEncoder(getU16Encoder(), 2).encode(0xffff);\n * const value = padLeftDecoder(getU16Decoder(), 2).decode(bytes);\n * ```\n *\n * @see {@link padLeftEncoder}\n * @see {@link padLeftDecoder}\n */\nexport function padLeftCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset)) as TCodec;\n}\n\n/**\n * Adds right padding to the given codec, extending the encoded and decoded value\n * by `offset` bytes whilst increasing the size of the codec accordingly.\n *\n * The extra bytes remain unused, ensuring that the next operation starts further\n * along the byte array.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to pad.\n * @param offset - The number of padding bytes to add after encoding and decoding.\n * @returns A new codec with right padding applied.\n *\n * @example\n * ```ts\n * const codec = padRightCodec(getU16Codec(), 2);\n * const bytes = codec.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * const value = codec.decode(bytes);  // 0xffff (ignores padding bytes)\n * ```\n *\n * @remarks\n * If you only need to apply padding for encoding, use {@link padRightEncoder}.\n * If you only need to apply padding for decoding, use {@link padRightDecoder}.\n *\n * ```ts\n * const bytes = padRightEncoder(getU16Encoder(), 2).encode(0xffff);\n * const value = padRightDecoder(getU16Decoder(), 2).decode(bytes);\n * ```\n *\n * @see {@link padRightEncoder}\n * @see {@link padRightDecoder}\n */\nexport function padRightCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset)) as TCodec;\n}\n","import {\n    assertIsFixedSize,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\nfunction copySourceToTargetInReverse(\n    source: ReadonlyUint8Array,\n    target_WILL_MUTATE: Uint8Array,\n    sourceOffset: number,\n    sourceLength: number,\n    targetOffset: number = 0,\n) {\n    while (sourceOffset < --sourceLength) {\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\n\n/**\n * Reverses the bytes of a fixed-size encoder.\n *\n * Given a `FixedSizeEncoder`, this function returns a new `FixedSizeEncoder` that\n * reverses the bytes within the fixed-size byte array when encoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * For more details, see {@link reverseCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param encoder - The fixed-size encoder to reverse.\n * @returns A new encoder that writes bytes in reverse order.\n *\n * @example\n * Encoding a `u16` value in reverse order.\n * ```ts\n * const encoder = reverseEncoder(getU16Encoder({ endian: Endian.Big }));\n * const bytes = encoder.encode(0x1234); // 0x3412 (bytes are flipped)\n * ```\n *\n * @see {@link reverseCodec}\n * @see {@link reverseDecoder}\n */\nexport function reverseEncoder<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value: TFrom, bytes, offset) => {\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                bytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + encoder.fixedSize /* sourceLength */,\n            );\n            return newOffset;\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size decoder.\n *\n * Given a `FixedSizeDecoder`, this function returns a new `FixedSizeDecoder` that\n * reverses the bytes within the fixed-size byte array before decoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * For more details, see {@link reverseCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the decoded value in bytes.\n *\n * @param decoder - The fixed-size decoder to reverse.\n * @returns A new decoder that reads bytes in reverse order.\n *\n * @example\n * Decoding a reversed `u16` value.\n * ```ts\n * const decoder = reverseDecoder(getU16Decoder({ endian: Endian.Big }));\n * const value = decoder.decode(new Uint8Array([0x34, 0x12])); // 0x1234 (bytes are flipped back)\n * ```\n *\n * @see {@link reverseCodec}\n * @see {@link reverseEncoder}\n */\nexport function reverseDecoder<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset) => {\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                reversedBytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + decoder.fixedSize /* sourceLength */,\n            );\n            return decoder.read(reversedBytes, offset);\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size codec.\n *\n * Given a `FixedSizeCodec`, this function returns a new `FixedSizeCodec` that\n * reverses the bytes within the fixed-size byte array during encoding and decoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded/decoded value in bytes.\n *\n * @param codec - The fixed-size codec to reverse.\n * @returns A new codec that encodes and decodes bytes in reverse order.\n *\n * @example\n * Reversing a `u16` codec.\n * ```ts\n * const codec = reverseCodec(getU16Codec({ endian: Endian.Big }));\n * const bytes = codec.encode(0x1234); // 0x3412 (bytes are flipped)\n * const value = codec.decode(bytes);  // 0x1234 (bytes are flipped back)\n * ```\n *\n * @remarks\n * If you only need to reverse an encoder, use {@link reverseEncoder}.\n * If you only need to reverse a decoder, use {@link reverseDecoder}.\n *\n * ```ts\n * const bytes = reverseEncoder(getU16Encoder()).encode(0x1234);\n * const value = reverseDecoder(getU16Decoder()).decode(bytes);\n * ```\n *\n * @see {@link reverseEncoder}\n * @see {@link reverseDecoder}\n */\nexport function reverseCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  isProgramError,\n  type Address,\n  type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n  type SolanaError,\n} from '@solana/kit';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\n\n/** InvalidOwner: Associated token account owner does not match address derivation */\nexport const ASSOCIATED_TOKEN_ERROR__INVALID_OWNER = 0x0; // 0\n\nexport type AssociatedTokenError = typeof ASSOCIATED_TOKEN_ERROR__INVALID_OWNER;\n\nlet associatedTokenErrorMessages:\n  | Record<AssociatedTokenError, string>\n  | undefined;\nif (process.env.NODE_ENV !== 'production') {\n  associatedTokenErrorMessages = {\n    [ASSOCIATED_TOKEN_ERROR__INVALID_OWNER]: `Associated token account owner does not match address derivation`,\n  };\n}\n\nexport function getAssociatedTokenErrorMessage(\n  code: AssociatedTokenError\n): string {\n  if (process.env.NODE_ENV !== 'production') {\n    return (\n      associatedTokenErrorMessages as Record<AssociatedTokenError, string>\n    )[code];\n  }\n\n  return 'Error message not available in production bundles.';\n}\n\nexport function isAssociatedTokenError<\n  TProgramErrorCode extends AssociatedTokenError,\n>(\n  error: unknown,\n  transactionMessage: {\n    instructions: Record<number, { programAddress: Address }>;\n  },\n  code?: TProgramErrorCode\n): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &\n  Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {\n  return isProgramError<TProgramErrorCode>(\n    error,\n    transactionMessage,\n    ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n    code\n  );\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    EnumLookupObject,\n    formatNumericalValues,\n    GetEnumFrom,\n    getEnumIndexFromDiscriminator,\n    getEnumIndexFromVariant,\n    getEnumStats,\n    GetEnumTo,\n} from './enum-helpers';\n\n/**\n * Defines the configuration options for enum codecs.\n *\n * The `size` option determines the numerical encoding used for the enum's discriminant.\n * By default, enums are stored as a `u8` (1 byte).\n *\n * The `useValuesAsDiscriminators` option allows mapping the actual enum values\n * as discriminators instead of using their positional index.\n *\n * @typeParam TDiscriminator - A number codec, encoder, or decoder used for the discriminant.\n */\nexport type EnumCodecConfig<TDiscriminator extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec used to encode/decode the enum discriminator.\n     * @defaultValue `u8` discriminator.\n     */\n    size?: TDiscriminator;\n\n    /**\n     * If set to `true`, the enum values themselves will be used as discriminators.\n     * This is only valid for numerical enum values.\n     *\n     * @defaultValue `false`\n     */\n    useValuesAsDiscriminators?: boolean;\n};\n\n/**\n * Returns an encoder for enums.\n *\n * This encoder serializes enums as a numerical discriminator.\n * By default, the discriminator is based on the positional index of the enum variants.\n *\n * For more details, see {@link getEnumCodec}.\n *\n * @typeParam TEnum - The TypeScript enum or object mapping enum keys to values.\n *\n * @param constructor - The constructor of the enum.\n * @param config - Configuration options for encoding the enum.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding enums.\n *\n * @example\n * Encoding enum values.\n * ```ts\n * enum Direction { Up,  Down, Left, Right }\n * const encoder = getEnumEncoder(Direction);\n *\n * encoder.encode(Direction.Up);    // 0x00\n * encoder.encode(Direction.Down);  // 0x01\n * encoder.encode(Direction.Left);  // 0x02\n * encoder.encode(Direction.Right); // 0x03\n * ```\n *\n * @see {@link getEnumCodec}\n */\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberEncoder>, 'size'>,\n): FixedSizeEncoder<GetEnumFrom<TEnum>, 1>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<GetEnumFrom<TEnum>, TSize>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<GetEnumFrom<TEnum>>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> = {},\n): Encoder<GetEnumFrom<TEnum>> {\n    const prefix = config.size ?? getU8Encoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues, stringValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformEncoder(prefix, (variant: GetEnumFrom<TEnum>): number => {\n        const index = getEnumIndexFromVariant({ enumKeys, enumValues, variant });\n        if (index < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, {\n                formattedNumericalValues: formatNumericalValues(numericalValues),\n                numericalValues,\n                stringValues,\n                variant,\n            });\n        }\n        return useValuesAsDiscriminators ? (enumValues[index] as number) : index;\n    });\n}\n\n/**\n * Returns a decoder for enums.\n *\n * This decoder deserializes enums from a numerical discriminator.\n * By default, the discriminator is based on the positional index of the enum variants.\n *\n * For more details, see {@link getEnumCodec}.\n *\n * @typeParam TEnum - The TypeScript enum or object mapping enum keys to values.\n *\n * @param constructor - The constructor of the enum.\n * @param config - Configuration options for decoding the enum.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding enums.\n *\n * @example\n * Decoding enum values.\n * ```ts\n * enum Direction { Up,  Down, Left, Right }\n * const decoder = getEnumDecoder(Direction);\n *\n * decoder.decode(new Uint8Array([0x00])); // Direction.Up\n * decoder.decode(new Uint8Array([0x01])); // Direction.Down\n * decoder.decode(new Uint8Array([0x02])); // Direction.Left\n * decoder.decode(new Uint8Array([0x03])); // Direction.Right\n * ```\n *\n * @see {@link getEnumCodec}\n */\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberDecoder>, 'size'>,\n): FixedSizeDecoder<GetEnumTo<TEnum>, 1>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<GetEnumTo<TEnum>, TSize>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<GetEnumTo<TEnum>>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> = {},\n): Decoder<GetEnumTo<TEnum>> {\n    const prefix = config.size ?? getU8Decoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformDecoder(prefix, (value: bigint | number): GetEnumTo<TEnum> => {\n        const discriminator = Number(value);\n        const index = getEnumIndexFromDiscriminator({\n            discriminator,\n            enumKeys,\n            enumValues,\n            useValuesAsDiscriminators,\n        });\n        if (index < 0) {\n            const validDiscriminators = useValuesAsDiscriminators\n                ? numericalValues\n                : [...Array(enumKeys.length).keys()];\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator,\n                formattedValidDiscriminators: formatNumericalValues(validDiscriminators),\n                validDiscriminators,\n            });\n        }\n        return enumValues[index] as GetEnumTo<TEnum>;\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding enums.\n *\n * This codec serializes enums as a numerical discriminator, allowing them\n * to be efficiently stored and reconstructed from binary data.\n *\n * By default, the discriminator is derived from the positional index\n * of the enum variant, but it can be configured to use the enum's numeric values instead.\n *\n * @typeParam TEnum - The TypeScript enum or object mapping enum keys to values.\n *\n * @param constructor - The constructor of the enum.\n * @param config - Configuration options for encoding and decoding the enum.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding enums.\n *\n * @example\n * Encoding and decoding enums using positional indexes.\n * ```ts\n * enum Direction { Up, Down, Left, Right }\n * const codec = getEnumCodec(Direction);\n *\n * codec.encode(Direction.Up);    // 0x00\n * codec.encode(Direction.Down);  // 0x01\n * codec.encode(Direction.Left);  // 0x02\n * codec.encode(Direction.Right); // 0x03\n *\n * codec.decode(new Uint8Array([0x00])); // Direction.Up\n * codec.decode(new Uint8Array([0x01])); // Direction.Down\n * codec.decode(new Uint8Array([0x02])); // Direction.Left\n * codec.decode(new Uint8Array([0x03])); // Direction.Right\n * ```\n *\n * @example\n * Encoding and decoding enums using their numeric values.\n * ```ts\n * enum GameDifficulty { Easy = 1, Normal = 4, Hard = 7, Expert = 9 }\n * const codec = getEnumCodec(GameDifficulty, { useValuesAsDiscriminators: true });\n *\n * codec.encode(GameDifficulty.Easy);   // 0x01\n * codec.encode(GameDifficulty.Normal); // 0x04\n * codec.encode(GameDifficulty.Hard);   // 0x07\n * codec.encode(GameDifficulty.Expert); // 0x09\n *\n * codec.decode(new Uint8Array([0x01])); // GameDifficulty.Easy\n * codec.decode(new Uint8Array([0x04])); // GameDifficulty.Normal\n * codec.decode(new Uint8Array([0x07])); // GameDifficulty.Hard\n * codec.decode(new Uint8Array([0x09])); // GameDifficulty.Expert\n * ```\n *\n * Note that, when using values as discriminators, the enum values must be numerical.\n * Otherwise, an error will be thrown.\n *\n * ```ts\n * enum GameDifficulty { Easy = 'EASY', Normal = 'NORMAL', Hard = 'HARD' }\n * getEnumCodec(GameDifficulty, { useValuesAsDiscriminators: true }); // Throws an error.\n * ```\n *\n * @example\n * Using a custom discriminator size.\n * ```ts\n * enum Status { Pending, Approved, Rejected }\n * const codec = getEnumCodec(Status, { size: getU16Codec() });\n *\n * codec.encode(Status.Pending);  // 0x0000\n * codec.encode(Status.Approved); // 0x0100\n * codec.encode(Status.Rejected); // 0x0200\n *\n * codec.decode(new Uint8Array([0x00, 0x00])); // Status.Pending\n * codec.decode(new Uint8Array([0x01, 0x00])); // Status.Approved\n * codec.decode(new Uint8Array([0x02, 0x00])); // Status.Rejected\n * ```\n *\n * @remarks\n * Separate {@link getEnumEncoder} and {@link getEnumDecoder} functions are available.\n *\n * ```ts\n * const bytes = getEnumEncoder(Direction).encode(Direction.Up);\n * const value = getEnumDecoder(Direction).decode(bytes);\n * ```\n *\n * @see {@link getEnumEncoder}\n * @see {@link getEnumDecoder}\n */\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberCodec>, 'size'>,\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, 1>;\nexport function getEnumCodec<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, TSize>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberCodec>,\n): VariableSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> = {},\n): Codec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>> {\n    return combineCodec(getEnumEncoder(constructor, config), getEnumDecoder(constructor, config));\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ASSIGN_DISCRIMINATOR = 1;\n\nexport function getAssignDiscriminatorBytes() {\n  return getU32Encoder().encode(ASSIGN_DISCRIMINATOR);\n}\n\nexport type AssignInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableSignerAccount<TAccountAccount> &\n            AccountSignerMeta<TAccountAccount>\n        : TAccountAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AssignInstructionData = {\n  discriminator: number;\n  programAddress: Address;\n};\n\nexport type AssignInstructionDataArgs = { programAddress: Address };\n\nexport function getAssignInstructionDataEncoder(): FixedSizeEncoder<AssignInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['programAddress', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: ASSIGN_DISCRIMINATOR })\n  );\n}\n\nexport function getAssignInstructionDataDecoder(): FixedSizeDecoder<AssignInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['programAddress', getAddressDecoder()],\n  ]);\n}\n\nexport function getAssignInstructionDataCodec(): FixedSizeCodec<\n  AssignInstructionDataArgs,\n  AssignInstructionData\n> {\n  return combineCodec(\n    getAssignInstructionDataEncoder(),\n    getAssignInstructionDataDecoder()\n  );\n}\n\nexport type AssignInput<TAccountAccount extends string = string> = {\n  account: TransactionSigner<TAccountAccount>;\n  programAddress: AssignInstructionDataArgs['programAddress'];\n};\n\nexport function getAssignInstruction<\n  TAccountAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AssignInput<TAccountAccount>,\n  config?: { programAddress?: TProgramAddress }\n): AssignInstruction<TProgramAddress, TAccountAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.account)],\n    programAddress,\n    data: getAssignInstructionDataEncoder().encode(\n      args as AssignInstructionDataArgs\n    ),\n  } as AssignInstruction<TProgramAddress, TAccountAccount>;\n\n  return instruction;\n}\n\nexport type ParsedAssignInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    account: TAccountMetas[0];\n  };\n  data: AssignInstructionData;\n};\n\nexport function parseAssignInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedAssignInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n    },\n    data: getAssignInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  isProgramError,\n  type Address,\n  type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n  type SolanaError,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\n\n/** NotRentExempt: Lamport balance below rent-exempt threshold */\nexport const TOKEN_ERROR__NOT_RENT_EXEMPT = 0x0; // 0\n/** InsufficientFunds: Insufficient funds */\nexport const TOKEN_ERROR__INSUFFICIENT_FUNDS = 0x1; // 1\n/** InvalidMint: Invalid Mint */\nexport const TOKEN_ERROR__INVALID_MINT = 0x2; // 2\n/** MintMismatch: Account not associated with this Mint */\nexport const TOKEN_ERROR__MINT_MISMATCH = 0x3; // 3\n/** OwnerMismatch: Owner does not match */\nexport const TOKEN_ERROR__OWNER_MISMATCH = 0x4; // 4\n/** FixedSupply: Fixed supply */\nexport const TOKEN_ERROR__FIXED_SUPPLY = 0x5; // 5\n/** AlreadyInUse: Already in use */\nexport const TOKEN_ERROR__ALREADY_IN_USE = 0x6; // 6\n/** InvalidNumberOfProvidedSigners: Invalid number of provided signers */\nexport const TOKEN_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS = 0x7; // 7\n/** InvalidNumberOfRequiredSigners: Invalid number of required signers */\nexport const TOKEN_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS = 0x8; // 8\n/** UninitializedState: State is unititialized */\nexport const TOKEN_ERROR__UNINITIALIZED_STATE = 0x9; // 9\n/** NativeNotSupported: Instruction does not support native tokens */\nexport const TOKEN_ERROR__NATIVE_NOT_SUPPORTED = 0xa; // 10\n/** NonNativeHasBalance: Non-native account can only be closed if its balance is zero */\nexport const TOKEN_ERROR__NON_NATIVE_HAS_BALANCE = 0xb; // 11\n/** InvalidInstruction: Invalid instruction */\nexport const TOKEN_ERROR__INVALID_INSTRUCTION = 0xc; // 12\n/** InvalidState: State is invalid for requested operation */\nexport const TOKEN_ERROR__INVALID_STATE = 0xd; // 13\n/** Overflow: Operation overflowed */\nexport const TOKEN_ERROR__OVERFLOW = 0xe; // 14\n/** AuthorityTypeNotSupported: Account does not support specified authority type */\nexport const TOKEN_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED = 0xf; // 15\n/** MintCannotFreeze: This token mint cannot freeze accounts */\nexport const TOKEN_ERROR__MINT_CANNOT_FREEZE = 0x10; // 16\n/** AccountFrozen: Account is frozen */\nexport const TOKEN_ERROR__ACCOUNT_FROZEN = 0x11; // 17\n/** MintDecimalsMismatch: The provided decimals value different from the Mint decimals */\nexport const TOKEN_ERROR__MINT_DECIMALS_MISMATCH = 0x12; // 18\n/** NonNativeNotSupported: Instruction does not support non-native tokens */\nexport const TOKEN_ERROR__NON_NATIVE_NOT_SUPPORTED = 0x13; // 19\n\nexport type TokenError =\n  | typeof TOKEN_ERROR__ACCOUNT_FROZEN\n  | typeof TOKEN_ERROR__ALREADY_IN_USE\n  | typeof TOKEN_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED\n  | typeof TOKEN_ERROR__FIXED_SUPPLY\n  | typeof TOKEN_ERROR__INSUFFICIENT_FUNDS\n  | typeof TOKEN_ERROR__INVALID_INSTRUCTION\n  | typeof TOKEN_ERROR__INVALID_MINT\n  | typeof TOKEN_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS\n  | typeof TOKEN_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS\n  | typeof TOKEN_ERROR__INVALID_STATE\n  | typeof TOKEN_ERROR__MINT_CANNOT_FREEZE\n  | typeof TOKEN_ERROR__MINT_DECIMALS_MISMATCH\n  | typeof TOKEN_ERROR__MINT_MISMATCH\n  | typeof TOKEN_ERROR__NATIVE_NOT_SUPPORTED\n  | typeof TOKEN_ERROR__NON_NATIVE_HAS_BALANCE\n  | typeof TOKEN_ERROR__NON_NATIVE_NOT_SUPPORTED\n  | typeof TOKEN_ERROR__NOT_RENT_EXEMPT\n  | typeof TOKEN_ERROR__OVERFLOW\n  | typeof TOKEN_ERROR__OWNER_MISMATCH\n  | typeof TOKEN_ERROR__UNINITIALIZED_STATE;\n\nlet tokenErrorMessages: Record<TokenError, string> | undefined;\nif (process.env.NODE_ENV !== 'production') {\n  tokenErrorMessages = {\n    [TOKEN_ERROR__ACCOUNT_FROZEN]: `Account is frozen`,\n    [TOKEN_ERROR__ALREADY_IN_USE]: `Already in use`,\n    [TOKEN_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED]: `Account does not support specified authority type`,\n    [TOKEN_ERROR__FIXED_SUPPLY]: `Fixed supply`,\n    [TOKEN_ERROR__INSUFFICIENT_FUNDS]: `Insufficient funds`,\n    [TOKEN_ERROR__INVALID_INSTRUCTION]: `Invalid instruction`,\n    [TOKEN_ERROR__INVALID_MINT]: `Invalid Mint`,\n    [TOKEN_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS]: `Invalid number of provided signers`,\n    [TOKEN_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS]: `Invalid number of required signers`,\n    [TOKEN_ERROR__INVALID_STATE]: `State is invalid for requested operation`,\n    [TOKEN_ERROR__MINT_CANNOT_FREEZE]: `This token mint cannot freeze accounts`,\n    [TOKEN_ERROR__MINT_DECIMALS_MISMATCH]: `The provided decimals value different from the Mint decimals`,\n    [TOKEN_ERROR__MINT_MISMATCH]: `Account not associated with this Mint`,\n    [TOKEN_ERROR__NATIVE_NOT_SUPPORTED]: `Instruction does not support native tokens`,\n    [TOKEN_ERROR__NON_NATIVE_HAS_BALANCE]: `Non-native account can only be closed if its balance is zero`,\n    [TOKEN_ERROR__NON_NATIVE_NOT_SUPPORTED]: `Instruction does not support non-native tokens`,\n    [TOKEN_ERROR__NOT_RENT_EXEMPT]: `Lamport balance below rent-exempt threshold`,\n    [TOKEN_ERROR__OVERFLOW]: `Operation overflowed`,\n    [TOKEN_ERROR__OWNER_MISMATCH]: `Owner does not match`,\n    [TOKEN_ERROR__UNINITIALIZED_STATE]: `State is unititialized`,\n  };\n}\n\nexport function getTokenErrorMessage(code: TokenError): string {\n  if (process.env.NODE_ENV !== 'production') {\n    return (tokenErrorMessages as Record<TokenError, string>)[code];\n  }\n\n  return 'Error message not available in production bundles.';\n}\n\nexport function isTokenError<TProgramErrorCode extends TokenError>(\n  error: unknown,\n  transactionMessage: {\n    instructions: Record<number, { programAddress: Address }>;\n  },\n  code?: TProgramErrorCode\n): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &\n  Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {\n  return isProgramError<TProgramErrorCode>(\n    error,\n    transactionMessage,\n    TOKEN_PROGRAM_ADDRESS,\n    code\n  );\n}\n","import {\n    Codec,\n    createCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isVariableSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Transforms an encoder by mapping its input values.\n *\n * This function takes an existing `Encoder<A>` and returns an `Encoder<B>`, allowing values of type `B`\n * to be converted into values of type `A` before encoding. The transformation is applied via the `unmap` function.\n *\n * This is useful for handling type conversions, applying default values, or structuring data before encoding.\n *\n * For more details, see {@link transformCodec}.\n *\n * @typeParam TOldFrom - The original type expected by the encoder.\n * @typeParam TNewFrom - The new type that will be transformed before encoding.\n *\n * @param encoder - The encoder to transform.\n * @param unmap - A function that converts values of `TNewFrom` into `TOldFrom` before encoding.\n * @returns A new encoder that accepts `TNewFrom` values and transforms them before encoding.\n *\n * @example\n * Encoding a string by counting its characters and storing the length as a `u32`.\n * ```ts\n * const encoder = transformEncoder(getU32Encoder(), (value: string) => value.length);\n * encoder.encode(\"hello\"); // 0x05000000 (stores length 5)\n * ```\n *\n * @see {@link transformCodec}\n * @see {@link transformDecoder}\n */\nexport function transformEncoder<TOldFrom, TNewFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TOldFrom, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeEncoder<TNewFrom, TSize>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: VariableSizeEncoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeEncoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom> {\n    return createEncoder({\n        ...(isVariableSize(encoder)\n            ? { ...encoder, getSizeFromValue: (value: TNewFrom) => encoder.getSizeFromValue(unmap(value)) }\n            : encoder),\n        write: (value: TNewFrom, bytes, offset) => encoder.write(unmap(value), bytes, offset),\n    });\n}\n\n/**\n * Transforms a decoder by mapping its output values.\n *\n * This function takes an existing `Decoder<A>` and returns a `Decoder<B>`, allowing values of type `A`\n * to be converted into values of type `B` after decoding. The transformation is applied via the `map` function.\n *\n * This is useful for post-processing, type conversions, or enriching decoded data.\n *\n * For more details, see {@link transformCodec}.\n *\n * @typeParam TOldTo - The original type returned by the decoder.\n * @typeParam TNewTo - The new type that will be transformed after decoding.\n *\n * @param decoder - The decoder to transform.\n * @param map - A function that converts values of `TOldTo` into `TNewTo` after decoding.\n * @returns A new decoder that decodes into `TNewTo`.\n *\n * @example\n * Decoding a stored `u32` length into a string of `'x'` characters.\n * ```ts\n * const decoder = transformDecoder(getU32Decoder(), (length) => 'x'.repeat(length));\n * decoder.decode(new Uint8Array([0x05, 0x00, 0x00, 0x00])); // \"xxxxx\"\n * ```\n *\n * @see {@link transformCodec}\n * @see {@link transformEncoder}\n */\nexport function transformDecoder<TOldTo, TNewTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TOldTo, TSize>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeDecoder<TNewTo, TSize>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: VariableSizeDecoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeDecoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo> {\n    return createDecoder({\n        ...decoder,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [map(value, bytes, offset), newOffset];\n        },\n    });\n}\n\n/**\n * Transforms a codec by mapping its input and output values.\n *\n * This function takes an existing `Codec<A, B>` and returns a `Codec<C, D>`, allowing:\n * - Values of type `C` to be transformed into `A` before encoding.\n * - Values of type `B` to be transformed into `D` after decoding.\n *\n * This is useful for adapting codecs to work with different representations, handling default values, or\n * converting between primitive and structured types.\n *\n * @typeParam TOldFrom - The original type expected by the codec.\n * @typeParam TNewFrom - The new type that will be transformed before encoding.\n * @typeParam TOldTo - The original type returned by the codec.\n * @typeParam TNewTo - The new type that will be transformed after decoding.\n *\n * @param codec - The codec to transform.\n * @param unmap - A function that converts values of `TNewFrom` into `TOldFrom` before encoding.\n * @param map - A function that converts values of `TOldTo` into `TNewTo` after decoding (optional).\n * @returns A new codec that encodes `TNewFrom` and decodes into `TNewTo`.\n *\n * @example\n * Mapping a `u32` codec to encode string lengths and decode them into `'x'` characters.\n * ```ts\n * const codec = transformCodec(\n *     getU32Codec(),\n *     (value: string) => value.length, // Encode string length\n *     (length) => 'x'.repeat(length)  // Decode length into a string of 'x's\n * );\n *\n * const bytes = codec.encode(\"hello\"); // 0x05000000 (stores length 5)\n * const value = codec.decode(bytes);   // \"xxxxx\"\n * ```\n *\n * @remarks\n * If only input transformation is needed, use {@link transformEncoder}.\n * If only output transformation is needed, use {@link transformDecoder}.\n *\n * ```ts\n * const bytes = transformEncoder(getU32Encoder(), (value: string) => value.length).encode(\"hello\");\n * const value = transformDecoder(getU32Decoder(), (length) => 'x'.repeat(length)).decode(bytes);\n * ```\n *\n * @see {@link transformEncoder}\n * @see {@link transformDecoder}\n */\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom, TSize extends number>(\n    codec: FixedSizeCodec<TOldFrom, TTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeCodec<TNewFrom, TTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: VariableSizeCodec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeCodec<TNewFrom, TTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: Codec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Codec<TNewFrom, TTo>;\nexport function transformCodec<\n    TOldFrom,\n    TNewFrom,\n    TOldTo extends TOldFrom,\n    TNewTo extends TNewFrom,\n    TSize extends number,\n>(\n    codec: FixedSizeCodec<TOldFrom, TOldTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeCodec<TNewFrom, TNewTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: VariableSizeCodec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeCodec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map?: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo> {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : (codec.read as unknown as Decoder<TNewTo>['read']),\n    });\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Returns an encoder that prefixes encoded values with hidden data.\n *\n * This encoder applies a list of void encoders before encoding the main value.\n * The prefixed data is encoded before the main value without being exposed to the user.\n *\n * For more details, see {@link getHiddenPrefixCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param encoder - The encoder for the main value.\n * @param prefixedEncoders - A list of void encoders that produce the hidden prefix.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` that encodes the value with a hidden prefix.\n *\n * @example\n * Prefixing a value with constants.\n * ```ts\n * const encoder = getHiddenPrefixEncoder(getUtf8Encoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * encoder.encode('Hello');\n * // 0x01020304050648656c6c6f\n * //   |     |     -- Our encoded value (\"Hello\").\n * //   |     -- Our second hidden prefix.\n * //   -- Our first hidden prefix.\n * ```\n *\n * @see {@link getHiddenPrefixCodec}\n */\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([...prefixedEncoders, encoder]) as Encoder<readonly [...void[], TFrom]>,\n        (value: TFrom) => [...prefixedEncoders.map(() => undefined), value] as const,\n    );\n}\n\n/**\n * Returns a decoder that skips hidden prefixed data before decoding the main value.\n *\n * This decoder applies a list of void decoders before decoding the main value.\n * The prefixed data is skipped during decoding without being exposed to the user.\n *\n * For more details, see {@link getHiddenPrefixCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param decoder - The decoder for the main value.\n * @param prefixedDecoders - A list of void decoders that produce the hidden prefix.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` that decodes values while ignoring the hidden prefix.\n *\n * @example\n * Decoding a value with prefixed constants.\n * ```ts\n * const decoder = getHiddenPrefixDecoder(getUtf8Decoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * decoder.decode(new Uint8Array([1, 2, 3, 4, 5, 6, 0x48, 0x65, 0x6C, 0x6C, 0x6F]));\n * // 'Hello'\n * ```\n *\n * @see {@link getHiddenPrefixCodec}\n */\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([...prefixedDecoders, decoder]) as Decoder<readonly [...void[], TTo]>,\n        tuple => tuple[tuple.length - 1] as TTo,\n    );\n}\n\n/**\n * Returns a codec that encodes and decodes values with a hidden prefix.\n *\n * - **Encoding:** Prefixes the value with hidden data before encoding.\n * - **Decoding:** Skips the hidden prefix before decoding the main value.\n *\n * This is useful for any implicit metadata that should be present in\n * binary formats but omitted from the API.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param codec - The codec for the main value.\n * @param prefixedCodecs - A list of void codecs that produce the hidden prefix.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding values with a hidden prefix.\n *\n * @example\n * Encoding and decoding a value with prefixed constants.\n * ```ts\n * const codec = getHiddenPrefixCodec(getUtf8Codec(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * const bytes = codec.encode('Hello');\n * // 0x01020304050648656c6c6f\n * //   |     |     -- Our encoded value (\"Hello\").\n * //   |     -- Our second hidden prefix.\n * //   -- Our first hidden prefix.\n *\n * codec.decode(bytes);\n * // 'Hello'\n * ```\n *\n * @remarks\n * If all you need is padding zeroes before a value, consider using {@link padLeftCodec} instead.\n *\n * Separate {@link getHiddenPrefixEncoder} and {@link getHiddenPrefixDecoder} functions are available.\n *\n * ```ts\n * const bytes = getHiddenPrefixEncoder(getUtf8Encoder(), [\n *   getConstantEncoder(new Uint8Array([1, 2, 3])),\n *   getConstantEncoder(new Uint8Array([4, 5, 6])),\n * ]).encode('Hello');\n *\n * const value = getHiddenPrefixDecoder(getUtf8Decoder(), [\n *   getConstantDecoder(new Uint8Array([1, 2, 3])),\n *   getConstantDecoder(new Uint8Array([4, 5, 6])),\n * ]).decode(bytes);\n * ```\n *\n * @see {@link getHiddenPrefixEncoder}\n * @see {@link getHiddenPrefixDecoder}\n */\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ASSIGN_WITH_SEED_DISCRIMINATOR = 10;\n\nexport function getAssignWithSeedDiscriminatorBytes() {\n  return getU32Encoder().encode(ASSIGN_WITH_SEED_DISCRIMINATOR);\n}\n\nexport type AssignWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountBaseAccount extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountBaseAccount extends string\n        ? ReadonlySignerAccount<TAccountBaseAccount> &\n            AccountSignerMeta<TAccountBaseAccount>\n        : TAccountBaseAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AssignWithSeedInstructionData = {\n  discriminator: number;\n  base: Address;\n  seed: string;\n  programAddress: Address;\n};\n\nexport type AssignWithSeedInstructionDataArgs = {\n  base: Address;\n  seed: string;\n  programAddress: Address;\n};\n\nexport function getAssignWithSeedInstructionDataEncoder(): Encoder<AssignWithSeedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['base', getAddressEncoder()],\n      ['seed', addEncoderSizePrefix(getUtf8Encoder(), getU64Encoder())],\n      ['programAddress', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: ASSIGN_WITH_SEED_DISCRIMINATOR })\n  );\n}\n\nexport function getAssignWithSeedInstructionDataDecoder(): Decoder<AssignWithSeedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['base', getAddressDecoder()],\n    ['seed', addDecoderSizePrefix(getUtf8Decoder(), getU64Decoder())],\n    ['programAddress', getAddressDecoder()],\n  ]);\n}\n\nexport function getAssignWithSeedInstructionDataCodec(): Codec<\n  AssignWithSeedInstructionDataArgs,\n  AssignWithSeedInstructionData\n> {\n  return combineCodec(\n    getAssignWithSeedInstructionDataEncoder(),\n    getAssignWithSeedInstructionDataDecoder()\n  );\n}\n\nexport type AssignWithSeedInput<\n  TAccountAccount extends string = string,\n  TAccountBaseAccount extends string = string,\n> = {\n  account: Address<TAccountAccount>;\n  baseAccount: TransactionSigner<TAccountBaseAccount>;\n  base: AssignWithSeedInstructionDataArgs['base'];\n  seed: AssignWithSeedInstructionDataArgs['seed'];\n  programAddress: AssignWithSeedInstructionDataArgs['programAddress'];\n};\n\nexport function getAssignWithSeedInstruction<\n  TAccountAccount extends string,\n  TAccountBaseAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AssignWithSeedInput<TAccountAccount, TAccountBaseAccount>,\n  config?: { programAddress?: TProgramAddress }\n): AssignWithSeedInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountBaseAccount\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    baseAccount: { value: input.baseAccount ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.baseAccount),\n    ],\n    programAddress,\n    data: getAssignWithSeedInstructionDataEncoder().encode(\n      args as AssignWithSeedInstructionDataArgs\n    ),\n  } as AssignWithSeedInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountBaseAccount\n  >;\n\n  return instruction;\n}\n\nexport type ParsedAssignWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    account: TAccountMetas[0];\n    baseAccount: TAccountMetas[1];\n  };\n  data: AssignWithSeedInstructionData;\n};\n\nexport function parseAssignWithSeedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedAssignWithSeedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      baseAccount: getNextAccount(),\n    },\n    data: getAssignWithSeedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Returns an encoder that appends hidden data after the encoded value.\n *\n * This encoder applies a list of void encoders after encoding the main value.\n * The suffixed data is encoded after the main value without being exposed to the user.\n *\n * For more details, see {@link getHiddenSuffixCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param encoder - The encoder for the main value.\n * @param suffixedEncoders - A list of void encoders that produce the hidden suffix.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` that encodes the value with a hidden suffix.\n *\n * @example\n * Suffixing a value with constants.\n * ```ts\n * const encoder = getHiddenSuffixEncoder(getUtf8Encoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * encoder.encode('Hello');\n * // 0x48656c6c6f010203040506\n * //   |         |     -- Our second hidden suffix.\n * //   |         -- Our first hidden suffix.\n * //   -- Our encoded value (\"Hello\").\n * ```\n *\n * @see {@link getHiddenSuffixCodec}\n */\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    suffixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([encoder, ...suffixedEncoders]) as Encoder<readonly [TFrom, ...void[]]>,\n        (value: TFrom) => [value, ...suffixedEncoders.map(() => undefined)] as const,\n    );\n}\n\n/**\n * Returns a decoder that skips hidden suffixed data after decoding the main value.\n *\n * This decoder applies a list of void decoders after decoding the main value.\n * The suffixed data is skipped during decoding without being exposed to the user.\n *\n * For more details, see {@link getHiddenSuffixCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param decoder - The decoder for the main value.\n * @param suffixedDecoders - A list of void decoders that produce the hidden suffix.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` that decodes values while ignoring the hidden suffix.\n *\n * @example\n * Decoding a value with suffixed constants.\n * ```ts\n * const decoder = getHiddenSuffixDecoder(getUtf8Decoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * decoder.decode(new Uint8Array([0x48, 0x65, 0x6C, 0x6C, 0x6F, 1, 2, 3, 4, 5, 6]));\n * // 'Hello'\n * ```\n *\n * @see {@link getHiddenSuffixCodec}\n */\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    suffixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([decoder, ...suffixedDecoders]) as Decoder<readonly [TTo, ...void[]]>,\n        tuple => tuple[0],\n    );\n}\n\n/**\n * Returns a codec that encodes and decodes values with a hidden suffix.\n *\n * - **Encoding:** Appends hidden data after encoding the main value.\n * - **Decoding:** Skips the hidden suffix after decoding the main value.\n *\n * This is useful for any implicit metadata that should be present in\n * binary formats but omitted from the API.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param codec - The codec for the main value.\n * @param suffixedCodecs - A list of void codecs that produce the hidden suffix.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding values with a hidden suffix.\n *\n * @example\n * Encoding and decoding a value with suffixed constants.\n * ```ts\n * const codec = getHiddenSuffixCodec(getUtf8Codec(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * const bytes = codec.encode('Hello');\n * // 0x48656c6c6f010203040506\n * //   |         |     -- Our second hidden suffix.\n * //   |         -- Our first hidden suffix.\n * //   -- Our encoded value (\"Hello\").\n *\n * codec.decode(bytes);\n * // 'Hello'\n * ```\n *\n * @remarks\n * If all you need is padding zeroes after a value, consider using {@link padRightCodec} instead.\n *\n * Separate {@link getHiddenSuffixEncoder} and {@link getHiddenSuffixDecoder} functions are available.\n *\n * ```ts\n * const bytes = getHiddenSuffixEncoder(getUtf8Encoder(), [\n *   getConstantEncoder(new Uint8Array([1, 2, 3])),\n *   getConstantEncoder(new Uint8Array([4, 5, 6])),\n * ]).encode('Hello');\n *\n * const value = getHiddenSuffixDecoder(getUtf8Decoder(), [\n *   getConstantDecoder(new Uint8Array([1, 2, 3])),\n *   getConstantDecoder(new Uint8Array([4, 5, 6])),\n * ]).decode(bytes);\n * ```\n *\n * @see {@link getHiddenSuffixEncoder}\n * @see {@link getHiddenSuffixDecoder}\n */\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    suffixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  isProgramDerivedAddress,\n  isTransactionSigner as kitIsTransactionSigner,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type ProgramDerivedAddress,\n  type TransactionSigner,\n  upgradeRoleToSigner,\n} from '@solana/kit';\n\n/**\n * Asserts that the given value is not null or undefined.\n * @internal\n */\nexport function expectSome<T>(value: T | null | undefined): T {\n  if (value === null || value === undefined) {\n    throw new Error('Expected a value but received null or undefined.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a PublicKey.\n * @internal\n */\nexport function expectAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): Address<T> {\n  if (!value) {\n    throw new Error('Expected a Address.');\n  }\n  if (typeof value === 'object' && 'address' in value) {\n    return value.address;\n  }\n  if (Array.isArray(value)) {\n    return value[0] as Address<T>;\n  }\n  return value as Address<T>;\n}\n\n/**\n * Asserts that the given value is a PDA.\n * @internal\n */\nexport function expectProgramDerivedAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): ProgramDerivedAddress<T> {\n  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {\n    throw new Error('Expected a ProgramDerivedAddress.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a TransactionSigner.\n * @internal\n */\nexport function expectTransactionSigner<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): TransactionSigner<T> {\n  if (!value || !isTransactionSigner(value)) {\n    throw new Error('Expected a TransactionSigner.');\n  }\n  return value;\n}\n\n/**\n * Defines an instruction account to resolve.\n * @internal\n */\nexport type ResolvedAccount<\n  T extends string = string,\n  U extends\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null =\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null,\n> = {\n  isWritable: boolean;\n  value: U;\n};\n\n/**\n * Defines an instruction that stores additional bytes on-chain.\n * @internal\n */\nexport type InstructionWithByteDelta = {\n  byteDelta: number;\n};\n\n/**\n * Get account metas and signers from resolved accounts.\n * @internal\n */\nexport function getAccountMetaFactory(\n  programAddress: Address,\n  optionalAccountStrategy: 'omitted' | 'programId'\n) {\n  return (\n    account: ResolvedAccount\n  ): AccountMeta | AccountSignerMeta | undefined => {\n    if (!account.value) {\n      if (optionalAccountStrategy === 'omitted') return;\n      return Object.freeze({\n        address: programAddress,\n        role: AccountRole.READONLY,\n      });\n    }\n\n    const writableRole = account.isWritable\n      ? AccountRole.WRITABLE\n      : AccountRole.READONLY;\n    return Object.freeze({\n      address: expectAddress(account.value),\n      role: isTransactionSigner(account.value)\n        ? upgradeRoleToSigner(writableRole)\n        : writableRole,\n      ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),\n    });\n  };\n}\n\nexport function isTransactionSigner<TAddress extends string = string>(\n  value:\n    | Address<TAddress>\n    | ProgramDerivedAddress<TAddress>\n    | TransactionSigner<TAddress>\n): value is TransactionSigner<TAddress> {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'address' in value &&\n    kitIsTransactionSigner(value)\n  );\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\n/**\n * Defines the configuration options for literal union codecs.\n *\n * A literal union codec encodes values from a predefined set of literals.\n * The `size` option determines the numerical encoding used for the discriminant.\n * By default, literals are stored as a `u8` (1 byte).\n *\n * @typeParam TDiscriminator - A number codec, encoder, or decoder used for the discriminant.\n */\nexport type LiteralUnionCodecConfig<TDiscriminator = NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec used to encode/decode the discriminator.\n     * @defaultValue `u8` discriminator.\n     */\n    size?: TDiscriminator;\n};\n\ntype Variant = bigint | boolean | number | string | null | undefined;\ntype GetTypeFromVariants<TVariants extends readonly Variant[]> = TVariants[number];\n\n/**\n * Returns an encoder for literal unions.\n *\n * This encoder serializes a value from a predefined set of literals\n * as a numerical index representing its position in the `variants` array.\n *\n * For more details, see {@link getLiteralUnionCodec}.\n *\n * @typeParam TVariants - A tuple of allowed literal values.\n *\n * @param variants - The possible literal values for the union.\n * @param config - Configuration options for encoding the literal union.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding literal unions.\n *\n * @example\n * Encoding a union of string literals.\n * ```ts\n * type Size = 'small' | 'medium' | 'large';\n * const sizeEncoder = getLiteralUnionEncoder(['small', 'medium', 'large']);\n *\n * sizeEncoder.encode('small');  // 0x00\n * sizeEncoder.encode('medium'); // 0x01\n * sizeEncoder.encode('large');  // 0x02\n * ```\n *\n * @see {@link getLiteralUnionCodec}\n */\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n): FixedSizeEncoder<GetTypeFromVariants<TVariants>, 1>;\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[], TSize extends number>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<GetTypeFromVariants<TVariants>, TSize>;\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config?: LiteralUnionCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<GetTypeFromVariants<TVariants>>;\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberEncoder> = {},\n): Encoder<GetTypeFromVariants<TVariants>> {\n    const discriminator = config.size ?? getU8Encoder();\n    return transformEncoder(discriminator, variant => {\n        const index = variants.indexOf(variant);\n        if (index < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT, {\n                value: variant,\n                variants,\n            });\n        }\n        return index;\n    });\n}\n\n/**\n * Returns a decoder for literal unions.\n *\n * This decoder deserializes a numerical index into a corresponding\n * value from a predefined set of literals.\n *\n * For more details, see {@link getLiteralUnionCodec}.\n *\n * @typeParam TVariants - A tuple of allowed literal values.\n *\n * @param variants - The possible literal values for the union.\n * @param config - Configuration options for decoding the literal union.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding literal unions.\n *\n * @example\n * Decoding a union of string literals.\n * ```ts\n * type Size = 'small' | 'medium' | 'large';\n * const sizeDecoder = getLiteralUnionDecoder(['small', 'medium', 'large']);\n *\n * sizeDecoder.decode(new Uint8Array([0x00])); // 'small'\n * sizeDecoder.decode(new Uint8Array([0x01])); // 'medium'\n * sizeDecoder.decode(new Uint8Array([0x02])); // 'large'\n * ```\n *\n * @see {@link getLiteralUnionCodec}\n */\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n): FixedSizeDecoder<GetTypeFromVariants<TVariants>, 1>;\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[], TSize extends number>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<GetTypeFromVariants<TVariants>, TSize>;\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config?: LiteralUnionCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<GetTypeFromVariants<TVariants>>;\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberDecoder> = {},\n): Decoder<GetTypeFromVariants<TVariants>> {\n    const discriminator = config.size ?? getU8Decoder();\n    return transformDecoder(discriminator, (index: bigint | number) => {\n        if (index < 0 || index >= variants.length) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator: index,\n                maxRange: variants.length - 1,\n                minRange: 0,\n            });\n        }\n        return variants[Number(index)];\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding literal unions.\n *\n * A literal union codec serializes and deserializes values\n * from a predefined set of literals, using a numerical index\n * to represent each value in the `variants` array.\n *\n * This allows efficient storage and retrieval of common\n * predefined values such as enum-like structures in TypeScript.\n *\n * @typeParam TVariants - A tuple of allowed literal values.\n *\n * @param variants - The possible literal values for the union.\n * @param config - Configuration options for encoding and decoding the literal union.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding literal unions.\n *\n * @example\n * Encoding and decoding a union of string literals.\n * ```ts\n * type Size = 'small' | 'medium' | 'large';\n * const sizeCodec = getLiteralUnionCodec(['small', 'medium', 'large']);\n *\n * sizeCodec.encode('small');  // 0x00\n * sizeCodec.encode('medium'); // 0x01\n * sizeCodec.encode('large');  // 0x02\n *\n * sizeCodec.decode(new Uint8Array([0x00])); // 'small'\n * sizeCodec.decode(new Uint8Array([0x01])); // 'medium'\n * sizeCodec.decode(new Uint8Array([0x02])); // 'large'\n * ```\n *\n * @example\n * Encoding and decoding a union of number literals.\n * ```ts\n * type Level = 10 | 20 | 30;\n * const levelCodec = getLiteralUnionCodec([10, 20, 30]);\n *\n * levelCodec.encode(10);  // 0x00\n * levelCodec.encode(20);  // 0x01\n * levelCodec.encode(30);  // 0x02\n *\n * levelCodec.decode(new Uint8Array([0x00])); // 10\n * levelCodec.decode(new Uint8Array([0x01])); // 20\n * levelCodec.decode(new Uint8Array([0x02])); // 30\n * ```\n *\n * @example\n * Using a custom discriminator size with different variant types.\n * ```ts\n * type MaybeBoolean = false | true | \"either\";\n * const codec = getLiteralUnionCodec([false, true, 'either'], { size: getU16Codec() });\n *\n * codec.encode(false);    // 0x0000\n * codec.encode(true);     // 0x0100\n * codec.encode('either'); // 0x0200\n *\n * codec.decode(new Uint8Array([0x00, 0x00])); // false\n * codec.decode(new Uint8Array([0x01, 0x00])); // true\n * codec.decode(new Uint8Array([0x02, 0x00])); // 'either'\n * ```\n *\n * @remarks\n * Separate {@link getLiteralUnionEncoder} and {@link getLiteralUnionDecoder} functions are available.\n *\n * ```ts\n * const bytes = getLiteralUnionEncoder(['red', 'green', 'blue']).encode('green');\n * const value = getLiteralUnionDecoder(['red', 'green', 'blue']).decode(bytes);\n * ```\n *\n * @see {@link getLiteralUnionEncoder}\n * @see {@link getLiteralUnionDecoder}\n */\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n): FixedSizeCodec<GetTypeFromVariants<TVariants>, GetTypeFromVariants<TVariants>, 1>;\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[], TSize extends number>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<GetTypeFromVariants<TVariants>, GetTypeFromVariants<TVariants>, TSize>;\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config?: LiteralUnionCodecConfig<NumberCodec>,\n): VariableSizeCodec<GetTypeFromVariants<TVariants>>;\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberCodec> = {},\n): Codec<GetTypeFromVariants<TVariants>> {\n    return combineCodec(getLiteralUnionEncoder(variants, config), getLiteralUnionDecoder(variants, config));\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport { AccountRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype AddressTableLookup = Readonly<{\n    /** The address of the address lookup table account. */\n    lookupTableAddress: Address;\n    /** Indexes of accounts in a lookup table to load as read-only. */\n    readonlyIndexes: readonly number[];\n    /** Indexes of accounts in a lookup table to load as writable. */\n    writableIndexes: readonly number[];\n}>;\n\nexport function getCompiledAddressTableLookups(orderedAccounts: OrderedAccounts): AddressTableLookup[] {\n    const index: Record<\n        Address,\n        Readonly<{\n            [K in keyof Omit<AddressTableLookup, 'lookupTableAddress'>]: number[];\n        }>\n    > = {};\n    for (const account of orderedAccounts) {\n        if (!('lookupTableAddress' in account)) {\n            continue;\n        }\n        const entry = (index[account.lookupTableAddress] ||= {\n            readonlyIndexes: [],\n            writableIndexes: [],\n        });\n        if (account.role === AccountRole.WRITABLE) {\n            entry.writableIndexes.push(account.addressIndex);\n        } else {\n            entry.readonlyIndexes.push(account.addressIndex);\n        }\n    }\n    return Object.keys(index)\n        .sort(getAddressComparator())\n        .map(lookupTableAddress => ({\n            lookupTableAddress: lookupTableAddress as Address,\n            ...index[lookupTableAddress as unknown as Address],\n        }));\n}\n","import { SolanaErrorCode } from './codes';\nimport { encodeContextObject } from './context';\nimport { SolanaErrorMessages } from './messages';\n\nconst enum StateType {\n    EscapeSequence,\n    Text,\n    Variable,\n}\ntype State = Readonly<{\n    [START_INDEX]: number;\n    [TYPE]: StateType;\n}>;\nconst START_INDEX = 'i';\nconst TYPE = 't';\n\nexport function getHumanReadableErrorMessage<TErrorCode extends SolanaErrorCode>(\n    code: TErrorCode,\n    context: object = {},\n): string {\n    const messageFormatString = SolanaErrorMessages[code];\n    if (messageFormatString.length === 0) {\n        return '';\n    }\n    let state: State;\n    function commitStateUpTo(endIndex?: number) {\n        if (state[TYPE] === StateType.Variable) {\n            const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);\n\n            fragments.push(\n                variableName in context\n                    ? // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                      `${context[variableName as keyof typeof context]}`\n                    : `$${variableName}`,\n            );\n        } else if (state[TYPE] === StateType.Text) {\n            fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));\n        }\n    }\n    const fragments: string[] = [];\n    messageFormatString.split('').forEach((char, ii) => {\n        if (ii === 0) {\n            state = {\n                [START_INDEX]: 0,\n                [TYPE]:\n                    messageFormatString[0] === '\\\\'\n                        ? StateType.EscapeSequence\n                        : messageFormatString[0] === '$'\n                          ? StateType.Variable\n                          : StateType.Text,\n            };\n            return;\n        }\n        let nextState;\n        switch (state[TYPE]) {\n            case StateType.EscapeSequence:\n                nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                break;\n            case StateType.Text:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                }\n                break;\n            case StateType.Variable:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                } else if (!char.match(/\\w/)) {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                }\n                break;\n        }\n        if (nextState) {\n            if (state !== nextState) {\n                commitStateUpTo(ii);\n            }\n            state = nextState;\n        }\n    });\n    commitStateUpTo();\n    return fragments.join('');\n}\n\nexport function getErrorMessage<TErrorCode extends SolanaErrorCode>(\n    code: TErrorCode,\n    context: Record<string, unknown> = {},\n): string {\n    if (process.env.NODE_ENV !== \"production\") {\n        return getHumanReadableErrorMessage(code, context);\n    } else {\n        let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \\`npx @solana/errors decode -- ${code}`;\n        if (Object.keys(context).length) {\n            /**\n             * DANGER: Be sure that the shell command is escaped in such a way that makes it\n             *         impossible for someone to craft malicious context values that would result in\n             *         an exploit against anyone who bindly copy/pastes it into their terminal.\n             */\n            decodingAdviceMessage += ` '${encodeContextObject(context)}'`;\n        }\n        return `${decodingAdviceMessage}\\``;\n    }\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR = 23;\n\nexport function getAmountToUiAmountDiscriminatorBytes() {\n  return getU8Encoder().encode(AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR);\n}\n\nexport type AmountToUiAmountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AmountToUiAmountInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to reformat. */\n  amount: bigint;\n};\n\nexport type AmountToUiAmountInstructionDataArgs = {\n  /** The amount of tokens to reformat. */\n  amount: number | bigint;\n};\n\nexport function getAmountToUiAmountInstructionDataEncoder(): FixedSizeEncoder<AmountToUiAmountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getAmountToUiAmountInstructionDataDecoder(): FixedSizeDecoder<AmountToUiAmountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getAmountToUiAmountInstructionDataCodec(): FixedSizeCodec<\n  AmountToUiAmountInstructionDataArgs,\n  AmountToUiAmountInstructionData\n> {\n  return combineCodec(\n    getAmountToUiAmountInstructionDataEncoder(),\n    getAmountToUiAmountInstructionDataDecoder()\n  );\n}\n\nexport type AmountToUiAmountInput<TAccountMint extends string = string> = {\n  /** The mint to calculate for. */\n  mint: Address<TAccountMint>;\n  amount: AmountToUiAmountInstructionDataArgs['amount'];\n};\n\nexport function getAmountToUiAmountInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: AmountToUiAmountInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): AmountToUiAmountInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getAmountToUiAmountInstructionDataEncoder().encode(\n      args as AmountToUiAmountInstructionDataArgs\n    ),\n  } as AmountToUiAmountInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedAmountToUiAmountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to calculate for. */\n    mint: TAccountMetas[0];\n  };\n  data: AmountToUiAmountInstructionData;\n};\n\nexport function parseAmountToUiAmountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedAmountToUiAmountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getAmountToUiAmountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Defines the configuration options for map codecs.\n *\n * The `size` option determines how the number of entries in the map is stored.\n * It can be:\n * - A {@link NumberCodec} to prefix the map with its size.\n * - A fixed number of entries.\n * - `'remainder'`, which infers the number of entries based on the remaining bytes.\n *   This option is only available for fixed-size keys and values.\n *\n * @typeParam TPrefix - A number codec, encoder, or decoder used for the size prefix.\n */\nexport type MapCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the map.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Returns an encoder for maps.\n *\n * This encoder serializes maps where the keys and values are encoded\n * using the provided key and value encoders. The number of entries\n * is determined by the `size` configuration.\n *\n * For more details, see {@link getMapCodec}.\n *\n * @typeParam TFromKey - The type of the keys before encoding.\n * @typeParam TFromValue - The type of the values before encoding.\n *\n * @param key - The encoder for the map's keys.\n * @param value - The encoder for the map's values.\n * @param config - Configuration options for encoding the map.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding maps.\n *\n * @example\n * Encoding a map with a `u32` size prefix.\n * ```ts\n * const encoder = getMapEncoder(fixCodecSize(getUtf8Encoder(), 5), getU8Encoder());\n * const bytes = encoder.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x02000000616c6963652a626f62000005\n * //   |       |         | |          Value (5)\n * //   |       |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |       |          Value (42)\n * //   |        Key (\"alice\", 5 bytes fixed)\n * //    4-byte prefix (2 entries)\n * ```\n *\n * @see {@link getMapCodec}\n */\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>, 0>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: FixedSizeEncoder<TFromKey>,\n    value: FixedSizeEncoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config?: MapCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> = {},\n): Encoder<Map<TFromKey, TFromValue>> {\n    return transformEncoder(\n        getArrayEncoder(getTupleEncoder([key, value]), config as object),\n        (map: Map<TFromKey, TFromValue>): [TFromKey, TFromValue][] => [...map.entries()],\n    );\n}\n\n/**\n * Returns a decoder for maps.\n *\n * This decoder deserializes maps where the keys and values are decoded\n * using the provided key and value decoders. The number of entries\n * is determined by the `size` configuration.\n *\n * For more details, see {@link getMapCodec}.\n *\n * @typeParam TToKey - The type of the keys after decoding.\n * @typeParam TToValue - The type of the values after decoding.\n *\n * @param key - The decoder for the map's keys.\n * @param value - The decoder for the map's values.\n * @param config - Configuration options for decoding the map.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding maps.\n *\n * @example\n * Decoding a map with a `u32` size prefix.\n * ```ts\n * const decoder = getMapDecoder(fixCodecSize(getUtf8Decoder(), 5), getU8Decoder());\n * const map = decoder.decode(new Uint8Array([\n *   0x02,0x00,0x00,0x00,0x61,0x6c,0x69,0x63,0x65,0x2a,0x62,0x6f,0x62,0x00,0x00,0x05\n * ]));\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @see {@link getMapCodec}\n */\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Map<TToKey, TToValue>, 0>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: FixedSizeDecoder<TToKey>,\n    value: FixedSizeDecoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config?: MapCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> = {},\n): Decoder<Map<TToKey, TToValue>> {\n    return transformDecoder(\n        getArrayDecoder(getTupleDecoder([key, value]), config as object) as Decoder<[TToKey, TToValue][]>,\n        (entries: [TToKey, TToValue][]): Map<TToKey, TToValue> => new Map(entries),\n    );\n}\n\n/**\n * Returns a codec for encoding and decoding maps.\n *\n * This codec serializes maps where the key/value pairs are encoded\n * and decoded one after another using the provided key and value codecs.\n * The number of entries is determined by the `size` configuration and\n * defaults to a `u32` size prefix.\n *\n * @typeParam TFromKey - The type of the keys before encoding.\n * @typeParam TFromValue - The type of the values before encoding.\n * @typeParam TToKey - The type of the keys after decoding.\n * @typeParam TToValue - The type of the values after decoding.\n *\n * @param key - The codec for the map's keys.\n * @param value - The codec for the map's values.\n * @param config - Configuration options for encoding and decoding the map.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding maps.\n *\n * @example\n * Encoding and decoding a map with a `u32` size prefix (default).\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec());\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x02000000616c6963652a626f62000005\n * //   |       |         | |          Value (5)\n * //   |       |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |       |          Value (42)\n * //   |        Key (\"alice\", 5 bytes fixed)\n * //    4-byte prefix (2 entries)\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @example\n * Encoding and decoding a map with a `u16` size prefix.\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec(), { size: getU16Codec() });\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x0200616c6963652a626f62000005\n * //   |   |         | |          Value (5)\n * //   |   |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |   |          Value (42)\n * //   |    Key (\"alice\", 5 bytes fixed)\n * //    2-byte prefix (2 entries)\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @example\n * Encoding and decoding a fixed-size map.\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec(), { size: 2 });\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x616c6963652a626f62000005\n * //   |         | |          Value (5)\n * //   |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |          Value (42)\n * //    Key (\"alice\", 5 bytes fixed)\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @example\n * Encoding and decoding a map with remainder size.\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec(), { size: 'remainder' });\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x616c6963652a626f62000005\n * //   |         | |          Value (5)\n * //   |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |          Value (42)\n * //    Key (\"alice\", 5 bytes fixed)\n * // No size prefix, the size is inferred from the remaining bytes.\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @remarks\n * Separate {@link getMapEncoder} and {@link getMapDecoder} functions are available.\n * ```ts\n * const bytes = getMapEncoder(fixCodecSize(getUtf8Encoder(), 5), getU8Encoder()).encode(new Map([['alice', 42]]));\n * const map = getMapDecoder(fixCodecSize(getUtf8Decoder(), 5), getU8Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getMapEncoder}\n * @see {@link getMapDecoder}\n */\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>, 0>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: FixedSizeCodec<TFromKey, TToKey>,\n    value: FixedSizeCodec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config?: MapCodecConfig<NumberCodec>,\n): VariableSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> = {},\n): Codec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>> {\n    return combineCodec(getMapEncoder(key, value, config as object), getMapDecoder(key, value, config as object));\n}\n","import { isSignerRole, isWritableRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype MessageHeader = Readonly<{\n    /**\n     * The number of accounts in the static accounts list that are neither writable nor\n     * signers.\n     *\n     * Adding this number to `numSignerAccounts` yields the index of the first read-only non-signer\n     * account in the static accounts list.\n     */\n    numReadonlyNonSignerAccounts: number;\n    /**\n     * The number of read-only accounts in the static accounts list that must sign this\n     * transaction.\n     *\n     * Subtracting this number from `numSignerAccounts` yields the index of the first read-only\n     * signer account in the static accounts list.\n     */\n    numReadonlySignerAccounts: number;\n    /**\n     * The number of accounts in the static accounts list that must sign this transaction.\n     *\n     * Subtracting `numReadonlySignerAccounts` from this number yields the number of\n     * writable signer accounts in the static accounts list. Writable signer accounts always\n     * begin at index zero in the static accounts list.\n     *\n     * This number itself is the index of the first non-signer account in the static\n     * accounts list.\n     */\n    numSignerAccounts: number;\n}>;\n\nexport function getCompiledMessageHeader(orderedAccounts: OrderedAccounts): MessageHeader {\n    let numReadonlyNonSignerAccounts = 0;\n    let numReadonlySignerAccounts = 0;\n    let numSignerAccounts = 0;\n    for (const account of orderedAccounts) {\n        if ('lookupTableAddress' in account) {\n            break;\n        }\n        const accountIsWritable = isWritableRole(account.role);\n        if (isSignerRole(account.role)) {\n            numSignerAccounts++;\n            if (!accountIsWritable) {\n                numReadonlySignerAccounts++;\n            }\n        } else if (!accountIsWritable) {\n            numReadonlyNonSignerAccounts++;\n        }\n    }\n    return {\n        numReadonlyNonSignerAccounts,\n        numReadonlySignerAccounts,\n        numSignerAccounts,\n    };\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\n/**\n * Returns an encoder for `void` values.\n *\n * This encoder writes nothing to the byte array and has a fixed size of 0 bytes.\n * It is useful when working with structures that require a no-op encoder,\n * such as empty variants in {@link getDiscriminatedUnionEncoder}.\n *\n * For more details, see {@link getUnitCodec}.\n *\n * @returns A `FixedSizeEncoder<void, 0>`, representing an empty encoder.\n *\n * @example\n * Encoding a `void` value.\n * ```ts\n * getUnitEncoder().encode(undefined); // Produces an empty byte array.\n * ```\n *\n * @see {@link getUnitCodec}\n */\nexport function getUnitEncoder(): FixedSizeEncoder<void, 0> {\n    return createEncoder({\n        fixedSize: 0,\n        write: (_value, _bytes, offset) => offset,\n    });\n}\n\n/**\n * Returns a decoder for `void` values.\n *\n * This decoder always returns `undefined` and has a fixed size of 0 bytes.\n * It is useful when working with structures that require a no-op decoder,\n * such as empty variants in {@link getDiscriminatedUnionDecoder}.\n *\n * For more details, see {@link getUnitCodec}.\n *\n * @returns A `FixedSizeDecoder<void, 0>`, representing an empty decoder.\n *\n * @example\n * Decoding a `void` value.\n * ```ts\n * getUnitDecoder().decode(anyBytes); // Returns `undefined`.\n * ```\n *\n * @see {@link getUnitCodec}\n */\nexport function getUnitDecoder(): FixedSizeDecoder<void, 0> {\n    return createDecoder({\n        fixedSize: 0,\n        read: (_bytes: ReadonlyUint8Array | Uint8Array, offset) => [undefined, offset],\n    });\n}\n\n/**\n * Returns a codec for `void` values.\n *\n * This codec does nothing when encoding or decoding and has a fixed size of 0 bytes.\n * Namely, it always returns `undefined` when decoding and produces an empty byte array when encoding.\n *\n * This can be useful when working with structures that require a no-op codec,\n * such as empty variants in {@link getDiscriminatedUnionCodec}.\n *\n * @returns A `FixedSizeCodec<void, void, 0>`, representing an empty codec.\n *\n * @example\n * Encoding and decoding a `void` value.\n * ```ts\n * const codec = getUnitCodec();\n *\n * codec.encode(undefined); // Produces an empty byte array.\n * codec.decode(new Uint8Array([])); // Returns `undefined`.\n * ```\n *\n * @example\n * Using unit codecs as empty variants in a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Enter' }\n *   | { __kind: 'Leave' }\n *   | { __kind: 'Move'; x: number; y: number };\n *\n * const messageCodec = getDiscriminatedUnionCodec([\n *   ['Enter', getUnitCodec()], // <- No-op codec for empty data\n *   ['Leave', getUnitCodec()], // <- No-op codec for empty data\n *   ['Move', getStructCodec([...])]\n * ]);\n * ```\n *\n * @remarks\n * Separate {@link getUnitEncoder} and {@link getUnitDecoder} functions are available.\n *\n * ```ts\n * const bytes = getUnitEncoder().encode();\n * const value = getUnitDecoder().decode(bytes);\n * ```\n *\n * @see {@link getUnitEncoder}\n * @see {@link getUnitDecoder}\n */\nexport function getUnitCodec(): FixedSizeCodec<void, void, 0> {\n    return combineCodec(getUnitEncoder(), getUnitDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const AUTHORIZE_NONCE_ACCOUNT_DISCRIMINATOR = 7;\n\nexport function getAuthorizeNonceAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(AUTHORIZE_NONCE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type AuthorizeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNonceAccount extends string | AccountMeta<string> = string,\n  TAccountNonceAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountNonceAccount extends string\n        ? WritableAccount<TAccountNonceAccount>\n        : TAccountNonceAccount,\n      TAccountNonceAuthority extends string\n        ? ReadonlySignerAccount<TAccountNonceAuthority> &\n            AccountSignerMeta<TAccountNonceAuthority>\n        : TAccountNonceAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AuthorizeNonceAccountInstructionData = {\n  discriminator: number;\n  newNonceAuthority: Address;\n};\n\nexport type AuthorizeNonceAccountInstructionDataArgs = {\n  newNonceAuthority: Address;\n};\n\nexport function getAuthorizeNonceAccountInstructionDataEncoder(): FixedSizeEncoder<AuthorizeNonceAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['newNonceAuthority', getAddressEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: AUTHORIZE_NONCE_ACCOUNT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getAuthorizeNonceAccountInstructionDataDecoder(): FixedSizeDecoder<AuthorizeNonceAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['newNonceAuthority', getAddressDecoder()],\n  ]);\n}\n\nexport function getAuthorizeNonceAccountInstructionDataCodec(): FixedSizeCodec<\n  AuthorizeNonceAccountInstructionDataArgs,\n  AuthorizeNonceAccountInstructionData\n> {\n  return combineCodec(\n    getAuthorizeNonceAccountInstructionDataEncoder(),\n    getAuthorizeNonceAccountInstructionDataDecoder()\n  );\n}\n\nexport type AuthorizeNonceAccountInput<\n  TAccountNonceAccount extends string = string,\n  TAccountNonceAuthority extends string = string,\n> = {\n  nonceAccount: Address<TAccountNonceAccount>;\n  nonceAuthority: TransactionSigner<TAccountNonceAuthority>;\n  newNonceAuthority: AuthorizeNonceAccountInstructionDataArgs['newNonceAuthority'];\n};\n\nexport function getAuthorizeNonceAccountInstruction<\n  TAccountNonceAccount extends string,\n  TAccountNonceAuthority extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: AuthorizeNonceAccountInput<\n    TAccountNonceAccount,\n    TAccountNonceAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): AuthorizeNonceAccountInstruction<\n  TProgramAddress,\n  TAccountNonceAccount,\n  TAccountNonceAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nonceAccount: { value: input.nonceAccount ?? null, isWritable: true },\n    nonceAuthority: { value: input.nonceAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.nonceAccount),\n      getAccountMeta(accounts.nonceAuthority),\n    ],\n    programAddress,\n    data: getAuthorizeNonceAccountInstructionDataEncoder().encode(\n      args as AuthorizeNonceAccountInstructionDataArgs\n    ),\n  } as AuthorizeNonceAccountInstruction<\n    TProgramAddress,\n    TAccountNonceAccount,\n    TAccountNonceAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedAuthorizeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    nonceAccount: TAccountMetas[0];\n    nonceAuthority: TAccountMetas[1];\n  };\n  data: AuthorizeNonceAccountInstructionData;\n};\n\nexport function parseAuthorizeNonceAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedAuthorizeNonceAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nonceAccount: getNextAccount(),\n      nonceAuthority: getNextAccount(),\n    },\n    data: getAuthorizeNonceAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { Instruction } from '@solana/instructions';\n\nimport { OrderedAccounts } from './accounts';\n\ntype CompiledInstruction = Readonly<{\n    /**\n     * An ordered list of indices that indicate which accounts in the transaction message's\n     * accounts list are loaded by this instruction.\n     */\n    accountIndices?: number[];\n    /** The input to the invoked program */\n    data?: ReadonlyUint8Array;\n    /**\n     * The index of the address in the transaction message's accounts list associated with the\n     * program to invoke.\n     */\n    programAddressIndex: number;\n}>;\n\nfunction getAccountIndex(orderedAccounts: OrderedAccounts) {\n    const out: Record<Address, number> = {};\n    for (const [index, account] of orderedAccounts.entries()) {\n        out[account.address] = index;\n    }\n    return out;\n}\n\nexport function getCompiledInstructions(\n    instructions: readonly Instruction[],\n    orderedAccounts: OrderedAccounts,\n): CompiledInstruction[] {\n    const accountIndex = getAccountIndex(orderedAccounts);\n    return instructions.map(({ accounts, data, programAddress }) => {\n        return {\n            programAddressIndex: accountIndex[programAddress],\n            ...(accounts ? { accountIndices: accounts.map(({ address }) => accountIndex[address]) } : null),\n            ...(data ? { data } : null),\n        };\n    });\n}\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    containsBytes,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { getBooleanDecoder, getBooleanEncoder } from './boolean';\nimport { getConstantDecoder, getConstantEncoder } from './constant';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { getUnitDecoder, getUnitEncoder } from './unit';\n\n/**\n * Defines the configuration options for nullable codecs.\n *\n * This configuration controls how nullable values are encoded and decoded.\n *\n * By default, nullable values are prefixed with a `u8` (0 = `null`, 1 = present).\n * The `noneValue` and `prefix` options allow customizing this behavior.\n *\n * @typeParam TPrefix - A number codec, encoder, or decoder used as the presence prefix.\n *\n * @see {@link getNullableEncoder}\n * @see {@link getNullableDecoder}\n * @see {@link getNullableCodec}\n */\nexport type NullableCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Specifies how `null` values are represented in the encoded data.\n     *\n     * - By default, `null` values are omitted from encoding.\n     * - `'zeroes'`: The bytes allocated for the value are filled with zeroes. This requires a fixed-size codec.\n     * - Custom byte array: `null` values are replaced with a predefined byte sequence. This results in a variable-size codec.\n     *\n     * @defaultValue No explicit `noneValue` is used; `null` values are omitted.\n     */\n    noneValue?: ReadonlyUint8Array | 'zeroes';\n\n    /**\n     * The presence prefix used to distinguish between `null` and present values.\n     *\n     * - By default, a `u8` prefix is used (`0 = null`, `1 = present`).\n     * - Custom number codec: Allows defining a different number size for the prefix.\n     * - `null`: No prefix is used; `noneValue` (if provided) determines `null`.\n     *   If no `noneValue` is set, `null` is identified by the absence of bytes.\n     *\n     * @defaultValue `u8` prefix.\n     */\n    prefix?: TPrefix | null;\n};\n\n/**\n * Returns an encoder for optional values, allowing `null` values to be encoded.\n *\n * This encoder serializes an optional value using a configurable approach:\n * - By default, a `u8` prefix is used (0 = `null`, 1 = present). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, `null` values are encoded as zeroes.\n * - If `noneValue` is a byte array, `null` values are replaced with the provided constant.\n *\n * For more details, see {@link getNullableCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param item - The encoder for the value that may be present.\n * @param config - Configuration options for encoding optional values.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding nullable values.\n *\n * @example\n * Encoding an optional number.\n * ```ts\n * const encoder = getNullableEncoder(getU32Encoder());\n *\n * encoder.encode(null); // 0x00\n * encoder.encode(42);   // 0x012a000000\n * ```\n *\n * @see {@link getNullableCodec}\n */\nexport function getNullableEncoder<TFrom, TSize extends number>(\n    item: FixedSizeEncoder<TFrom, TSize>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeEncoder<TFrom | null, TSize>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<FixedSizeNumberEncoder> & { noneValue: 'zeroes' },\n): FixedSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes' },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: NullableCodecConfig<NumberEncoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformEncoder(getUnitEncoder(), (_boolean: boolean) => undefined);\n        }\n        return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n\n    return getUnionEncoder(\n        [\n            transformEncoder(getTupleEncoder([prefix, noneValue]), (_value: null): [boolean, void] => [\n                false,\n                undefined,\n            ]),\n            transformEncoder(getTupleEncoder([prefix, item]), (value: TFrom): [boolean, TFrom] => [true, value]),\n        ],\n        variant => Number(variant !== null),\n    );\n}\n\n/**\n * Returns a decoder for optional values, allowing `null` values to be recognized.\n *\n * This decoder deserializes an optional value using a configurable approach:\n * - By default, a `u8` prefix is used (0 = `null`, 1 = present). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, `null` values are identified by zeroes.\n * - If `noneValue` is a byte array, `null` values match the provided constant.\n *\n * For more details, see {@link getNullableCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The decoder for the value that may be present.\n * @param config - Configuration options for decoding optional values.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding nullable values.\n *\n * @example\n * Decoding an optional number.\n * ```ts\n * const decoder = getNullableDecoder(getU32Decoder());\n *\n * decoder.decode(new Uint8Array([0x00])); // null\n * decoder.decode(new Uint8Array([0x01, 0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @see {@link getNullableCodec}\n */\nexport function getNullableDecoder<TTo, TSize extends number>(\n    item: FixedSizeDecoder<TTo, TSize>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeDecoder<TTo | null, TSize>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<FixedSizeNumberDecoder> & { noneValue: 'zeroes' },\n): FixedSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes' },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: NullableCodecConfig<NumberDecoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> = {},\n): Decoder<TTo | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformDecoder(getUnitDecoder(), () => false);\n        }\n        return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n\n    return getUnionDecoder(\n        [\n            transformDecoder(getTupleDecoder([prefix, noneValue]), () => null),\n            transformDecoder(getTupleDecoder([prefix, item]), ([, value]): TTo => value),\n        ],\n        (bytes, offset) => {\n            if (config.prefix === null && !config.noneValue) {\n                return Number(offset < bytes.length);\n            }\n            if (config.prefix === null && config.noneValue != null) {\n                const zeroValue =\n                    config.noneValue === 'zeroes' ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n                return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n            }\n            return Number(prefix.read(bytes, offset)[0]);\n        },\n    );\n}\n\n/**\n * Returns a codec for encoding and decoding optional values, allowing `null` values to be handled.\n *\n * This codec serializes and deserializes optional values using a configurable approach:\n * - By default, a `u8` prefix is used (0 = `null`, 1 = present).\n *    This can be customized using a custom number codec or even disabled by setting\n *    the `prefix` to `null`.\n * - If `noneValue: 'zeroes'` is set, `null` values are encoded/decoded as zeroes.\n * - If `noneValue` is a byte array, `null` values are represented by the provided constant.\n *\n * For more details on the configuration options, see {@link NullableCodecConfig}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The codec for the value that may be present.\n * @param config - Configuration options for encoding and decoding optional values.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding nullable values.\n *\n * @example\n * Encoding and decoding an optional number using a `u8` prefix (default).\n * ```ts\n * const codec = getNullableCodec(getU32Codec());\n *\n * codec.encode(null); // 0x00\n * codec.encode(42);   // 0x012a000000\n *\n * codec.decode(new Uint8Array([0x00])); // null\n * codec.decode(new Uint8Array([0x01, 0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @example\n * Encoding and decoding an optional number using a fixed-size codec, by filling `null` values with zeroes.\n * ```ts\n * const codec = getNullableCodec(getU32Codec(), { noneValue: 'zeroes' });\n *\n * codec.encode(null); // 0x0000000000\n * codec.encode(42);   // 0x012a000000\n *\n * codec.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00])); // null\n * codec.decode(new Uint8Array([0x01, 0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @example\n * Encoding and decoding `null` values with zeroes and no prefix.\n * ```ts\n * const codec = getNullableCodec(getU32Codec(), {\n *   noneValue: 'zeroes',\n *   prefix: null,\n * });\n *\n * codec.encode(null); // 0x00000000\n * codec.encode(42);   // 0x2a000000\n *\n * codec.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00])); // null\n * codec.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @example\n * Encoding and decoding `null` values with a custom byte sequence and no prefix.\n * ```ts\n * const codec = getNullableCodec(getU16Codec(), {\n *   noneValue: new Uint8Array([0xff, 0xff]),\n *   prefix: null,\n * });\n *\n * codec.encode(null); // 0xffff\n * codec.encode(42); // 0x2a00\n *\n * codec.decode(new Uint8Array([0xff, 0xff])); // null\n * codec.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @example\n * Identifying `null` values by the absence of bytes.\n * ```ts\n * const codec = getNullableCodec(getU16Codec(), { prefix: null });\n *\n * codec.encode(null); // Empty bytes\n * codec.encode(42); // 0x2a00\n *\n * codec.decode(new Uint8Array([])); // null\n * codec.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @remarks\n * Separate {@link getNullableEncoder} and {@link getNullableDecoder} functions are available.\n *\n * ```ts\n * const bytes = getNullableEncoder(getU32Encoder()).encode(42);\n * const value = getNullableDecoder(getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getNullableEncoder}\n * @see {@link getNullableDecoder}\n */\nexport function getNullableCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    item: FixedSizeCodec<TFrom, TTo, TSize>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeCodec<TFrom | null, TTo | null, TSize>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<FixedSizeNumberCodec> & { noneValue: 'zeroes' },\n): FixedSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes' },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> = {},\n): Codec<TFrom | null, TTo | null> {\n    type ConfigCast = NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array };\n    return combineCodec(\n        getNullableEncoder<TFrom>(item, config as ConfigCast),\n        getNullableDecoder<TTo>(item, config as ConfigCast),\n    );\n}\n","import { TransactionMessageWithBlockhashLifetime, TransactionMessageWithDurableNonceLifetime } from '../index';\n\nexport function getCompiledLifetimeToken(\n    lifetimeConstraint: (\n        | TransactionMessageWithBlockhashLifetime\n        | TransactionMessageWithDurableNonceLifetime\n    )['lifetimeConstraint'],\n): string {\n    if ('nonce' in lifetimeConstraint) {\n        return lifetimeConstraint.nonce;\n    }\n    return lifetimeConstraint.blockhash;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const APPROVE_DISCRIMINATOR = 4;\n\nexport function getApproveDiscriminatorBytes() {\n  return getU8Encoder().encode(APPROVE_DISCRIMINATOR);\n}\n\nexport type ApproveInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountDelegate extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountDelegate extends string\n        ? ReadonlyAccount<TAccountDelegate>\n        : TAccountDelegate,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ApproveInstructionData = {\n  discriminator: number;\n  /** The amount of tokens the delegate is approved for. */\n  amount: bigint;\n};\n\nexport type ApproveInstructionDataArgs = {\n  /** The amount of tokens the delegate is approved for. */\n  amount: number | bigint;\n};\n\nexport function getApproveInstructionDataEncoder(): FixedSizeEncoder<ApproveInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: APPROVE_DISCRIMINATOR })\n  );\n}\n\nexport function getApproveInstructionDataDecoder(): FixedSizeDecoder<ApproveInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getApproveInstructionDataCodec(): FixedSizeCodec<\n  ApproveInstructionDataArgs,\n  ApproveInstructionData\n> {\n  return combineCodec(\n    getApproveInstructionDataEncoder(),\n    getApproveInstructionDataDecoder()\n  );\n}\n\nexport type ApproveInput<\n  TAccountSource extends string = string,\n  TAccountDelegate extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The delegate. */\n  delegate: Address<TAccountDelegate>;\n  /** The source account owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  amount: ApproveInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getApproveInstruction<\n  TAccountSource extends string,\n  TAccountDelegate extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: ApproveInput<TAccountSource, TAccountDelegate, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): ApproveInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountDelegate,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    delegate: { value: input.delegate ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.delegate),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getApproveInstructionDataEncoder().encode(\n      args as ApproveInstructionDataArgs\n    ),\n  } as ApproveInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountDelegate,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedApproveInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The delegate. */\n    delegate: TAccountMetas[1];\n    /** The source account owner or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: ApproveInstructionData;\n};\n\nexport function parseApproveInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedApproveInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      delegate: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getApproveInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","import { Address } from '@solana/addresses';\n\nimport { OrderedAccounts } from './accounts';\n\nexport function getCompiledStaticAccounts(orderedAccounts: OrderedAccounts): Address[] {\n    const firstLookupTableAccountIndex = orderedAccounts.findIndex(account => 'lookupTableAddress' in account);\n    const orderedStaticAccounts =\n        firstLookupTableAccountIndex === -1 ? orderedAccounts : orderedAccounts.slice(0, firstLookupTableAccountIndex);\n    return orderedStaticAccounts.map(({ address }) => address);\n}\n","import { TransactionMessageWithFeePayer } from '../fee-payer';\nimport { TransactionMessageWithLifetime } from '../lifetime';\nimport { BaseTransactionMessage } from '../transaction-message';\nimport { getAddressMapFromInstructions, getOrderedAccountsFromAddressMap } from './accounts';\nimport { getCompiledAddressTableLookups } from './address-table-lookups';\nimport { getCompiledMessageHeader } from './header';\nimport { getCompiledInstructions } from './instructions';\nimport { getCompiledLifetimeToken } from './lifetime-token';\nimport { getCompiledStaticAccounts } from './static-accounts';\n\ntype BaseCompiledTransactionMessage = Readonly<{\n    /**\n     * Information about the version of the transaction message and the role of the accounts it\n     * loads.\n     */\n    header: ReturnType<typeof getCompiledMessageHeader>;\n    instructions: ReturnType<typeof getCompiledInstructions>;\n    /** A list of addresses indicating which accounts to load */\n    staticAccounts: ReturnType<typeof getCompiledStaticAccounts>;\n}>;\n\n/**\n * A transaction message in a form suitable for encoding for execution on the network.\n *\n * You can not fully reconstruct a source message from a compiled message without extra information.\n * In particular, supporting details about the lifetime constraint and the concrete addresses of\n * accounts sourced from account lookup tables are lost to compilation.\n */\nexport type CompiledTransactionMessage = LegacyCompiledTransactionMessage | VersionedCompiledTransactionMessage;\n\nexport type CompiledTransactionMessageWithLifetime = Readonly<{\n    /**\n     * 32 bytes of data observed by the transaction proposed that makes a transaction eligible to\n     * land on the network.\n     *\n     * In the case of a transaction message with a nonce lifetime constraint, this will be the value\n     * of the nonce itself. In all other cases this will be a recent blockhash.\n     */\n    lifetimeToken: ReturnType<typeof getCompiledLifetimeToken>;\n}>;\n\ntype LegacyCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        version: 'legacy';\n    }>;\n\ntype VersionedCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        /** A list of address tables and the accounts that this transaction loads from them */\n        addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups>;\n        version: number;\n    }>;\n\n/**\n * Converts the type of transaction message data structure that you create in your application to\n * the type of transaction message data structure that can be encoded for execution on the network.\n *\n * This is a lossy process; you can not fully reconstruct a source message from a compiled message\n * without extra information. In particular, supporting details about the lifetime constraint and\n * the concrete addresses of accounts sourced from account lookup tables will be lost to\n * compilation.\n *\n * @see {@link decompileTransactionMessage}\n */\nexport function compileTransactionMessage<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(transactionMessage: TTransactionMessage): CompiledTransactionMessageFromTransactionMessage<TTransactionMessage> {\n    type ReturnType = CompiledTransactionMessageFromTransactionMessage<TTransactionMessage>;\n\n    const addressMap = getAddressMapFromInstructions(\n        transactionMessage.feePayer.address,\n        transactionMessage.instructions,\n    );\n    const orderedAccounts = getOrderedAccountsFromAddressMap(addressMap);\n    const lifetimeConstraint = (transactionMessage as Partial<TransactionMessageWithLifetime>).lifetimeConstraint;\n\n    return {\n        ...(transactionMessage.version !== 'legacy'\n            ? { addressTableLookups: getCompiledAddressTableLookups(orderedAccounts) }\n            : null),\n        ...(lifetimeConstraint ? { lifetimeToken: getCompiledLifetimeToken(lifetimeConstraint) } : null),\n        header: getCompiledMessageHeader(orderedAccounts),\n        instructions: getCompiledInstructions(transactionMessage.instructions, orderedAccounts),\n        staticAccounts: getCompiledStaticAccounts(orderedAccounts),\n        version: transactionMessage.version,\n    } as ReturnType;\n}\n\ntype CompiledTransactionMessageFromTransactionMessage<TTransactionMessage extends BaseTransactionMessage> =\n    ForwardTransactionMessageLifetime<ForwardTransactionMessageVersion<TTransactionMessage>, TTransactionMessage>;\n\ntype ForwardTransactionMessageVersion<TTransactionMessage extends BaseTransactionMessage> =\n    TTransactionMessage extends Readonly<{ version: 'legacy' }>\n        ? LegacyCompiledTransactionMessage\n        : VersionedCompiledTransactionMessage;\n\ntype ForwardTransactionMessageLifetime<\n    TCompiledTransactionMessage extends CompiledTransactionMessage,\n    TTransactionMessage extends BaseTransactionMessage,\n> = TTransactionMessage extends TransactionMessageWithLifetime\n    ? CompiledTransactionMessageWithLifetime & TCompiledTransactionMessage\n    : TCompiledTransactionMessage;\n","import { SolanaErrorCode, SolanaErrorCodeWithCause } from './codes';\nimport { SolanaErrorContext } from './context';\nimport { getErrorMessage } from './message-formatter';\n\n/**\n * A type guard that returns `true` if the input is a {@link SolanaError}, optionally with a\n * particular error code.\n *\n * When the `code` argument is supplied and the input is a {@link SolanaError}, TypeScript will\n * refine the error's {@link SolanaError#context | `context`} property to the type associated with\n * that error code. You can use that context to render useful error messages, or to make\n * context-aware decisions that help your application to recover from the error.\n *\n * @example\n * ```ts\n * import {\n *     SOLANA_ERROR__TRANSACTION__MISSING_SIGNATURE,\n *     SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n *     isSolanaError,\n * } from '@solana/errors';\n * import { assertIsFullySignedTransaction, getSignatureFromTransaction } from '@solana/transactions';\n *\n * try {\n *     const transactionSignature = getSignatureFromTransaction(tx);\n *     assertIsFullySignedTransaction(tx);\n *     /* ... *\\/\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING)) {\n *         displayError(\n *             \"We can't send this transaction without signatures for these addresses:\\n- %s\",\n *             // The type of the `context` object is now refined to contain `addresses`.\n *             e.context.addresses.join('\\n- '),\n *         );\n *         return;\n *     } else if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING)) {\n *         if (!tx.feePayer) {\n *             displayError('Choose a fee payer for this transaction before sending it');\n *         } else {\n *             displayError('The fee payer still needs to sign for this transaction');\n *         }\n *         return;\n *     }\n *     throw e;\n * }\n * ```\n */\nexport function isSolanaError<TErrorCode extends SolanaErrorCode>(\n    e: unknown,\n    /**\n     * When supplied, this function will require that the input is a {@link SolanaError} _and_ that\n     * its error code is exactly this value.\n     */\n    code?: TErrorCode,\n): e is SolanaError<TErrorCode> {\n    const isSolanaError = e instanceof Error && e.name === 'SolanaError';\n    if (isSolanaError) {\n        if (code !== undefined) {\n            return (e as SolanaError<TErrorCode>).context.__code === code;\n        }\n        return true;\n    }\n    return false;\n}\n\ntype SolanaErrorCodedContext = Readonly<{\n    [P in SolanaErrorCode]: (SolanaErrorContext[P] extends undefined ? object : SolanaErrorContext[P]) & {\n        __code: P;\n    };\n}>;\n\n/**\n * Encapsulates an error's stacktrace, a Solana-specific numeric code that indicates what went\n * wrong, and optional context if the type of error indicated by the code supports it.\n */\nexport class SolanaError<TErrorCode extends SolanaErrorCode = SolanaErrorCode> extends Error {\n    /**\n     * Indicates the root cause of this {@link SolanaError}, if any.\n     *\n     * For example, a transaction error might have an instruction error as its root cause. In this\n     * case, you will be able to access the instruction error on the transaction error as `cause`.\n     */\n    readonly cause?: TErrorCode extends SolanaErrorCodeWithCause ? SolanaError : unknown = this.cause;\n    /**\n     * Contains context that can assist in understanding or recovering from a {@link SolanaError}.\n     */\n    readonly context: SolanaErrorCodedContext[TErrorCode];\n    constructor(\n        ...[code, contextAndErrorOptions]: SolanaErrorContext[TErrorCode] extends undefined\n            ? [code: TErrorCode, errorOptions?: ErrorOptions | undefined]\n            : [code: TErrorCode, contextAndErrorOptions: SolanaErrorContext[TErrorCode] & (ErrorOptions | undefined)]\n    ) {\n        let context: SolanaErrorContext[TErrorCode] | undefined;\n        let errorOptions: ErrorOptions | undefined;\n        if (contextAndErrorOptions) {\n            Object.entries(Object.getOwnPropertyDescriptors(contextAndErrorOptions)).forEach(([name, descriptor]) => {\n                // If the `ErrorOptions` type ever changes, update this code.\n                if (name === 'cause') {\n                    errorOptions = { cause: descriptor.value };\n                } else {\n                    if (context === undefined) {\n                        context = {} as SolanaErrorContext[TErrorCode];\n                    }\n                    Object.defineProperty(context, name, descriptor);\n                }\n            });\n        }\n        const message = getErrorMessage(code, context);\n        super(message, errorOptions);\n        this.context = (context === undefined ? {} : context) as SolanaErrorCodedContext[TErrorCode];\n        this.context.__code = code;\n        // This is necessary so that `isSolanaError()` can identify a `SolanaError` without having\n        // to import the class for use in an `instanceof` check.\n        this.name = 'SolanaError';\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { AccountLookupMeta, AccountMeta, AccountRole, Instruction, isSignerRole } from '@solana/instructions';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { BaseTransactionMessage, TransactionMessage } from './transaction-message';\n\ntype Mutable<T> = {\n    -readonly [P in keyof T]: T[P];\n};\n\n// Look up the address in lookup tables, return a lookup meta if it is found in any of them\nfunction findAddressInLookupTables(\n    address: Address,\n    role: AccountRole.READONLY | AccountRole.WRITABLE,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): AccountLookupMeta | undefined {\n    for (const [lookupTableAddress, addresses] of Object.entries(addressesByLookupTableAddress)) {\n        for (let i = 0; i < addresses.length; i++) {\n            if (address === addresses[i]) {\n                return {\n                    address,\n                    addressIndex: i,\n                    lookupTableAddress: lookupTableAddress as Address,\n                    role,\n                };\n            }\n        }\n    }\n}\n\ntype TransactionMessageNotLegacy = Exclude<TransactionMessage, { version: 'legacy' }>;\n\n// Each account can be AccountLookupMeta | AccountMeta\ntype WidenInstructionAccounts<TInstruction extends Instruction> =\n    TInstruction extends Instruction<infer TProgramAddress, infer TAccounts>\n        ? Instruction<\n              TProgramAddress,\n              {\n                  [K in keyof TAccounts]: TAccounts[K] extends AccountMeta<infer TAddress>\n                      ? AccountLookupMeta<TAddress> | AccountMeta<TAddress>\n                      : TAccounts[K];\n              }\n          >\n        : TInstruction;\n\ntype ExtractAdditionalProps<T, U> = Omit<T, keyof U>;\n\ntype WidenTransactionMessageInstructions<TTransactionMessage extends TransactionMessage> =\n    TTransactionMessage extends BaseTransactionMessage<infer TVersion, infer TInstruction>\n        ? BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>> &\n              ExtractAdditionalProps<\n                  TTransactionMessage,\n                  BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>>\n              >\n        : TTransactionMessage;\n\n/**\n * Given a transaction message and a mapping of lookup tables to the addresses stored in them, this\n * function will return a new transaction message with the same instructions but with all non-signer\n * accounts that are found in the given lookup tables represented by an {@link AccountLookupMeta}\n * instead of an {@link AccountMeta}.\n *\n * This means that these accounts will take up less space in the compiled transaction message. This\n * size reduction is most significant when the transaction includes many accounts from the same\n * lookup table.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import {\n *     AddressesByLookupTableAddress,\n *     compressTransactionMessageUsingAddressLookupTables,\n * } from '@solana/transaction-messages';\n * import { fetchAddressLookupTable } from '@solana-program/address-lookup-table';\n *\n * const lookupTableAddress = address('4QwSwNriKPrz8DLW4ju5uxC2TN5cksJx6tPUPj7DGLAW');\n * const {\n *     data: { addresses },\n * } = await fetchAddressLookupTable(rpc, lookupTableAddress);\n * const addressesByAddressLookupTable: AddressesByLookupTableAddress = {\n *     [lookupTableAddress]: addresses,\n * };\n *\n * const compressedTransactionMessage = compressTransactionMessageUsingAddressLookupTables(\n *     transactionMessage,\n *     addressesByAddressLookupTable,\n * );\n * ```\n */\nexport function compressTransactionMessageUsingAddressLookupTables<\n    TTransactionMessage extends TransactionMessageNotLegacy = TransactionMessageNotLegacy,\n>(\n    transactionMessage: TTransactionMessage,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): TTransactionMessage | WidenTransactionMessageInstructions<TTransactionMessage> {\n    const lookupTableAddresses = new Set(Object.values(addressesByLookupTableAddress).flatMap(a => a));\n\n    const newInstructions: Instruction[] = [];\n    let updatedAnyInstructions = false;\n    for (const instruction of transactionMessage.instructions) {\n        if (!instruction.accounts) {\n            newInstructions.push(instruction);\n            continue;\n        }\n\n        const newAccounts: Mutable<NonNullable<Instruction['accounts']>> = [];\n        let updatedAnyAccounts = false;\n        for (const account of instruction.accounts) {\n            // If the address is already a lookup, is not in any lookup tables, or is a signer role, return as-is\n            if (\n                'lookupTableAddress' in account ||\n                !lookupTableAddresses.has(account.address) ||\n                isSignerRole(account.role)\n            ) {\n                newAccounts.push(account);\n                continue;\n            }\n\n            // We already checked it's in one of the lookup tables\n            const lookupMetaAccount = findAddressInLookupTables(\n                account.address,\n                account.role,\n                addressesByLookupTableAddress,\n            )!;\n            newAccounts.push(Object.freeze(lookupMetaAccount));\n            updatedAnyAccounts = true;\n            updatedAnyInstructions = true;\n        }\n\n        newInstructions.push(\n            Object.freeze(updatedAnyAccounts ? { ...instruction, accounts: newAccounts } : instruction),\n        );\n    }\n\n    return Object.freeze(\n        updatedAnyInstructions ? { ...transactionMessage, instructions: newInstructions } : transactionMessage,\n    );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  BASE_ACCOUNT_SIZE,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport {\n  getAccountMetaFactory,\n  type InstructionWithByteDelta,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const CREATE_ACCOUNT_DISCRIMINATOR = 0;\n\nexport function getCreateAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(CREATE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type CreateAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountPayer extends string | AccountMeta<string> = string,\n  TAccountNewAccount extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            AccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountNewAccount extends string\n        ? WritableSignerAccount<TAccountNewAccount> &\n            AccountSignerMeta<TAccountNewAccount>\n        : TAccountNewAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateAccountInstructionData = {\n  discriminator: number;\n  lamports: bigint;\n  space: bigint;\n  programAddress: Address;\n};\n\nexport type CreateAccountInstructionDataArgs = {\n  lamports: number | bigint;\n  space: number | bigint;\n  programAddress: Address;\n};\n\nexport function getCreateAccountInstructionDataEncoder(): FixedSizeEncoder<CreateAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['lamports', getU64Encoder()],\n      ['space', getU64Encoder()],\n      ['programAddress', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: CREATE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getCreateAccountInstructionDataDecoder(): FixedSizeDecoder<CreateAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['lamports', getU64Decoder()],\n    ['space', getU64Decoder()],\n    ['programAddress', getAddressDecoder()],\n  ]);\n}\n\nexport function getCreateAccountInstructionDataCodec(): FixedSizeCodec<\n  CreateAccountInstructionDataArgs,\n  CreateAccountInstructionData\n> {\n  return combineCodec(\n    getCreateAccountInstructionDataEncoder(),\n    getCreateAccountInstructionDataDecoder()\n  );\n}\n\nexport type CreateAccountInput<\n  TAccountPayer extends string = string,\n  TAccountNewAccount extends string = string,\n> = {\n  payer: TransactionSigner<TAccountPayer>;\n  newAccount: TransactionSigner<TAccountNewAccount>;\n  lamports: CreateAccountInstructionDataArgs['lamports'];\n  space: CreateAccountInstructionDataArgs['space'];\n  programAddress: CreateAccountInstructionDataArgs['programAddress'];\n};\n\nexport function getCreateAccountInstruction<\n  TAccountPayer extends string,\n  TAccountNewAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: CreateAccountInput<TAccountPayer, TAccountNewAccount>,\n  config?: { programAddress?: TProgramAddress }\n): CreateAccountInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountNewAccount\n> &\n  InstructionWithByteDelta {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    newAccount: { value: input.newAccount ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Bytes created or reallocated by the instruction.\n  const byteDelta: number = [Number(args.space) + BASE_ACCOUNT_SIZE].reduce(\n    (a, b) => a + b,\n    0\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.newAccount),\n    ],\n    programAddress,\n    data: getCreateAccountInstructionDataEncoder().encode(\n      args as CreateAccountInstructionDataArgs\n    ),\n  } as CreateAccountInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountNewAccount\n  >;\n\n  return Object.freeze({ ...instruction, byteDelta });\n}\n\nexport type ParsedCreateAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    payer: TAccountMetas[0];\n    newAccount: TAccountMetas[1];\n  };\n  data: CreateAccountInstructionData;\n};\n\nexport function parseCreateAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedCreateAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      newAccount: getNextAccount(),\n    },\n    data: getCreateAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\n\n/**\n * Defines the configuration options for set codecs.\n *\n * This configuration allows specifying how the size of the set is encoded.\n * The `size` option can be:\n *\n * - A {@link NumberCodec}, {@link NumberEncoder}, or {@link NumberDecoder} to store the size as a prefix.\n * - A fixed number of items, enforcing a strict length.\n * - The string `'remainder'` to infer the set size from the remaining bytes (only for fixed-size items).\n *\n * @typeParam TPrefix - The type used for encoding the size of the set.\n */\nexport type SetCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size encoding strategy for the set.\n     * @defaultValue Uses a `u32` prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Returns an encoder for sets of items.\n *\n * This encoder serializes `Set<T>` values by encoding each item using the provided item encoder.\n * The number of items is stored as a prefix using a `u32` codec by default.\n *\n * For more details, see {@link getSetCodec}.\n *\n * @typeParam TFrom - The type of the items in the set before encoding.\n *\n * @param item - The encoder to use for each set item.\n * @param config - Optional configuration specifying the size strategy.\n * @returns An `Encoder<Set<TFrom>>` for encoding sets of items.\n *\n * @example\n * Encoding a set of `u8` numbers.\n * ```ts\n * const encoder = getSetEncoder(getU8Encoder());\n * const bytes = encoder.encode(new Set([1, 2, 3]));\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix indicating 3 items.\n * ```\n *\n * @see {@link getSetCodec}\n */\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Set<TFrom>, 0>;\nexport function getSetEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: SetCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> = {},\n): Encoder<Set<TFrom>> {\n    return transformEncoder(getArrayEncoder(item, config as object), (set: Set<TFrom>): TFrom[] => [...set]);\n}\n\n/**\n * Returns a decoder for sets of items.\n *\n * This decoder deserializes a `Set<T>` from a byte array by decoding each item using the provided item decoder.\n * The number of items is determined by a `u32` size prefix by default.\n *\n * For more details, see {@link getSetCodec}.\n *\n * @typeParam TTo - The type of the items in the set after decoding.\n *\n * @param item - The decoder to use for each set item.\n * @param config - Optional configuration specifying the size strategy.\n * @returns A `Decoder<Set<TTo>>` for decoding sets of items.\n *\n * @example\n * Decoding a set of `u8` numbers.\n * ```ts\n * const decoder = getSetDecoder(getU8Decoder());\n * const value = decoder.decode(new Uint8Array([0x03, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03]));\n * // new Set([1, 2, 3])\n * ```\n *\n * @see {@link getSetCodec}\n */\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Set<TTo>, 0>;\nexport function getSetDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: SetCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(item: Decoder<TTo>, config: SetCodecConfig<NumberDecoder> = {}): Decoder<Set<TTo>> {\n    return transformDecoder(getArrayDecoder(item, config as object), (entries: TTo[]): Set<TTo> => new Set(entries));\n}\n\n/**\n * Returns a codec for encoding and decoding sets of items.\n *\n * This codec serializes `Set<T>` values by encoding each item using the provided item codec.\n * The number of items is stored as a prefix using a `u32` codec by default.\n *\n * @typeParam TFrom - The type of the items in the set before encoding.\n * @typeParam TTo - The type of the items in the set after decoding.\n *\n * @param item - The codec to use for each set item.\n * @param config - Optional configuration specifying the size strategy.\n * @returns A `Codec<Set<TFrom>, Set<TTo>>` for encoding and decoding sets.\n *\n * @example\n * Encoding and decoding a set of `u8` numbers.\n * ```ts\n * const codec = getSetCodec(getU8Codec());\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix indicating 3 items.\n *\n * const value = codec.decode(bytes);\n * // new Set([1, 2, 3])\n * ```\n *\n * @example\n * Using a `u16` prefix for size.\n * ```ts\n * const codec = getSetCodec(getU8Codec(), { size: getU16Codec() });\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x0300010203\n * //   |   -- 3 items of 1 byte each.\n * //   -- 2-byte prefix indicating 3 items.\n * ```\n *\n * @example\n * Using a fixed-size set.\n * ```ts\n * const codec = getSetCodec(getU8Codec(), { size: 3 });\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x010203\n * //   -- Exactly 3 items of 1 byte each.\n * ```\n *\n * @example\n * Using remainder to infer set size.\n * ```ts\n * const codec = getSetCodec(getU8Codec(), { size: 'remainder' });\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x010203\n * //   -- 3 items of 1 byte each. The size is inferred from the remaining bytes.\n * ```\n *\n * @remarks\n * Separate {@link getSetEncoder} and {@link getSetDecoder} functions are available.\n *\n * ```ts\n * const bytes = getSetEncoder(getU8Encoder()).encode(new Set([1, 2, 3]));\n * const value = getSetDecoder(getU8Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getSetEncoder}\n * @see {@link getSetDecoder}\n */\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>, 0>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: SetCodecConfig<NumberCodec>,\n): VariableSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> = {},\n): Codec<Set<TFrom>, Set<TTo>> {\n    return combineCodec(getSetEncoder(item, config as object), getSetDecoder(item, config as object));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\n/**\n * Represents a collection of named fields used in struct codecs.\n *\n * Each field is defined as a tuple containing:\n * - A string key representing the field name.\n * - A codec used to encode and decode the field's value.\n *\n * @typeParam T - The codec type used for each field.\n */\ntype Fields<T> = readonly (readonly [string, T])[];\n\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\n/**\n * Infers the TypeScript type for an object that can be encoded using a struct codec.\n *\n * This type maps the provided field encoders to their corresponding values.\n *\n * @typeParam TFields - The fields of the struct, each paired with an encoder.\n */\ntype GetEncoderTypeFromFields<TFields extends Fields<Encoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\n/**\n * Infers the TypeScript type for an object that can be decoded using a struct codec.\n *\n * This type maps the provided field decoders to their corresponding values.\n *\n * @typeParam TFields - The fields of the struct, each paired with a decoder.\n */\ntype GetDecoderTypeFromFields<TFields extends Fields<Decoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Returns an encoder for custom objects.\n *\n * This encoder serializes an object by encoding its fields sequentially,\n * using the provided field encoders.\n *\n * For more details, see {@link getStructCodec}.\n *\n * @typeParam TFields - The fields of the struct, each paired with an encoder.\n *\n * @param fields - The name and encoder of each field.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding custom objects.\n *\n * @example\n * Encoding a custom struct.\n * ```ts\n * const encoder = getStructEncoder([\n *   ['name', fixCodecSize(getUtf8Encoder(), 5)],\n *   ['age', getU8Encoder()]\n * ]);\n *\n * const bytes = encoder.encode({ name: 'Alice', age: 42 });\n * // 0x416c6963652a\n * //   |          Age (42)\n * //    Name (\"Alice\")\n * ```\n *\n * @see {@link getStructCodec}\n */\nexport function getStructEncoder<const TFields extends Fields<FixedSizeEncoder<any>>>(\n    fields: TFields,\n): FixedSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): VariableSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): Encoder<GetEncoderTypeFromFields<TFields>> {\n    type TFrom = GetEncoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      fields\n                          .map(([key, codec]) => getEncodedSize(value[key as keyof TFrom], codec))\n                          .reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (struct: TFrom, bytes, offset) => {\n            fields.forEach(([key, codec]) => {\n                offset = codec.write(struct[key as keyof TFrom], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder for custom objects.\n *\n * This decoder deserializes an object by decoding its fields sequentially,\n * using the provided field decoders.\n *\n * For more details, see {@link getStructCodec}.\n *\n * @typeParam TFields - The fields of the struct, each paired with a decoder.\n *\n * @param fields - The name and decoder of each field.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding custom objects.\n *\n * @example\n * Decoding a custom struct.\n * ```ts\n * const decoder = getStructDecoder([\n *   ['name', fixCodecSize(getUtf8Decoder(), 5)],\n *   ['age', getU8Decoder()]\n * ]);\n *\n * const struct = decoder.decode(new Uint8Array([\n *   0x41,0x6c,0x69,0x63,0x65,0x2a\n * ]));\n * // { name: 'Alice', age: 42 }\n * ```\n *\n * @see {@link getStructCodec}\n */\nexport function getStructDecoder<const TFields extends Fields<FixedSizeDecoder<any>>>(\n    fields: TFields,\n): FixedSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): VariableSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): Decoder<GetDecoderTypeFromFields<TFields>> {\n    type TTo = GetDecoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const struct = {} as TTo;\n            fields.forEach(([key, codec]) => {\n                const [value, newOffset] = codec.read(bytes, offset);\n                offset = newOffset;\n                struct[key as keyof TTo] = value;\n            });\n            return [struct, offset];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding custom objects.\n *\n * This codec serializes objects by encoding and decoding each field sequentially.\n *\n * @typeParam TFields - The fields of the struct, each paired with a codec.\n *\n * @param fields - The name and codec of each field.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding custom objects.\n *\n * @example\n * Encoding and decoding a custom struct.\n * ```ts\n * const codec = getStructCodec([\n *   ['name', fixCodecSize(getUtf8Codec(), 5)],\n *   ['age', getU8Codec()]\n * ]);\n *\n * const bytes = codec.encode({ name: 'Alice', age: 42 });\n * // 0x416c6963652a\n * //   |          Age (42)\n * //    Name (\"Alice\")\n *\n * const struct = codec.decode(bytes);\n * // { name: 'Alice', age: 42 }\n * ```\n *\n * @remarks\n * Separate {@link getStructEncoder} and {@link getStructDecoder} functions are available.\n *\n * ```ts\n * const bytes = getStructEncoder([\n *   ['name', fixCodecSize(getUtf8Encoder(), 5)],\n *   ['age', getU8Encoder()]\n * ]).encode({ name: 'Alice', age: 42 });\n *\n * const struct = getStructDecoder([\n *   ['name', fixCodecSize(getUtf8Decoder(), 5)],\n *   ['age', getU8Decoder()]\n * ]).decode(bytes);\n * ```\n *\n * @see {@link getStructEncoder}\n * @see {@link getStructDecoder}\n */\nexport function getStructCodec<const TFields extends Fields<FixedSizeCodec<any>>>(\n    fields: TFields,\n): FixedSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): VariableSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): Codec<GetEncoderTypeFromFields<TFields>, GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>> {\n    return combineCodec(\n        getStructEncoder(fields),\n        getStructDecoder(fields) as Decoder<GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>>,\n    );\n}\n","export function safeCaptureStackTrace(...args: Parameters<typeof Error.captureStackTrace>): void {\n    if ('captureStackTrace' in Error && typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(...args);\n    }\n}\n","import { SolanaErrorCode } from './codes';\nimport { SolanaErrorContext } from './context';\nimport { SolanaError } from './error';\nimport { safeCaptureStackTrace } from './stack-trace';\n\ntype Config = Readonly<{\n    /**\n     * Oh, hello. You might wonder what in tarnation is going on here. Allow us to explain.\n     *\n     * One of the goals of `@solana/errors` is to allow errors that are not interesting to your\n     * application to shake out of your app bundle in production. This means that we must never\n     * export large hardcoded maps of error codes/messages.\n     *\n     * Unfortunately, where instruction and transaction errors from the RPC are concerned, we have\n     * no choice but to keep a map between the RPC `rpcEnumError` enum name and its corresponding\n     * `SolanaError` code. In the interest of implementing that map in as few bytes of source code\n     * as possible, we do the following:\n     *\n     *   1. Reserve a block of sequential error codes for the enum in question\n     *   2. Hardcode the list of enum names in that same order\n     *   3. Match the enum error name from the RPC with its index in that list, and reconstruct the\n     *      `SolanaError` code by adding the `errorCodeBaseOffset` to that index\n     */\n    errorCodeBaseOffset: number;\n    getErrorContext: (\n        errorCode: SolanaErrorCode,\n        rpcErrorName: string,\n        rpcErrorContext?: unknown,\n    ) => SolanaErrorContext[SolanaErrorCode];\n    orderedErrorNames: string[];\n    rpcEnumError: string | { [key: string]: unknown };\n}>;\n\nexport function getSolanaErrorFromRpcError(\n    { errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }: Config,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    constructorOpt: Function,\n): SolanaError {\n    let rpcErrorName;\n    let rpcErrorContext;\n    if (typeof rpcEnumError === 'string') {\n        rpcErrorName = rpcEnumError;\n    } else {\n        rpcErrorName = Object.keys(rpcEnumError)[0];\n        rpcErrorContext = rpcEnumError[rpcErrorName];\n    }\n    const codeOffset = orderedErrorNames.indexOf(rpcErrorName);\n    const errorCode = (errorCodeBaseOffset + codeOffset) as SolanaErrorCode;\n    const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);\n    const err = new SolanaError(errorCode, errorContext);\n    safeCaptureStackTrace(err, constructorOpt);\n    return err;\n}\n","import { TransactionMessage, TransactionVersion } from './transaction-message';\nimport { TransactionMessageWithinSizeLimit } from './transaction-message-size';\n\ntype TransactionConfig<TVersion extends TransactionVersion> = Readonly<{\n    version: TVersion;\n}>;\n\ntype EmptyTransactionMessage<TVersion extends TransactionVersion> = Omit<\n    Extract<TransactionMessage, { version: TVersion }>,\n    'instructions'\n> &\n    TransactionMessageWithinSizeLimit & { instructions: readonly [] };\n\n/**\n * Given a {@link TransactionVersion} this method will return an empty transaction having the\n * capabilities of that version.\n *\n * @example\n * ```ts\n * import { createTransactionMessage } from '@solana/transaction-messages';\n *\n * const message = createTransactionMessage({ version: 0 });\n * ```\n */\nexport function createTransactionMessage<TVersion extends TransactionVersion>(\n    config: TransactionConfig<TVersion>,\n): EmptyTransactionMessage<TVersion> {\n    return Object.freeze({\n        instructions: Object.freeze([]),\n        version: config.version,\n    }) as EmptyTransactionMessage<TVersion>;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const APPROVE_CHECKED_DISCRIMINATOR = 13;\n\nexport function getApproveCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(APPROVE_CHECKED_DISCRIMINATOR);\n}\n\nexport type ApproveCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountDelegate extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDelegate extends string\n        ? ReadonlyAccount<TAccountDelegate>\n        : TAccountDelegate,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ApproveCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of tokens the delegate is approved for. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type ApproveCheckedInstructionDataArgs = {\n  /** The amount of tokens the delegate is approved for. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getApproveCheckedInstructionDataEncoder(): FixedSizeEncoder<ApproveCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: APPROVE_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getApproveCheckedInstructionDataDecoder(): FixedSizeDecoder<ApproveCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getApproveCheckedInstructionDataCodec(): FixedSizeCodec<\n  ApproveCheckedInstructionDataArgs,\n  ApproveCheckedInstructionData\n> {\n  return combineCodec(\n    getApproveCheckedInstructionDataEncoder(),\n    getApproveCheckedInstructionDataDecoder()\n  );\n}\n\nexport type ApproveCheckedInput<\n  TAccountSource extends string = string,\n  TAccountMint extends string = string,\n  TAccountDelegate extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The delegate. */\n  delegate: Address<TAccountDelegate>;\n  /** The source account owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  amount: ApproveCheckedInstructionDataArgs['amount'];\n  decimals: ApproveCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getApproveCheckedInstruction<\n  TAccountSource extends string,\n  TAccountMint extends string,\n  TAccountDelegate extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: ApproveCheckedInput<\n    TAccountSource,\n    TAccountMint,\n    TAccountDelegate,\n    TAccountOwner\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ApproveCheckedInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountMint,\n  TAccountDelegate,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    delegate: { value: input.delegate ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.delegate),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getApproveCheckedInstructionDataEncoder().encode(\n      args as ApproveCheckedInstructionDataArgs\n    ),\n  } as ApproveCheckedInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountMint,\n    TAccountDelegate,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedApproveCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The delegate. */\n    delegate: TAccountMetas[2];\n    /** The source account owner or its multisignature account. */\n    owner: TAccountMetas[3];\n  };\n  data: ApproveCheckedInstructionData;\n};\n\nexport function parseApproveCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedApproveCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      mint: getNextAccount(),\n      delegate: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getApproveCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    AccountRole,\n    Instruction,\n    InstructionWithAccounts,\n    InstructionWithData,\n    isSignerRole,\n    ReadonlyAccount,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nexport type AdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n> = Instruction<'11111111111111111111111111111111'> &\n    InstructionWithAccounts<\n        readonly [\n            WritableAccount<TNonceAccountAddress>,\n            ReadonlyAccount<'SysvarRecentB1ockHashes11111111111111111111'>,\n            ReadonlySignerAccount<TNonceAuthorityAddress> | WritableSignerAccount<TNonceAuthorityAddress>,\n        ]\n    > &\n    InstructionWithData<AdvanceNonceAccountInstructionData>;\n\ntype AdvanceNonceAccountInstructionData = Brand<Uint8Array, 'AdvanceNonceAccountInstructionData'>;\n\nconst RECENT_BLOCKHASHES_SYSVAR_ADDRESS =\n    'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\nconst SYSTEM_PROGRAM_ADDRESS = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n\n/**\n * Creates an instruction for the System program to advance a nonce.\n *\n * This instruction is a prerequisite for a transaction with a nonce-based lifetime to be landed on\n * the network. In order to be considered valid, the transaction must meet all of these criteria.\n *\n * 1. Its lifetime constraint must be a {@link NonceLifetimeConstraint}.\n * 2. The value contained in the on-chain account at the address `nonceAccountAddress` must be equal\n *    to {@link NonceLifetimeConstraint.nonce} at the time the transaction is landed.\n * 3. The first instruction in that transaction message must be the one returned by this function.\n *\n * You could also use the `getAdvanceNonceAccountInstruction` method of `@solana-program/system`.\n */\nexport function createAdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n>(\n    nonceAccountAddress: Address<TNonceAccountAddress>,\n    nonceAuthorityAddress: Address<TNonceAuthorityAddress>,\n): AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return {\n        accounts: [\n            { address: nonceAccountAddress, role: AccountRole.WRITABLE },\n            {\n                address: RECENT_BLOCKHASHES_SYSVAR_ADDRESS,\n                role: AccountRole.READONLY,\n            },\n            { address: nonceAuthorityAddress, role: AccountRole.READONLY_SIGNER },\n        ],\n        data: new Uint8Array([4, 0, 0, 0]) as AdvanceNonceAccountInstructionData,\n        programAddress: SYSTEM_PROGRAM_ADDRESS,\n    };\n}\n\n/**\n * A type guard that returns `true` if the instruction conforms to the\n * {@link AdvanceNonceAccountInstruction} type, and refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isAdvanceNonceAccountInstruction } from '@solana/transaction-messages';\n *\n * if (isAdvanceNonceAccountInstruction(message.instructions[0])) {\n *     // At this point, the first instruction in the message has been refined to a\n *     // `AdvanceNonceAccountInstruction`.\n *     setNonceAccountAddress(message.instructions[0].accounts[0].address);\n * } else {\n *     setError('The first instruction is not an `AdvanceNonce` instruction');\n * }\n * ```\n */\nexport function isAdvanceNonceAccountInstruction(\n    instruction: Instruction,\n): instruction is AdvanceNonceAccountInstruction {\n    return (\n        instruction.programAddress === SYSTEM_PROGRAM_ADDRESS &&\n        // Test for `AdvanceNonceAccount` instruction data\n        instruction.data != null &&\n        isAdvanceNonceAccountInstructionData(instruction.data) &&\n        // Test for exactly 3 accounts\n        instruction.accounts?.length === 3 &&\n        // First account is nonce account address\n        instruction.accounts[0].address != null &&\n        instruction.accounts[0].role === AccountRole.WRITABLE &&\n        // Second account is recent blockhashes sysvar\n        instruction.accounts[1].address === RECENT_BLOCKHASHES_SYSVAR_ADDRESS &&\n        instruction.accounts[1].role === AccountRole.READONLY &&\n        // Third account is nonce authority account\n        instruction.accounts[2].address != null &&\n        isSignerRole(instruction.accounts[2].role)\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionData(data: ReadonlyUint8Array): data is AdvanceNonceAccountInstructionData {\n    // AdvanceNonceAccount is the fifth instruction in the System Program (index 4)\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\n","import {\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n} from './codes';\nimport { SolanaError } from './error';\nimport { getSolanaErrorFromRpcError } from './rpc-enum-errors';\n\nconst ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/program/src/instruction.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    'GenericError',\n    'InvalidArgument',\n    'InvalidInstructionData',\n    'InvalidAccountData',\n    'AccountDataTooSmall',\n    'InsufficientFunds',\n    'IncorrectProgramId',\n    'MissingRequiredSignature',\n    'AccountAlreadyInitialized',\n    'UninitializedAccount',\n    'UnbalancedInstruction',\n    'ModifiedProgramId',\n    'ExternalAccountLamportSpend',\n    'ExternalAccountDataModified',\n    'ReadonlyLamportChange',\n    'ReadonlyDataModified',\n    'DuplicateAccountIndex',\n    'ExecutableModified',\n    'RentEpochModified',\n    'NotEnoughAccountKeys',\n    'AccountDataSizeChanged',\n    'AccountNotExecutable',\n    'AccountBorrowFailed',\n    'AccountBorrowOutstanding',\n    'DuplicateAccountOutOfSync',\n    'Custom',\n    'InvalidError',\n    'ExecutableDataModified',\n    'ExecutableLamportChange',\n    'ExecutableAccountNotRentExempt',\n    'UnsupportedProgramId',\n    'CallDepth',\n    'MissingAccount',\n    'ReentrancyNotAllowed',\n    'MaxSeedLengthExceeded',\n    'InvalidSeeds',\n    'InvalidRealloc',\n    'ComputationalBudgetExceeded',\n    'PrivilegeEscalation',\n    'ProgramEnvironmentSetupFailure',\n    'ProgramFailedToComplete',\n    'ProgramFailedToCompile',\n    'Immutable',\n    'IncorrectAuthority',\n    'BorshIoError',\n    'AccountNotRentExempt',\n    'InvalidAccountOwner',\n    'ArithmeticOverflow',\n    'UnsupportedSysvar',\n    'IllegalOwner',\n    'MaxAccountsDataAllocationsExceeded',\n    'MaxAccountsExceeded',\n    'MaxInstructionTraceLengthExceeded',\n    'BuiltinProgramsMustConsumeComputeUnits',\n];\n\nexport function getSolanaErrorFromInstructionError(\n    /**\n     * The index of the instruction inside the transaction.\n     */\n    index: bigint | number,\n    instructionError: string | { [key: string]: unknown },\n): SolanaError {\n    const numberIndex = Number(index);\n    return getSolanaErrorFromRpcError(\n        {\n            errorCodeBaseOffset: 4615001,\n            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n                if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN) {\n                    return {\n                        errorName: rpcErrorName,\n                        index: numberIndex,\n                        ...(rpcErrorContext !== undefined ? { instructionErrorContext: rpcErrorContext } : null),\n                    };\n                } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM) {\n                    return {\n                        code: Number(rpcErrorContext as bigint | number),\n                        index: numberIndex,\n                    };\n                } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR) {\n                    return {\n                        encodedData: rpcErrorContext as string,\n                        index: numberIndex,\n                    };\n                }\n                return { index: numberIndex };\n            },\n            orderedErrorNames: ORDERED_ERROR_NAMES,\n            rpcEnumError: instructionError,\n        },\n        getSolanaErrorFromInstructionError,\n    );\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME, SolanaError } from '@solana/errors';\nimport { Instruction } from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nimport {\n    AdvanceNonceAccountInstruction,\n    createAdvanceNonceAccountInstruction,\n    isAdvanceNonceAccountInstruction,\n} from './durable-nonce-instruction';\nimport { ExcludeTransactionMessageLifetime } from './lifetime';\nimport { BaseTransactionMessage } from './transaction-message';\nimport { ExcludeTransactionMessageWithinSizeLimit } from './transaction-message-size';\n\ntype DurableNonceConfig<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = Readonly<{\n    readonly nonce: Nonce<TNonceValue>;\n    readonly nonceAccountAddress: Address<TNonceAccountAddress>;\n    readonly nonceAuthorityAddress: Address<TNonceAuthorityAddress>;\n}>;\n\n/** Represents a string that is particularly known to be the base58-encoded value of a nonce. */\nexport type Nonce<TNonceValue extends string = string> = Brand<TNonceValue, 'Nonce'>;\n\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network.\n *\n * The transaction message will continue to be eligible to land until the network considers the\n * `nonce` to have advanced. This can happen when the nonce account in which this nonce is found is\n * destroyed, or the nonce value within changes.\n */\ntype NonceLifetimeConstraint<TNonceValue extends string = string> = Readonly<{\n    /**\n     * A value contained in the related nonce account at the time the transaction was prepared.\n     *\n     * The transaction will be considered eligible to land until the nonce account ceases to exist\n     * or contain this value.\n     */\n    nonce: Nonce<TNonceValue>;\n}>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the value of a nonce it includes.\n *\n * Such a transaction can only be landed on the network if the nonce is known to the network and has\n * not already been used to land a different transaction.\n */\nexport interface TransactionMessageWithDurableNonceLifetime<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> {\n    readonly instructions: readonly [\n        // The first instruction *must* be the system program's `AdvanceNonceAccount` instruction.\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...Instruction[],\n    ];\n    readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n}\n\n/**\n * A helper type to exclude the durable nonce lifetime constraint from a transaction message.\n */\nexport type ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage extends BaseTransactionMessage> =\n    TTransactionMessage extends TransactionMessageWithDurableNonceLifetime\n        ? ExcludeTransactionMessageLifetime<TTransactionMessage>\n        : TTransactionMessage;\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithDurableNonceLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithDurableNonceLifetime } from '@solana/transaction-messages';\n * import { fetchNonce } from \"@solana-program/system\";\n *\n * if (isTransactionMessageWithDurableNonceLifetime(message)) {\n *     // At this point, `message` has been refined to a\n *     // `TransactionMessageWithDurableNonceLifetime`.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n *     setNonceIsValid(nonce === actualNonce);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a nonce-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionMessageWithDurableNonceLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): transactionMessage is BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    return (\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.nonce === 'string' &&\n        transactionMessage.instructions[0] != null &&\n        isAdvanceNonceAccountInstruction(transactionMessage.instructions[0])\n    );\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * nonce-based lifetime, from an untrusted network API or user input. Use this function to assert\n * that such a transaction message actually has a nonce-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithDurableNonceLifetime } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithDurableNonceLifetime`.\n *     assertIsTransactionMessageWithDurableNonceLifetime(message);\n *     // At this point, `message` is a `TransactionMessageWithDurableNonceLifetime` that can be used\n *     // with the RPC.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n * } catch (e) {\n *     // `message` turned out not to have a nonce-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionMessageWithDurableNonceLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): asserts transactionMessage is BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    if (!isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n    }\n}\n\nfunction isAdvanceNonceAccountInstructionForNonce<\n    TNonceAccountAddress extends Address = Address,\n    TNonceAuthorityAddress extends Address = Address,\n>(\n    instruction: AdvanceNonceAccountInstruction,\n    nonceAccountAddress: TNonceAccountAddress,\n    nonceAuthorityAddress: TNonceAuthorityAddress,\n): instruction is AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return (\n        instruction.accounts[0].address === nonceAccountAddress &&\n        instruction.accounts[2].address === nonceAuthorityAddress\n    );\n}\n\n/**\n * Given a nonce, the account where the value of the nonce is stored, and the address of the account\n * authorized to consume that nonce, this method will return a new transaction having the same type\n * as the one supplied plus the {@link TransactionMessageWithDurableNonceLifetime} type.\n *\n * In particular, this method _prepends_ an instruction to the transaction message designed to\n * consume (or 'advance') the nonce in the same transaction whose lifetime is defined by it.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { Nonce, setTransactionMessageLifetimeUsingDurableNonce } from '@solana/transaction-messages';\n * import { fetchNonce } from '@solana-program/system';\n *\n * const nonceAccountAddress = address('EGtMh4yvXswwHhwVhyPxGrVV2TkLTgUqGodbATEPvojZ');\n * const nonceAuthorityAddress = address('4KD1Rdrd89NG7XbzW3xsX9Aqnx2EExJvExiNme6g9iAT');\n *\n * const {\n *     data: { blockhash },\n * } = await fetchNonce(rpc, nonceAccountAddress);\n * const nonce = blockhash as string as Nonce;\n *\n * const durableNonceTransactionMessage = setTransactionMessageLifetimeUsingDurableNonce(\n *     { nonce, nonceAccountAddress, nonceAuthorityAddress },\n *     tx,\n * );\n * ```\n */\nexport function setTransactionMessageLifetimeUsingDurableNonce<\n    TTransactionMessage extends BaseTransactionMessage,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n>(\n    {\n        nonce,\n        nonceAccountAddress,\n        nonceAuthorityAddress,\n    }: DurableNonceConfig<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue>,\n    transactionMessage: TTransactionMessage,\n): SetTransactionMessageWithDurableNonceLifetime<\n    TTransactionMessage,\n    TNonceAccountAddress,\n    TNonceAuthorityAddress,\n    TNonceValue\n> {\n    type ReturnType = SetTransactionMessageWithDurableNonceLifetime<\n        TTransactionMessage,\n        TNonceAccountAddress,\n        TNonceAuthorityAddress,\n        TNonceValue\n    >;\n\n    let newInstructions: [\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...Instruction[],\n    ];\n\n    const firstInstruction = transactionMessage.instructions[0];\n    if (firstInstruction && isAdvanceNonceAccountInstruction(firstInstruction)) {\n        if (isAdvanceNonceAccountInstructionForNonce(firstInstruction, nonceAccountAddress, nonceAuthorityAddress)) {\n            if (\n                isTransactionMessageWithDurableNonceLifetime(transactionMessage) &&\n                transactionMessage.lifetimeConstraint.nonce === nonce\n            ) {\n                return transactionMessage as unknown as ReturnType;\n            } else {\n                // we already have the right first instruction, leave it as-is\n                newInstructions = [firstInstruction, ...transactionMessage.instructions.slice(1)];\n            }\n        } else {\n            // we have a different advance nonce instruction as the first instruction, replace it\n            newInstructions = [\n                Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n                ...transactionMessage.instructions.slice(1),\n            ];\n        }\n    } else {\n        // we don't have an existing advance nonce instruction as the first instruction, prepend one\n        newInstructions = [\n            Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n            ...transactionMessage.instructions,\n        ];\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze(newInstructions),\n        lifetimeConstraint: Object.freeze({ nonce }),\n    }) as unknown as ReturnType;\n}\n\n/**\n * Helper type that transforms a given transaction message type into a new one that has the\n * `AdvanceNonceAccount` instruction as the first instruction and a lifetime constraint\n * representing the nonce value.\n */\ntype SetTransactionMessageWithDurableNonceLifetime<\n    TTransactionMessage extends BaseTransactionMessage,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = Omit<\n    // 1. The transaction message only grows in size if it currently has a different (or no) lifetime.\n    TTransactionMessage extends TransactionMessageWithDurableNonceLifetime\n        ? TTransactionMessage\n        : ExcludeTransactionMessageWithinSizeLimit<TTransactionMessage>,\n    // 2. Remove the instructions array as we are going to replace it with a new one.\n    'instructions'\n> & {\n    // 3. Replace or prepend the first instruction with the advance nonce account instruction.\n    readonly instructions: TTransactionMessage['instructions'] extends readonly [\n        AdvanceNonceAccountInstruction,\n        ...infer TTail extends readonly Instruction[],\n    ]\n        ? readonly [AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>, ...TTail]\n        : readonly [\n              AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n              ...TTransactionMessage['instructions'],\n          ];\n    // 4. Set the lifetime constraint to the nonce value.\n    readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n};\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const CREATE_ACCOUNT_WITH_SEED_DISCRIMINATOR = 3;\n\nexport function getCreateAccountWithSeedDiscriminatorBytes() {\n  return getU32Encoder().encode(CREATE_ACCOUNT_WITH_SEED_DISCRIMINATOR);\n}\n\nexport type CreateAccountWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountPayer extends string | AccountMeta<string> = string,\n  TAccountNewAccount extends string | AccountMeta<string> = string,\n  TAccountBaseAccount extends\n    | string\n    | AccountMeta<string>\n    | undefined = undefined,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            AccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountNewAccount extends string\n        ? WritableAccount<TAccountNewAccount>\n        : TAccountNewAccount,\n      ...(TAccountBaseAccount extends undefined\n        ? []\n        : [\n            TAccountBaseAccount extends string\n              ? ReadonlySignerAccount<TAccountBaseAccount> &\n                  AccountSignerMeta<TAccountBaseAccount>\n              : TAccountBaseAccount,\n          ]),\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateAccountWithSeedInstructionData = {\n  discriminator: number;\n  base: Address;\n  seed: string;\n  amount: bigint;\n  space: bigint;\n  programAddress: Address;\n};\n\nexport type CreateAccountWithSeedInstructionDataArgs = {\n  base: Address;\n  seed: string;\n  amount: number | bigint;\n  space: number | bigint;\n  programAddress: Address;\n};\n\nexport function getCreateAccountWithSeedInstructionDataEncoder(): Encoder<CreateAccountWithSeedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['base', getAddressEncoder()],\n      ['seed', addEncoderSizePrefix(getUtf8Encoder(), getU64Encoder())],\n      ['amount', getU64Encoder()],\n      ['space', getU64Encoder()],\n      ['programAddress', getAddressEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CREATE_ACCOUNT_WITH_SEED_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getCreateAccountWithSeedInstructionDataDecoder(): Decoder<CreateAccountWithSeedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['base', getAddressDecoder()],\n    ['seed', addDecoderSizePrefix(getUtf8Decoder(), getU64Decoder())],\n    ['amount', getU64Decoder()],\n    ['space', getU64Decoder()],\n    ['programAddress', getAddressDecoder()],\n  ]);\n}\n\nexport function getCreateAccountWithSeedInstructionDataCodec(): Codec<\n  CreateAccountWithSeedInstructionDataArgs,\n  CreateAccountWithSeedInstructionData\n> {\n  return combineCodec(\n    getCreateAccountWithSeedInstructionDataEncoder(),\n    getCreateAccountWithSeedInstructionDataDecoder()\n  );\n}\n\nexport type CreateAccountWithSeedInput<\n  TAccountPayer extends string = string,\n  TAccountNewAccount extends string = string,\n  TAccountBaseAccount extends string = string,\n> = {\n  payer: TransactionSigner<TAccountPayer>;\n  newAccount: Address<TAccountNewAccount>;\n  baseAccount?: TransactionSigner<TAccountBaseAccount>;\n  base: CreateAccountWithSeedInstructionDataArgs['base'];\n  seed: CreateAccountWithSeedInstructionDataArgs['seed'];\n  amount: CreateAccountWithSeedInstructionDataArgs['amount'];\n  space: CreateAccountWithSeedInstructionDataArgs['space'];\n  programAddress: CreateAccountWithSeedInstructionDataArgs['programAddress'];\n};\n\nexport function getCreateAccountWithSeedInstruction<\n  TAccountPayer extends string,\n  TAccountNewAccount extends string,\n  TAccountBaseAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: CreateAccountWithSeedInput<\n    TAccountPayer,\n    TAccountNewAccount,\n    TAccountBaseAccount\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CreateAccountWithSeedInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountNewAccount,\n  TAccountBaseAccount\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    newAccount: { value: input.newAccount ?? null, isWritable: true },\n    baseAccount: { value: input.baseAccount ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.newAccount),\n      getAccountMeta(accounts.baseAccount),\n    ].filter(<T>(x: T | undefined): x is T => x !== undefined),\n    programAddress,\n    data: getCreateAccountWithSeedInstructionDataEncoder().encode(\n      args as CreateAccountWithSeedInstructionDataArgs\n    ),\n  } as CreateAccountWithSeedInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountNewAccount,\n    TAccountBaseAccount\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCreateAccountWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    payer: TAccountMetas[0];\n    newAccount: TAccountMetas[1];\n    baseAccount?: TAccountMetas[2] | undefined;\n  };\n  data: CreateAccountWithSeedInstructionData;\n};\n\nexport function parseCreateAccountWithSeedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedCreateAccountWithSeedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  let optionalAccountsRemaining = instruction.accounts.length - 2;\n  const getNextOptionalAccount = () => {\n    if (optionalAccountsRemaining === 0) return undefined;\n    optionalAccountsRemaining -= 1;\n    return getNextAccount();\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      newAccount: getNextAccount(),\n      baseAccount: getNextOptionalAccount(),\n    },\n    data: getCreateAccountWithSeedInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","import { Address } from '@solana/addresses';\n\nimport { BaseTransactionMessage } from './transaction-message';\n\n/**\n * Represents a transaction message for which a fee payer has been declared. A transaction must\n * conform to this type to be compiled and landed on the network.\n */\nexport interface TransactionMessageWithFeePayer<TAddress extends string = string> {\n    readonly feePayer: Readonly<{ address: Address<TAddress> }>;\n}\n\n/**\n * A helper type to exclude the fee payer from a transaction message.\n */\ntype ExcludeTransactionMessageFeePayer<TTransactionMessage extends BaseTransactionMessage> = Omit<\n    TTransactionMessage,\n    'feePayer'\n>;\n\n/**\n * Given a base58-encoded address of a system account, this method will return a new transaction\n * message having the same type as the one supplied plus the {@link TransactionMessageWithFeePayer}\n * type.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { setTransactionMessageFeePayer } from '@solana/transaction-messages';\n *\n * const myAddress = address('mpngsFd4tmbUfzDYJayjKZwZcaR7aWb2793J6grLsGu');\n * const txPaidByMe = setTransactionMessageFeePayer(myAddress, tx);\n * ```\n */\nexport function setTransactionMessageFeePayer<\n    TFeePayerAddress extends string,\n    TTransactionMessage extends BaseTransactionMessage & Partial<TransactionMessageWithFeePayer>,\n>(\n    feePayer: Address<TFeePayerAddress>,\n    transactionMessage: TTransactionMessage,\n): ExcludeTransactionMessageFeePayer<TTransactionMessage> & TransactionMessageWithFeePayer<TFeePayerAddress> {\n    if (\n        'feePayer' in transactionMessage &&\n        feePayer === transactionMessage.feePayer?.address &&\n        isAddressOnlyFeePayer(transactionMessage.feePayer)\n    ) {\n        return transactionMessage as unknown as Omit<TTransactionMessage, 'feePayer'> &\n            TransactionMessageWithFeePayer<TFeePayerAddress>;\n    }\n    const out = {\n        ...transactionMessage,\n        feePayer: Object.freeze({ address: feePayer }),\n    };\n    Object.freeze(out);\n    return out;\n}\n\nfunction isAddressOnlyFeePayer(\n    feePayer: Partial<TransactionMessageWithFeePayer>['feePayer'],\n): feePayer is { address: Address } {\n    return (\n        !!feePayer &&\n        'address' in feePayer &&\n        typeof feePayer.address === 'string' &&\n        Object.keys(feePayer).length === 1\n    );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const BURN_DISCRIMINATOR = 8;\n\nexport function getBurnDiscriminatorBytes() {\n  return getU8Encoder().encode(BURN_DISCRIMINATOR);\n}\n\nexport type BurnInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type BurnInstructionData = {\n  /** The amount of tokens to burn. */\n  discriminator: number;\n  amount: bigint;\n};\n\nexport type BurnInstructionDataArgs = { amount: number | bigint };\n\nexport function getBurnInstructionDataEncoder(): FixedSizeEncoder<BurnInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: BURN_DISCRIMINATOR })\n  );\n}\n\nexport function getBurnInstructionDataDecoder(): FixedSizeDecoder<BurnInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getBurnInstructionDataCodec(): FixedSizeCodec<\n  BurnInstructionDataArgs,\n  BurnInstructionData\n> {\n  return combineCodec(\n    getBurnInstructionDataEncoder(),\n    getBurnInstructionDataDecoder()\n  );\n}\n\nexport type BurnInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The account to burn from. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: BurnInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getBurnInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: BurnInput<TAccountAccount, TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): BurnInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getBurnInstructionDataEncoder().encode(\n      args as BurnInstructionDataArgs\n    ),\n  } as BurnInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedBurnInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to burn from. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: BurnInstructionData;\n};\n\nexport function parseBurnInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedBurnInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getBurnInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","import { Instruction } from '@solana/instructions';\n\nimport { ExcludeTransactionMessageDurableNonceLifetime } from './durable-nonce';\nimport { BaseTransactionMessage } from './transaction-message';\nimport { ExcludeTransactionMessageWithinSizeLimit } from './transaction-message-size';\n\n/**\n * A helper type to append instructions to a transaction message\n * without losing type information about the current instructions.\n */\ntype AppendTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstructions extends readonly Instruction[],\n> = Omit<ExcludeTransactionMessageWithinSizeLimit<TTransactionMessage>, 'instructions'> & {\n    readonly instructions: readonly [...TTransactionMessage['instructions'], ...TInstructions];\n};\n\n/**\n * A helper type to prepend instructions to a transaction message\n * without losing type information about the current instructions.\n */\ntype PrependTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstructions extends readonly Instruction[],\n> = Omit<\n    ExcludeTransactionMessageWithinSizeLimit<ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage>>,\n    'instructions'\n> & {\n    readonly instructions: readonly [...TInstructions, ...TTransactionMessage['instructions']];\n};\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstructions} if you need to append multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { getUtf8Encoder } from '@solana/codecs-strings';\n * import { appendTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransactionMessage = appendTransactionMessageInstruction(\n *     {\n *         data: getUtf8Encoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     transactionMessage,\n * );\n * ```\n */\nexport function appendTransactionMessageInstruction<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstruction extends Instruction,\n>(\n    instruction: TInstruction,\n    transactionMessage: TTransactionMessage,\n): AppendTransactionMessageInstructions<TTransactionMessage, [TInstruction]> {\n    return appendTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstruction} if you only need to append one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { appendTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = appendTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function appendTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    const TInstructions extends readonly Instruction[],\n>(\n    instructions: TInstructions,\n    transactionMessage: TTransactionMessage,\n): AppendTransactionMessageInstructions<TTransactionMessage, TInstructions> {\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze([\n            ...(transactionMessage.instructions as TTransactionMessage['instructions']),\n            ...instructions,\n        ] as readonly [...TTransactionMessage['instructions'], ...TInstructions]),\n    });\n}\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstructions} if you need to prepend multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstruction(\n *     {\n *         data: new TextEncoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstruction<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstruction extends Instruction,\n>(\n    instruction: TInstruction,\n    transactionMessage: TTransactionMessage,\n): PrependTransactionMessageInstructions<TTransactionMessage, [TInstruction]> {\n    return prependTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstruction} if you only need to prepend one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    const TInstructions extends readonly Instruction[],\n>(\n    instructions: TInstructions,\n    transactionMessage: TTransactionMessage,\n): PrependTransactionMessageInstructions<TTransactionMessage, TInstructions> {\n    return Object.freeze({\n        ...(transactionMessage as ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage>),\n        instructions: Object.freeze([\n            ...instructions,\n            ...(transactionMessage.instructions as TTransactionMessage['instructions']),\n        ] as readonly [...TInstructions, ...TTransactionMessage['instructions']]),\n    });\n}\n","import {\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n} from './codes';\nimport { SolanaError } from './error';\nimport { getSolanaErrorFromInstructionError } from './instruction-error';\nimport { getSolanaErrorFromRpcError } from './rpc-enum-errors';\n\n/**\n * How to add an error when an entry is added to the RPC `TransactionError` enum:\n *\n *   1. Follow the instructions in `./codes.ts` to add a corresponding Solana error code\n *   2. Add the `TransactionError` enum name in the same order as it appears in `./codes.ts`\n *   3. Add the new error name/code mapping to `./__tests__/transaction-error-test.ts`\n */\nconst ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/src/transaction/error.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    'AccountInUse',\n    'AccountLoadedTwice',\n    'AccountNotFound',\n    'ProgramAccountNotFound',\n    'InsufficientFundsForFee',\n    'InvalidAccountForFee',\n    'AlreadyProcessed',\n    'BlockhashNotFound',\n    // `InstructionError` intentionally omitted; delegated to `getSolanaErrorFromInstructionError`\n    'CallChainTooDeep',\n    'MissingSignatureForFee',\n    'InvalidAccountIndex',\n    'SignatureFailure',\n    'InvalidProgramForExecution',\n    'SanitizeFailure',\n    'ClusterMaintenance',\n    'AccountBorrowOutstanding',\n    'WouldExceedMaxBlockCostLimit',\n    'UnsupportedVersion',\n    'InvalidWritableAccount',\n    'WouldExceedMaxAccountCostLimit',\n    'WouldExceedAccountDataBlockLimit',\n    'TooManyAccountLocks',\n    'AddressLookupTableNotFound',\n    'InvalidAddressLookupTableOwner',\n    'InvalidAddressLookupTableData',\n    'InvalidAddressLookupTableIndex',\n    'InvalidRentPayingAccount',\n    'WouldExceedMaxVoteCostLimit',\n    'WouldExceedAccountDataTotalLimit',\n    'DuplicateInstruction',\n    'InsufficientFundsForRent',\n    'MaxLoadedAccountsDataSizeExceeded',\n    'InvalidLoadedAccountsDataSizeLimit',\n    'ResanitizationNeeded',\n    'ProgramExecutionTemporarilyRestricted',\n    'UnbalancedTransaction',\n];\n\nexport function getSolanaErrorFromTransactionError(transactionError: string | { [key: string]: unknown }): SolanaError {\n    if (typeof transactionError === 'object' && 'InstructionError' in transactionError) {\n        return getSolanaErrorFromInstructionError(\n            ...(transactionError.InstructionError as Parameters<typeof getSolanaErrorFromInstructionError>),\n        );\n    }\n    return getSolanaErrorFromRpcError(\n        {\n            errorCodeBaseOffset: 7050001,\n            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n                if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN) {\n                    return {\n                        errorName: rpcErrorName,\n                        ...(rpcErrorContext !== undefined ? { transactionErrorContext: rpcErrorContext } : null),\n                    };\n                } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION) {\n                    return {\n                        index: Number(rpcErrorContext as bigint | number),\n                    };\n                } else if (\n                    errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT ||\n                    errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED\n                ) {\n                    return {\n                        accountIndex: Number((rpcErrorContext as { account_index: bigint | number }).account_index),\n                    };\n                }\n            },\n            orderedErrorNames: ORDERED_ERROR_NAMES,\n            rpcEnumError: transactionError,\n        },\n        getSolanaErrorFromTransactionError,\n    );\n}\n","import { Address, assertIsAddress } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\nimport { pipe } from '@solana/functional';\nimport { AccountLookupMeta, AccountMeta, AccountRole, Instruction } from '@solana/instructions';\nimport type { Blockhash } from '@solana/rpc-types';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { setTransactionMessageLifetimeUsingBlockhash } from './blockhash';\nimport { CompiledTransactionMessage, CompiledTransactionMessageWithLifetime } from './compile';\nimport type { getCompiledAddressTableLookups } from './compile/address-table-lookups';\nimport { createTransactionMessage } from './create-transaction-message';\nimport { Nonce, setTransactionMessageLifetimeUsingDurableNonce } from './durable-nonce';\nimport { isAdvanceNonceAccountInstruction } from './durable-nonce-instruction';\nimport { setTransactionMessageFeePayer, TransactionMessageWithFeePayer } from './fee-payer';\nimport { appendTransactionMessageInstruction } from './instructions';\nimport { TransactionMessageWithLifetime } from './lifetime';\nimport { BaseTransactionMessage, TransactionVersion } from './transaction-message';\n\nfunction getAccountMetas(message: CompiledTransactionMessage): AccountMeta[] {\n    const { header } = message;\n    const numWritableSignerAccounts = header.numSignerAccounts - header.numReadonlySignerAccounts;\n    const numWritableNonSignerAccounts =\n        message.staticAccounts.length - header.numSignerAccounts - header.numReadonlyNonSignerAccounts;\n\n    const accountMetas: AccountMeta[] = [];\n\n    let accountIndex = 0;\n    for (let i = 0; i < numWritableSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlySignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < numWritableNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlyNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY,\n        });\n        accountIndex++;\n    }\n\n    return accountMetas;\n}\n\nfunction getAddressLookupMetas(\n    compiledAddressTableLookups: ReturnType<typeof getCompiledAddressTableLookups>,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): AccountLookupMeta[] {\n    // check that all message lookups are known\n    const compiledAddressTableLookupAddresses = compiledAddressTableLookups.map(l => l.lookupTableAddress);\n    const missing = compiledAddressTableLookupAddresses.filter(a => addressesByLookupTableAddress[a] === undefined);\n    if (missing.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, {\n            lookupTableAddresses: missing,\n        });\n    }\n\n    const readOnlyMetas: AccountLookupMeta[] = [];\n    const writableMetas: AccountLookupMeta[] = [];\n\n    // we know that for each lookup, knownLookups[lookup.lookupTableAddress] is defined\n    for (const lookup of compiledAddressTableLookups) {\n        const addresses = addressesByLookupTableAddress[lookup.lookupTableAddress];\n        const readonlyIndexes = lookup.readonlyIndexes;\n        const writableIndexes = lookup.writableIndexes;\n\n        const highestIndex = Math.max(...readonlyIndexes, ...writableIndexes);\n        if (highestIndex >= addresses.length) {\n            throw new SolanaError(\n                SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n                {\n                    highestKnownIndex: addresses.length - 1,\n                    highestRequestedIndex: highestIndex,\n                    lookupTableAddress: lookup.lookupTableAddress,\n                },\n            );\n        }\n\n        const readOnlyForLookup: AccountLookupMeta[] = readonlyIndexes.map(r => ({\n            address: addresses[r],\n            addressIndex: r,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.READONLY,\n        }));\n        readOnlyMetas.push(...readOnlyForLookup);\n\n        const writableForLookup: AccountLookupMeta[] = writableIndexes.map(w => ({\n            address: addresses[w],\n            addressIndex: w,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.WRITABLE,\n        }));\n        writableMetas.push(...writableForLookup);\n    }\n\n    return [...writableMetas, ...readOnlyMetas];\n}\n\nfunction convertInstruction(\n    instruction: CompiledTransactionMessage['instructions'][0],\n    accountMetas: AccountMeta[],\n): Instruction {\n    const programAddress = accountMetas[instruction.programAddressIndex]?.address;\n    if (!programAddress) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, {\n            index: instruction.programAddressIndex,\n        });\n    }\n\n    const accounts = instruction.accountIndices?.map(accountIndex => accountMetas[accountIndex]);\n    const { data } = instruction;\n\n    return Object.freeze({\n        programAddress,\n        ...(accounts && accounts.length ? { accounts: Object.freeze(accounts) } : {}),\n        ...(data && data.length ? { data } : {}),\n    });\n}\n\ntype LifetimeConstraint =\n    | {\n          blockhash: Blockhash;\n          lastValidBlockHeight: bigint;\n      }\n    | {\n          nonce: Nonce;\n          nonceAccountAddress: Address;\n          nonceAuthorityAddress: Address;\n      };\n\nfunction getLifetimeConstraint(\n    messageLifetimeToken: string,\n    firstInstruction?: Instruction,\n    lastValidBlockHeight?: bigint,\n): LifetimeConstraint {\n    if (!firstInstruction || !isAdvanceNonceAccountInstruction(firstInstruction)) {\n        // first instruction is not advance durable nonce, so use blockhash lifetime constraint\n        return {\n            blockhash: messageLifetimeToken as Blockhash,\n            lastValidBlockHeight: lastValidBlockHeight ?? 2n ** 64n - 1n, // U64 MAX\n        };\n    } else {\n        // We know these accounts are defined because we checked `isAdvanceNonceAccountInstruction`\n        const nonceAccountAddress = firstInstruction.accounts[0].address;\n        assertIsAddress(nonceAccountAddress);\n\n        const nonceAuthorityAddress = firstInstruction.accounts[2].address;\n        assertIsAddress(nonceAuthorityAddress);\n\n        return {\n            nonce: messageLifetimeToken as Nonce,\n            nonceAccountAddress,\n            nonceAuthorityAddress,\n        };\n    }\n}\n\nexport type DecompileTransactionMessageConfig = {\n    /**\n     * If the compiled message loads addresses from one or more address lookup tables, you will have\n     * to supply a map of those tables to an array of the addresses they contained at the time that\n     * the transaction message was constructed.\n     *\n     * @see {@link decompileTransactionMessageFetchingLookupTables} if you do not already have this.\n     */\n    addressesByLookupTableAddress?: AddressesByLookupTableAddress;\n    /**\n     * If the compiled message has a blockhash-based lifetime constraint, you will have to supply\n     * the block height after which that blockhash is no longer valid for use as a lifetime\n     * constraint.\n     */\n    lastValidBlockHeight?: bigint;\n};\n\n/**\n * Converts the type of transaction message data structure appropriate for execution on the network\n * to the type of transaction message data structure designed for use in your application.\n *\n * Because compilation is a lossy process, you can not fully reconstruct a source message from a\n * compiled message without extra information. In order to faithfully reconstruct the original\n * source message you will need to supply supporting details about the lifetime constraint and the\n * concrete addresses of any accounts sourced from account lookup tables.\n *\n * @see {@link compileTransactionMessage}\n */\nexport function decompileTransactionMessage(\n    compiledTransactionMessage: CompiledTransactionMessage & CompiledTransactionMessageWithLifetime,\n    config?: DecompileTransactionMessageConfig,\n): BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithLifetime {\n    const feePayer = compiledTransactionMessage.staticAccounts[0];\n    if (!feePayer) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING);\n    }\n\n    const accountMetas = getAccountMetas(compiledTransactionMessage);\n    const accountLookupMetas =\n        'addressTableLookups' in compiledTransactionMessage &&\n        compiledTransactionMessage.addressTableLookups !== undefined &&\n        compiledTransactionMessage.addressTableLookups.length > 0\n            ? getAddressLookupMetas(\n                  compiledTransactionMessage.addressTableLookups,\n                  config?.addressesByLookupTableAddress ?? {},\n              )\n            : [];\n    const transactionMetas = [...accountMetas, ...accountLookupMetas];\n\n    const instructions: Instruction[] = compiledTransactionMessage.instructions.map(compiledInstruction =>\n        convertInstruction(compiledInstruction, transactionMetas),\n    );\n\n    const firstInstruction = instructions[0];\n    const lifetimeConstraint = getLifetimeConstraint(\n        compiledTransactionMessage.lifetimeToken,\n        firstInstruction,\n        config?.lastValidBlockHeight,\n    );\n\n    return pipe(\n        createTransactionMessage({ version: compiledTransactionMessage.version as TransactionVersion }),\n        m => setTransactionMessageFeePayer(feePayer, m),\n        m =>\n            instructions.reduce(\n                (acc, instruction) => appendTransactionMessageInstruction(instruction, acc),\n                m as BaseTransactionMessage & TransactionMessageWithFeePayer,\n            ),\n        m =>\n            'blockhash' in lifetimeConstraint\n                ? setTransactionMessageLifetimeUsingBlockhash(lifetimeConstraint, m)\n                : setTransactionMessageLifetimeUsingDurableNonce(lifetimeConstraint, m),\n    );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_NONCE_ACCOUNT_DISCRIMINATOR = 6;\n\nexport function getInitializeNonceAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(INITIALIZE_NONCE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type InitializeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNonceAccount extends string | AccountMeta<string> = string,\n  TAccountRecentBlockhashesSysvar extends\n    | string\n    | AccountMeta<string> = 'SysvarRecentB1ockHashes11111111111111111111',\n  TAccountRentSysvar extends\n    | string\n    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountNonceAccount extends string\n        ? WritableAccount<TAccountNonceAccount>\n        : TAccountNonceAccount,\n      TAccountRecentBlockhashesSysvar extends string\n        ? ReadonlyAccount<TAccountRecentBlockhashesSysvar>\n        : TAccountRecentBlockhashesSysvar,\n      TAccountRentSysvar extends string\n        ? ReadonlyAccount<TAccountRentSysvar>\n        : TAccountRentSysvar,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeNonceAccountInstructionData = {\n  discriminator: number;\n  nonceAuthority: Address;\n};\n\nexport type InitializeNonceAccountInstructionDataArgs = {\n  nonceAuthority: Address;\n};\n\nexport function getInitializeNonceAccountInstructionDataEncoder(): FixedSizeEncoder<InitializeNonceAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['nonceAuthority', getAddressEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_NONCE_ACCOUNT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeNonceAccountInstructionDataDecoder(): FixedSizeDecoder<InitializeNonceAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['nonceAuthority', getAddressDecoder()],\n  ]);\n}\n\nexport function getInitializeNonceAccountInstructionDataCodec(): FixedSizeCodec<\n  InitializeNonceAccountInstructionDataArgs,\n  InitializeNonceAccountInstructionData\n> {\n  return combineCodec(\n    getInitializeNonceAccountInstructionDataEncoder(),\n    getInitializeNonceAccountInstructionDataDecoder()\n  );\n}\n\nexport type InitializeNonceAccountInput<\n  TAccountNonceAccount extends string = string,\n  TAccountRecentBlockhashesSysvar extends string = string,\n  TAccountRentSysvar extends string = string,\n> = {\n  nonceAccount: Address<TAccountNonceAccount>;\n  recentBlockhashesSysvar?: Address<TAccountRecentBlockhashesSysvar>;\n  rentSysvar?: Address<TAccountRentSysvar>;\n  nonceAuthority: InitializeNonceAccountInstructionDataArgs['nonceAuthority'];\n};\n\nexport function getInitializeNonceAccountInstruction<\n  TAccountNonceAccount extends string,\n  TAccountRecentBlockhashesSysvar extends string,\n  TAccountRentSysvar extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: InitializeNonceAccountInput<\n    TAccountNonceAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountRentSysvar\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeNonceAccountInstruction<\n  TProgramAddress,\n  TAccountNonceAccount,\n  TAccountRecentBlockhashesSysvar,\n  TAccountRentSysvar\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nonceAccount: { value: input.nonceAccount ?? null, isWritable: true },\n    recentBlockhashesSysvar: {\n      value: input.recentBlockhashesSysvar ?? null,\n      isWritable: false,\n    },\n    rentSysvar: { value: input.rentSysvar ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.recentBlockhashesSysvar.value) {\n    accounts.recentBlockhashesSysvar.value =\n      'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\n  }\n  if (!accounts.rentSysvar.value) {\n    accounts.rentSysvar.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.nonceAccount),\n      getAccountMeta(accounts.recentBlockhashesSysvar),\n      getAccountMeta(accounts.rentSysvar),\n    ],\n    programAddress,\n    data: getInitializeNonceAccountInstructionDataEncoder().encode(\n      args as InitializeNonceAccountInstructionDataArgs\n    ),\n  } as InitializeNonceAccountInstruction<\n    TProgramAddress,\n    TAccountNonceAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountRentSysvar\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    nonceAccount: TAccountMetas[0];\n    recentBlockhashesSysvar: TAccountMetas[1];\n    rentSysvar: TAccountMetas[2];\n  };\n  data: InitializeNonceAccountInstructionData;\n};\n\nexport function parseInitializeNonceAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeNonceAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nonceAccount: getNextAccount(),\n      recentBlockhashesSysvar: getNextAccount(),\n      rentSysvar: getNextAccount(),\n    },\n    data: getInitializeNonceAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const BURN_CHECKED_DISCRIMINATOR = 15;\n\nexport function getBurnCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(BURN_CHECKED_DISCRIMINATOR);\n}\n\nexport type BurnCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type BurnCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to burn. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type BurnCheckedInstructionDataArgs = {\n  /** The amount of tokens to burn. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getBurnCheckedInstructionDataEncoder(): FixedSizeEncoder<BurnCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: BURN_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getBurnCheckedInstructionDataDecoder(): FixedSizeDecoder<BurnCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getBurnCheckedInstructionDataCodec(): FixedSizeCodec<\n  BurnCheckedInstructionDataArgs,\n  BurnCheckedInstructionData\n> {\n  return combineCodec(\n    getBurnCheckedInstructionDataEncoder(),\n    getBurnCheckedInstructionDataDecoder()\n  );\n}\n\nexport type BurnCheckedInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The account to burn from. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: BurnCheckedInstructionDataArgs['amount'];\n  decimals: BurnCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getBurnCheckedInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: BurnCheckedInput<TAccountAccount, TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): BurnCheckedInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getBurnCheckedInstructionDataEncoder().encode(\n      args as BurnCheckedInstructionDataArgs\n    ),\n  } as BurnCheckedInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedBurnCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to burn from. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: BurnCheckedInstructionData;\n};\n\nexport function parseBurnCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedBurnCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getBurnCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","import {\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR,\n    SolanaErrorCode,\n} from './codes';\nimport { SolanaErrorContext } from './context';\nimport { SolanaError } from './error';\nimport { safeCaptureStackTrace } from './stack-trace';\nimport { getSolanaErrorFromTransactionError } from './transaction-error';\n\ninterface RpcErrorResponse {\n    code: bigint | number;\n    data?: unknown;\n    message: string;\n}\n\ntype TransactionError = string | { [key: string]: unknown };\n\n/**\n * Keep in sync with https://github.com/anza-xyz/agave/blob/master/rpc-client-types/src/response.rs\n * @hidden\n */\nexport interface RpcSimulateTransactionResult {\n    accounts:\n        | ({\n              data:\n                  | string // LegacyBinary\n                  | {\n                        // Json\n                        parsed: unknown;\n                        program: string;\n                        space: number;\n                    }\n                  // Binary\n                  | [encodedBytes: string, encoding: 'base58' | 'base64' | 'base64+zstd' | 'binary' | 'jsonParsed'];\n              executable: boolean;\n              lamports: number;\n              owner: string;\n              rentEpoch: number;\n              space?: number;\n          } | null)[]\n        | null;\n    err: TransactionError | null;\n    // Enabled by `enable_cpi_recording`\n    innerInstructions?:\n        | {\n              index: number;\n              instructions: (\n                  | {\n                        // Compiled\n                        accounts: number[];\n                        data: string;\n                        programIdIndex: number;\n                        stackHeight?: number;\n                    }\n                  | {\n                        // Parsed\n                        parsed: unknown;\n                        program: string;\n                        programId: string;\n                        stackHeight?: number;\n                    }\n                  | {\n                        // PartiallyDecoded\n                        accounts: string[];\n                        data: string;\n                        programId: string;\n                        stackHeight?: number;\n                    }\n              )[];\n          }[]\n        | null;\n    loadedAccountsDataSize: number | null;\n    logs: string[] | null;\n    replacementBlockhash: string | null;\n    returnData: {\n        data: [string, 'base64'];\n        programId: string;\n    } | null;\n    unitsConsumed: bigint | null;\n}\n\nexport function getSolanaErrorFromJsonRpcError(putativeErrorResponse: unknown): SolanaError {\n    let out: SolanaError;\n    if (isRpcErrorResponse(putativeErrorResponse)) {\n        const { code: rawCode, data, message } = putativeErrorResponse;\n        const code = Number(rawCode);\n        if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE) {\n            const { err, ...preflightErrorContext } = data as RpcSimulateTransactionResult;\n            const causeObject = err ? { cause: getSolanaErrorFromTransactionError(err) } : null;\n            out = new SolanaError(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, {\n                ...preflightErrorContext,\n                ...causeObject,\n            });\n        } else {\n            let errorContext;\n            switch (code) {\n                case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR:\n                case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS:\n                case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST:\n                case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND:\n                case SOLANA_ERROR__JSON_RPC__PARSE_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SCAN_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:\n                    // The server supplies no structured data, but rather a pre-formatted message. Put\n                    // the server message in `context` so as not to completely lose the data. The long\n                    // term fix for this is to add data to the server responses and modify the\n                    // messages in `@solana/errors` to be actual format strings.\n                    errorContext = { __serverMessage: message };\n                    break;\n                default:\n                    if (typeof data === 'object' && !Array.isArray(data)) {\n                        errorContext = data;\n                    }\n            }\n            out = new SolanaError(code as SolanaErrorCode, errorContext as SolanaErrorContext[SolanaErrorCode]);\n        }\n    } else {\n        const message =\n            typeof putativeErrorResponse === 'object' &&\n            putativeErrorResponse !== null &&\n            'message' in putativeErrorResponse &&\n            typeof putativeErrorResponse.message === 'string'\n                ? putativeErrorResponse.message\n                : 'Malformed JSON-RPC error with no message attribute';\n        out = new SolanaError(SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR, { error: putativeErrorResponse, message });\n    }\n    safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);\n    return out;\n}\n\nfunction isRpcErrorResponse(value: unknown): value is RpcErrorResponse {\n    return (\n        typeof value === 'object' &&\n        value !== null &&\n        'code' in value &&\n        'message' in value &&\n        (typeof value.code === 'number' || typeof value.code === 'bigint') &&\n        typeof value.message === 'string'\n    );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_SOL_DISCRIMINATOR = 2;\n\nexport function getTransferSolDiscriminatorBytes() {\n  return getU32Encoder().encode(TRANSFER_SOL_DISCRIMINATOR);\n}\n\nexport type TransferSolInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountDestination extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableSignerAccount<TAccountSource> &\n            AccountSignerMeta<TAccountSource>\n        : TAccountSource,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferSolInstructionData = {\n  discriminator: number;\n  amount: bigint;\n};\n\nexport type TransferSolInstructionDataArgs = { amount: number | bigint };\n\nexport function getTransferSolInstructionDataEncoder(): FixedSizeEncoder<TransferSolInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: TRANSFER_SOL_DISCRIMINATOR })\n  );\n}\n\nexport function getTransferSolInstructionDataDecoder(): FixedSizeDecoder<TransferSolInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getTransferSolInstructionDataCodec(): FixedSizeCodec<\n  TransferSolInstructionDataArgs,\n  TransferSolInstructionData\n> {\n  return combineCodec(\n    getTransferSolInstructionDataEncoder(),\n    getTransferSolInstructionDataDecoder()\n  );\n}\n\nexport type TransferSolInput<\n  TAccountSource extends string = string,\n  TAccountDestination extends string = string,\n> = {\n  source: TransactionSigner<TAccountSource>;\n  destination: Address<TAccountDestination>;\n  amount: TransferSolInstructionDataArgs['amount'];\n};\n\nexport function getTransferSolInstruction<\n  TAccountSource extends string,\n  TAccountDestination extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: TransferSolInput<TAccountSource, TAccountDestination>,\n  config?: { programAddress?: TProgramAddress }\n): TransferSolInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountDestination\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.destination),\n    ],\n    programAddress,\n    data: getTransferSolInstructionDataEncoder().encode(\n      args as TransferSolInstructionDataArgs\n    ),\n  } as TransferSolInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountDestination\n  >;\n\n  return instruction;\n}\n\nexport type ParsedTransferSolInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    source: TAccountMetas[0];\n    destination: TAccountMetas[1];\n  };\n  data: TransferSolInstructionData;\n};\n\nexport function parseTransferSolInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedTransferSolInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      destination: getNextAccount(),\n    },\n    data: getTransferSolInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const CLOSE_ACCOUNT_DISCRIMINATOR = 9;\n\nexport function getCloseAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(CLOSE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type CloseAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountDestination extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CloseAccountInstructionData = { discriminator: number };\n\nexport type CloseAccountInstructionDataArgs = {};\n\nexport function getCloseAccountInstructionDataEncoder(): FixedSizeEncoder<CloseAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: CLOSE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getCloseAccountInstructionDataDecoder(): FixedSizeDecoder<CloseAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCloseAccountInstructionDataCodec(): FixedSizeCodec<\n  CloseAccountInstructionDataArgs,\n  CloseAccountInstructionData\n> {\n  return combineCodec(\n    getCloseAccountInstructionDataEncoder(),\n    getCloseAccountInstructionDataDecoder()\n  );\n}\n\nexport type CloseAccountInput<\n  TAccountAccount extends string = string,\n  TAccountDestination extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The account to close. */\n  account: Address<TAccountAccount>;\n  /** The destination account. */\n  destination: Address<TAccountDestination>;\n  /** The account's owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getCloseAccountInstruction<\n  TAccountAccount extends string,\n  TAccountDestination extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CloseAccountInput<TAccountAccount, TAccountDestination, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): CloseAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountDestination,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getCloseAccountInstructionDataEncoder().encode({}),\n  } as CloseAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountDestination,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCloseAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to close. */\n    account: TAccountMetas[0];\n    /** The destination account. */\n    destination: TAccountMetas[1];\n    /** The account's owner or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: CloseAccountInstructionData;\n};\n\nexport function parseCloseAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedCloseAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      destination: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getCloseAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_SOL_WITH_SEED_DISCRIMINATOR = 11;\n\nexport function getTransferSolWithSeedDiscriminatorBytes() {\n  return getU32Encoder().encode(TRANSFER_SOL_WITH_SEED_DISCRIMINATOR);\n}\n\nexport type TransferSolWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountBaseAccount extends string | AccountMeta<string> = string,\n  TAccountDestination extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountBaseAccount extends string\n        ? ReadonlySignerAccount<TAccountBaseAccount> &\n            AccountSignerMeta<TAccountBaseAccount>\n        : TAccountBaseAccount,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferSolWithSeedInstructionData = {\n  discriminator: number;\n  amount: bigint;\n  fromSeed: string;\n  fromOwner: Address;\n};\n\nexport type TransferSolWithSeedInstructionDataArgs = {\n  amount: number | bigint;\n  fromSeed: string;\n  fromOwner: Address;\n};\n\nexport function getTransferSolWithSeedInstructionDataEncoder(): Encoder<TransferSolWithSeedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['amount', getU64Encoder()],\n      ['fromSeed', addEncoderSizePrefix(getUtf8Encoder(), getU64Encoder())],\n      ['fromOwner', getAddressEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: TRANSFER_SOL_WITH_SEED_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getTransferSolWithSeedInstructionDataDecoder(): Decoder<TransferSolWithSeedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['amount', getU64Decoder()],\n    ['fromSeed', addDecoderSizePrefix(getUtf8Decoder(), getU64Decoder())],\n    ['fromOwner', getAddressDecoder()],\n  ]);\n}\n\nexport function getTransferSolWithSeedInstructionDataCodec(): Codec<\n  TransferSolWithSeedInstructionDataArgs,\n  TransferSolWithSeedInstructionData\n> {\n  return combineCodec(\n    getTransferSolWithSeedInstructionDataEncoder(),\n    getTransferSolWithSeedInstructionDataDecoder()\n  );\n}\n\nexport type TransferSolWithSeedInput<\n  TAccountSource extends string = string,\n  TAccountBaseAccount extends string = string,\n  TAccountDestination extends string = string,\n> = {\n  source: Address<TAccountSource>;\n  baseAccount: TransactionSigner<TAccountBaseAccount>;\n  destination: Address<TAccountDestination>;\n  amount: TransferSolWithSeedInstructionDataArgs['amount'];\n  fromSeed: TransferSolWithSeedInstructionDataArgs['fromSeed'];\n  fromOwner: TransferSolWithSeedInstructionDataArgs['fromOwner'];\n};\n\nexport function getTransferSolWithSeedInstruction<\n  TAccountSource extends string,\n  TAccountBaseAccount extends string,\n  TAccountDestination extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: TransferSolWithSeedInput<\n    TAccountSource,\n    TAccountBaseAccount,\n    TAccountDestination\n  >,\n  config?: { programAddress?: TProgramAddress }\n): TransferSolWithSeedInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountBaseAccount,\n  TAccountDestination\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    baseAccount: { value: input.baseAccount ?? null, isWritable: false },\n    destination: { value: input.destination ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.baseAccount),\n      getAccountMeta(accounts.destination),\n    ],\n    programAddress,\n    data: getTransferSolWithSeedInstructionDataEncoder().encode(\n      args as TransferSolWithSeedInstructionDataArgs\n    ),\n  } as TransferSolWithSeedInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountBaseAccount,\n    TAccountDestination\n  >;\n\n  return instruction;\n}\n\nexport type ParsedTransferSolWithSeedInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    source: TAccountMetas[0];\n    baseAccount: TAccountMetas[1];\n    destination: TAccountMetas[2];\n  };\n  data: TransferSolWithSeedInstructionData;\n};\n\nexport function parseTransferSolWithSeedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedTransferSolWithSeedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      baseAccount: getNextAccount(),\n      destination: getNextAccount(),\n    },\n    data: getTransferSolWithSeedInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  getAddressEncoder,\n  getProgramDerivedAddress,\n  type Address,\n  type ProgramDerivedAddress,\n} from '@solana/kit';\n\nexport type AssociatedTokenSeeds = {\n  /** The wallet address of the associated token account. */\n  owner: Address;\n  /** The address of the token program to use. */\n  tokenProgram: Address;\n  /** The mint address of the associated token account. */\n  mint: Address;\n};\n\nexport async function findAssociatedTokenPda(\n  seeds: AssociatedTokenSeeds,\n  config: { programAddress?: Address | undefined } = {}\n): Promise<ProgramDerivedAddress> {\n  const {\n    programAddress = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>,\n  } = config;\n  return await getProgramDerivedAddress({\n    programAddress,\n    seeds: [\n      getAddressEncoder().encode(seeds.owner),\n      getAddressEncoder().encode(seeds.tokenProgram),\n      getAddressEncoder().encode(seeds.mint),\n    ],\n  });\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { findAssociatedTokenPda } from '../pdas';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport {\n  expectAddress,\n  getAccountMetaFactory,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR = 0;\n\nexport function getCreateAssociatedTokenDiscriminatorBytes() {\n  return getU8Encoder().encode(CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR);\n}\n\nexport type CreateAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountPayer extends string | AccountMeta<string> = string,\n  TAccountAta extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | AccountMeta<string> = '11111111111111111111111111111111',\n  TAccountTokenProgram extends\n    | string\n    | AccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            AccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountAta extends string ? WritableAccount<TAccountAta> : TAccountAta,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateAssociatedTokenInstructionData = { discriminator: number };\n\nexport type CreateAssociatedTokenInstructionDataArgs = {};\n\nexport function getCreateAssociatedTokenInstructionDataEncoder(): FixedSizeEncoder<CreateAssociatedTokenInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getCreateAssociatedTokenInstructionDataDecoder(): FixedSizeDecoder<CreateAssociatedTokenInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCreateAssociatedTokenInstructionDataCodec(): FixedSizeCodec<\n  CreateAssociatedTokenInstructionDataArgs,\n  CreateAssociatedTokenInstructionData\n> {\n  return combineCodec(\n    getCreateAssociatedTokenInstructionDataEncoder(),\n    getCreateAssociatedTokenInstructionDataDecoder()\n  );\n}\n\nexport type CreateAssociatedTokenAsyncInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata?: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport async function getCreateAssociatedTokenInstructionAsync<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenAsyncInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): Promise<\n  CreateAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n  if (!accounts.ata.value) {\n    accounts.ata.value = await findAssociatedTokenPda({\n      owner: expectAddress(accounts.owner.value),\n      tokenProgram: expectAddress(accounts.tokenProgram.value),\n      mint: expectAddress(accounts.mint.value),\n    });\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getCreateAssociatedTokenInstructionDataEncoder().encode({}),\n  } as CreateAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type CreateAssociatedTokenInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getCreateAssociatedTokenInstruction<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CreateAssociatedTokenInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountAta,\n  TAccountOwner,\n  TAccountMint,\n  TAccountSystemProgram,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getCreateAssociatedTokenInstructionDataEncoder().encode({}),\n  } as CreateAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCreateAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Funding account (must be a system account). */\n    payer: TAccountMetas[0];\n    /** Associated token account address to be created. */\n    ata: TAccountMetas[1];\n    /** Wallet address for the new associated token account. */\n    owner: TAccountMetas[2];\n    /** The token mint for the new associated token account. */\n    mint: TAccountMetas[3];\n    /** System program. */\n    systemProgram: TAccountMetas[4];\n    /** SPL Token program. */\n    tokenProgram: TAccountMetas[5];\n  };\n  data: CreateAssociatedTokenInstructionData;\n};\n\nexport function parseCreateAssociatedTokenInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedCreateAssociatedTokenInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      ata: getNextAccount(),\n      owner: getNextAccount(),\n      mint: getNextAccount(),\n      systemProgram: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getCreateAssociatedTokenInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPGRADE_NONCE_ACCOUNT_DISCRIMINATOR = 12;\n\nexport function getUpgradeNonceAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(UPGRADE_NONCE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type UpgradeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNonceAccount extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountNonceAccount extends string\n        ? WritableAccount<TAccountNonceAccount>\n        : TAccountNonceAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpgradeNonceAccountInstructionData = { discriminator: number };\n\nexport type UpgradeNonceAccountInstructionDataArgs = {};\n\nexport function getUpgradeNonceAccountInstructionDataEncoder(): FixedSizeEncoder<UpgradeNonceAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU32Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: UPGRADE_NONCE_ACCOUNT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpgradeNonceAccountInstructionDataDecoder(): FixedSizeDecoder<UpgradeNonceAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU32Decoder()]]);\n}\n\nexport function getUpgradeNonceAccountInstructionDataCodec(): FixedSizeCodec<\n  UpgradeNonceAccountInstructionDataArgs,\n  UpgradeNonceAccountInstructionData\n> {\n  return combineCodec(\n    getUpgradeNonceAccountInstructionDataEncoder(),\n    getUpgradeNonceAccountInstructionDataDecoder()\n  );\n}\n\nexport type UpgradeNonceAccountInput<\n  TAccountNonceAccount extends string = string,\n> = {\n  nonceAccount: Address<TAccountNonceAccount>;\n};\n\nexport function getUpgradeNonceAccountInstruction<\n  TAccountNonceAccount extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: UpgradeNonceAccountInput<TAccountNonceAccount>,\n  config?: { programAddress?: TProgramAddress }\n): UpgradeNonceAccountInstruction<TProgramAddress, TAccountNonceAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nonceAccount: { value: input.nonceAccount ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.nonceAccount)],\n    programAddress,\n    data: getUpgradeNonceAccountInstructionDataEncoder().encode({}),\n  } as UpgradeNonceAccountInstruction<TProgramAddress, TAccountNonceAccount>;\n\n  return instruction;\n}\n\nexport type ParsedUpgradeNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    nonceAccount: TAccountMetas[0];\n  };\n  data: UpgradeNonceAccountInstructionData;\n};\n\nexport function parseUpgradeNonceAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpgradeNonceAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nonceAccount: getNextAccount(),\n    },\n    data: getUpgradeNonceAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { SYSTEM_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const WITHDRAW_NONCE_ACCOUNT_DISCRIMINATOR = 5;\n\nexport function getWithdrawNonceAccountDiscriminatorBytes() {\n  return getU32Encoder().encode(WITHDRAW_NONCE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type WithdrawNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountNonceAccount extends string | AccountMeta<string> = string,\n  TAccountRecipientAccount extends string | AccountMeta<string> = string,\n  TAccountRecentBlockhashesSysvar extends\n    | string\n    | AccountMeta<string> = 'SysvarRecentB1ockHashes11111111111111111111',\n  TAccountRentSysvar extends\n    | string\n    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TAccountNonceAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountNonceAccount extends string\n        ? WritableAccount<TAccountNonceAccount>\n        : TAccountNonceAccount,\n      TAccountRecipientAccount extends string\n        ? WritableAccount<TAccountRecipientAccount>\n        : TAccountRecipientAccount,\n      TAccountRecentBlockhashesSysvar extends string\n        ? ReadonlyAccount<TAccountRecentBlockhashesSysvar>\n        : TAccountRecentBlockhashesSysvar,\n      TAccountRentSysvar extends string\n        ? ReadonlyAccount<TAccountRentSysvar>\n        : TAccountRentSysvar,\n      TAccountNonceAuthority extends string\n        ? ReadonlySignerAccount<TAccountNonceAuthority> &\n            AccountSignerMeta<TAccountNonceAuthority>\n        : TAccountNonceAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawNonceAccountInstructionData = {\n  discriminator: number;\n  withdrawAmount: bigint;\n};\n\nexport type WithdrawNonceAccountInstructionDataArgs = {\n  withdrawAmount: number | bigint;\n};\n\nexport function getWithdrawNonceAccountInstructionDataEncoder(): FixedSizeEncoder<WithdrawNonceAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['withdrawAmount', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: WITHDRAW_NONCE_ACCOUNT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawNonceAccountInstructionDataDecoder(): FixedSizeDecoder<WithdrawNonceAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['withdrawAmount', getU64Decoder()],\n  ]);\n}\n\nexport function getWithdrawNonceAccountInstructionDataCodec(): FixedSizeCodec<\n  WithdrawNonceAccountInstructionDataArgs,\n  WithdrawNonceAccountInstructionData\n> {\n  return combineCodec(\n    getWithdrawNonceAccountInstructionDataEncoder(),\n    getWithdrawNonceAccountInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawNonceAccountInput<\n  TAccountNonceAccount extends string = string,\n  TAccountRecipientAccount extends string = string,\n  TAccountRecentBlockhashesSysvar extends string = string,\n  TAccountRentSysvar extends string = string,\n  TAccountNonceAuthority extends string = string,\n> = {\n  nonceAccount: Address<TAccountNonceAccount>;\n  recipientAccount: Address<TAccountRecipientAccount>;\n  recentBlockhashesSysvar?: Address<TAccountRecentBlockhashesSysvar>;\n  rentSysvar?: Address<TAccountRentSysvar>;\n  nonceAuthority: TransactionSigner<TAccountNonceAuthority>;\n  withdrawAmount: WithdrawNonceAccountInstructionDataArgs['withdrawAmount'];\n};\n\nexport function getWithdrawNonceAccountInstruction<\n  TAccountNonceAccount extends string,\n  TAccountRecipientAccount extends string,\n  TAccountRecentBlockhashesSysvar extends string,\n  TAccountRentSysvar extends string,\n  TAccountNonceAuthority extends string,\n  TProgramAddress extends Address = typeof SYSTEM_PROGRAM_ADDRESS,\n>(\n  input: WithdrawNonceAccountInput<\n    TAccountNonceAccount,\n    TAccountRecipientAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountRentSysvar,\n    TAccountNonceAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawNonceAccountInstruction<\n  TProgramAddress,\n  TAccountNonceAccount,\n  TAccountRecipientAccount,\n  TAccountRecentBlockhashesSysvar,\n  TAccountRentSysvar,\n  TAccountNonceAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? SYSTEM_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nonceAccount: { value: input.nonceAccount ?? null, isWritable: true },\n    recipientAccount: {\n      value: input.recipientAccount ?? null,\n      isWritable: true,\n    },\n    recentBlockhashesSysvar: {\n      value: input.recentBlockhashesSysvar ?? null,\n      isWritable: false,\n    },\n    rentSysvar: { value: input.rentSysvar ?? null, isWritable: false },\n    nonceAuthority: { value: input.nonceAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.recentBlockhashesSysvar.value) {\n    accounts.recentBlockhashesSysvar.value =\n      'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\n  }\n  if (!accounts.rentSysvar.value) {\n    accounts.rentSysvar.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'omitted');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.nonceAccount),\n      getAccountMeta(accounts.recipientAccount),\n      getAccountMeta(accounts.recentBlockhashesSysvar),\n      getAccountMeta(accounts.rentSysvar),\n      getAccountMeta(accounts.nonceAuthority),\n    ],\n    programAddress,\n    data: getWithdrawNonceAccountInstructionDataEncoder().encode(\n      args as WithdrawNonceAccountInstructionDataArgs\n    ),\n  } as WithdrawNonceAccountInstruction<\n    TProgramAddress,\n    TAccountNonceAccount,\n    TAccountRecipientAccount,\n    TAccountRecentBlockhashesSysvar,\n    TAccountRentSysvar,\n    TAccountNonceAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedWithdrawNonceAccountInstruction<\n  TProgram extends string = typeof SYSTEM_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    nonceAccount: TAccountMetas[0];\n    recipientAccount: TAccountMetas[1];\n    recentBlockhashesSysvar: TAccountMetas[2];\n    rentSysvar: TAccountMetas[3];\n    nonceAuthority: TAccountMetas[4];\n  };\n  data: WithdrawNonceAccountInstructionData;\n};\n\nexport function parseWithdrawNonceAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedWithdrawNonceAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nonceAccount: getNextAccount(),\n      recipientAccount: getNextAccount(),\n      recentBlockhashesSysvar: getNextAccount(),\n      rentSysvar: getNextAccount(),\n      nonceAuthority: getNextAccount(),\n    },\n    data: getWithdrawNonceAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { findAssociatedTokenPda } from '../pdas';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport {\n  expectAddress,\n  getAccountMetaFactory,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR = 1;\n\nexport function getCreateAssociatedTokenIdempotentDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR\n  );\n}\n\nexport type CreateAssociatedTokenIdempotentInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountPayer extends string | AccountMeta<string> = string,\n  TAccountAta extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | AccountMeta<string> = '11111111111111111111111111111111',\n  TAccountTokenProgram extends\n    | string\n    | AccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            AccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountAta extends string ? WritableAccount<TAccountAta> : TAccountAta,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateAssociatedTokenIdempotentInstructionData = {\n  discriminator: number;\n};\n\nexport type CreateAssociatedTokenIdempotentInstructionDataArgs = {};\n\nexport function getCreateAssociatedTokenIdempotentInstructionDataEncoder(): FixedSizeEncoder<CreateAssociatedTokenIdempotentInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getCreateAssociatedTokenIdempotentInstructionDataDecoder(): FixedSizeDecoder<CreateAssociatedTokenIdempotentInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCreateAssociatedTokenIdempotentInstructionDataCodec(): FixedSizeCodec<\n  CreateAssociatedTokenIdempotentInstructionDataArgs,\n  CreateAssociatedTokenIdempotentInstructionData\n> {\n  return combineCodec(\n    getCreateAssociatedTokenIdempotentInstructionDataEncoder(),\n    getCreateAssociatedTokenIdempotentInstructionDataDecoder()\n  );\n}\n\nexport type CreateAssociatedTokenIdempotentAsyncInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata?: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport async function getCreateAssociatedTokenIdempotentInstructionAsync<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenIdempotentAsyncInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): Promise<\n  CreateAssociatedTokenIdempotentInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n  if (!accounts.ata.value) {\n    accounts.ata.value = await findAssociatedTokenPda({\n      owner: expectAddress(accounts.owner.value),\n      tokenProgram: expectAddress(accounts.tokenProgram.value),\n      mint: expectAddress(accounts.mint.value),\n    });\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getCreateAssociatedTokenIdempotentInstructionDataEncoder().encode({}),\n  } as CreateAssociatedTokenIdempotentInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type CreateAssociatedTokenIdempotentInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getCreateAssociatedTokenIdempotentInstruction<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenIdempotentInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CreateAssociatedTokenIdempotentInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountAta,\n  TAccountOwner,\n  TAccountMint,\n  TAccountSystemProgram,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getCreateAssociatedTokenIdempotentInstructionDataEncoder().encode({}),\n  } as CreateAssociatedTokenIdempotentInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCreateAssociatedTokenIdempotentInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Funding account (must be a system account). */\n    payer: TAccountMetas[0];\n    /** Associated token account address to be created. */\n    ata: TAccountMetas[1];\n    /** Wallet address for the new associated token account. */\n    owner: TAccountMetas[2];\n    /** The token mint for the new associated token account. */\n    mint: TAccountMetas[3];\n    /** System program. */\n    systemProgram: TAccountMetas[4];\n    /** SPL Token program. */\n    tokenProgram: TAccountMetas[5];\n  };\n  data: CreateAssociatedTokenIdempotentInstructionData;\n};\n\nexport function parseCreateAssociatedTokenIdempotentInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedCreateAssociatedTokenIdempotentInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      ata: getNextAccount(),\n      owner: getNextAccount(),\n      mint: getNextAccount(),\n      systemProgram: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getCreateAssociatedTokenIdempotentInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const FREEZE_ACCOUNT_DISCRIMINATOR = 10;\n\nexport function getFreezeAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(FREEZE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type FreezeAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type FreezeAccountInstructionData = { discriminator: number };\n\nexport type FreezeAccountInstructionDataArgs = {};\n\nexport function getFreezeAccountInstructionDataEncoder(): FixedSizeEncoder<FreezeAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: FREEZE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getFreezeAccountInstructionDataDecoder(): FixedSizeDecoder<FreezeAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getFreezeAccountInstructionDataCodec(): FixedSizeCodec<\n  FreezeAccountInstructionDataArgs,\n  FreezeAccountInstructionData\n> {\n  return combineCodec(\n    getFreezeAccountInstructionDataEncoder(),\n    getFreezeAccountInstructionDataDecoder()\n  );\n}\n\nexport type FreezeAccountInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The account to freeze. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The mint freeze authority or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getFreezeAccountInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: FreezeAccountInput<TAccountAccount, TAccountMint, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): FreezeAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getFreezeAccountInstructionDataEncoder().encode({}),\n  } as FreezeAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedFreezeAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to freeze. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The mint freeze authority or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: FreezeAccountInstructionData;\n};\n\nexport function parseFreezeAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedFreezeAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getFreezeAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR = 21;\n\nexport function getGetAccountDataSizeDiscriminatorBytes() {\n  return getU8Encoder().encode(GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR);\n}\n\nexport type GetAccountDataSizeInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type GetAccountDataSizeInstructionData = { discriminator: number };\n\nexport type GetAccountDataSizeInstructionDataArgs = {};\n\nexport function getGetAccountDataSizeInstructionDataEncoder(): FixedSizeEncoder<GetAccountDataSizeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getGetAccountDataSizeInstructionDataDecoder(): FixedSizeDecoder<GetAccountDataSizeInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getGetAccountDataSizeInstructionDataCodec(): FixedSizeCodec<\n  GetAccountDataSizeInstructionDataArgs,\n  GetAccountDataSizeInstructionData\n> {\n  return combineCodec(\n    getGetAccountDataSizeInstructionDataEncoder(),\n    getGetAccountDataSizeInstructionDataDecoder()\n  );\n}\n\nexport type GetAccountDataSizeInput<TAccountMint extends string = string> = {\n  /** The mint to calculate for. */\n  mint: Address<TAccountMint>;\n};\n\nexport function getGetAccountDataSizeInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: GetAccountDataSizeInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): GetAccountDataSizeInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getGetAccountDataSizeInstructionDataEncoder().encode({}),\n  } as GetAccountDataSizeInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedGetAccountDataSizeInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to calculate for. */\n    mint: TAccountMetas[0];\n  };\n  data: GetAccountDataSizeInstructionData;\n};\n\nexport function parseGetAccountDataSizeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedGetAccountDataSizeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getGetAccountDataSizeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_ACCOUNT_DISCRIMINATOR = 1;\n\nexport function getInitializeAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type InitializeAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeAccountInstructionData = { discriminator: number };\n\nexport type InitializeAccountInstructionDataArgs = {};\n\nexport function getInitializeAccountInstructionDataEncoder(): FixedSizeEncoder<InitializeAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeAccountInstructionDataDecoder(): FixedSizeDecoder<InitializeAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getInitializeAccountInstructionDataCodec(): FixedSizeCodec<\n  InitializeAccountInstructionDataArgs,\n  InitializeAccountInstructionData\n> {\n  return combineCodec(\n    getInitializeAccountInstructionDataEncoder(),\n    getInitializeAccountInstructionDataDecoder()\n  );\n}\n\nexport type InitializeAccountInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountOwner extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n  /** The mint this account will be associated with. */\n  mint: Address<TAccountMint>;\n  /** The new account's owner/multisignature. */\n  owner: Address<TAccountOwner>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n};\n\nexport function getInitializeAccountInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountOwner extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeAccountInput<\n    TAccountAccount,\n    TAccountMint,\n    TAccountOwner,\n    TAccountRent\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  TAccountOwner,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.rent),\n    ],\n    programAddress,\n    data: getInitializeAccountInstructionDataEncoder().encode({}),\n  } as InitializeAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    TAccountOwner,\n    TAccountRent\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n    /** The mint this account will be associated with. */\n    mint: TAccountMetas[1];\n    /** The new account's owner/multisignature. */\n    owner: TAccountMetas[2];\n    /** Rent sysvar. */\n    rent: TAccountMetas[3];\n  };\n  data: InitializeAccountInstructionData;\n};\n\nexport function parseInitializeAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_ACCOUNT2_DISCRIMINATOR = 16;\n\nexport function getInitializeAccount2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT2_DISCRIMINATOR);\n}\n\nexport type InitializeAccount2Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeAccount2InstructionData = {\n  discriminator: number;\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport type InitializeAccount2InstructionDataArgs = {\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport function getInitializeAccount2InstructionDataEncoder(): FixedSizeEncoder<InitializeAccount2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['owner', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT2_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeAccount2InstructionDataDecoder(): FixedSizeDecoder<InitializeAccount2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['owner', getAddressDecoder()],\n  ]);\n}\n\nexport function getInitializeAccount2InstructionDataCodec(): FixedSizeCodec<\n  InitializeAccount2InstructionDataArgs,\n  InitializeAccount2InstructionData\n> {\n  return combineCodec(\n    getInitializeAccount2InstructionDataEncoder(),\n    getInitializeAccount2InstructionDataDecoder()\n  );\n}\n\nexport type InitializeAccount2Input<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n  /** The mint this account will be associated with. */\n  mint: Address<TAccountMint>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n  owner: InitializeAccount2InstructionDataArgs['owner'];\n};\n\nexport function getInitializeAccount2Instruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeAccount2Input<TAccountAccount, TAccountMint, TAccountRent>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeAccount2Instruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.rent),\n    ],\n    programAddress,\n    data: getInitializeAccount2InstructionDataEncoder().encode(\n      args as InitializeAccount2InstructionDataArgs\n    ),\n  } as InitializeAccount2Instruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    TAccountRent\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeAccount2Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n    /** The mint this account will be associated with. */\n    mint: TAccountMetas[1];\n    /** Rent sysvar. */\n    rent: TAccountMetas[2];\n  };\n  data: InitializeAccount2InstructionData;\n};\n\nexport function parseInitializeAccount2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeAccount2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeAccount2InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_ACCOUNT3_DISCRIMINATOR = 18;\n\nexport function getInitializeAccount3DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT3_DISCRIMINATOR);\n}\n\nexport type InitializeAccount3Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeAccount3InstructionData = {\n  discriminator: number;\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport type InitializeAccount3InstructionDataArgs = {\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport function getInitializeAccount3InstructionDataEncoder(): FixedSizeEncoder<InitializeAccount3InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['owner', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT3_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeAccount3InstructionDataDecoder(): FixedSizeDecoder<InitializeAccount3InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['owner', getAddressDecoder()],\n  ]);\n}\n\nexport function getInitializeAccount3InstructionDataCodec(): FixedSizeCodec<\n  InitializeAccount3InstructionDataArgs,\n  InitializeAccount3InstructionData\n> {\n  return combineCodec(\n    getInitializeAccount3InstructionDataEncoder(),\n    getInitializeAccount3InstructionDataDecoder()\n  );\n}\n\nexport type InitializeAccount3Input<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n  /** The mint this account will be associated with. */\n  mint: Address<TAccountMint>;\n  owner: InitializeAccount3InstructionDataArgs['owner'];\n};\n\nexport function getInitializeAccount3Instruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeAccount3Input<TAccountAccount, TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeAccount3Instruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.account), getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeAccount3InstructionDataEncoder().encode(\n      args as InitializeAccount3InstructionDataArgs\n    ),\n  } as InitializeAccount3Instruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeAccount3Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n    /** The mint this account will be associated with. */\n    mint: TAccountMetas[1];\n  };\n  data: InitializeAccount3InstructionData;\n};\n\nexport function parseInitializeAccount3Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeAccount3Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n    },\n    data: getInitializeAccount3InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR = 22;\n\nexport function getInitializeImmutableOwnerDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR);\n}\n\nexport type InitializeImmutableOwnerInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeImmutableOwnerInstructionData = { discriminator: number };\n\nexport type InitializeImmutableOwnerInstructionDataArgs = {};\n\nexport function getInitializeImmutableOwnerInstructionDataEncoder(): FixedSizeEncoder<InitializeImmutableOwnerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeImmutableOwnerInstructionDataDecoder(): FixedSizeDecoder<InitializeImmutableOwnerInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getInitializeImmutableOwnerInstructionDataCodec(): FixedSizeCodec<\n  InitializeImmutableOwnerInstructionDataArgs,\n  InitializeImmutableOwnerInstructionData\n> {\n  return combineCodec(\n    getInitializeImmutableOwnerInstructionDataEncoder(),\n    getInitializeImmutableOwnerInstructionDataDecoder()\n  );\n}\n\nexport type InitializeImmutableOwnerInput<\n  TAccountAccount extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n};\n\nexport function getInitializeImmutableOwnerInstruction<\n  TAccountAccount extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeImmutableOwnerInput<TAccountAccount>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeImmutableOwnerInstruction<TProgramAddress, TAccountAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.account)],\n    programAddress,\n    data: getInitializeImmutableOwnerInstructionDataEncoder().encode({}),\n  } as InitializeImmutableOwnerInstruction<TProgramAddress, TAccountAccount>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeImmutableOwnerInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n  };\n  data: InitializeImmutableOwnerInstructionData;\n};\n\nexport function parseInitializeImmutableOwnerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeImmutableOwnerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n    },\n    data: getInitializeImmutableOwnerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  none,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MINT_DISCRIMINATOR = 0;\n\nexport function getInitializeMintDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MINT_DISCRIMINATOR);\n}\n\nexport type InitializeMintInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMintInstructionData = {\n  discriminator: number;\n  /** Number of decimals in token account amounts. */\n  decimals: number;\n  /** Minting authority. */\n  mintAuthority: Address;\n  /** Optional authority that can freeze token accounts. */\n  freezeAuthority: Option<Address>;\n};\n\nexport type InitializeMintInstructionDataArgs = {\n  /** Number of decimals in token account amounts. */\n  decimals: number;\n  /** Minting authority. */\n  mintAuthority: Address;\n  /** Optional authority that can freeze token accounts. */\n  freezeAuthority?: OptionOrNullable<Address>;\n};\n\nexport function getInitializeMintInstructionDataEncoder(): Encoder<InitializeMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['decimals', getU8Encoder()],\n      ['mintAuthority', getAddressEncoder()],\n      ['freezeAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_MINT_DISCRIMINATOR,\n      freezeAuthority: value.freezeAuthority ?? none(),\n    })\n  );\n}\n\nexport function getInitializeMintInstructionDataDecoder(): Decoder<InitializeMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['decimals', getU8Decoder()],\n    ['mintAuthority', getAddressDecoder()],\n    ['freezeAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getInitializeMintInstructionDataCodec(): Codec<\n  InitializeMintInstructionDataArgs,\n  InitializeMintInstructionData\n> {\n  return combineCodec(\n    getInitializeMintInstructionDataEncoder(),\n    getInitializeMintInstructionDataDecoder()\n  );\n}\n\nexport type InitializeMintInput<\n  TAccountMint extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** Token mint account. */\n  mint: Address<TAccountMint>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n  decimals: InitializeMintInstructionDataArgs['decimals'];\n  mintAuthority: InitializeMintInstructionDataArgs['mintAuthority'];\n  freezeAuthority?: InitializeMintInstructionDataArgs['freezeAuthority'];\n};\n\nexport function getInitializeMintInstruction<\n  TAccountMint extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeMintInput<TAccountMint, TAccountRent>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMintInstruction<TProgramAddress, TAccountMint, TAccountRent> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint), getAccountMeta(accounts.rent)],\n    programAddress,\n    data: getInitializeMintInstructionDataEncoder().encode(\n      args as InitializeMintInstructionDataArgs\n    ),\n  } as InitializeMintInstruction<TProgramAddress, TAccountMint, TAccountRent>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeMintInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Token mint account. */\n    mint: TAccountMetas[0];\n    /** Rent sysvar. */\n    rent: TAccountMetas[1];\n  };\n  data: InitializeMintInstructionData;\n};\n\nexport function parseInitializeMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeMintInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  none,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MINT2_DISCRIMINATOR = 20;\n\nexport function getInitializeMint2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MINT2_DISCRIMINATOR);\n}\n\nexport type InitializeMint2Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMint2InstructionData = {\n  discriminator: number;\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** The authority/multisignature to mint tokens. */\n  mintAuthority: Address;\n  /** The optional freeze authority/multisignature of the mint. */\n  freezeAuthority: Option<Address>;\n};\n\nexport type InitializeMint2InstructionDataArgs = {\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** The authority/multisignature to mint tokens. */\n  mintAuthority: Address;\n  /** The optional freeze authority/multisignature of the mint. */\n  freezeAuthority?: OptionOrNullable<Address>;\n};\n\nexport function getInitializeMint2InstructionDataEncoder(): Encoder<InitializeMint2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['decimals', getU8Encoder()],\n      ['mintAuthority', getAddressEncoder()],\n      ['freezeAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_MINT2_DISCRIMINATOR,\n      freezeAuthority: value.freezeAuthority ?? none(),\n    })\n  );\n}\n\nexport function getInitializeMint2InstructionDataDecoder(): Decoder<InitializeMint2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['decimals', getU8Decoder()],\n    ['mintAuthority', getAddressDecoder()],\n    ['freezeAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getInitializeMint2InstructionDataCodec(): Codec<\n  InitializeMint2InstructionDataArgs,\n  InitializeMint2InstructionData\n> {\n  return combineCodec(\n    getInitializeMint2InstructionDataEncoder(),\n    getInitializeMint2InstructionDataDecoder()\n  );\n}\n\nexport type InitializeMint2Input<TAccountMint extends string = string> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  decimals: InitializeMint2InstructionDataArgs['decimals'];\n  mintAuthority: InitializeMint2InstructionDataArgs['mintAuthority'];\n  freezeAuthority?: InitializeMint2InstructionDataArgs['freezeAuthority'];\n};\n\nexport function getInitializeMint2Instruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeMint2Input<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMint2Instruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getInitializeMint2InstructionDataEncoder().encode(\n      args as InitializeMint2InstructionDataArgs\n    ),\n  } as InitializeMint2Instruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeMint2Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeMint2InstructionData;\n};\n\nexport function parseInitializeMint2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeMint2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getInitializeMint2InstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MULTISIG_DISCRIMINATOR = 2;\n\nexport function getInitializeMultisigDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MULTISIG_DISCRIMINATOR);\n}\n\nexport type InitializeMultisigInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMultisig extends string | AccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMultisig extends string\n        ? WritableAccount<TAccountMultisig>\n        : TAccountMultisig,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMultisigInstructionData = {\n  discriminator: number;\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport type InitializeMultisigInstructionDataArgs = {\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport function getInitializeMultisigInstructionDataEncoder(): FixedSizeEncoder<InitializeMultisigInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['m', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_MULTISIG_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeMultisigInstructionDataDecoder(): FixedSizeDecoder<InitializeMultisigInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['m', getU8Decoder()],\n  ]);\n}\n\nexport function getInitializeMultisigInstructionDataCodec(): FixedSizeCodec<\n  InitializeMultisigInstructionDataArgs,\n  InitializeMultisigInstructionData\n> {\n  return combineCodec(\n    getInitializeMultisigInstructionDataEncoder(),\n    getInitializeMultisigInstructionDataDecoder()\n  );\n}\n\nexport type InitializeMultisigInput<\n  TAccountMultisig extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** The multisignature account to initialize. */\n  multisig: Address<TAccountMultisig>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n  m: InitializeMultisigInstructionDataArgs['m'];\n  signers: Array<Address>;\n};\n\nexport function getInitializeMultisigInstruction<\n  TAccountMultisig extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeMultisigInput<TAccountMultisig, TAccountRent>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMultisigInstruction<\n  TProgramAddress,\n  TAccountMultisig,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    multisig: { value: input.multisig ?? null, isWritable: true },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = args.signers.map((address) => ({\n    address,\n    role: AccountRole.READONLY,\n  }));\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.multisig),\n      getAccountMeta(accounts.rent),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getInitializeMultisigInstructionDataEncoder().encode(\n      args as InitializeMultisigInstructionDataArgs\n    ),\n  } as InitializeMultisigInstruction<\n    TProgramAddress,\n    TAccountMultisig,\n    TAccountRent\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeMultisigInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The multisignature account to initialize. */\n    multisig: TAccountMetas[0];\n    /** Rent sysvar. */\n    rent: TAccountMetas[1];\n  };\n  data: InitializeMultisigInstructionData;\n};\n\nexport function parseInitializeMultisigInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeMultisigInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      multisig: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeMultisigInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MULTISIG2_DISCRIMINATOR = 19;\n\nexport function getInitializeMultisig2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MULTISIG2_DISCRIMINATOR);\n}\n\nexport type InitializeMultisig2Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMultisig extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMultisig extends string\n        ? WritableAccount<TAccountMultisig>\n        : TAccountMultisig,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMultisig2InstructionData = {\n  discriminator: number;\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport type InitializeMultisig2InstructionDataArgs = {\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport function getInitializeMultisig2InstructionDataEncoder(): FixedSizeEncoder<InitializeMultisig2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['m', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_MULTISIG2_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeMultisig2InstructionDataDecoder(): FixedSizeDecoder<InitializeMultisig2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['m', getU8Decoder()],\n  ]);\n}\n\nexport function getInitializeMultisig2InstructionDataCodec(): FixedSizeCodec<\n  InitializeMultisig2InstructionDataArgs,\n  InitializeMultisig2InstructionData\n> {\n  return combineCodec(\n    getInitializeMultisig2InstructionDataEncoder(),\n    getInitializeMultisig2InstructionDataDecoder()\n  );\n}\n\nexport type InitializeMultisig2Input<TAccountMultisig extends string = string> =\n  {\n    /** The multisignature account to initialize. */\n    multisig: Address<TAccountMultisig>;\n    m: InitializeMultisig2InstructionDataArgs['m'];\n    signers: Array<Address>;\n  };\n\nexport function getInitializeMultisig2Instruction<\n  TAccountMultisig extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: InitializeMultisig2Input<TAccountMultisig>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMultisig2Instruction<TProgramAddress, TAccountMultisig> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    multisig: { value: input.multisig ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = args.signers.map((address) => ({\n    address,\n    role: AccountRole.READONLY,\n  }));\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.multisig), ...remainingAccounts],\n    programAddress,\n    data: getInitializeMultisig2InstructionDataEncoder().encode(\n      args as InitializeMultisig2InstructionDataArgs\n    ),\n  } as InitializeMultisig2Instruction<TProgramAddress, TAccountMultisig>;\n\n  return instruction;\n}\n\nexport type ParsedInitializeMultisig2Instruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The multisignature account to initialize. */\n    multisig: TAccountMetas[0];\n  };\n  data: InitializeMultisig2InstructionData;\n};\n\nexport function parseInitializeMultisig2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeMultisig2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      multisig: getNextAccount(),\n    },\n    data: getInitializeMultisig2InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const MINT_TO_DISCRIMINATOR = 7;\n\nexport function getMintToDiscriminatorBytes() {\n  return getU8Encoder().encode(MINT_TO_DISCRIMINATOR);\n}\n\nexport type MintToInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountMintAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMintAuthority extends string\n        ? ReadonlyAccount<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type MintToInstructionData = {\n  discriminator: number;\n  /** The amount of new tokens to mint. */\n  amount: bigint;\n};\n\nexport type MintToInstructionDataArgs = {\n  /** The amount of new tokens to mint. */\n  amount: number | bigint;\n};\n\nexport function getMintToInstructionDataEncoder(): FixedSizeEncoder<MintToInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: MINT_TO_DISCRIMINATOR })\n  );\n}\n\nexport function getMintToInstructionDataDecoder(): FixedSizeDecoder<MintToInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getMintToInstructionDataCodec(): FixedSizeCodec<\n  MintToInstructionDataArgs,\n  MintToInstructionData\n> {\n  return combineCodec(\n    getMintToInstructionDataEncoder(),\n    getMintToInstructionDataDecoder()\n  );\n}\n\nexport type MintToInput<\n  TAccountMint extends string = string,\n  TAccountToken extends string = string,\n  TAccountMintAuthority extends string = string,\n> = {\n  /** The mint account. */\n  mint: Address<TAccountMint>;\n  /** The account to mint tokens to. */\n  token: Address<TAccountToken>;\n  /** The mint's minting authority or its multisignature account. */\n  mintAuthority:\n    | Address<TAccountMintAuthority>\n    | TransactionSigner<TAccountMintAuthority>;\n  amount: MintToInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getMintToInstruction<\n  TAccountMint extends string,\n  TAccountToken extends string,\n  TAccountMintAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: MintToInput<TAccountMint, TAccountToken, TAccountMintAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): MintToInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountToken,\n  (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n    ? ReadonlySignerAccount<TAccountMintAuthority> &\n        AccountSignerMeta<TAccountMintAuthority>\n    : TAccountMintAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    token: { value: input.token ?? null, isWritable: true },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mintAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getMintToInstructionDataEncoder().encode(\n      args as MintToInstructionDataArgs\n    ),\n  } as MintToInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountToken,\n    (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n      ? ReadonlySignerAccount<TAccountMintAuthority> &\n          AccountSignerMeta<TAccountMintAuthority>\n      : TAccountMintAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedMintToInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint account. */\n    mint: TAccountMetas[0];\n    /** The account to mint tokens to. */\n    token: TAccountMetas[1];\n    /** The mint's minting authority or its multisignature account. */\n    mintAuthority: TAccountMetas[2];\n  };\n  data: MintToInstructionData;\n};\n\nexport function parseMintToInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedMintToInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      token: getNextAccount(),\n      mintAuthority: getNextAccount(),\n    },\n    data: getMintToInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const MINT_TO_CHECKED_DISCRIMINATOR = 14;\n\nexport function getMintToCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(MINT_TO_CHECKED_DISCRIMINATOR);\n}\n\nexport type MintToCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountMintAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMintAuthority extends string\n        ? ReadonlyAccount<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type MintToCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of new tokens to mint. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type MintToCheckedInstructionDataArgs = {\n  /** The amount of new tokens to mint. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getMintToCheckedInstructionDataEncoder(): FixedSizeEncoder<MintToCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: MINT_TO_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getMintToCheckedInstructionDataDecoder(): FixedSizeDecoder<MintToCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getMintToCheckedInstructionDataCodec(): FixedSizeCodec<\n  MintToCheckedInstructionDataArgs,\n  MintToCheckedInstructionData\n> {\n  return combineCodec(\n    getMintToCheckedInstructionDataEncoder(),\n    getMintToCheckedInstructionDataDecoder()\n  );\n}\n\nexport type MintToCheckedInput<\n  TAccountMint extends string = string,\n  TAccountToken extends string = string,\n  TAccountMintAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The account to mint tokens to. */\n  token: Address<TAccountToken>;\n  /** The mint's minting authority or its multisignature account. */\n  mintAuthority:\n    | Address<TAccountMintAuthority>\n    | TransactionSigner<TAccountMintAuthority>;\n  amount: MintToCheckedInstructionDataArgs['amount'];\n  decimals: MintToCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getMintToCheckedInstruction<\n  TAccountMint extends string,\n  TAccountToken extends string,\n  TAccountMintAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: MintToCheckedInput<TAccountMint, TAccountToken, TAccountMintAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): MintToCheckedInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountToken,\n  (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n    ? ReadonlySignerAccount<TAccountMintAuthority> &\n        AccountSignerMeta<TAccountMintAuthority>\n    : TAccountMintAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    token: { value: input.token ?? null, isWritable: true },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mintAuthority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getMintToCheckedInstructionDataEncoder().encode(\n      args as MintToCheckedInstructionDataArgs\n    ),\n  } as MintToCheckedInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountToken,\n    (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n      ? ReadonlySignerAccount<TAccountMintAuthority> &\n          AccountSignerMeta<TAccountMintAuthority>\n      : TAccountMintAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedMintToCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The account to mint tokens to. */\n    token: TAccountMetas[1];\n    /** The mint's minting authority or its multisignature account. */\n    mintAuthority: TAccountMetas[2];\n  };\n  data: MintToCheckedInstructionData;\n};\n\nexport function parseMintToCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedMintToCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      token: getNextAccount(),\n      mintAuthority: getNextAccount(),\n    },\n    data: getMintToCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { findAssociatedTokenPda } from '../pdas';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport {\n  expectAddress,\n  getAccountMetaFactory,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR = 2;\n\nexport function getRecoverNestedAssociatedTokenDiscriminatorBytes() {\n  return getU8Encoder().encode(RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR);\n}\n\nexport type RecoverNestedAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountNestedAssociatedAccountAddress extends\n    | string\n    | AccountMeta<string> = string,\n  TAccountNestedTokenMintAddress extends string | AccountMeta<string> = string,\n  TAccountDestinationAssociatedAccountAddress extends\n    | string\n    | AccountMeta<string> = string,\n  TAccountOwnerAssociatedAccountAddress extends\n    | string\n    | AccountMeta<string> = string,\n  TAccountOwnerTokenMintAddress extends string | AccountMeta<string> = string,\n  TAccountWalletAddress extends string | AccountMeta<string> = string,\n  TAccountTokenProgram extends\n    | string\n    | AccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountNestedAssociatedAccountAddress extends string\n        ? WritableAccount<TAccountNestedAssociatedAccountAddress>\n        : TAccountNestedAssociatedAccountAddress,\n      TAccountNestedTokenMintAddress extends string\n        ? ReadonlyAccount<TAccountNestedTokenMintAddress>\n        : TAccountNestedTokenMintAddress,\n      TAccountDestinationAssociatedAccountAddress extends string\n        ? WritableAccount<TAccountDestinationAssociatedAccountAddress>\n        : TAccountDestinationAssociatedAccountAddress,\n      TAccountOwnerAssociatedAccountAddress extends string\n        ? ReadonlyAccount<TAccountOwnerAssociatedAccountAddress>\n        : TAccountOwnerAssociatedAccountAddress,\n      TAccountOwnerTokenMintAddress extends string\n        ? ReadonlyAccount<TAccountOwnerTokenMintAddress>\n        : TAccountOwnerTokenMintAddress,\n      TAccountWalletAddress extends string\n        ? WritableSignerAccount<TAccountWalletAddress> &\n            AccountSignerMeta<TAccountWalletAddress>\n        : TAccountWalletAddress,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type RecoverNestedAssociatedTokenInstructionData = {\n  discriminator: number;\n};\n\nexport type RecoverNestedAssociatedTokenInstructionDataArgs = {};\n\nexport function getRecoverNestedAssociatedTokenInstructionDataEncoder(): FixedSizeEncoder<RecoverNestedAssociatedTokenInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getRecoverNestedAssociatedTokenInstructionDataDecoder(): FixedSizeDecoder<RecoverNestedAssociatedTokenInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getRecoverNestedAssociatedTokenInstructionDataCodec(): FixedSizeCodec<\n  RecoverNestedAssociatedTokenInstructionDataArgs,\n  RecoverNestedAssociatedTokenInstructionData\n> {\n  return combineCodec(\n    getRecoverNestedAssociatedTokenInstructionDataEncoder(),\n    getRecoverNestedAssociatedTokenInstructionDataDecoder()\n  );\n}\n\nexport type RecoverNestedAssociatedTokenAsyncInput<\n  TAccountNestedAssociatedAccountAddress extends string = string,\n  TAccountNestedTokenMintAddress extends string = string,\n  TAccountDestinationAssociatedAccountAddress extends string = string,\n  TAccountOwnerAssociatedAccountAddress extends string = string,\n  TAccountOwnerTokenMintAddress extends string = string,\n  TAccountWalletAddress extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Nested associated token account, must be owned by `ownerAssociatedAccountAddress`. */\n  nestedAssociatedAccountAddress?: Address<TAccountNestedAssociatedAccountAddress>;\n  /** Token mint for the nested associated token account. */\n  nestedTokenMintAddress: Address<TAccountNestedTokenMintAddress>;\n  /** Wallet's associated token account. */\n  destinationAssociatedAccountAddress?: Address<TAccountDestinationAssociatedAccountAddress>;\n  /** Owner associated token account address, must be owned by `walletAddress`. */\n  ownerAssociatedAccountAddress?: Address<TAccountOwnerAssociatedAccountAddress>;\n  /** Token mint for the owner associated token account. */\n  ownerTokenMintAddress: Address<TAccountOwnerTokenMintAddress>;\n  /** Wallet address for the owner associated token account. */\n  walletAddress: TransactionSigner<TAccountWalletAddress>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport async function getRecoverNestedAssociatedTokenInstructionAsync<\n  TAccountNestedAssociatedAccountAddress extends string,\n  TAccountNestedTokenMintAddress extends string,\n  TAccountDestinationAssociatedAccountAddress extends string,\n  TAccountOwnerAssociatedAccountAddress extends string,\n  TAccountOwnerTokenMintAddress extends string,\n  TAccountWalletAddress extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: RecoverNestedAssociatedTokenAsyncInput<\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): Promise<\n  RecoverNestedAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nestedAssociatedAccountAddress: {\n      value: input.nestedAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    nestedTokenMintAddress: {\n      value: input.nestedTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    destinationAssociatedAccountAddress: {\n      value: input.destinationAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    ownerAssociatedAccountAddress: {\n      value: input.ownerAssociatedAccountAddress ?? null,\n      isWritable: false,\n    },\n    ownerTokenMintAddress: {\n      value: input.ownerTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    walletAddress: { value: input.walletAddress ?? null, isWritable: true },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n  if (!accounts.ownerAssociatedAccountAddress.value) {\n    accounts.ownerAssociatedAccountAddress.value = await findAssociatedTokenPda(\n      {\n        owner: expectAddress(accounts.walletAddress.value),\n        tokenProgram: expectAddress(accounts.tokenProgram.value),\n        mint: expectAddress(accounts.ownerTokenMintAddress.value),\n      }\n    );\n  }\n  if (!accounts.nestedAssociatedAccountAddress.value) {\n    accounts.nestedAssociatedAccountAddress.value =\n      await findAssociatedTokenPda({\n        owner: expectAddress(accounts.ownerAssociatedAccountAddress.value),\n        tokenProgram: expectAddress(accounts.tokenProgram.value),\n        mint: expectAddress(accounts.nestedTokenMintAddress.value),\n      });\n  }\n  if (!accounts.destinationAssociatedAccountAddress.value) {\n    accounts.destinationAssociatedAccountAddress.value =\n      await findAssociatedTokenPda({\n        owner: expectAddress(accounts.walletAddress.value),\n        tokenProgram: expectAddress(accounts.tokenProgram.value),\n        mint: expectAddress(accounts.nestedTokenMintAddress.value),\n      });\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.nestedAssociatedAccountAddress),\n      getAccountMeta(accounts.nestedTokenMintAddress),\n      getAccountMeta(accounts.destinationAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerTokenMintAddress),\n      getAccountMeta(accounts.walletAddress),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getRecoverNestedAssociatedTokenInstructionDataEncoder().encode({}),\n  } as RecoverNestedAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type RecoverNestedAssociatedTokenInput<\n  TAccountNestedAssociatedAccountAddress extends string = string,\n  TAccountNestedTokenMintAddress extends string = string,\n  TAccountDestinationAssociatedAccountAddress extends string = string,\n  TAccountOwnerAssociatedAccountAddress extends string = string,\n  TAccountOwnerTokenMintAddress extends string = string,\n  TAccountWalletAddress extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Nested associated token account, must be owned by `ownerAssociatedAccountAddress`. */\n  nestedAssociatedAccountAddress: Address<TAccountNestedAssociatedAccountAddress>;\n  /** Token mint for the nested associated token account. */\n  nestedTokenMintAddress: Address<TAccountNestedTokenMintAddress>;\n  /** Wallet's associated token account. */\n  destinationAssociatedAccountAddress: Address<TAccountDestinationAssociatedAccountAddress>;\n  /** Owner associated token account address, must be owned by `walletAddress`. */\n  ownerAssociatedAccountAddress: Address<TAccountOwnerAssociatedAccountAddress>;\n  /** Token mint for the owner associated token account. */\n  ownerTokenMintAddress: Address<TAccountOwnerTokenMintAddress>;\n  /** Wallet address for the owner associated token account. */\n  walletAddress: TransactionSigner<TAccountWalletAddress>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getRecoverNestedAssociatedTokenInstruction<\n  TAccountNestedAssociatedAccountAddress extends string,\n  TAccountNestedTokenMintAddress extends string,\n  TAccountDestinationAssociatedAccountAddress extends string,\n  TAccountOwnerAssociatedAccountAddress extends string,\n  TAccountOwnerTokenMintAddress extends string,\n  TAccountWalletAddress extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: RecoverNestedAssociatedTokenInput<\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): RecoverNestedAssociatedTokenInstruction<\n  TProgramAddress,\n  TAccountNestedAssociatedAccountAddress,\n  TAccountNestedTokenMintAddress,\n  TAccountDestinationAssociatedAccountAddress,\n  TAccountOwnerAssociatedAccountAddress,\n  TAccountOwnerTokenMintAddress,\n  TAccountWalletAddress,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nestedAssociatedAccountAddress: {\n      value: input.nestedAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    nestedTokenMintAddress: {\n      value: input.nestedTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    destinationAssociatedAccountAddress: {\n      value: input.destinationAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    ownerAssociatedAccountAddress: {\n      value: input.ownerAssociatedAccountAddress ?? null,\n      isWritable: false,\n    },\n    ownerTokenMintAddress: {\n      value: input.ownerTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    walletAddress: { value: input.walletAddress ?? null, isWritable: true },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.nestedAssociatedAccountAddress),\n      getAccountMeta(accounts.nestedTokenMintAddress),\n      getAccountMeta(accounts.destinationAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerTokenMintAddress),\n      getAccountMeta(accounts.walletAddress),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getRecoverNestedAssociatedTokenInstructionDataEncoder().encode({}),\n  } as RecoverNestedAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedRecoverNestedAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Nested associated token account, must be owned by `ownerAssociatedAccountAddress`. */\n    nestedAssociatedAccountAddress: TAccountMetas[0];\n    /** Token mint for the nested associated token account. */\n    nestedTokenMintAddress: TAccountMetas[1];\n    /** Wallet's associated token account. */\n    destinationAssociatedAccountAddress: TAccountMetas[2];\n    /** Owner associated token account address, must be owned by `walletAddress`. */\n    ownerAssociatedAccountAddress: TAccountMetas[3];\n    /** Token mint for the owner associated token account. */\n    ownerTokenMintAddress: TAccountMetas[4];\n    /** Wallet address for the owner associated token account. */\n    walletAddress: TAccountMetas[5];\n    /** SPL Token program. */\n    tokenProgram: TAccountMetas[6];\n  };\n  data: RecoverNestedAssociatedTokenInstructionData;\n};\n\nexport function parseRecoverNestedAssociatedTokenInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedRecoverNestedAssociatedTokenInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 7) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nestedAssociatedAccountAddress: getNextAccount(),\n      nestedTokenMintAddress: getNextAccount(),\n      destinationAssociatedAccountAddress: getNextAccount(),\n      ownerAssociatedAccountAddress: getNextAccount(),\n      ownerTokenMintAddress: getNextAccount(),\n      walletAddress: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getRecoverNestedAssociatedTokenInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const REVOKE_DISCRIMINATOR = 5;\n\nexport function getRevokeDiscriminatorBytes() {\n  return getU8Encoder().encode(REVOKE_DISCRIMINATOR);\n}\n\nexport type RevokeInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type RevokeInstructionData = { discriminator: number };\n\nexport type RevokeInstructionDataArgs = {};\n\nexport function getRevokeInstructionDataEncoder(): FixedSizeEncoder<RevokeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: REVOKE_DISCRIMINATOR })\n  );\n}\n\nexport function getRevokeInstructionDataDecoder(): FixedSizeDecoder<RevokeInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getRevokeInstructionDataCodec(): FixedSizeCodec<\n  RevokeInstructionDataArgs,\n  RevokeInstructionData\n> {\n  return combineCodec(\n    getRevokeInstructionDataEncoder(),\n    getRevokeInstructionDataDecoder()\n  );\n}\n\nexport type RevokeInput<\n  TAccountSource extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The source account owner or its multisignature. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getRevokeInstruction<\n  TAccountSource extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: RevokeInput<TAccountSource, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): RevokeInstruction<\n  TProgramAddress,\n  TAccountSource,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getRevokeInstructionDataEncoder().encode({}),\n  } as RevokeInstruction<\n    TProgramAddress,\n    TAccountSource,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedRevokeInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The source account owner or its multisignature. */\n    owner: TAccountMetas[1];\n  };\n  data: RevokeInstructionData;\n};\n\nexport function parseRevokeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedRevokeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getRevokeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getAuthorityTypeDecoder,\n  getAuthorityTypeEncoder,\n  type AuthorityType,\n  type AuthorityTypeArgs,\n} from '../types';\n\nexport const SET_AUTHORITY_DISCRIMINATOR = 6;\n\nexport function getSetAuthorityDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_AUTHORITY_DISCRIMINATOR);\n}\n\nexport type SetAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountOwned extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountOwned extends string\n        ? WritableAccount<TAccountOwned>\n        : TAccountOwned,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetAuthorityInstructionData = {\n  discriminator: number;\n  /** The type of authority to update. */\n  authorityType: AuthorityType;\n  /** The new authority */\n  newAuthority: Option<Address>;\n};\n\nexport type SetAuthorityInstructionDataArgs = {\n  /** The type of authority to update. */\n  authorityType: AuthorityTypeArgs;\n  /** The new authority */\n  newAuthority: OptionOrNullable<Address>;\n};\n\nexport function getSetAuthorityInstructionDataEncoder(): Encoder<SetAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['authorityType', getAuthorityTypeEncoder()],\n      ['newAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({ ...value, discriminator: SET_AUTHORITY_DISCRIMINATOR })\n  );\n}\n\nexport function getSetAuthorityInstructionDataDecoder(): Decoder<SetAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['authorityType', getAuthorityTypeDecoder()],\n    ['newAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getSetAuthorityInstructionDataCodec(): Codec<\n  SetAuthorityInstructionDataArgs,\n  SetAuthorityInstructionData\n> {\n  return combineCodec(\n    getSetAuthorityInstructionDataEncoder(),\n    getSetAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type SetAuthorityInput<\n  TAccountOwned extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The mint or account to change the authority of. */\n  owned: Address<TAccountOwned>;\n  /** The current authority or the multisignature account of the mint or account to update. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  authorityType: SetAuthorityInstructionDataArgs['authorityType'];\n  newAuthority: SetAuthorityInstructionDataArgs['newAuthority'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getSetAuthorityInstruction<\n  TAccountOwned extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: SetAuthorityInput<TAccountOwned, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): SetAuthorityInstruction<\n  TProgramAddress,\n  TAccountOwned,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    owned: { value: input.owned ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.owned),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getSetAuthorityInstructionDataEncoder().encode(\n      args as SetAuthorityInstructionDataArgs\n    ),\n  } as SetAuthorityInstruction<\n    TProgramAddress,\n    TAccountOwned,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint or account to change the authority of. */\n    owned: TAccountMetas[0];\n    /** The current authority or the multisignature account of the mint or account to update. */\n    owner: TAccountMetas[1];\n  };\n  data: SetAuthorityInstructionData;\n};\n\nexport function parseSetAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedSetAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      owned: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getSetAuthorityInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SYNC_NATIVE_DISCRIMINATOR = 17;\n\nexport function getSyncNativeDiscriminatorBytes() {\n  return getU8Encoder().encode(SYNC_NATIVE_DISCRIMINATOR);\n}\n\nexport type SyncNativeInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SyncNativeInstructionData = { discriminator: number };\n\nexport type SyncNativeInstructionDataArgs = {};\n\nexport function getSyncNativeInstructionDataEncoder(): FixedSizeEncoder<SyncNativeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: SYNC_NATIVE_DISCRIMINATOR })\n  );\n}\n\nexport function getSyncNativeInstructionDataDecoder(): FixedSizeDecoder<SyncNativeInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getSyncNativeInstructionDataCodec(): FixedSizeCodec<\n  SyncNativeInstructionDataArgs,\n  SyncNativeInstructionData\n> {\n  return combineCodec(\n    getSyncNativeInstructionDataEncoder(),\n    getSyncNativeInstructionDataDecoder()\n  );\n}\n\nexport type SyncNativeInput<TAccountAccount extends string = string> = {\n  /** The native token account to sync with its underlying lamports. */\n  account: Address<TAccountAccount>;\n};\n\nexport function getSyncNativeInstruction<\n  TAccountAccount extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: SyncNativeInput<TAccountAccount>,\n  config?: { programAddress?: TProgramAddress }\n): SyncNativeInstruction<TProgramAddress, TAccountAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.account)],\n    programAddress,\n    data: getSyncNativeInstructionDataEncoder().encode({}),\n  } as SyncNativeInstruction<TProgramAddress, TAccountAccount>;\n\n  return instruction;\n}\n\nexport type ParsedSyncNativeInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The native token account to sync with its underlying lamports. */\n    account: TAccountMetas[0];\n  };\n  data: SyncNativeInstructionData;\n};\n\nexport function parseSyncNativeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedSyncNativeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n    },\n    data: getSyncNativeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const THAW_ACCOUNT_DISCRIMINATOR = 11;\n\nexport function getThawAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(THAW_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type ThawAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ThawAccountInstructionData = { discriminator: number };\n\nexport type ThawAccountInstructionDataArgs = {};\n\nexport function getThawAccountInstructionDataEncoder(): FixedSizeEncoder<ThawAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: THAW_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getThawAccountInstructionDataDecoder(): FixedSizeDecoder<ThawAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getThawAccountInstructionDataCodec(): FixedSizeCodec<\n  ThawAccountInstructionDataArgs,\n  ThawAccountInstructionData\n> {\n  return combineCodec(\n    getThawAccountInstructionDataEncoder(),\n    getThawAccountInstructionDataDecoder()\n  );\n}\n\nexport type ThawAccountInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The account to thaw. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The mint freeze authority or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getThawAccountInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: ThawAccountInput<TAccountAccount, TAccountMint, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): ThawAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getThawAccountInstructionDataEncoder().encode({}),\n  } as ThawAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedThawAccountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to thaw. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The mint freeze authority or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: ThawAccountInstructionData;\n};\n\nexport function parseThawAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedThawAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getThawAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_DISCRIMINATOR = 3;\n\nexport function getTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(TRANSFER_DISCRIMINATOR);\n}\n\nexport type TransferInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountDestination extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to transfer. */\n  amount: bigint;\n};\n\nexport type TransferInstructionDataArgs = {\n  /** The amount of tokens to transfer. */\n  amount: number | bigint;\n};\n\nexport function getTransferInstructionDataEncoder(): FixedSizeEncoder<TransferInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: TRANSFER_DISCRIMINATOR })\n  );\n}\n\nexport function getTransferInstructionDataDecoder(): FixedSizeDecoder<TransferInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getTransferInstructionDataCodec(): FixedSizeCodec<\n  TransferInstructionDataArgs,\n  TransferInstructionData\n> {\n  return combineCodec(\n    getTransferInstructionDataEncoder(),\n    getTransferInstructionDataDecoder()\n  );\n}\n\nexport type TransferInput<\n  TAccountSource extends string = string,\n  TAccountDestination extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The destination account. */\n  destination: Address<TAccountDestination>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: TransferInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getTransferInstruction<\n  TAccountSource extends string,\n  TAccountDestination extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: TransferInput<TAccountSource, TAccountDestination, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): TransferInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountDestination,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getTransferInstructionDataEncoder().encode(\n      args as TransferInstructionDataArgs\n    ),\n  } as TransferInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountDestination,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedTransferInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The destination account. */\n    destination: TAccountMetas[1];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: TransferInstructionData;\n};\n\nexport function parseTransferInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedTransferInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      destination: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getTransferInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_CHECKED_DISCRIMINATOR = 12;\n\nexport function getTransferCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(TRANSFER_CHECKED_DISCRIMINATOR);\n}\n\nexport type TransferCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountDestination extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to transfer. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type TransferCheckedInstructionDataArgs = {\n  /** The amount of tokens to transfer. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getTransferCheckedInstructionDataEncoder(): FixedSizeEncoder<TransferCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: TRANSFER_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getTransferCheckedInstructionDataDecoder(): FixedSizeDecoder<TransferCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getTransferCheckedInstructionDataCodec(): FixedSizeCodec<\n  TransferCheckedInstructionDataArgs,\n  TransferCheckedInstructionData\n> {\n  return combineCodec(\n    getTransferCheckedInstructionDataEncoder(),\n    getTransferCheckedInstructionDataDecoder()\n  );\n}\n\nexport type TransferCheckedInput<\n  TAccountSource extends string = string,\n  TAccountMint extends string = string,\n  TAccountDestination extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The destination account. */\n  destination: Address<TAccountDestination>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: TransferCheckedInstructionDataArgs['amount'];\n  decimals: TransferCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getTransferCheckedInstruction<\n  TAccountSource extends string,\n  TAccountMint extends string,\n  TAccountDestination extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: TransferCheckedInput<\n    TAccountSource,\n    TAccountMint,\n    TAccountDestination,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): TransferCheckedInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountMint,\n  TAccountDestination,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    destination: { value: input.destination ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    programAddress,\n    data: getTransferCheckedInstructionDataEncoder().encode(\n      args as TransferCheckedInstructionDataArgs\n    ),\n  } as TransferCheckedInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountMint,\n    TAccountDestination,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedTransferCheckedInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The destination account. */\n    destination: TAccountMetas[2];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[3];\n  };\n  data: TransferCheckedInstructionData;\n};\n\nexport function parseTransferCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedTransferCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      mint: getNextAccount(),\n      destination: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getTransferCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport { TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR = 24;\n\nexport function getUiAmountToAmountDiscriminatorBytes() {\n  return getU8Encoder().encode(UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR);\n}\n\nexport type UiAmountToAmountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UiAmountToAmountInstructionData = {\n  discriminator: number;\n  /** The ui_amount of tokens to reformat. */\n  uiAmount: string;\n};\n\nexport type UiAmountToAmountInstructionDataArgs = {\n  /** The ui_amount of tokens to reformat. */\n  uiAmount: string;\n};\n\nexport function getUiAmountToAmountInstructionDataEncoder(): Encoder<UiAmountToAmountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['uiAmount', getUtf8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getUiAmountToAmountInstructionDataDecoder(): Decoder<UiAmountToAmountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['uiAmount', getUtf8Decoder()],\n  ]);\n}\n\nexport function getUiAmountToAmountInstructionDataCodec(): Codec<\n  UiAmountToAmountInstructionDataArgs,\n  UiAmountToAmountInstructionData\n> {\n  return combineCodec(\n    getUiAmountToAmountInstructionDataEncoder(),\n    getUiAmountToAmountInstructionDataDecoder()\n  );\n}\n\nexport type UiAmountToAmountInput<TAccountMint extends string = string> = {\n  /** The mint to calculate for. */\n  mint: Address<TAccountMint>;\n  uiAmount: UiAmountToAmountInstructionDataArgs['uiAmount'];\n};\n\nexport function getUiAmountToAmountInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_PROGRAM_ADDRESS,\n>(\n  input: UiAmountToAmountInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): UiAmountToAmountInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [getAccountMeta(accounts.mint)],\n    programAddress,\n    data: getUiAmountToAmountInstructionDataEncoder().encode(\n      args as UiAmountToAmountInstructionDataArgs\n    ),\n  } as UiAmountToAmountInstruction<TProgramAddress, TAccountMint>;\n\n  return instruction;\n}\n\nexport type ParsedUiAmountToAmountInstruction<\n  TProgram extends string = typeof TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to calculate for. */\n    mint: TAccountMetas[0];\n  };\n  data: UiAmountToAmountInstructionData;\n};\n\nexport function parseUiAmountToAmountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUiAmountToAmountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n    },\n    data: getUiAmountToAmountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n"],"names":["alphabet","getU8Decoder","getArrayEncoder","getShortU16Encoder","combineCodec","getShortU16Decoder","getStructDecoder","SolanaError","kitIsTransactionSigner","SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT","getU32Decoder","getStructEncoder","AssociatedTokenInstruction","getU8Encoder","address","getAddressEncoder","createDecoder","pipe","transaction","getU32Encoder","TokenInstruction","isFixedSize","transformEncoder","containsBytes","getU64Encoder","getAddressDecoder","getU64Decoder","transformDecoder","isProgramError","getUtf8Encoder","addDecoderSizePrefix","isSignerRole","createEncoder","getEncodedSize","AccountRole","addEncoderSizePrefix","getUtf8Decoder","ORDERED_ERROR_NAMES","getOptionEncoder","getOptionDecoder","none"],"mappings":"iCACE,IAAI,EAGJ,IAFM,mEA4FN,EAAO,OAAO,GAAG,AA1FT,CAEN,KAAM,SAAS,CAAC,CAAE,CAAC,EACjB,OAAQ,GAAK,EAAM,IAAO,GAAK,CACjC,EAGA,KAAM,SAAS,CAAC,CAAE,CAAC,EACjB,OAAQ,GAAM,GAAK,EAAO,IAAM,CAClC,EAGA,OAAQ,SAAS,CAAC,EAEhB,GAAI,EAAE,WAAW,EAAI,OACnB,CAD2B,MACpB,AAAmB,WAAb,IAAI,CAAC,EAAG,GAAsC,WAApB,EAAM,IAAI,CAAC,EAAG,IAIvD,IAAK,IAAI,EAAI,EAAG,EAAI,EAAE,MAAM,CAAE,IAC5B,CAAC,CAAC,EAAE,CAAG,EAAM,MAAM,CAAC,CAAC,CAAC,EAAE,EAC1B,OAAO,CACT,EAGA,YAAa,SAAS,CAAC,EACrB,IAAK,IAAI,EAAQ,EAAE,CAAE,EAAI,EAAG,IAC1B,EAAM,IAAI,CAAC,KAAK,KAAK,CAAiB,IAAhB,KAAK,MAAM,KACnC,OAAO,CACT,EAGA,aAAc,SAAS,CAAK,EAC1B,IAAK,IAAI,EAAQ,EAAE,CAAE,EAAI,EAAG,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,IAAK,GAAK,EAC7D,CAAK,CAAC,IAAM,EAAE,EAAI,CAAK,CAAC,EAAE,EAAK,GAAK,EAAI,GAC1C,OAAO,CACT,EAGA,aAAc,SAAS,CAAK,EAC1B,IAAK,IAAI,EAAQ,EAAE,CAAE,EAAI,EAAG,EAAmB,GAAf,EAAM,MAAM,CAAO,GAAK,EACtD,EAAM,IAAI,CAAE,CAAK,CAAC,IAAM,EAAE,GAAM,GAAK,EAAI,GAAO,KAClD,OAAO,CACT,EAGA,WAAY,SAAS,CAAK,EACxB,IAAK,IAAI,EAAM,EAAE,CAAE,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,IAAK,AAC/C,EAAI,IAAI,CAAC,CAAC,CAAK,CAAC,EAAE,IAAK,CAAC,CAAE,QAAQ,CAAC,KACnC,EAAI,IAAI,CAAC,AAAC,CAAW,IAAN,CAAC,EAAK,AAAH,CAAM,CAAE,QAAQ,CAAC,KAErC,OAAO,EAAI,IAAI,CAAC,GAClB,EAGA,WAAY,SAAS,CAAG,EACtB,IAAK,IAAI,EAAQ,EAAE,CAAE,EAAI,EAAG,EAAI,EAAI,MAAM,CAAE,GAAK,EAC/C,EAAM,IAAI,CAAC,SAAS,EAAI,MAAM,CAAC,EAAG,GAAI,KACxC,OAAO,CACT,EAGA,cAAe,SAAS,CAAK,EAC3B,IAAK,IAAI,EAAS,EAAE,CAAE,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,GAAK,EAElD,AAFqD,IAEhD,IADD,EAAW,CAAK,CAAC,EAAE,EAAI,GAAO,CAAK,CAAC,EAAI,EAAE,EAAI,EAAK,CAAK,CAAC,EAAI,EAAE,CAC1D,EAAI,EAAG,EAAI,EAAG,IACrB,AAAQ,EAAJ,EAAY,EAAJ,GAAwB,AAAf,IAAM,MAAM,CAC/B,EAAO,IAAI,CAAC,EAAU,MAAM,CAAE,IAAY,EAAK,EAAD,EAAK,CAAC,CAAK,KAEzD,EAAO,IAAI,CAAC,KAElB,OAAO,EAAO,IAAI,CAAC,GACrB,EAGA,cAAe,SAAS,CAAM,EAE5B,EAAS,EAAO,OAAO,CAAC,iBAAkB,IAE1C,IAAK,IAAI,EAAQ,EAAE,CAAE,EAAI,EAAG,EAAQ,EAAG,EAAI,EAAO,MAAM,CACpD,EAAQ,EAAE,EAAI,EAAG,AACN,GAAT,AAAY,GAChB,EAAM,IAAI,CAAE,AAAC,GAAU,OAAO,CAAC,EAAO,MAAM,CAAC,EAAI,IAC1C,KAAK,GAAG,CAAC,EAAG,CAAC,EAAI,EAAQ,IAAK,CAAE,EAAc,EAAR,EACtC,EAAU,OAAO,CAAC,EAAO,MAAM,CAAC,MAAS,EAAY,EAAR,GAEtD,OAAO,CACT,CACF,oBC5FF,IAAI,EAAU,CAEZ,KAAM,CAEJ,cAAe,SAAS,CAAG,EACzB,OAAO,EAAQ,GAAG,CAAC,aAAa,CAAC,SAAS,mBAAmB,IAC/D,EAGA,cAAe,SAAS,CAAK,EAC3B,OAAO,mBAAmB,OAAO,EAAQ,GAAG,CAAC,aAAa,CAAC,IAC7D,CACF,EAGA,IAAK,CAEH,cAAe,SAAS,CAAG,EACzB,IAAK,IAAI,EAAQ,EAAE,CAAE,EAAI,EAAG,EAAI,EAAI,MAAM,CAAE,IAC1C,EAAM,IAAI,CAAqB,IAApB,EAAI,UAAU,CAAC,IAC5B,OAAO,CACT,EAGA,cAAe,SAAS,CAAK,EAC3B,IAAK,IAAI,EAAM,EAAE,CAAE,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,IAC1C,EAAI,IAAI,CAAC,OAAO,YAAY,CAAC,CAAK,CAAC,EAAE,GACvC,OAAO,EAAI,IAAI,CAAC,GAClB,CACF,CACF,EAEA,EAAO,OAAO,CAAG,oBCnBjB,SAAS,EAAU,CAAG,EACpB,MAAO,CAAC,CAAC,EAAI,WAAW,EAAwC,YAApC,OAAO,EAAI,WAAW,CAAC,QAAQ,EAAmB,EAAI,WAAW,CAAC,QAAQ,CAAC,EACzG,CANA,EAAO,OAAO,CAAG,SAAU,CAAG,MASP,EARrB,CAQwB,MARV,MAAP,EAAe,EAAC,EAAS,IASE,IATM,QASjC,MAAO,GATuC,GASnC,WAAW,EAAmB,AAAqB,mBAAd,EAAI,KAAK,EAAmB,EAAS,EAAI,KAAK,CAAC,EAAG,KAT5C,CAAC,CAAC,EAAI,SAAA,AAAS,CAC9E,oBCVE,QAEI,EACA,IAHA,EAAA,EAAA,CAAA,CAAA,QACA,EAAO,EAAA,CAAA,CAAA,QAAmB,IAAI,GAC9B,EAAA,CAAA,CAAA,UACM,EAAA,CAAA,CAAA,QAAmB,GAAG,CA4HhC,CA1HA,AACA,EAAM,SAAU,AADL,CACY,CAAE,CAAO,EAE1B,EAAQ,WAAW,EAAI,OAEvB,CADF,CAAI,GAAgC,WAArB,EAAQ,QAAQ,CACnB,EAAI,aAAa,CAAC,GAElB,EAAK,aAAa,CAAC,GACxB,EAAS,GAChB,EAAU,MAAM,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,EAAS,GACvC,AAAC,MAAM,OAAO,CAAC,IAAY,EAAQ,WAAW,GAAK,aAC1D,EAAU,EAAQ,QAAQ,EAAA,EAW5B,IAAK,IARD,EAAI,EAAM,YAAY,CAAC,GACvB,EAAqB,EAAjB,EAAQ,MAAM,CAClB,EAAK,WACL,EAAI,CAAC,WACL,EAAI,CAAC,WACL,EAAK,WAGA,EAAI,EAAG,EAAI,EAAE,MAAM,CAAE,IAAK,AACjC,CAAC,CAAC,EAAE,CAAG,CAAE,CAAC,CAAC,EAAE,EAAK,EAAM,CAAC,CAAC,EAAE,GAAK,EAAA,CAAG,CAAI,SACjC,CAAE,CAAC,CAAC,EAAE,EAAI,GAAO,CAAC,CAAC,EAAE,GAAM,CAAE,EAAI,WAI1C,CAAC,CAAC,IAAM,EAAE,EAAI,KAAS,EAAI,GAC3B,CAAC,CAAC,CAAG,EAAI,KAAQ,IAAM,CAAC,CAAI,GAAG,CAAG,EAQlC,IAAK,IALD,EAAK,EAAI,GAAG,CACZ,EAAK,EAAI,GAAG,CACZ,EAAK,EAAI,GAAG,CACZ,EAAK,EAAI,GAAG,CAEP,EAAI,EAAG,EAAI,EAAE,MAAM,CAAE,GAAK,GAAI,CAErC,IAAI,EAAK,EACL,EAAK,EACL,EAAK,EACL,EAAK,EAET,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAG,EAAG,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAI,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAK,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAI,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAG,EAAG,CAAC,WACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAK,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAI,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAI,CAAC,WACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAG,EAAI,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAI,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAE,GAAI,CAAC,OACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAE,GAAI,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAG,EAAI,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAE,GAAI,CAAC,WACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAE,GAAI,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAE,GAAK,YAEjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAG,EAAG,CAAC,WACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAG,EAAG,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAE,GAAK,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAI,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAG,EAAG,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAG,EAAI,WACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAE,GAAI,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAI,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAG,EAAI,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAG,EAAG,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAI,CAAC,WACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAK,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAG,EAAG,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAG,EAAG,CAAC,WACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAK,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAE,GAAI,CAAC,YAEjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAG,EAAG,CAAC,QACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAI,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAE,GAAK,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAE,GAAI,CAAC,WACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAG,EAAG,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAK,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAI,CAAC,WACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAE,GAAI,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAG,EAAI,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAI,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAI,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAK,WACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAG,EAAG,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAE,GAAI,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAE,GAAK,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAI,CAAC,YAEjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAG,EAAG,CAAC,WACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAK,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAE,GAAI,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAI,CAAC,WACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAG,EAAI,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAI,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAE,GAAI,CAAC,SACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAI,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAG,EAAI,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAE,GAAI,CAAC,WACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAI,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAE,GAAK,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAG,EAAG,CAAC,WACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAE,GAAG,CAAE,GAAI,CAAC,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAK,YACjC,EAAI,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,CAAC,EAAG,EAAE,CAAE,GAAI,CAAC,YAEjC,EAAK,EAAI,IAAQ,EACjB,EAAK,EAAI,IAAQ,EACjB,EAAK,EAAI,IAAQ,EACjB,EAAK,EAAI,IAAQ,CACnB,CAEA,OAAO,EAAM,MAAM,CAAC,CAAC,EAAG,EAAG,EAAG,EAAE,CAClC,GAGI,GAAG,CAAI,SAAU,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,EACtC,IAAI,EAAI,GAAK,CAAD,CAAK,EAAI,CAAC,GAAI,CAAC,EAAK,EAAD,GAAO,CAAC,CAAI,EAC3C,MAAO,CAAE,GAAK,EAAM,IAAO,IAAK,CAAG,CAAI,CACzC,EACA,EAAI,GAAG,CAAI,SAAU,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,EACtC,IAAI,EAAI,GAAK,CAAD,CAAK,EAAI,EAAI,EAAC,CAAC,CAAK,GAAD,GAAO,CAAC,CAAI,EAC3C,MAAO,CAAE,GAAK,EAAM,IAAO,GAAK,CAAG,EAAI,CACzC,EACA,EAAI,GAAG,CAAI,SAAU,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,EACtC,IAAI,EAAI,GAAK,CAAD,CAAK,GAAI,CAAC,EAAK,EAAD,GAAO,CAAC,CAAI,EACtC,MAAO,CAAE,GAAK,EAAM,IAAO,GAAK,CAAG,EAAI,CACzC,EACA,EAAI,GAAG,CAAI,SAAU,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,CAAE,CAAC,EACtC,IAAI,EAAI,GAAK,CAAD,EAAM,CAAD,CAAK,EAAC,CAAC,CAAC,EAAK,EAAD,GAAO,CAAC,CAAI,EACzC,MAAO,CAAE,GAAK,EAAM,IAAO,GAAK,CAAG,EAAI,CACzC,EAGA,EAAI,UAAU,CAAG,GACjB,EAAI,WAAW,CAAG,GAElB,EAAO,OAAO,CAAG,SAAU,CAAO,CAAE,CAAO,EACzC,SAAI,EACF,MAAM,AAAI,IADI,EACE,WADW,SACW,GAExC,AAHyC,IAGrC,EAAc,EAAM,YAAY,CAAC,EAAI,EAAS,IAClD,OAAO,GAAW,EAAQ,OAAO,CAAG,EAChC,GAAW,EAAQ,QAAQ,CAAG,EAAI,aAAa,CAAC,GAChD,EAAM,UAAU,CAAC,EACvB,oBC7JF,IAAI,EAAS,EAAA,CAAA,CAAA,QAAkB,MAAM,CACjC,EAAA,EAAA,CAAA,CAAA,QAGJ,SAAS,IACP,IAAI,CAAC,MAAM,CAAG,KACd,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,CAAC,WAAW,CAAG,OAAO,CAC1B,IAAI,CAAC,WAAW,EAAG,EAEnB,IAAI,CAAC,oBAAoB,EAAG,EAC5B,IAAI,CAAC,SAAS,EAAG,EACjB,IAAI,CAAC,eAAe,CAAG,EAAE,AAC3B,CAVA,EAAO,OAAO,CAAG,EAWjB,EAAK,QAAQ,CAAC,EAAe,GAE7B,EAAc,MAAM,CAAG,SAAS,CAAM,CAAE,CAAO,EAC7C,IAAI,EAAgB,IAAI,IAAI,CAG5B,IAAK,IAAI,KADT,EAAU,GAAW,AACF,CADG,EAEpB,CAAa,CAAC,EAAO,CADK,AACF,CAAO,CAAC,EAAO,CAGzC,EAAc,MAAM,CAAG,EAEvB,IAAI,EAAW,EAAO,IAAI,CAW1B,OAVA,EAAO,IAAI,CAAG,WAEZ,OADA,EAAc,WAAW,CAAC,WACnB,EAAS,KAAK,CAAC,EAAQ,UAChC,EAEA,EAAO,EAAE,CAAC,QAAS,WAAY,GAC3B,EAAc,WAAW,EAAE,AAC7B,EAAO,KAAK,GAGP,CACT,EAEA,OAAO,cAAc,CAAC,EAAc,SAAS,CAAE,WAAY,CACzD,cAAc,EACd,YAAY,EACZ,IAAK,WACH,OAAO,IAAI,CAAC,MAAM,CAAC,QAAQ,AAC7B,CACF,GAEA,EAAc,SAAS,CAAC,WAAW,CAAG,WACpC,OAAO,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAE,UACpD,EAEA,EAAc,SAAS,CAAC,MAAM,CAAG,WAC3B,AAAC,IAAI,CAAC,SAAS,EAAE,AACnB,IAAI,CAAC,OAAO,GAGd,IAAI,CAAC,MAAM,CAAC,MAAM,EACpB,EAEA,EAAc,SAAS,CAAC,KAAK,CAAG,WAC9B,IAAI,CAAC,MAAM,CAAC,KAAK,EACnB,EAEA,EAAc,SAAS,CAAC,OAAO,CAAG,WAChC,IAAI,CAAC,SAAS,CAAG,GAEjB,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,CAAA,SAAS,CAAI,EACxC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,GACxB,CAAA,CAAE,IAAI,CAAC,IAAI,GACX,IAAI,CAAC,eAAe,CAAG,EACzB,AAD2B,EAG3B,EAAc,SAAS,CAAC,IAAI,CAAG,WAC7B,IAAI,EAAI,EAAO,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,WAE1C,OADA,IAAI,CAAC,MAAM,GACJ,CACT,EAEA,EAAc,SAAS,CAAC,WAAW,CAAG,SAAS,CAAI,EACjD,AAAI,IAAI,CAAC,SAAS,CAChB,CADkB,GACd,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAE,IAIR,QAAQ,CAApB,CAAI,CAAC,EAAE,GACT,IAAI,CAAC,QAAQ,EAAI,CAAI,CAAC,EAAE,CAAC,MAAM,CAC/B,IAAI,CAAC,2BAA2B,IAGlC,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,GAC5B,EAEA,EAAc,SAAS,CAAC,2BAA2B,CAAG,WACpD,IAAI,IAAI,CAAC,oBAAoB,EAAE,EAI3B,IAAI,CAAC,QAAQ,EAAI,IAAI,CAAC,WAAA,AAAW,EAAE,CAIvC,IAAI,CAAC,oBAAoB,EAAG,EAC5B,IAAI,EACF,gCAAkC,IAAI,CAAC,WAAW,CAAG,mBACvD,IAAI,CAAC,IAAI,CAAC,QAAS,AAAI,MAAM,IAC/B,oBC1GA,IAAI,EAAA,EAAA,CAAA,CAAA,QACA,EAAS,EAAA,CAAA,CAAA,QAAkB,MAAM,CACjC,EAAA,EAAA,CAAA,CAAA,QAGJ,SAAS,IACP,IAAI,CAAC,QAAQ,EAAG,EAChB,IAAI,CAAC,QAAQ,EAAG,EAChB,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,CAAC,WAAW,CAAG,IAAI,IACvB,GAD8B,CAC1B,CAAC,YAAY,EAAG,EAEpB,IAAI,CAAC,SAAS,EAAG,EACjB,IAAI,CAAC,QAAQ,CAAG,EAAE,CAClB,IAAI,CAAC,cAAc,CAAG,KACtB,IAAI,CAAC,WAAW,EAAG,EACnB,IAAI,CAAC,YAAY,CAAG,EACtB,CAbA,EAAO,OAAO,CAAG,EAcjB,EAAK,QAAQ,CAAC,EAAgB,GAE9B,EAAe,MAAM,CAAG,SAAS,CAAO,EACtC,IAAI,EAAiB,IAAI,IAAI,CAG7B,IAAK,IAAI,KADT,EAAU,GACS,AADE,CAAC,EAEpB,CAAc,CAAC,EAAO,CADI,AACD,CAAO,CAAC,EAAO,CAG1C,OAAO,CACT,EAEA,EAAe,YAAY,CAAG,SAAS,CAAM,EAC3C,MAA0B,YAAlB,OAAO,GACS,UAAlB,OAAO,GACW,WAAlB,OAAO,GACW,UAAlB,OAAO,GACP,CAAC,OAAO,QAAQ,CAAC,EACzB,EAEA,EAAe,SAAS,CAAC,MAAM,CAAG,SAAS,CAAM,EAG/C,GAFmB,CAEf,CAF8B,YAAY,CAAC,GAE7B,CAChB,GAAI,CAAC,CAAC,aAAkB,CAAA,CAAa,CAAG,CACtC,IAAI,EAAY,EAAc,MAAM,CAAC,EAAQ,CAC3C,YAAa,IACb,YAAa,IAAI,CAAC,YAAY,AAChC,GACA,EAAO,EAAE,CAAC,OAAQ,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,GAC/C,EAAS,CACX,CAEA,IAAI,CAAC,aAAa,CAAC,GAEf,IAAI,CAAC,YAAY,EAAE,AACrB,EAAO,KAAK,EAEhB,CAGA,OADA,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,GACZ,IACT,AADa,EAGb,EAAe,SAAS,CAAC,IAAI,CAAG,SAAS,CAAI,CAAE,CAAO,EAGpD,OAFA,EAAO,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAE,EAAM,GACvC,IAAI,CAAC,MAAM,GACJ,CACT,EAEA,EAAe,SAAS,CAAC,QAAQ,CAAG,WAGlC,GAFA,IAAI,CAAC,cAAc,CAAG,KAElB,IAAI,CAAC,WAAW,CAAE,CACpB,IAAI,CAAC,YAAY,EAAG,EACpB,MACF,CAEA,CAHU,GAGN,CAAC,SAHkB,EAGP,EAAG,EACnB,GAAI,CACF,GAAG,AACD,IAAI,CAAC,YAAY,CAAG,GACpB,IAAI,CAAC,YAAY,SACV,IAAI,CAAC,YAAY,CAAE,AAC9B,QAAU,CACR,IAAI,CAAC,WAAW,CAAG,EACrB,CACF,EAEA,EAAe,SAAS,CAAC,YAAY,CAAG,WACtC,IAAI,EAAS,IAAI,CAAC,QAAQ,CAAC,KAAK,EAGhC,AAAI,MAAiB,IAAV,EACT,IAAI,CAAC,EAD2B,CACxB,GAIY,YAAlB,AAA8B,OAAvB,EACT,IAAI,CAAC,SAAS,CAAC,GAID,AAChB,EAAU,UAAS,CAAM,EACJ,EAAe,YAAY,CAAC,KAE7C,EAAO,EAAE,CAAC,OAAQ,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,GAC/C,IAAI,CAAC,aAAa,CAAC,IAGrB,IAAI,CAAC,SAAS,CAAC,GACjB,CAAA,CAAE,IAAI,CAAC,IAAI,EACb,EAEA,EAAe,SAAS,CAAC,SAAS,CAAG,SAAS,CAAM,EAIlD,GAHA,CAGI,GAHA,CAAC,cAAc,CAAG,EAEH,EAAe,YAAY,CAAC,GAC7B,CAChB,EAAO,EAAE,CAAC,MAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,GACxC,EAAO,IAAI,CAAC,IAAI,CAAE,CAAC,KAAK,CAAK,GAC7B,MACF,CAGA,IAAI,CAAC,KAAK,CADE,AACD,GACX,IAAI,CAAC,QAAQ,EACf,EAEA,EAAe,SAAS,CAAC,aAAa,CAAG,SAAS,CAAM,EACtD,IAAI,EAAO,IAAI,CACf,EAAO,EAAE,CAAC,QAAS,SAAS,CAAG,EAC7B,EAAK,UAAU,CAAC,EAClB,EACF,EAEA,EAAe,SAAS,CAAC,KAAK,CAAG,SAAS,CAAI,EAC5C,IAAI,CAAC,IAAI,CAAC,OAAQ,EACpB,EAEA,EAAe,SAAS,CAAC,KAAK,CAAG,WAC1B,IAAI,CAAC,YAAY,EAAE,CAIrB,IAAI,CAAC,YAAY,EAAI,IAAI,CAAC,cAAc,EAAyC,AAArC,mBAAO,IAAI,CAAC,cAAc,CAAC,KAAK,EAAiB,IAAI,CAAC,cAAc,CAAC,KAAK,GACzH,IAAI,CAAC,IAAI,CAAC,SACZ,EAEA,EAAe,SAAS,CAAC,MAAM,CAAG,WAC3B,IAAI,CAAC,SAAS,EAAE,CACnB,IAAI,CAAC,SAAS,EAAG,EACjB,IAAI,CAAC,QAAQ,EAAG,EAChB,IAAI,CAAC,QAAQ,IAGZ,IAAI,CAAC,YAAY,EAAI,IAAI,CAAC,cAAc,EAA0C,YAAtC,OAAO,IAAI,CAAC,cAAc,CAAC,MAAM,EAAiB,IAAI,CAAC,cAAc,CAAC,MAAM,GAC3H,IAAI,CAAC,IAAI,CAAC,SACZ,EAEA,EAAe,SAAS,CAAC,GAAG,CAAG,WAC7B,IAAI,CAAC,MAAM,GACX,IAAI,CAAC,IAAI,CAAC,MACZ,EAEA,EAAe,SAAS,CAAC,OAAO,CAAG,WACjC,IAAI,CAAC,MAAM,GACX,IAAI,CAAC,IAAI,CAAC,QACZ,EAEA,EAAe,SAAS,CAAC,MAAM,CAAG,WAChC,IAAI,CAAC,QAAQ,EAAG,EAChB,IAAI,CAAC,QAAQ,CAAG,EAAE,CAClB,IAAI,CAAC,cAAc,CAAG,IACxB,EAEA,EAAe,SAAS,CAAC,cAAc,CAAG,WAExC,GADA,IAAI,CAAC,eAAe,KAChB,IAAI,CAAC,QAAQ,EAAI,IAAI,CAAC,WAAA,AAAW,EAAE,CAIvC,IAAI,EACF,gCAAkC,IAAI,CAAC,WAAW,CAAG,mBACvD,IAAI,CAAC,UAAU,CAAC,AAAI,MAAM,IAC5B,EAEA,EAAe,SAAS,CAAC,eAAe,CAAG,WACzC,IAAI,CAAC,QAAQ,CAAG,EAEhB,IAAI,EAAO,IAAI,CACf,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,SAAS,CAAM,EAC9B,EAAO,QAAQ,EAAE,CAItB,EAAK,QAAQ,EAAI,EAAO,QAAA,AAAQ,CAClC,GAEI,IAAI,CAAC,cAAc,EAAI,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,CACvD,IAAI,CAAC,QAAQ,EAAI,IAAI,CAAC,cAAc,CAAC,QAAA,AAAQ,CAEjD,EAEA,EAAe,SAAS,CAAC,UAAU,CAAG,SAAS,CAAG,EAChD,IAAI,CAAC,MAAM,GACX,IAAI,CAAC,IAAI,CAAC,QAAS,EACrB,cC/MA,EAAA,CAAA,CAAA,KAAA,KAAA,CAAA,iw9I,mBCWA,EAAO,OAAO,CAAA,EAAA,CAAA,CAAA,uCCGd,IA2IuB,EAAY,EAE7B,EA7IF,CA2IoC,CA3IpC,EAAA,AA2I6B,CA3I7B,CAAA,QACA,EAAU,EAAA,CAAA,CAAA,QAAgB,OAAO,CAOjC,EAAsB,0BACtB,EAAmB,WAyBvB,SAAS,EAAS,CAAI,EACpB,GAAI,CAAC,GAAwB,UAAhB,AAA0B,OAAnB,EAClB,MAAO,GAIT,IAAI,EAAQ,EAAoB,IAAI,CAAC,GACjC,EAAO,GAAS,CAAE,CAAC,CAAK,CAAC,EAAE,CAAC,WAAW,GAAG,QAE9C,AAAI,GAAQ,EAAK,OAAO,CACf,CADiB,CACZ,OAAO,GAIjB,IAAS,EAAiB,IAAI,CAAC,CAAK,CAAC,GAAE,GAAG,AACrC,OAIX,CArCA,EAAQ,OAAO,CAAG,EAClB,EAAQ,QAAQ,CAAG,CAAE,OAAQ,CAAQ,EACrC,EAAQ,WAAW,CA4CnB,EA5CsB,OA4Cb,AAAa,CAAG,EAEvB,GAAI,CAAC,GAAsB,UAAf,AAAyB,OAAlB,EACjB,MAAO,GAGT,IAAI,EAA4B,CAAC,IAAtB,EAAI,OAAO,CAAC,KACnB,EAAQ,MAAM,CAAC,GACf,EAEJ,GAAI,CAAC,EACH,IADS,GACF,EAIT,GAAgC,CAAC,IAA7B,EAAK,OAAO,CAAC,WAAmB,CAClC,IAAI,EAAU,EAAQ,OAAO,CAAC,GAC1B,IAAS,GAAQ,aAAe,EAAQ,WAAW,EAAA,CACzD,CAEA,OAAO,CACT,EAhEA,EAAQ,SAAS,CAyEjB,EAzEoB,OAyEX,AAAW,CAAI,EACtB,GAAI,CAAC,GAAQ,AAAgB,UAAU,OAAnB,EAClB,MAAO,GAIT,IAAI,EAAQ,EAAoB,IAAI,CAAC,GAGjC,EAAO,GAAS,EAAQ,UAAU,CAAC,CAAK,CAAC,EAAE,CAAC,WAAW,GAAG,OAE9D,CAAI,CAAC,IAAQ,CAAC,EAAK,MAAM,EAAE,AAIpB,CAAI,CAAC,EAAE,AAChB,EAxFA,EAAQ,UAAU,CAAG,OAAO,MAAM,CAAC,MACnC,EAAQ,MAAM,CAgGd,EAhGiB,OAgGR,AAAQ,CAAI,EACnB,GAAI,CAAC,GAAwB,UAAU,AAA1B,OAAO,EAClB,OAAO,EAIT,IAAI,EAAY,EAAQ,KAAO,GAC5B,WAAW,GACX,MAAM,CAAC,SAEV,CAAI,CAAC,GAIE,GAAQ,KAJC,AAII,CAAC,EAAU,GAAI,CAAA,CACrC,EA9GA,EAAQ,KAAK,CAAG,OAAO,MAAM,CAAC,QAGjB,EAAQ,UAAU,GAAE,EAAQ,KAAK,GAoH3B,CAAC,QAAS,cAAU,EAAW,OAAO,CAEvD,OAAO,IAAI,CAAC,GAAI,OAAO,CAAC,SAAS,AAAiB,CAAI,EACpD,IAAI,EAAO,CAAE,CAAC,EAAK,CACf,EAAO,EAAK,UAAU,CAE1B,GAAI,AAAC,GAAS,EAAK,GAAN,GAAY,EAAE,AAK3B,CAAU,CAAC,EAAK,CAAG,EAGnB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,MAAM,CAAE,IAAK,CACpC,IAAI,EAAY,CAAI,CAAC,EAAE,CAEvB,GAAI,CAAK,CAAC,EAAU,CAAE,CACpB,IAAI,EAAO,EAAW,OAAO,CAAC,CAAE,CAAC,CAAK,CAAC,EAAU,CAAC,CAAC,MAAM,EACrD,EAAK,EAAW,OAAO,CAAC,EAAK,MAAM,EAEvC,GAAyB,6BAArB,CAAK,AACP,CADQ,EAAU,GACjB,EAAO,GAAO,IAAS,GAAyC,iBAAnC,CAAK,CAAC,EAAU,CAAC,MAAM,CAAC,EAAG,GAAQ,CAAe,CAEhF,EAFmF,MAIvF,CAGA,CAAK,CAAC,EAAU,CAAG,CACrB,EACF,qBC1LF,EAAO,OAAO,CAOd,EAPiB,OAOR,AAAM,CAAE,EAEf,IAAI,EAAkC,YAAvB,OAAO,aAClB,aAEkB,UAAlB,OAAO,SAAkD,YAA3B,OAAO,QAAQ,QAAQ,CACnD,QAAQ,QAAQ,CAChB,KAGF,EAEF,EAAS,GAIT,GALF,QAKa,EAAI,EAEnB,oBCzBA,IAAI,EAAA,EAAA,CAAA,CAAA,QAGJ,EAAO,OAAO,CASd,EATiB,OASR,AAAM,CAAQ,EAErB,IAAI,GAAU,EAKd,OAFA,EAAM,WAAa,GAAU,CAAM,GAE5B,SAAS,AAAe,CAAG,CAAE,CAAM,EAEpC,EAEF,EAAS,EAAK,GADhB,AAKE,EAAM,SAAS,EAEb,EAAS,EAAK,EAChB,EAEJ,CACF,oBChCA,EAAO,OAAO,CAOd,EAPiB,OAOR,AAAM,CAAK,EAElB,OAAO,IAAI,CAAC,EAAM,IAAI,EAAE,OAAO,CAAC,EAAM,IAAI,CAAC,IAG3C,EAAM,IAAI,CAAG,CAAC,CAChB,EAQA,SAAS,EAAM,CAAG,EAEZ,AAAyB,YAC7B,OADW,IAAI,CAAC,IAAI,CAAC,EAAI,EAEvB,IAAI,CAAC,IAAI,CAAC,EAAI,EAElB,oBC5BA,IAAI,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QAIJ,EAAO,OAAO,CAUd,EAViB,OAUR,AAAQ,CAAI,CAAE,CAAQ,CAAE,CAAK,CAAE,CAAQ,EAG9C,IAwCc,EAAU,GAAG,GAxCvB,AAwCkB,EAxCZ,EAAM,GAAD,MAAa,CAAG,EAAM,GAAD,MAAa,CAAC,EAAM,KAAK,CAAC,CAAG,EAAM,KAAK,CAE5E,EAAM,IAAI,CAAC,EAAI,GAAG,CAAO,IAAU,EAsCN,EAtCW,CAAI,CAAC,AAsCZ,EAtCgB,CAsCd,EAtCgB,MAsCR,GAtCiB,CAAK,CAAE,CAAM,EAIjE,KAAO,EAAM,IAAI,GACvB,AAKA,OAAO,EAAM,IAAI,CAAC,EAAI,CAElB,EAKF,EAAM,GAJR,AAQE,EAAM,OAAO,CAAC,EAAI,CAAG,EAIvB,EAAS,EAAO,EAAM,OAAO,EAC/B,EAiBuB,GACvB,AADI,EAAS,MAAM,CAEP,EAAS,EAAM,EAAM,IAKrB,EAAS,EAAM,EAAK,EAAM,IAvBxC,oBC9CA,EAAO,OAAO,CAWd,EAXiB,OAWR,AAAM,CAAI,CAAE,CAAU,EAE7B,IAAI,EAAc,CAAC,MAAM,OAAO,CAAC,GAC7B,EACF,CACE,MAAW,EACX,UAAW,GAAe,EAAa,OAAO,IAAI,CAAC,GAAQ,KAC3D,KAAW,CAAC,EACZ,QAAW,EAAc,CAAC,EAAI,EAAE,CAChC,KAAW,EAAc,OAAO,IAAI,CAAC,GAAM,MAAM,CAAG,EAAK,MAAM,AACjE,EAaF,OAVI,GAIF,EAAU,OAHZ,EAGqB,CAAC,IAAI,CAAC,EAAc,EAAa,SAAS,CAAC,CAAE,CAAC,EAE/D,OAAO,EAAW,CAAI,CAAC,EAAE,CAAE,CAAI,CAAC,EAAE,CACpC,GAGK,CACT,oBCpCA,IAAI,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QAIJ,EAAO,OAAO,CAQd,EARiB,OAQR,AAAW,CAAQ,EAErB,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,EAClC,CAKA,IAAI,CAAC,KAAK,CAAG,IAAI,CAAC,IAAI,CAGtB,EAAM,IAAI,EAGV,EAAM,GAAU,KAAM,IAAI,CAAC,OAAO,EACpC,oBC5BA,IAAI,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QAIJ,EAAO,OAAO,CAUd,EAViB,OAUR,AAAS,CAAI,CAAE,CAAQ,CAAE,CAAQ,EAIxC,IAFA,IAAI,EAAQ,EAAU,GAEf,EAAM,KAAK,CAAG,AAAC,GAAM,EAAD,OAAa,EAAI,CAAA,CAAI,CAAE,MAAM,CACxD,CACE,EAAQ,EAAM,EAAU,EAAO,SAAS,CAAK,CAAE,CAAM,EAEnD,AAAI,EAEF,EAAS,EAAO,CADlB,EAMuC,GACvC,CADI,OAAO,IAAI,CAAC,EAAM,IAAI,EAAE,MAAM,EAEhC,EAAS,KAAM,EAAM,OAAO,CAGhC,GAEA,EAAM,KAAK,GAGb,OAAO,EAAW,IAAI,CAAC,EAAO,EAChC,oBC1CA,IAAI,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QAyDJ,SAAS,EAAU,CAAC,CAAE,CAAC,EAErB,OAAO,EAAI,EAAI,CAAC,IAAI,EAAI,EAC1B,CAxDA,CAuD8B,CAvDvB,GAuD2B,IAvDpB,CAcd,EAdiB,OAcR,AAAc,CAAI,CAAE,CAAQ,CAAE,CAAU,CAAE,CAAQ,EAEzD,IAAI,EAAQ,EAAU,EAAM,GAuB5B,OArBA,EAAQ,EAAM,EAAU,EAAO,SAAS,EAAgB,CAAK,CAAE,CAAM,EAEnE,AAAI,EAEF,EAAS,EAAO,CADlB,GAKA,EAAM,KAAK,GAGP,EAAM,KAAK,CAAG,CAAC,EAAM,GAAD,MAAa,EAAI,CAAA,CAAI,CAAE,MAAM,EACrD,AACE,EAAQ,EAAM,EAAU,EAAO,GAKjC,EAAS,KAAM,EAAM,OAAO,CAC9B,GAEO,EAAW,IAAI,CAAC,EAAO,EAChC,EAtCA,EAAO,OAAO,CAAC,SAAS,CAAI,EAC5B,EAAO,OAAO,CAAC,UAAU,CA8DzB,EA9D4B,OA8DnB,AAAW,CAAC,CAAE,CAAC,EAEtB,OAAO,CAAC,EAAI,EAAU,EAAG,EAC3B,oBC1EA,IAAI,EAAA,EAAA,CAAA,CAAA,QAGJ,EAAO,OAAO,CAUd,EAViB,OAUR,AAAO,CAAI,CAAE,CAAQ,CAAE,CAAQ,EAEtC,OAAO,EAAc,EAAM,EAAU,KAAM,EAC7C,oBChBA,EAAO,OAAO,CACd,CACE,QAAQ,CAAA,EAAA,CAAA,CAAA,QACR,MAAM,CAAA,EAAA,CAAA,CAAA,QACN,aAAa,CAAA,EAAA,CAAA,CAAA,OACf,iCCFA,EAAO,OAAO,CAAG,sCCAjB,EAAO,OAAO,CAAG,qCCAjB,EAAO,OAAO,CAAG,yCCAjB,EAAO,OAAO,CAAG,0CCAjB,EAAO,OAAO,CAAG,8CCAjB,EAAO,OAAO,CAAG,2CCAjB,EAAO,OAAO,CAAG,yCCAjB,EAAO,OAAO,CAAG,wCCAjB,EAAO,OAAO,CAAG,KAAK,GAAG,gCCAzB,EAAO,OAAO,CAAG,KAAK,KAAK,gCCA3B,EAAO,OAAO,CAAG,KAAK,GAAG,gCCAzB,EAAO,OAAO,CAAG,KAAK,GAAG,gCCAzB,EAAO,OAAO,CAAG,KAAK,GAAG,gCCAzB,EAAO,OAAO,CAAG,KAAK,KAAK,gCCA3B,EAAO,OAAO,CAAG,OAAO,KAAK,EAAI,SAAS,AAAM,CAAC,EAChD,OAAO,GAAM,CACd,iCCHA,IAAI,EAAA,EAAA,CAAA,CAAA,QAGJ,EAAO,OAAO,CAAG,SAAS,AAAK,CAAM,SACpC,AAAI,EAAO,IAAW,AAAW,GAAG,GAC5B,EAED,EAAS,EAAI,CAAC,EAAI,CAAC,AAC3B,iCCPA,EAAO,OAAO,CAAG,OAAO,wBAAwB,gCCAhD,IAAI,EAAA,EAAA,CAAA,CAAA,QAEJ,GAAI,EACH,GAAI,CACH,CAFS,CAEH,EAAE,CAAE,SACX,CAAE,MAAO,EAAG,CAEX,EAAQ,IACT,CAGD,EAAO,OAAO,CAAG,iCCXjB,IAAI,EAAkB,OAAO,cAAc,EAAI,GAC/C,GAAI,EACH,GAAI,CACH,EAAgB,CAAC,EAAG,IAAK,CAAE,CAFR,KAEe,CAAE,EACrC,CAAE,MAAO,EAAG,CAEX,GAAkB,CACnB,CAGD,EAAO,OAAO,CAAG,iCCTjB,EAAO,OAAO,CAAG,SAAS,EACzB,GAAsB,YAAlB,OAAO,QAAiE,AAAxC,YAAoD,OAA7C,OAAO,qBAAqB,CAAmB,OAAO,EACjG,GAA+B,UAAU,AAArC,OAAO,OAAO,QAAQ,CAAiB,OAAO,EAGlD,IAAI,EAAM,CAAC,EACP,EAAM,OAAO,QACb,EAAS,OAAO,GACpB,GAAmB,UAAU,AAAzB,OAAO,GAEiC,mBAAmB,CAA3D,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,IACY,mBAAmB,CAA9D,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,GAHJ,OAAO,EAetC,IAAK,IAAI,KADT,CAAG,CAAC,EAAI,GAAG,CACG,EAAO,EAAF,KAAS,EAC5B,GAA2B,YAAvB,OAAO,OAAO,IAAI,EAA+C,GAAG,CAA/B,OAAO,IAAI,CAAC,GAAK,MAAM,EAEtB,YAAtC,OAAO,OAAO,mBAAmB,EAA8D,GAAG,CAA9C,OAAO,mBAAmB,CAAC,GAAK,MAAM,CAFpB,OAAO,EAIjF,IAAI,EAAO,OAAO,qBAAqB,CAAC,GACxC,GAAoB,IAAhB,EAAK,MAAM,EAAU,CAAI,CAAC,EAAE,GAAK,GAEjC,CAAC,CAFqC,MAE9B,SAAS,CAAC,oBAAoB,CAAC,IAAI,CAAC,EAAK,GAFT,GAEe,IAFR,EAInD,GAA+C,AAA3C,mBAAO,OAAO,wBAAwB,CAAiB,CAE1D,IAAI,EAAgD,OAAO,wBAAwB,CAAC,EAAK,GACzF,GAfY,KAeR,EAAW,KAAK,EAAyC,AAA1B,GAAV,GAA0C,CAArB,UAAU,CAAa,OAAO,CAC7E,CAEA,OAAO,CACR,iCC1CA,IAAI,EAA+B,aAAlB,OAAO,QAA0B,OAC9C,EAAA,EAAA,CAAA,CAAA,QAGJ,EAAO,OAAO,CAAG,SAAS,QACzB,AAA0B,YAAY,AAAlC,OAAO,GACP,AAAkB,YAAY,OAAvB,QACsB,UAAU,AAAvC,OAAO,EAAW,QACO,UAAzB,AAAmC,OAA5B,OAAO,QAEX,GACR,iCCVA,EAAO,OAAO,CAAI,AAAmB,oBAAZ,SAA2B,QAAQ,cAAc,EAAK,oCCE/E,EAAO,OAAO,CAAG,AAHb,EAAA,CAAA,CAAA,QAGqB,cAAc,EAAI,mCCA3C,IAAI,EAAQ,OAAO,SAAS,CAAC,QAAQ,CACjC,EAAM,KAAK,GAAG,CAGd,EAAW,SAAS,AAAS,CAAC,CAAE,CAAC,EAGjC,IAAK,IAFD,EAAM,EAAE,CAEH,EAAI,EAAG,EAAI,EAAE,MAAM,CAAE,GAAK,EAAG,AAClC,CAAG,CAAC,EAAE,CAAG,CAAC,CAAC,EAAE,CAEjB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAE,MAAM,CAAE,GAAK,EAC/B,AADkC,CAC/B,CAAC,EAAI,EAAE,MAAM,CAAC,CAAG,CAAC,CAAC,EAAE,CAG5B,OAAO,CACX,EAEI,EAAQ,SAAS,AAAM,CAAO,CAAE,CAAM,EAEtC,IAAK,IADD,EAAM,EAAE,CACH,EAAI,GAAU,EAAG,EAAI,EAAG,EAAI,EAAQ,MAAM,CAAE,GAAK,EAAG,GAAK,EAAG,AACjE,CAAG,CAAC,EAAE,CAAG,CAAO,CAAC,EAAE,CAEvB,OAAO,CACX,EAEI,EAAQ,SAAU,CAAG,CAAE,CAAM,EAE7B,IAAK,IADD,EAAM,GACD,EAAI,EAAG,EAAI,EAAI,MAAM,CAAE,GAAK,EAAG,AACpC,GAAO,CAAG,CAAC,EAAE,CACT,EAAI,EAAI,EAAI,MAAM,EAAE,CACpB,GAAO,CAAA,EAGf,OAAO,CACX,EAEA,EAAO,OAAO,CAAG,SAAS,AAAK,CAAI,EAC/B,IAMI,EANA,EAAS,IAAI,CACjB,GAAsB,YAAlB,OAAO,GAAyB,AApCzB,wBAoC+B,KAAK,CAAC,GAC5C,MAAM,AAAI,GAD8C,OACpC,AAxCR,GAuCsD,+CAC9B,GAyBxC,IAAK,IAvBD,EAAO,EAAM,UAAW,GAqBxB,EAAc,EAAI,EAAG,EAAO,MAAM,CAAG,EAAK,MAAM,EAChD,EAAY,EAAE,CACT,EAAI,EAAG,EAAI,EAAa,IAAK,AAClC,CAAS,CAAC,EAAE,CAAG,IAAM,EAKzB,GAFA,EAAQ,SAAS,SAAU,oBAAsB,EAAM,EAAW,KAAO,6CAA6C,AAxBzG,WACT,GAAI,IAAI,YAAY,EAAO,CACvB,IAAI,EAAS,EAAO,KAAK,CACrB,IAAI,CACJ,EAAS,EAAM,mBAEnB,AAAI,OAAO,KAAY,EACZ,EAEJ,IAHwB,AAGpB,AACf,CACA,OAAO,EAAO,KAAK,CACf,EACA,EAAS,EAAM,WAGvB,GAUI,EAAO,SAAS,CAAE,CAClB,IAAI,EAAQ,SAAS,EAAS,EAC9B,EAAM,SAAS,CAAG,EAAO,SAAS,CAClC,EAAM,SAAS,CAAG,IAAI,EACtB,EAAM,SAAS,CAAG,IACtB,CAEA,OAAO,CACX,gCCjFA,IAAI,EAAA,EAAA,CAAA,CAAA,OAEJ,EAAO,OAAO,CAAG,SAAS,SAAS,CAAC,IAAI,EAAI,iCCD5C,EAAO,OAAO,CAAG,SAAS,SAAS,CAAC,IAAI,gCCAxC,EAAO,OAAO,CAAG,SAAS,SAAS,CAAC,KAAK,+BCAzC,GAAO,OAAO,CAAsB,aAAnB,OAAO,SAA2B,SAAW,QAAQ,KAAK,gCCD3E,IAAI,EAAA,EAAA,CAAA,CAAA,OAEA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QAIJ,EAAO,OAAO,CAAG,AAHb,EAAA,CAAA,CAAA,SAG8B,EAAK,IAAI,CAAC,EAAO,kCCPnD,IAAI,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,QAEA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QAGJ,EAAO,OAAO,CAAG,SAAS,AAAc,CAAI,EAC3C,GAAI,EAAK,MAAM,CAAG,GAAwB,YAAnB,AAA+B,OAAxB,CAAI,CAAC,EAAE,CACpC,MAAM,IAAI,EAAW,0BAEtB,OAAO,EAAa,EAAM,EAAO,EAClC,iCCZA,IAGI,EAHA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QAGJ,GAAI,CAEH,EAA0E,EAAE,CAAE,SAAS,GAAK,EAAzE,IAA+E,SAAS,AAC5G,CAAE,MAAO,EAAG,CACX,GAAI,CAAC,GAAkB,UAAb,OAAO,GAAkB,CAAC,AAFkC,CAEjC,UAAU,CAAC,EAAK,AAAW,oBAAoB,GAA7B,IAAI,CAC1D,MAAM,CAER,CAGA,IAAI,EAAO,CAAC,CAAC,GAAoB,GAAQ,EAAK,OAAO,SAAS,CAAgD,aAE1G,EAAU,OACV,EAAkB,EAAQ,cAAc,CAG5C,EAAO,OAAO,CAAG,GAA4B,YAApB,OAAO,EAAK,GAAG,CACrC,EAAS,CAAC,EAAK,GAAG,CAAC,EACQ,YAA3B,CACC,MADM,GACyB,SAAS,AAAU,CAAK,EAExD,OAF6B,AAEtB,EAAyB,MAAT,EAAgB,EAAQ,EAAQ,GACxD,IACE,6BC3BJ,IAAI,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QAEA,EAAA,EAAA,CAAA,CAAA,QAGJ,EAAO,OAAO,CAAG,EACd,SAAS,AAAS,CAAC,EAEpB,OAAO,EAAgB,EACxB,EACE,EACC,SAAS,AAAS,CAAC,EACpB,GAAI,CAAC,GAAmB,UAAb,OAAO,GAA+B,YAAa,AAA1B,OAAO,EAC1C,MAAM,AAAI,UAAU,2BAGrB,OAAO,EAAiB,EACzB,EACE,EACC,SAAS,AAAS,CAAC,EAEpB,OAAO,EAAe,EACvB,EACE,oCCxBL,IAAI,EAAO,SAAS,SAAS,CAAC,IAAI,CAC9B,EAAU,OAAO,SAAS,CAAC,cAAc,CAI7C,EAAO,OAAO,CAHV,AAGa,EAHb,CAAA,CAAA,OAGkB,IAAI,CAAC,EAAM,iCCHjC,IAAI,EAAA,EAAA,CAAA,CAAA,QAEA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QAEA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QAEA,EAAY,SAGZ,EAAwB,SAAU,CAAgB,EACrD,GAAI,CACH,OAAO,EAAU,yBAA2B,EAAmB,mBAChE,CAAE,MAAO,EAAG,CAAC,CACd,EAEI,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QAEA,EAAiB,WACpB,MAAM,IAAI,CACX,EACI,EAAiB,EACjB,WACF,GAAI,CAGH,OADA,UAAU,MAAM,CACT,CADW,AAEnB,CAAE,MAAO,EAAc,CACtB,GAAI,CAEH,OAAO,EAAM,IAL+B,MAKpB,UAAU,GAAG,AACtC,CAAE,MAAO,EAAY,CACpB,OAAO,CACR,CACD,CACD,IACE,EAEC,EAAa,EAAA,CAAA,CAAA,UAEb,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QAEA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QAEA,EAAY,CAAC,EAEb,EAAmC,aAAtB,EAAqC,KAA9B,YAA+B,EAAuB,EAAS,iBAArB,EAE9D,EAAa,CAChB,UAAW,KACX,mBAA8C,aAA1B,OAAO,eAAiC,OAAY,eACxE,UAAW,MACX,gBAAwC,aAAvB,OAAO,iBAA8B,EAAY,YAClE,2BAA4B,GAAc,EAAW,EAAS,EAAE,CAAC,OAAO,QAAQ,CAAC,SAAM,EACvF,wCAAoC,EACpC,kBAAmB,EACnB,mBAAoB,EACpB,2BAA4B,EAC5B,2BAA4B,EAC5B,YAAgC,aAAnB,OAAO,aAA0B,EAAY,QAC1D,WAA8B,aAAlB,OAAO,YAAyB,EAAY,OACxD,kBAA4C,aAAzB,OAAO,mBAAgC,EAAY,cACtE,mBAA8C,aAA1B,OAAO,oBAAiC,EAAY,eACxE,YAAa,QACb,aAAkC,aAApB,OAAO,SAA2B,OAAY,SAC5D,SAAU,KACV,cAAe,UACf,uBAAwB,mBACxB,cAAe,UACf,uBAAwB,mBACxB,UAAW,EACX,SAAU,KACV,cAAe,EACf,iBAA0C,aAAxB,OAAO,kBAA+B,EAAY,aACpE,iBAAkB,AAAwB,oBAAjB,kBAA+B,EAAY,aACpE,iBAA0C,aAAxB,OAAO,kBAA+B,EAAY,aACpE,yBAA0D,aAAhC,OAAO,0BAAuC,EAAY,qBACpF,aAAc,EACd,sBAAuB,EACvB,cAAoC,aAArB,OAAO,eAA4B,EAAY,UAC9D,eAAsC,aAAtB,OAAO,gBAA6B,EAAY,WAChE,eAAgB,AAAsB,oBAAf,WAA6B,OAAY,WAChE,aAAc,SACd,UAAW,MACX,sBAAuB,GAAc,EAAW,EAAS,EAAS,EAAE,CAAC,OAAO,QAAQ,CAAC,UAAO,EAC5F,SAA0B,UAAhB,OAAO,KAAoB,UAAO,EAC5C,QAAS,AAAe,oBAAR,IAAsB,OAAY,IAClD,yBAAyC,aAAf,EAA8B,KAAvB,KAAwB,GAAe,EAAuB,EAAS,IAAI,GAArC,EAA0C,CAAC,OAAO,QAAQ,CAAC,SAA/C,EACnF,SAAU,KACV,WAAY,OACZ,WAAY,EACZ,oCAAqC,EACrC,eAAgB,WAChB,aAAc,SACd,YAAgC,aAAnB,OAAO,aAA0B,EAAY,QAC1D,UAA4B,aAAjB,OAAO,WAAwB,EAAY,MACtD,eAAgB,EAChB,mBAAoB,EACpB,YAAgC,aAAnB,OAAO,QAA0B,OAAY,QAC1D,WAAY,OACZ,QAAwB,aAAf,OAAO,SAAsB,EAAY,IAClD,yBAAyC,aAAf,EAA8B,KAAvB,KAAwB,GAAe,EAAuB,EAAS,IAAI,GAArC,EAA0C,CAAC,OAAO,QAAQ,CAAC,IAA/C,OACnF,sBAAoD,aAA7B,OAAO,uBAAoC,EAAY,kBAC9E,WAAY,OACZ,4BAA6B,GAAc,EAAW,EAAS,EAAE,CAAC,OAAO,QAAQ,CAAC,SAAM,EACxF,WAAY,EAAa,YAAS,EAClC,gBAAiB,EACjB,mBAAoB,EACpB,eAAgB,EAChB,cAAe,EACf,eAAsC,aAAtB,OAAO,gBAA6B,EAAY,WAChE,sBAAoD,AAA7B,oBAAO,uBAAoC,EAAY,kBAC9E,gBAAwC,aAAvB,OAAO,iBAA8B,EAAY,YAClE,gBAAwC,aAAvB,OAAO,iBAA8B,EAAY,YAClE,aAAc,EACd,YAAgC,aAAnB,OAAO,QAA0B,OAAY,QAC1D,YAAgC,aAAnB,OAAO,aAA0B,EAAY,QAC1D,YAAgC,aAAnB,OAAO,aAA0B,EAAY,QAE1D,4BAA6B,EAC7B,6BAA8B,EAC9B,0BAA2B,EAC3B,0BAA2B,EAC3B,aAAc,EACd,eAAgB,EAChB,aAAc,EACd,aAAc,EACd,aAAc,EACd,eAAgB,EAChB,cAAe,EACf,2BAA4B,CAC7B,EAEA,GAAI,EACH,GAAI,CACH,IAFY,CAEP,KAAK,AACX,CAAE,CADW,KACJ,EAAG,CAEX,IAAI,EAAa,EAAS,EAAS,IACnC,CAAU,CAAC,oBAAoB,AAJyB,CAItB,CACnC,CAGD,IAAI,EAAS,SAAS,EAAO,CAAI,EAChC,IAAI,EACJ,GAAa,mBAAmB,CAA5B,EACH,EAAQ,EAAsB,6BACxB,GAAI,AAAS,uBAAuB,GAC1C,EAAQ,EAAsB,wBACxB,GAAa,4BAA4B,CAArC,EACV,EAAQ,EAAsB,8BACxB,GAAa,qBAAT,EAA6B,CACvC,IAAI,EAAK,EAAO,4BACZ,IAAI,AACP,EAAQ,EAAG,SAAA,AAAS,CAEtB,MAAO,GAAI,AAAS,+BAA4B,CAC/C,IAAI,EAAM,EAAO,oBACb,GAAO,GACV,GAAQ,EAAS,EADG,AACC,UAAS,CAEhC,CAIA,OAFA,CAAU,CAAC,EAAK,CAAG,EAEZ,CACR,EAEI,EAAiB,CACpB,UAAW,KACX,yBAA0B,CAAC,cAAe,YAAY,CACtD,mBAAoB,CAAC,QAAS,YAAY,CAC1C,uBAAwB,CAAC,QAAS,YAAa,UAAU,CACzD,uBAAwB,CAAC,QAAS,YAAa,UAAU,CACzD,oBAAqB,CAAC,QAAS,YAAa,OAAO,CACnD,sBAAuB,CAAC,QAAS,YAAa,SAAS,CACvD,2BAA4B,CAAC,gBAAiB,YAAY,CAC1D,mBAAoB,CAAC,yBAA0B,YAAY,CAC3D,4BAA6B,CAAC,yBAA0B,YAAa,YAAY,CACjF,qBAAsB,CAAC,UAAW,YAAY,CAC9C,sBAAuB,CAAC,WAAY,YAAY,CAChD,kBAAmB,CAAC,OAAQ,YAAY,CACxC,mBAAoB,CAAC,QAAS,YAAY,CAC1C,uBAAwB,CAAC,YAAa,YAAY,CAClD,0BAA2B,CAAC,eAAgB,YAAY,CACxD,0BAA2B,CAAC,eAAgB,YAAY,CACxD,sBAAuB,CAAC,WAAY,YAAY,CAChD,cAAe,CAAC,oBAAqB,YAAY,CACjD,uBAAwB,CAAC,oBAAqB,YAAa,YAAY,CACvE,uBAAwB,CAAC,YAAa,YAAY,CAClD,wBAAyB,CAAC,aAAc,YAAY,CACpD,wBAAyB,CAAC,aAAc,YAAY,CACpD,cAAe,CAAC,OAAQ,QAAQ,CAChC,kBAAmB,CAAC,OAAQ,YAAY,CACxC,iBAAkB,CAAC,MAAO,YAAY,CACtC,oBAAqB,CAAC,SAAU,YAAY,CAC5C,oBAAqB,CAAC,SAAU,YAAY,CAC5C,sBAAuB,CAAC,SAAU,YAAa,WAAW,CAC1D,qBAAsB,CAAC,SAAU,YAAa,UAAU,CACxD,qBAAsB,CAAC,UAAW,YAAY,CAC9C,sBAAuB,CAAC,UAAW,YAAa,OAAO,CACvD,gBAAiB,CAAC,UAAW,MAAM,CACnC,mBAAoB,CAAC,UAAW,SAAS,CACzC,oBAAqB,CAAC,UAAW,UAAU,CAC3C,wBAAyB,CAAC,aAAc,YAAY,CACpD,4BAA6B,CAAC,iBAAkB,YAAY,CAC5D,oBAAqB,CAAC,SAAU,YAAY,CAC5C,iBAAkB,CAAC,MAAO,YAAY,CACtC,+BAAgC,CAAC,oBAAqB,YAAY,CAClE,oBAAqB,CAAC,SAAU,YAAY,CAC5C,oBAAqB,CAAC,SAAU,YAAY,CAC5C,yBAA0B,CAAC,cAAe,YAAY,CACtD,wBAAyB,CAAC,aAAc,YAAY,CACpD,uBAAwB,CAAC,YAAa,YAAY,CAClD,wBAAyB,CAAC,aAAc,YAAY,CACpD,+BAAgC,CAAC,oBAAqB,YAAY,CAClE,yBAA0B,CAAC,cAAe,YAAY,CACtD,yBAA0B,CAAC,cAAe,YAAY,CACtD,sBAAuB,CAAC,WAAY,YAAY,CAChD,qBAAsB,CAAC,UAAW,YAAY,CAC9C,qBAAsB,CAAC,UAAW,YAAY,AAC/C,EAEI,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAU,EAAK,IAAI,CAAC,EAAO,MAAM,SAAS,CAAC,MAAM,EACjD,EAAe,EAAK,IAAI,CAAC,EAAQ,MAAM,SAAS,CAAC,MAAM,EACvD,EAAW,EAAK,IAAI,CAAC,EAAO,OAAO,SAAS,CAAC,OAAO,EACpD,EAAY,EAAK,IAAI,CAAC,EAAO,OAAO,SAAS,CAAC,KAAK,EACnD,EAAQ,EAAK,IAAI,CAAC,EAAO,OAAO,SAAS,CAAC,IAAI,EAG9C,EAAa,qGACb,EAAe,WACf,CAD2B,CACZ,SAAS,AAAa,CAAM,EAC9C,IAAI,EAAQ,EAAU,EAAQ,EAAG,GAC7B,EAAO,EAAU,EAAQ,CAAC,GAC9B,GAAc,MAAV,EAJ2E,CAIjD,KAAK,CAAd,EACpB,MAAM,IAAI,EAAa,kDACjB,GAAa,MAAT,GAA0B,KAAK,CAAf,EAC1B,MAAM,IAAI,EAAa,kDAExB,IAAI,EAAS,EAAE,CAIf,OAHA,EAAS,EAAQ,EAAY,SAAU,CAAK,CAAE,CAAM,CAAE,CAAK,CAAE,CAAS,EACrE,CAAM,CAAC,EAAO,MAAM,CAAC,CAAG,EAAQ,EAAS,EAAW,EAAc,MAAQ,GAAU,CACrF,GACO,CACR,EAGI,EAAmB,SAAS,AAAiB,CAAI,CAAE,CAAY,EAClE,IACI,EADA,EAAgB,EAOpB,GALI,EAAO,EAAgB,KAE1B,EAAgB,IAAM,CADtB,EAAQ,CAAc,CAAC,AADmB,EACnB,AAAc,CACV,CAAC,EAAE,CAAG,GAAA,EAG9B,EAAO,EAAY,GAAgB,CACtC,IAAI,EAAQ,CAAU,CAAC,EAAc,CAIrC,GAHI,IAAU,IACb,EAAQ,EAAO,EAAA,CADS,CAGrB,KAAiB,IAAV,GAAyB,CAAC,EACpC,MAAM,IAAI,EADwC,AAC7B,aAAe,EAAO,wDAG5C,MAAO,CACN,MAAO,EACP,KAAM,EACN,MAAO,CACR,CACD,CAEA,MAAM,IAAI,EAAa,aAAe,EAAO,mBAC9C,EAEA,EAAO,OAAO,CAAG,SAAS,AAAa,CAAI,CAAE,CAAY,EACxD,GAAoB,UAAhB,OAAO,GAAqC,GAAG,CAAnB,EAAK,MAAM,CAC1C,MAAM,IAAI,EAAW,6CAEtB,GAAI,UAAU,MAAM,CAAG,GAA6B,WAAxB,AAAmC,OAA5B,EAClC,MAAM,IAAI,EAAW,6CAGtB,GAAmC,MAAM,CAArC,EAAM,cAAe,GACxB,MAAM,IAAI,EAAa,sFAExB,IAAI,EAAQ,EAAa,GACrB,EAAoB,EAAM,MAAM,CAAG,EAAI,CAAK,CAAC,EAAE,CAAG,GAElD,EAAY,EAAiB,IAAM,EAAoB,IAAK,GAC5D,EAAoB,EAAU,IAAI,CAClC,EAAQ,EAAU,KAAK,CACvB,GAAqB,EAErB,EAAQ,EAAU,KAAK,CACvB,IACH,EAAoB,CADV,AACe,CAAC,EAAE,CAC5B,EAAa,EAAO,EAAQ,CAAC,EAAG,EAAE,CAAE,KAGrC,IAAK,IAAI,EAAI,EAAG,GAAQ,EAAM,EAAI,EAAM,MAAM,CAAE,GAAK,EAAG,CACvD,IAAI,EAAO,CAAK,CAAC,EAAE,CACf,EAAQ,EAAU,EAAM,EAAG,GAC3B,EAAO,EAAU,EAAM,CAAC,GAC5B,GACC,CACY,MAAV,GAAiB,AAAU,SAAiB,MAAV,GACtB,MAAT,GAAyB,MAAT,GAAyB,MAAT,CAAS,CAC9C,EACG,IAAU,EAEb,IADC,EACK,IAAI,EAAa,wDASxB,GAPa,AAAT,iBAA0B,EAAC,IAC9B,GADqC,AAChB,CAAA,EAGtB,GAAqB,IAAM,EAGvB,EAAO,EAFX,EAAoB,IAAM,EAAoB,EAEvB,GACtB,EAAQ,CAAU,CAAC,EAAkB,MAC/B,GAAa,EAFuB,IAEhC,EAAe,CACzB,GAAI,CAAC,CAAC,KAAQ,CAAA,CAAK,CAAG,CACrB,GAAI,CAAC,EACJ,MAAM,IAAI,EADQ,AACG,sBAAwB,EAAO,+CAErD,MACD,CADQ,AAER,GAAI,EAFS,CAEC,EAAI,GAAM,EAAM,MAAM,CAAE,CACrC,IAAI,EAAO,EAAM,EAAO,GAWvB,EADG,CATJ,EAAQ,CAAC,CAAC,CAAA,GASG,QAAS,GAAQ,CAAC,CAAC,kBAAmB,EAAK,GAAG,AAAH,EAC/C,CADqD,CAChD,GAAG,CAER,CAAK,CAAC,EAAK,AAErB,MACC,CADM,CACE,EAAO,EAAO,GACtB,EAAQ,CAAK,CAAC,EAAK,CAGhB,GAAS,CAAC,GACb,EAAU,CAAC,EAAkB,CAAG,CAAA,CAElC,CACD,CACA,OAAO,AAL6B,CAMrC,iCCvXA,IAAI,EAAA,EAAA,CAAA,CAAA,QAGJ,EAAO,OAAO,CAAG,SAAS,EACzB,OAAO,KAAgB,CAAC,CAAC,OAAO,WAAW,AAC5C,iCCHA,IAAI,EAAkB,AAFlB,EAAA,CAAA,CAAA,OAE+B,2BAA2B,GAE1D,EAAiB,EAAA,CAAA,CAAA,UACjB,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QAEA,EAAc,EAAiB,OAAO,WAAW,CAAG,KAGxD,EAAO,OAAO,CAAG,SAAS,AAAe,CAAM,CAAE,CAAK,EACrD,IAAI,EAAgB,UAAU,MAAM,CAAG,GAAK,CAAC,CAAC,SAAS,CAAC,EAAE,EAAI,SAAS,CAAC,EAAE,CAAC,KAAK,CAC5E,EAAkB,UAAU,MAAM,CAAG,GAAK,CAAC,CAAC,SAAS,CAAC,EAAE,EAAI,SAAS,CAAC,EAAE,CAAC,eAAe,CAC5F,GACE,KAAyB,IAAlB,GAAiC,AAAyB,kBAAlB,GAC5C,KAA2B,IAApB,GAA8D,WAA3B,AAC7C,OADoD,EAErD,MAAM,IAAI,EAAW,mFAElB,IAAgB,GAAiB,CAAC,EAAO,EAAQ,EAAA,CAAlC,AAA8C,GAAG,AAC/D,EACH,EAAgB,EAAQ,EAAa,CACpC,QAFmB,KAEL,CAAC,EACf,YAAY,EACZ,MAAO,EACP,SAAU,EACX,GAEA,CAAM,CAAC,EAAY,CAAG,EAGzB,KAHgC,4BC5BhC,EAAO,OAAO,CAAG,ED4BuD,OC5B7C,CAAG,CAAE,CAAG,EAKjC,OAJA,OAAO,IAAI,CAAC,GAAK,OAAO,CAAC,SAAU,CAAI,EACrC,CAAG,CAAC,EAAK,CAAG,CAAG,CAAC,EAAK,EAAI,CAAG,CAAC,EAAK,AACpC,EADsC,CAG/B,CACT,iCCPA,IAAI,CDG4E,CCH5E,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAW,EAAA,CAAA,CAAA,QAAe,KAAK,CAC/B,EAAA,EAAA,CAAA,CAAA,QACA,EAAS,EAAA,CAAA,CAAA,QAAkB,MAAM,CACjC,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QAUJ,SAAS,EAAS,CAAO,EACvB,GAAI,CAAC,CAAC,IAAI,YAAY,CAAA,CAAQ,CAC5B,EAD+B,KACxB,IAAI,EAAS,GAUtB,IAAK,IAAI,KAPT,IAAI,CAOe,AAPd,QAOuB,OAPR,CAAG,EACvB,IAAI,CAAC,YAAY,CAAG,EACpB,IAAI,CAAC,gBAAgB,CAAG,EAAE,CAE1B,EAAe,IAAI,CAAC,IAAI,EAExB,EAAU,GAAW,CAAC,EAEpB,CAFuB,GAEnB,CAAC,EAAO,CAAG,CAAO,CAAC,EAAO,AAElC,CAGA,EAAK,QAAQ,CAAC,EAAU,GAExB,EAAS,UAAU,AATgD,CAS7C,OACtB,EAAS,oBAAoB,CAAG,2BAEhC,EAAS,SAAS,CAAC,MAAM,CAAG,SAAU,CAAK,CAAE,CAAK,CAAE,CAAO,EAIlC,AAAnB,OAAO,GAAsB,OAHjC,EAAU,GAAW,EAAC,GAAG,CAIvB,EAAU,CAAE,SAAU,EAAQ,EAGhC,CAHmC,GAG/B,EAAS,EAAe,SAAS,CAAC,KAP2B,CAOrB,CAAC,IAAI,CAAC,IAAI,EAQtD,IALqB,CANsD,SAMvE,OAAO,GAA+B,MAAT,CAAS,GAAM,CAC9C,EAAQ,OAAO,EAAA,EAIb,CAJqB,KAIf,OAAO,CAAC,GAAQ,YAKxB,IAAI,CAAC,MAAM,CAAC,AATmD,AAS/C,MAAM,8BAIxB,IAAI,EAAS,IAAI,CAAC,gBAAgB,CAAC,EAAO,EAAO,GAC7C,EAAS,IAAI,CAAC,gBAAgB,GAElC,EAAO,GACP,EAAO,GACP,EAAO,GAGP,IAAI,CAAC,YAAY,CAAC,EAAQ,EAAO,EACnC,EAEA,EAAS,SAAS,CAAC,YAAY,CAAG,SAAU,CAAM,CAAE,CAAK,CAAE,CAAO,EAChE,IAAI,EAAc,CAQS,MAAM,CAA7B,EAAQ,WAAW,CACrB,GAAe,OAAO,EAAQ,WAAW,EAChC,OAAO,QAAQ,CAAC,GACzB,EAAc,EAAM,CADa,KACP,CACA,UAAjB,AAA2B,OAApB,IAChB,EAAc,OAAO,UAAU,CAAC,EAAA,EAGlC,IAAI,CAAC,YAAY,EAAI,EAGrB,IAAI,CAAC,eAAe,EAAI,OAAO,UAAU,CAAC,GAAU,EAAS,UAAU,CAAC,MAAM,CAGzE,IAAU,AAAC,EAAM,IAAI,EAAM,EAAF,AAAQ,CAAP,OAAe,EAAI,EAAO,EAAO,cAAc,EAAO,GAAF,CAAC,SAAkB,CAAM,GAAI,CAK5G,AAAC,EAAQ,WAAW,EAAE,AACxB,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,EADhB,CAGf,EAEA,EAAS,SAAS,CAAC,gBAAgB,CAAG,SAAU,CAAK,CAAE,CAAQ,EACzD,EAAO,EAAO,MAQZ,AAAa,CARM,SAQb,GAAG,EAAiB,EAAM,GAAG,EAAI,UAA2B,GAAf,EAAM,KAAK,CAAe,AAI/E,EAAS,KAAM,EAAM,GAAG,CAAG,GAAK,CAAD,CAAO,KAAK,CAAG,EAAM,KAAK,EAAG,CAAC,EAK7D,EALiE,AAK9D,IAAI,CAAC,EAAM,IAAI,CAAE,SAAU,CAAG,CAAE,CAAI,EACrC,AAAI,EACF,EAAS,CADF,EAOT,EAAS,GAb4F,EAYtF,CACA,CADK,IAAI,EAAI,CAAD,CAAO,KAAK,CAAG,EAAM,KAAK,CAAG,CAAC,EAE3D,GAIO,EAAO,EAAO,eACvB,CADuC,CAC9B,KAAM,OAAO,EAAM,OAAO,CAAC,iBAAiB,GAG5C,CAHgD,CAGzC,EAAO,eAAe,AAEtC,EAAM,EAAE,CAAC,WAAY,IAL0E,KAKhE,CAAQ,EACrC,EAAM,KAAK,GACX,EAAS,KAAM,OAAO,EAAS,OAAO,CAAC,iBAAiB,EAC1D,GACA,EAAM,MAAM,IAIZ,EAAS,iBAEb,EAEA,AAJgC,EAIvB,SAAS,CAAC,gBAAgB,CAAG,SAAU,AAJsB,CAIjB,CAAE,CAAK,CAAE,CAAO,EAMnE,GAAI,AAA0B,UAAU,OAA7B,EAAQ,MAAM,CACvB,OAAO,EAAQ,MAAM,CAGvB,IAgBI,EAhBA,EAAqB,IAAI,CAAC,sBAAsB,CAAC,EAAO,GACxD,EAAc,IAAI,CAAC,eAAe,CAAC,EAAO,GAE1C,EAAW,GACX,EAAU,CAEZ,sBAAuB,CAAC,YAAa,SAAW,EAAQ,IAAI,CAAC,MAAM,CAAC,GAAsB,EAAE,EAE5F,eAAgB,EAAE,CAAC,MAAM,CAAC,GAAe,EAAE,CAC7C,EAQA,IAAK,IAAI,IALqB,UAA1B,AAAoC,OAA7B,EAAQ,MAAM,EACvB,EAAS,EAAS,EAAQ,MAAM,EAIjB,EACf,GAAI,EAAO,CADa,CACJ,GAAO,CAIzB,GAAI,AAAU,MAAM,CAHpB,EAAS,CAAO,CAAC,EAAA,AAAK,EAIpB,QAIE,CAAC,CAJO,KAID,OAAO,CAAC,KACjB,EAAS,CAAC,CADgB,CACT,EAIf,EAAO,MAAM,EAAE,CACjB,GAAY,EAAO,KAAO,EAAO,IAAI,CAAC,GAV4B,GAUpB,EAAS,UAAA,AAAU,CAErE,CAGF,MAAO,KAAO,IAAI,CAAC,WAAW,GAAK,EAAS,UAAU,CAAG,EAAW,EAAS,UAAU,AACzF,EAEA,EAAS,SAAS,CAAC,sBAAsB,CAAG,SAAU,CAAK,CAAE,CAAO,EAClE,IAAI,EAiBJ,GAfgC,UAAU,AAAtC,OAAO,EAAQ,QAAQ,CAEzB,EAAW,EAAK,SAAS,CAAC,EAAQ,QAAQ,EAAE,OAAO,CAAC,MAAO,KAClD,EAAQ,QAAQ,EAAK,IAAU,EAAM,GAAP,CAAW,EAAI,EAAM,IAAI,AAAJ,EAM5D,CANoE,CAMzD,EAAK,QAAQ,CAAC,EAAQ,QAAQ,EAAK,GAAU,GAAM,GAAP,CAAW,EAAI,EAAM,IAAA,AAAI,GACvE,GAAS,EAAM,QAAQ,EAAI,EAAO,EAAO,gBAAgB,CAElE,EAAW,EAAK,QAAQ,CAAC,EAAM,MAAM,CAAC,YAAY,CAAC,IAAI,EAAI,GAAA,EAGzD,EACF,MAAO,EADK,WACU,EAAW,GAErC,EAEA,EAAS,SAAS,CAAC,eAAe,CAAG,SAAU,CAAK,CAAE,CAAO,EAE3D,IAAI,EAAc,EAAQ,WAAW,CA2BrC,MAxBI,CAAC,GAAe,GAAS,EAAM,IAAI,EAAE,CACvC,EAAc,EAAK,MAAM,CAAC,EAAM,KAAI,EAIlC,CAAC,GAAe,GAAS,EAAM,IAAI,EAAE,CACvC,EAAc,EAAK,MAAM,CAAC,EAAM,KAAI,EAIlC,CAAC,GAAe,GAAS,EAAM,QAAQ,EAAI,EAAO,EAAO,gBAAgB,CAC3E,EAAc,EAAM,OAAO,CAAC,eAAe,AAAf,EAI1B,CAAC,IAAgB,EAAQ,QAAQ,CAAjB,CAAqB,EAAQ,QAAA,AAAQ,GAAG,CAC1D,EAAc,EAAK,MAAM,CAAC,EAAQ,QAAQ,EAAI,EAAQ,SAAQ,EAI5D,CAAC,GAAe,GAA0B,UAAjB,AAA2B,OAApB,IAClC,EAAc,EAAS,oBAAA,AAAoB,EAGtC,CACT,EAEA,EAAS,SAAS,CAAC,gBAAgB,CAAG,WACpC,MAAO,CAAA,SAAU,CAAI,EACnB,IAAI,EAAS,EAAS,UAAU,AAG5B,CADoC,IAAzB,IAAI,CAAC,AACN,QADc,CAAC,MAAM,EAEjC,IAAU,IAAI,CAAC,aAAa,EAAA,EAG9B,EAAK,EACP,CAAA,EAAE,IAAI,CAAC,IAAI,CACb,EAEA,EAAS,SAAS,CAAC,aAAa,CAAG,WACjC,MAAO,KAAO,IAAI,CAAC,WAAW,GAAK,KAAO,EAAS,UAAU,AAC/D,EAEA,EAAS,SAAS,CAAC,UAAU,CAAG,SAAU,CAAW,EAEnD,IADI,EACA,EAAc,CAChB,eAAgB,iCAAmC,IAAI,CAAC,WAAW,EACrE,EAEA,IAAK,KAAU,EACT,EAAO,EAAa,KACtB,CAFwB,AAEb,CAAC,EADmB,AACZ,WAAW,GAAG,CAAG,CAAW,CAAC,EAAA,AAAO,EAI3D,OAAO,CACT,EAEA,EAAS,SAAS,CAAC,WAAW,CAAG,SAAU,CAAQ,EACjD,GAAwB,UAApB,AAA8B,OAAvB,EACT,MAAM,AAAI,UAAU,sCAEtB,IAAI,CAAC,SAAS,CAAG,CACnB,EAEA,EAAS,SAAS,CAAC,WAAW,CAAG,WAK/B,OAJK,AAAD,IAAK,CAAC,SAAS,EACjB,AADmB,IACf,CAAC,iBAAiB,GAGjB,IAAI,CAAC,SAAS,AACvB,EAEA,EAAS,SAAS,CAAC,SAAS,CAAG,WAK7B,IAAK,IAJD,EAAa,IAAI,OAAO,KAAK,CAAC,GAC9B,CADkC,CACvB,IAAI,CAAC,WAAW,GAGtB,EAAI,EAAG,EAAM,IAJ8C,AAI1C,CAAC,QAAQ,CAAC,MAAM,CAAE,EAAI,EAAK,IACnB,AADwB,YACZ,AAAxC,OAAO,IAAI,CAAC,QAAQ,CAAC,EAAE,GAGvB,EADE,OAAO,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,EACrB,CADwB,MACjB,MAAM,CAAC,CAAC,EAAY,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,EAE5C,OAAO,MAAM,CAAC,CAAC,EAAY,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,GAIxC,UAA5B,OAAO,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAiB,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,SAAS,CAAC,EAAG,EAAS,MAAM,CAAG,KAAO,CAAA,GAAU,CAC3G,EAAa,OAAO,MAAM,CAAC,CAAC,EAAY,OAAO,IAAI,CAAC,EAAS,UAAU,GAAE,GAM/E,OAAO,OAAO,MAAM,CAAC,CAAC,EAAY,OAAO,IAAI,CAAC,IAAI,CAAC,aAAa,IAAI,CACtE,EAEA,EAAS,SAAS,CAAC,iBAAiB,CAAG,WAIrC,IAAI,CAAC,SAAS,CAAG,6BAA+B,EAAO,WAAW,CAAC,IAAI,QAAQ,CAAC,MAClF,EAIA,EAAS,SAAS,CAAC,aAAa,CAAG,WACjC,IAAI,EAAc,IAAI,CAAC,eAAe,CAAG,IAAI,CAAC,YAAY,CAiB1D,OAdI,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,CACxB,GAAe,IAAI,CAAC,aAAa,GAAG,MAAA,AAAM,EAIxC,AAAC,IAAI,CAAC,cAAc,IAAI,AAM1B,IAAI,CAAC,MAAM,CAAC,AAAI,MAAM,uDAGjB,CACT,EAKA,EAAS,SAAS,CAAC,cAAc,CAAG,WAClC,IAAI,GAAiB,EAMrB,OAJI,IAAI,CAAC,gBAAgB,CAAC,MAAM,EAAE,CAChC,EAAiB,EAAA,EAGZ,CACT,EAEA,EAAS,SAAS,CAAC,SAAS,CAAG,SAAU,CAAE,EACzC,IAAI,EAAc,IAAI,CAAC,eAAe,CAAG,IAAI,CAAC,YAAY,AAM1D,EAJI,EAIA,EAJI,CAAC,QAAQ,CAAC,MAAM,EAAE,CACxB,GAAe,IAAI,CAAC,aAAa,GAAG,MAAA,AAAM,EAGvC,IAAI,CAAC,gBAAgB,CAAC,MAAM,EAAE,AAKnC,EAAS,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAE,IAAI,CAAC,gBAAgB,CAAE,SAAU,CAAG,CAAE,CAAM,EACnF,AAAI,EACF,EAAG,CADI,GAKT,EAAO,OAAO,CAAC,SAAU,CAAM,EAC7B,GAAe,CACjB,GAEA,EAAG,KAAM,GACX,GAfE,QAAQ,QAAQ,CAAC,EAAG,IAAI,CAAC,IAAI,CAAE,KAAM,GAgBzC,EAEA,EAAS,SAAS,CAAC,MAAM,CAAG,SAAU,CAAM,CAAE,CAAE,EAG9C,IAFI,EACA,EACA,EAAW,CAAE,OAAQ,MAAO,EA4DhC,MAzDsB,UAAU,AAA5B,OAAO,EAGT,EAAU,EAAS,CACjB,KAHF,AAGQ,GAHC,EAAS,EAAA,EAGH,CAHY,GAGR,CACjB,KAAM,EAAO,QAAQ,CACrB,KAAM,EAAO,QAAQ,CACrB,IANiE,KAMvD,EAAO,QAAQ,AAC3B,EAAG,GAIE,AAAD,AAFJ,GAAU,EAAS,EAAQ,EAAA,EAEd,IAAI,EAAE,AACjB,GAAQ,IAAI,CAAwB,WAArB,EAAQ,QAAQ,CAAgB,IAAM,EAAA,EAKzD,EAAQ,OAAO,CAAG,IAAI,CAAC,UAAU,CAAC,EAAO,OAAO,EAI9C,EADuB,UAAU,CAA/B,EAAQ,QAAQ,CACR,EAAM,OAAO,CAAC,GAEd,EAAK,OAAO,CAAC,GAIzB,IAAI,CAAC,SAAS,CAAC,CAAA,SAAU,CAAG,CAAE,CAAM,EAClC,GAAI,GAAe,mBAAR,EAA0B,YACnC,IAAI,CAAC,MAAM,CAAC,GAUd,GALI,GACF,EAAQ,GADE,MACO,CAAC,iBAAkB,GAGtC,IAAI,CAAC,IAAI,CAAC,GACN,EAAI,CAGN,IAFI,EAEA,EAAW,SAAU,CAAK,CAAE,CAAQ,EAItC,OAHA,EAAQ,cAAc,CAAC,QAAS,GAChC,EAAQ,cAAc,CAAC,WAAY,GAE5B,EAAG,IAAI,CAAC,IAAI,CAAE,EAAO,EAC9B,EAEA,EAAa,EAAS,GAHmB,CAGf,CAAC,IAAI,CAAE,MAEjC,EAAQ,EAAE,CAAC,QAAS,GACpB,EAAQ,EAAE,CAAC,IANoE,OAMxD,EACzB,CACF,CAAA,EAAE,IAAI,CAAC,IAAI,GAEJ,CACT,EAEA,EAAS,SAAS,CAAC,MAAM,CAAG,SAAU,CAAG,EAClC,IAAI,CAAC,KAAK,EAAE,CACf,IAAI,CAAC,KAAK,CAAG,EACb,IAAI,CAAC,KAAK,GACV,IAAI,CAAC,IAAI,CAAC,QAAS,GAEvB,EAEA,EAAS,SAAS,CAAC,QAAQ,CAAG,WAC5B,MAAO,mBACT,EACA,EAAe,EAAU,YAGzB,EAAO,OAAO,CAAG,iCC3ejB,IAAI,EAAW,EAAA,CAAA,CAAA,QAAe,KAAK,CAE/B,EAAgB,CAClB,IAAK,GACL,OAAQ,GACR,KAAM,GACN,MAAO,IACP,GAAI,GACJ,IAAK,GACP,EAEI,EAAiB,OAAO,SAAS,CAAC,QAAQ,EAAI,SAAS,CAAC,EAC1D,OAAO,EAAE,MAAM,EAAI,IAAI,CAAC,MAAM,EACgB,CAAC,IAA7C,IAAI,CAAC,OAAO,CAAC,EAAG,IAAI,CAAC,MAAM,CAAG,EAAE,MAAM,CAC1C,EAuFA,SAAS,EAAO,CAAG,EACjB,OAAO,QAAQ,GAAG,CAAC,EAAI,WAAW,GAAG,EAAI,QAAQ,GAAG,CAAC,EAAI,WAAW,GAAG,EAAI,EAC7E,CAEA,EAAQ,cAAc,CApFtB,EAoFyB,OApFhB,AAAe,CAAG,EACzB,MAqC6B,IAAI,AArC7B,EAA2B,UAAf,OAAO,EAAmB,EAAS,GAAO,GAAO,CAAC,EAC9D,EAAQ,EAAU,QAAQ,CAC1B,EAAW,EAAU,IAAI,CACzB,EAAO,EAAU,IAAI,CACzB,GAAwB,UAApB,OAAO,GAAyB,CAAC,GAA6B,UAAU,AAA3B,OAAO,EACtD,MAAO,GAQT,CARc,EAGd,CAKI,CAAC,AALG,EAAM,KAAK,CAAC,IAKH,AALQ,EAAE,CAAC,EAAE,CA6BX,EA1BnB,EAAW,AAEgB,EAFP,EA0BO,GAxBO,EAFP,CAAC,QAAS,MACrC,CAPiE,CAO1D,SAAS,IAAS,CAAa,CAAC,EAAM,EAAI,IA4BjD,EAFI,EACF,AACE,CADD,AACE,EADK,QACK,gBADqB,EAAO,WAAA,CAAW,CAAE,WAAW,KAIlD,KAAK,CAAlB,GAIG,EAAS,KAAK,CAAC,SAAS,KAAK,CAAC,SAAS,CAAK,EACjD,GAAI,CAAC,EACH,KADU,EACH,EAET,IAFgB,AAEZ,EAAc,EAAM,KAAK,CAAC,gBAC1B,AAHsC,EAGhB,EAAc,CAAW,CAAC,EAAE,CAAG,EACrD,EAAkB,EAAc,SAAS,CAAW,CAAC,EAAE,EAAI,QAC/D,EAAI,GAAmB,IAAoB,IAItC,EAJ4C,MAIpC,IAAI,CAAC,IAKoB,KAAK,CAAvC,EAAoB,MAAM,CAAC,GALS,EAOtC,EAAsB,EAAoB,KAAK,CAAC,EAAA,EAG3C,CAAC,EAAe,IAAI,CAAC,EAAU,IAR7B,IAAa,EASxB,EA3BA,EA5BE,MAAO,GAGT,CAHc,GAGV,EACF,EAAO,cAAgB,EAAQ,WAC/B,EAAO,EAAQ,EALqC,SAMpD,EAAO,qBACP,EAAO,aAKT,OAJI,GAAkC,CAAC,GAAG,CAA7B,EAAM,OAAO,CAAC,SAEzB,EAAQ,EAAQ,MAAQ,CAAA,EAEnB,CACT,iFCgPA,EAAO,OAAO,CA7Rd,EA6RiB,OA7RF,AAAN,CAAS,EAqDjB,SAAS,EAAY,CAAS,EAE7B,IADI,EAEA,EACA,EAFA,EAAiB,KAIrB,SAAS,EAAM,GAAG,CAAI,EAErB,GAAI,CAAC,EAAM,OAAO,CACjB,CADmB,MAOpB,IAAM,EAAO,OAAO,IAAI,KAExB,CALa,EAKR,IAAI,CADE,EACC,CADO,GAAY,CAAb,AAAa,CAAI,CAEnC,EAAK,IAAI,CAAG,EACZ,EAAK,IAAI,CAAG,EACZ,EAAW,EAEX,CAAI,CAAC,EAAE,CAAG,EAAY,MAAM,CAAC,CAAI,CAAC,EAAE,EAEb,UAAU,AAA7B,OAAO,CAAI,CAAC,EAAE,EAEjB,EAAK,OAAO,CAAC,MAId,IAAI,EAAQ,EACZ,CAAI,CAAC,EAAE,CAAG,CAAI,CAAC,EAAE,CAAC,OAAO,CAAC,gBAAiB,CAAC,EAAO,KAElD,GAAc,AAAV,MAAgB,GACnB,MAAO,IAER,IACA,IAAM,EAAY,EAAY,UAAU,CAAC,EAAO,CAChD,GAAyB,YAArB,OAAO,EAA0B,CACpC,IAAM,EAAM,CAAI,CAAC,EAAM,CACvB,EAAQ,EAAU,IAAI,CAAC,EAAM,GAG7B,EAAK,MAAM,CAAC,EAAO,GACnB,GACD,CACA,OAAO,CACR,GAGA,EAAY,UAAU,CAAC,IAAI,CAAC,EAAM,GAGlC,CADc,EAAK,GAAG,EAAI,EAAY,GAAA,AAAG,EACnC,KAAK,CAAC,EAAM,EACnB,CAgCA,OA9BA,EAAM,SAAS,CAAG,EAClB,EAAM,SAAS,CAAG,EAAY,SAAS,GACvC,EAAM,KAAK,CAAG,EAAY,WAAW,CAAC,GACtC,EAAM,MAAM,CAAG,EACf,EAAM,OAAO,CAAG,EAAY,OAAO,CAEnC,CAFqC,MAE9B,cAAc,CAAC,EAAO,UAAW,CACvC,YAAY,EACZ,YAJgG,EAIlF,EACd,IAAK,IACmB,AAAvB,MAA6B,CAAzB,EACI,GAEJ,IAAoB,EAAY,UAAU,EAAE,CAC/C,EAAkB,EAAY,UAAU,CACxC,EAAe,EAAY,OAAO,CAAC,IAG7B,GAER,IAAK,IACJ,EAAiB,CAClB,CACD,GAGgC,AAA5B,YAAwC,OAAjC,EAAY,IAAI,EAC1B,EAAY,IAAI,CAAC,GAGX,CACR,CAEA,SAAS,EAAO,CAAS,CAAE,CAAS,EACnC,IAAM,EAAW,EAAY,IAAI,CAAC,SAAS,EAAI,CAAD,IAAsB,IAAd,EAA4B,IAAM,CAAA,CAAS,CAAI,GAErG,OADA,EAAS,GAAG,CAAG,IAAI,CAAC,GAAG,CAChB,CACR,CAuCA,SAAS,EAAgB,CAAM,CAAE,CAAQ,EACxC,IAAI,EAAc,EACd,EAAgB,EAChB,EAAY,CAAC,EACb,EAAa,EAEjB,KAAO,EAAc,EAAO,MAAM,CAAE,CACnC,GAAI,EAAgB,EAAS,MAAM,GAAK,CAAQ,AAAT,CAAU,EAAc,GAAK,CAAM,CAAC,EAAY,EAAgC,MAA5B,CAAQ,CAAC,EAAmB,AAAL,CAAQ,CAEzF,EAF4F,GAEvF,CAAjC,CAAQ,CAAC,EAAc,EAC1B,EAAY,EACZ,EAAa,GAGb,IACA,SAEK,GAAkB,CAAC,GAAG,CAAlB,EAMV,OAAO,EAJP,EAAgB,EAAY,CAId,CAFd,IAAc,EAOhB,IAL2B,CAKpB,EAAgB,EAAS,MAAM,EAAgC,IAAK,EAAjC,CAAQ,CAAC,EAAc,EAChE,IAGD,OAAO,IAAkB,EAAS,MAAM,AACzC,CAgEA,OAzRA,EAAY,KAAK,CAAG,EACpB,EAAY,OAAO,CAAG,EACtB,EAAY,MAAM,CAsQlB,EAtQqB,OAsQZ,AAAO,CAAG,SAClB,AAAI,aAAe,MACX,CADkB,CACd,KAAK,EAAI,EAAI,OAAO,CAEzB,CACR,EA1QA,EAAY,OAAO,CA8NnB,EA9NsB,OA8Nb,EACR,IAAM,EAAa,IACf,EAAY,KAAK,IACjB,EAAY,KAAK,CAAC,GAAG,CAAC,GAAa,IAAM,GAC5C,CAAC,IAAI,CAAC,KAEP,OADA,EAAY,MAAM,CAAC,IACZ,CACR,EApOA,EAAY,MAAM,CAsJlB,EAtJqB,OAsJZ,AAAO,CAAU,EAazB,IAAK,IAAM,KAZX,CAYiB,CAZL,IAAI,CAAC,AAYO,GAXxB,EAAY,UAAU,CAAG,EAEzB,EAAY,KAAK,CAAG,EAAE,CACtB,EAAY,KAAK,CAAG,EAAE,CAER,CAAuB,UAAtB,OAAO,EAA0B,EAAa,EAAA,CAAE,CAC7D,IAAI,GACJ,OAAO,CAAC,OAAQ,KAChB,KAAK,CAAC,KACN,MAAM,CAAC,UAGM,KAAK,CAAf,CAAE,CAAC,EAAE,CACR,EAAY,KAAK,CAAC,IAAI,CAAC,EAAG,KAAK,CAAC,IAEhC,EAAY,KAAK,CAAC,IAAI,CAAC,EAG1B,EAzKA,EAAY,OAAO,CA4OnB,EA5OsB,OA4Ob,AAAQ,CAAI,EACpB,IAAK,IAAM,KAAQ,EAAY,KAAK,CAAE,AACrC,GAAI,EAAgB,EAAM,GACzB,IADgC,EACzB,GAIT,IAAK,IAAM,KAAM,EAAY,KAAK,CAAE,AACnC,GAAI,EAAgB,EAAM,GACzB,EAD8B,KACvB,EAIT,OAAO,CACR,EAzPA,EAAY,QAAQ,CAAA,EAAA,CAAA,CAAA,QACpB,EAAY,OAAO,CA4QnB,EA5QsB,OA4Qb,EACR,QAAQ,IAAI,CAAC,wIACd,EA5QA,OAAO,IAAI,CAAC,GAAK,OAAO,CAAC,IACxB,CAAW,CAAC,EAAI,CAAG,CAAG,CAAC,EAAI,AAC5B,GAMA,EAAY,KAAK,CAAG,EAAE,CACtB,EAAY,KAAK,CAAG,EAAE,CAOtB,EAAY,UAAU,CAAG,CAAC,EAkB1B,EAAY,WAAW,CAVvB,EAU0B,OAVjB,AAAY,CAAS,EAC7B,IAAI,EAAO,EAEX,IAAK,IAAI,EAAI,EAAG,EAAI,EAAU,MAAM,CAAE,IAAK,AAE1C,GADS,IAAQ,CAAC,CAAI,EAAQ,EAAU,UAAU,CAAC,GAC3C,EAGT,CAHY,MAGL,EAAY,MAAM,CAAC,KAAK,GAAG,CAAC,GAHI,AAGI,EAAY,MAAM,CAAC,MAAM,CACrE,AADsE,EA8OtE,EAAY,MAAM,CAAC,EAAY,IAAI,IAE5B,CACR,oBC7RA,IAAM,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QAMN,EAAQ,IAAI,CA2NZ,EA3Ne,OA2NN,AAAK,CAAK,EAClB,EAAM,WAAW,CAAG,CAAC,EAErB,IAAM,EAAO,OAAO,IAAI,CAAC,EAAQ,WAAW,EAC5C,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,MAAM,CAAE,IAAK,AACrC,EAAM,WAAW,CAAC,CAAI,CAAC,EAAE,CAAC,CAAG,EAAQ,WAAW,CAAC,CAAI,CAAC,EAAE,CAAC,AAE3D,EAjOA,EAAQ,GAAG,CAoLX,EApLc,OAoLL,AAAI,GAAG,CAAI,EACnB,OAAO,QAAQ,MAAM,CAAC,KAAK,CAAC,EAAK,iBAAiB,CAAC,EAAQ,WAAW,IAAK,GAAQ,KACpF,EArLA,EAAQ,UAAU,CAyJlB,EAzJqB,OAyJD,AAAX,CAAe,EACvB,GAAM,CAAC,UAAW,CAAI,WAAE,CAAS,CAAC,CAAG,IAAI,CAEzC,GAAI,EAAW,CACd,IAAM,EAAI,IAAI,CAAC,KAAK,CACd,EAAY,SAAc,GAAI,CAAL,CAAS,EAAI,QAAS,CAAC,CAChD,EAAS,CAAC,EAAE,EAAE,EAAU,GAAG,EAAE,EAAK,UAAU,CAAC,CAEnD,CAAI,CAAC,EAAE,CAAG,EAAS,CAAI,CAAC,EAAE,CAAC,KAAK,CAAC,MAAM,IAAI,CAAC,KAAO,GACnD,EAAK,IAAI,CAAC,EAAY,KAAO,EAAO,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAI,UACnE,MACC,CADM,AACF,CAAC,EAAE,CAAG,CAKP,AAAJ,EAAY,WAAW,CAAC,QAAQ,CACxB,CAD0B,EAG3B,IAAI,OAAO,WAAW,GAAK,GADlC,EAPuB,EAAO,IAAM,CAAI,CAAC,EAAE,AAE5C,EArKA,EAAQ,IAAI,CA4LZ,EA5Le,OA4LN,AAAK,CAAU,EACnB,EACH,QAAQ,EADO,CACJ,CAAC,KAAK,CAAG,EAIpB,OAAO,QAAQ,GAAG,CAAC,KAAK,AAE1B,EAnMA,EAAQ,IAAI,CA4MZ,EA5Me,OA4MN,EACR,OAAO,QAAQ,GAAG,CAAC,KAAK,AACzB,EA7MA,EAAQ,SAAS,CA0IjB,EA1IoB,OA0IX,EACR,MAAO,WAAY,EAAQ,WAAW,CACrC,EAAQ,EAAQ,WAAW,CAAC,MAAM,CAClC,EAAI,MAAM,CAAC,QAAQ,MAAM,CAAC,EAAE,CAC9B,EA7IA,EAAQ,OAAO,CAAG,EAAK,SAAS,CAC/B,KAAO,EACP,yIAOD,EAAQ,MAAM,CAAG,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,CAEnC,GAAI,CAGH,IAAM,EAAA,EAAA,CAAA,CAAA,OAEF,GAAiB,AAAC,GAAc,MAAM,EAAI,CAAA,CAAa,CAAE,KAAK,EAAI,GAAG,AACxE,GAAQ,MAAM,CAAG,CAChB,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,CAEH,CAAE,MAAO,EAAO,CAEhB,CAQA,EAAQ,WAAW,CAAG,OAAO,IAAI,CAAC,QAAQ,GAAG,EAAE,MAAM,CAAC,GAC9C,WAAW,IAAI,CAAC,IACrB,MAAM,CAAC,CAAC,EAAK,KAEf,IAAM,EAAO,EACX,SAAS,CAAC,GACV,WAAW,GACX,OAAO,CAAC,YAAa,CAAC,EAAG,IAClB,EAAE,WAAW,IAIlB,EAAM,QAAQ,GAAG,CAAC,EAAI,CAY1B,OAVC,IADG,EACG,yBADwB,IAAI,CAAC,KAEzB,CAF+B,4BAEF,IAAI,CAAC,KAE1B,CAFgC,OAExB,CAAhB,EACJ,KAEA,OAAO,IAGd,CAAG,CAAC,EAAK,CAAG,EACL,CACR,EAAG,CAAC,GA2FJ,EAAO,OAAO,CAAG,EAAA,CAAA,CAAA,OAAoB,GAErC,GAAM,YAAC,CAAU,CAAC,CAAG,EAAO,OAAO,CAMnC,EAAW,CAAC,CAAG,SAAU,CAAC,EAEzB,OADA,IAAI,CAAC,WAAW,CAAC,MAAM,CAAG,IAAI,CAAC,SAAS,CACjC,EAAK,OAAO,CAAC,EAAG,IAAI,CAAC,WAAW,EACrC,KAAK,CAAC,MACN,GAAG,CAAC,GAAO,EAAI,IAAI,IACnB,IAAI,CAAC,IACR,EAMA,EAAW,CAAC,CAAG,SAAU,CAAC,EAEzB,OADA,IAAI,CAAC,WAAW,CAAC,MAAM,CAAG,IAAI,CAAC,SAAS,CACjC,EAAK,OAAO,CAAC,EAAG,IAAI,CAAC,WAAW,CACxC,0BChQA,EAAQ,UAAU,CA8IlB,EA9IqB,OA8IZ,AAAW,CAAI,EAQvB,GAPA,CAAI,CAAC,EAAE,CAAG,AAAC,KAAI,CAAC,SAAS,CAAG,KAAO,EAAA,CAAE,CACpC,IAAI,CAAC,SAAS,EACb,CAAD,GAAK,CAAC,SAAS,CAAG,MAAQ,GAAA,CAAG,CAC7B,CAAI,CAAC,EAAE,EACN,CAAD,GAAK,CAAC,SAAS,CAAG,MAAQ,GAAA,CAAG,CAC7B,IAAM,EAAO,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAEpC,CAAC,IAAI,CAAC,SAAS,CAClB,CADoB,MAIrB,IAAM,EAAI,UAAY,IAAI,CAAC,KAAK,CAChC,EAAK,MAAM,CAAC,EAAG,EAAG,EAAG,kBAKrB,IAAI,EAAQ,EACR,EAAQ,EACZ,CAAI,CAAC,EAAE,CAAC,OAAO,CAAC,cAAe,IAChB,MAAM,CAAhB,IAGJ,IACc,MAAM,CAAhB,IAGH,EAAQ,CAAA,EAEV,GAEA,EAAK,MAAM,CAAC,EAAO,EAAG,EACvB,EA9KA,EAAQ,IAAI,CAgMZ,EAhMe,OAgMD,AAAL,CAAe,EACvB,GAAI,CACC,EACH,EAAQ,OAAO,CADA,AACC,OAAO,CAAC,QAAS,GAEjC,EAAQ,OAAO,CAAC,UAAU,CAAC,QAE7B,CAAE,MAAO,EAAO,CAGhB,CACD,EA1MA,EAAQ,IAAI,CAkNZ,EAlNe,OAkNN,EACR,IAAI,EACJ,GAAI,CACH,EAAI,EAAQ,OAAO,CAAC,OAAO,CAAC,UAAY,EAAQ,OAAO,CAAC,OAAO,CAAC,QACjE,CAAE,MAAO,EAAO,CAGhB,CAOA,MAJI,CAAC,GAAwB,aAAnB,OAAO,SAA2B,QAAS,SAAS,CAC7D,EAAI,QAAQ,GAAG,CAAC,KAAA,AAAK,EAGf,CACR,EAhOA,EAAQ,SAAS,CAyGjB,EAzGoB,OAyGX,MAaJ,QAJJ,EAAyB,aAArB,OAAO,WAA6B,UAAU,SAAS,EAAI,UAAU,SAAS,CAAC,WAAW,GAAG,KAAK,CAAC,wBAAA,GAA0B,CASrG,aAApB,OAAO,UAA4B,SAAS,eAAe,EAAI,SAAS,eAAe,CAAC,KAAK,EAAI,SAAS,eAAe,CAAC,KAAK,CAAC,gBAAgB,EAKjI,EAHrB,WAGA,OAAO,WAA6B,UAAU,SAAS,EAHrC,CAG0C,CAAD,CAAK,UAAU,EAHzC,OAGkD,AAH3C,CAG4C,MAHrC,IAAI,CAG4C,AAH3C,GAG8C,IAHvC,CAG4C,CAAC,KAHtC,CAAC,OAAO,IAAK,AAGyB,CAAiB,EAAK,IAHxC,KAGiD,CAAC,CAH3C,AAG4C,CAH3C,CAG6C,CAAE,KAAO,EAH7C,EAKlF,EALsF,OAAO,IAKlH,GALyH,CAAC,GAKnH,EALyH,AAAD,SAK3F,UAAU,SAAS,EAAI,UAAU,SAAS,CAAC,WAAW,GAAG,KAAK,CAAC,qBAAA,CACtG,EAlIA,EAAQ,OAAO,CAAG,AA4OlB,SAAS,EACR,GAAI,CAGH,OAAO,YACR,CAAE,MAAO,EAAO,CAGhB,CACD,IAnPK,GAAS,EADd,EAAQ,OAAO,CAGP,EAHU,CAAC,EAIZ,IACJ,GAAS,CADG,CAEZ,QAAQ,IAAI,CAAC,yIAEf,EAOD,EAAQ,MAAM,CAAG,CAChB,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,CAwFD,EAAQ,GAAG,CAAG,QAAQ,KAAK,EAAI,QAAQ,GAAG,GAAK,CAAD,KAAQ,CAAC,CAkEvD,EAAO,OAAO,CAAG,EAAA,CAAA,CAAA,OAAoB,GAErC,GAAM,YAAC,CAAU,CAAC,CAAG,EAAO,OAAO,CAMnC,EAAW,CAAC,CAAG,SAAU,CAAC,EACzB,GAAI,CACH,OAAO,KAAK,SAAS,CAAC,EACvB,CAAE,MAAO,EAAO,CACf,MAAO,+BAAiC,EAAM,OAAO,AACtD,CACD,oBC1QuB,aAAnB,OAAO,SAA4C,aAAjB,CAA+B,OAAvB,IAAI,EAA+C,QAAQ,MAAM,CAC9G,CADgH,CACzG,OAAO,CAAA,EAAA,CAAA,CAAA,EAD0E,MAGxF,EAAO,OAAO,CAAA,EAAA,CAAA,CAAA,0BCRf,IAAI,EAEJ,EAAO,OAAO,CAAG,WACf,GAAI,CAAC,EAAO,CACV,GAAI,CAEF,EAAQ,EAAA,CAAA,CAAA,QAAiB,mBAC3B,CACA,MAAO,EAAO,CAAQ,CACD,AAAjB,YAA6B,OAAtB,IACT,EAAQ,YAAoB,CAEhC,CACA,EAAM,KAAK,CAAC,KAAM,UACpB,oBCdA,QAAI,EAAA,EAAA,CAAA,CAAA,QACA,EAAM,EAAI,GAAG,CACb,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAW,EAAA,CAAA,CAAA,QAAkB,QAAQ,CACrC,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QAKE,EAAmC,aAAnB,OAAO,QAEvB,EAAc,EAAW,MAAM,iBAAiB,EAChD,AAAC,GAAuC,GAC1C,QADqD,AAC7C,GADgD,AAApC,CACR,AADS,CACR,mBAD4B,qDAM7C,IAAI,GAAe,EACnB,GAAI,CACF,EAAO,IAAI,EAAI,IACjB,CACA,MAAO,EAAO,CACZ,EAA8B,oBAAf,EAAM,IACvB,AAD2B,CAI3B,IAAI,EAAqB,CACvB,OACA,OACA,WACA,OACA,OACA,WACA,OACA,WACA,QACA,SACA,OACD,CAGG,EAAS,CAAC,QAAS,UAAW,UAAW,QAAS,SAAU,UAAU,CACtE,EAAgB,OAAO,MAAM,CAAC,MAClC,EAAO,OAAO,CAAC,SAAU,CAAK,EAC5B,CAAa,CAAC,EAAM,CAAG,SAAU,CAAI,CAAE,CAAI,CAAE,CAAI,EAC/C,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,EAAO,EAAM,EAAM,EAC7C,CACF,GAGA,IAAI,EAAkB,EACpB,kBACA,cACA,WAEE,EAAmB,EACrB,6BACA,6BAEE,EAAwB,EAC1B,4BACA,uCACA,GAEE,EAA6B,EAC/B,kCACA,gDAEE,EAAqB,EACvB,6BACA,mBAIE,EAAU,EAAS,SAAS,CAAC,OAAO,EAAI,EAG5C,SAAS,EAAoB,CAAO,CAAE,CAAgB,EAEpD,EAAS,IAAI,CAAC,IAAI,EAClB,IAAI,CAAC,gBAAgB,CAAC,GACtB,IAAI,CAAC,QAAQ,CAAG,EAChB,IAAI,CAAC,MAAM,EAAG,EACd,IAAI,CAAC,OAAO,EAAG,EACf,IAAI,CAAC,cAAc,CAAG,EACtB,IAAI,CAAC,UAAU,CAAG,EAAE,CACpB,IAAI,CAAC,kBAAkB,CAAG,EAC1B,IAAI,CAAC,mBAAmB,CAAG,EAAE,CAGzB,GACF,IAAI,CAAC,EAAE,CAAC,OADY,IACA,GAItB,IAAI,EAAO,IAAI,CACf,IAAI,CAAC,iBAAiB,CAAG,SAAU,CAAQ,EACzC,GAAI,CACF,EAAK,gBAAgB,CAAC,EACxB,CACA,MAAO,EAAO,CACZ,EAAK,IAAI,CAAC,QAAS,aAAiB,EAClC,EAAQ,IAAI,EAAiB,CAAE,MAAO,CAAM,GAChD,CACF,EAGA,IAAI,CAAC,eAAe,EACtB,CAkYA,SAAS,EAAK,CAAS,EAErB,IAAI,EAAU,CACZ,aAAc,GACd,cAAe,KAAK,GACtB,EAGI,EAJyB,AAIP,CAAC,EAqDvB,OApDA,OAAO,IAAI,CAAC,GAAW,OAAO,CAAC,SAAU,CAAM,EAC7C,IAAI,EAAW,EAAS,IACpB,EAAiB,CAAe,CAAC,EAAS,CAAG,CAAS,CAAC,EAAO,CAC9D,EAAkB,CAAO,CAAC,EAAO,CAAG,OAAO,MAAM,CAAC,GA4CtD,OAAO,gBAAgB,CAAC,EAAiB,CACvC,QAAS,CAAE,MA1Cb,CA0CoB,QA1CX,AAAQ,CAAK,CAAE,CAAO,CAAE,CAAQ,QA8BvC,OAyIS,EArKC,EAsKP,CADW,EACJ,GAtKQ,UAsKS,GArKzB,EAAQ,EAAgB,GAEjB,EAAS,GAChB,EAAQ,EAAgB,CADA,CACS,KAGjC,EAAW,EACX,EAAU,EAAY,GACtB,EAAQ,CAAE,SAAU,CAAS,GAE3B,EAAW,KACb,EAAW,EACX,CAFuB,CAEb,MAQZ,CAJA,EAAU,OAAO,MAAM,CAAC,CACtB,aAAc,EAAQ,YAAY,CAClC,cAAe,EAAQ,aAAa,AACtC,EAAG,EAAO,EAAA,EACF,eAAe,CAAG,EACtB,AAAC,EAAS,EAAQ,IAAI,GAAM,EAAD,AAAU,EAAQ,QAAQ,GAAG,CAC1D,EAAQ,QAAQ,CAAG,KAAA,EAGrB,EAAO,KAAK,CAAC,EAAQ,QAAQ,CAAE,EAAU,qBACzC,EAAM,UAAW,GACV,IAAI,EAAoB,EAAS,EAC1C,EAW6B,cAAc,EAAM,YAAY,EAAM,UAAU,CAAK,EAChF,IAAK,CAAE,MATT,CASgB,QATP,AAAI,CAAK,CAAE,CAAO,CAAE,CAAQ,EACnC,IAAI,EAAiB,EAAgB,OAAO,CAAC,EAAO,EAAS,GAE7D,OADA,EAAe,GAAG,GACX,CACT,EAKqB,cAAc,EAAM,WAAY,GAAM,UAAU,CAAK,CAC1E,EACF,GACO,CACT,CAEA,SAAS,IAAqB,CAE9B,SAAS,EAAS,CAAK,EACrB,IAAI,EAEJ,GAAI,EACF,EAAS,IAAI,EAAI,IADD,IAMhB,GAAI,CAAC,EAAS,CADd,EAAS,EAAY,EAAI,KAAK,CAAC,GAAA,EACV,QAAQ,EAC3B,CAD8B,KACxB,IAAI,EAAgB,OAAE,CAAM,GAGtC,OAAO,CACT,CAOA,SAAS,EAAY,CAAK,EACxB,GAAI,MAAM,IAAI,CAAC,EAAM,QAAQ,GAAK,CAAC,oBAAoB,IAAI,CAAC,EAAM,QAAQ,GAAG,AAGzE,MAAM,IAAI,CAAC,EAAM,IAAI,GAAK,CAAC,2BAA2B,IAAI,CAAC,EAAM,IAAI,EAFvE,CAE0E,KAFpE,IAAI,EAAgB,CAAE,MAAO,EAAM,IAAI,EAAI,CAAM,GAKzD,OAAO,CACT,CAEA,SAAS,EAAgB,CAAS,CAAE,CAAM,EACxC,IAAI,EAAS,GAAU,CAAC,EACxB,IAAK,IAAI,KAAO,EACd,CAAM,CAAC,EAAI,CAAG,CAAS,CAAC,EAAI,CAc9B,OAVI,AALgC,EAKzB,QAAQ,CAAC,UAAU,CAAC,MAAM,CACnC,EAAO,QAAQ,CAAG,EAAO,QAAQ,CAAC,KAAK,CAAC,EAAG,CAAC,EAAA,EAG1B,IAAI,CAApB,EAAO,IAAI,GACb,EAAO,IAAI,CAAG,OAAO,EAAO,IAAI,GAGlC,EAAO,IAAI,CAAG,EAAO,MAAM,CAAG,EAAO,QAAQ,CAAG,EAAO,MAAM,CAAG,EAAO,QAAQ,CAExE,CACT,CAEA,SAAS,EAAsB,CAAK,CAAE,CAAO,EAC3C,IAAI,EACJ,IAAK,IAAI,KAAU,EACb,EAAM,IADgB,AACZ,CAAC,KACb,EAAY,CAAO,CAAC,AADE,EACK,CAC3B,OAAO,CAAO,CAAC,EAAO,EAG1B,aAAQ,OACN,EAAY,KADQ,EACD,GAAW,GADF,CACM,EACtC,CAEA,GAJuC,MAI9B,EAAgB,CAAI,CAAE,CAAO,CAAE,CAAS,CAJI,CAMnD,SAAS,EAAY,CAAU,EAEzB,EAAW,MAAM,iBAAiB,GAAG,AACvC,MAAM,iBAAiB,CAAC,IAAI,CAAE,IAAI,CAAC,WAAW,EAEhD,OAAO,MAAM,CAAC,IAAI,CAAE,GAAc,CAAC,GACnC,IAAI,CAAC,IAAI,CAAG,EACZ,IAAI,CAAC,OAAO,CAAG,IAAI,CAAC,KAAK,CAAG,EAAU,KAAO,IAAI,CAAC,KAAK,CAAC,OAAO,CAAG,CACpE,CAcA,OAXA,EAAY,SAAS,CAAG,GAAK,CAAD,GAAc,KAAA,CAAK,CAC/C,OAAO,gBAAgB,CAAC,EAAY,SAAS,CAAE,CAC7C,YAAa,CACX,MAAO,EACP,YAAY,CACd,EACA,KAAM,CACJ,MAAO,UAAY,EAAO,IAC1B,YAAY,CACd,CACF,GACO,CACT,CAEA,SAAS,EAAe,CAAO,CAAE,CAAK,EACpC,IAAK,IAAI,KAAS,EAChB,EAAQ,GADgB,WACF,CAAC,EAAO,CAAa,CAAC,EAAM,EAEpD,EAAQ,EAAE,CAAC,QAAS,GACpB,EAAQ,OAAO,CAAC,EAClB,CAQA,SAAS,EAAS,CAAK,EACrB,MAAwB,UAAjB,OAAO,GAAsB,aAAiB,MACvD,CAEA,SAAS,EAAW,CAAK,EACvB,MAAwB,YAAjB,OAAO,CAChB,CAjjBA,EAAoB,SAAS,CAAG,OAAO,MAAM,CAAC,EAAS,SAAS,EAEhE,EAAoB,SAAS,CAAC,KAAK,CAAG,WACpC,EAAe,IAAI,CAAC,eAAe,EACnC,IAAI,CAAC,eAAe,CAAC,KAAK,GAC1B,IAAI,CAAC,IAAI,CAAC,QACZ,EAEA,EAAoB,SAAS,CAAC,OAAO,CAAG,SAAU,CAAK,EAGrD,OAFA,EAAe,IAAI,CAAC,eAAe,CAAE,GACrC,EAAQ,IAAI,CAAC,IAAI,CAAE,GACZ,IAAI,AACb,EAGA,EAAoB,SAAS,CAAC,KAAK,CAAG,SAAU,CAAI,CAAE,CAAQ,CAAE,CAAQ,QAEtE,GAAI,IAAI,CAAC,OAAO,CACd,CADgB,KACV,IAAI,EAIZ,GAAI,CAAC,EAAS,IAAS,CAAC,CA8hBA,UAAjB,OADS,AACF,EA9hBmB,GA6hBZ,CACgB,GA9hBG,QA8hBS,CAAA,EA7hB/C,MAAM,AAAI,UAAU,iDAStB,GAPI,EAAW,KACb,EAAW,EACX,EAFwB,AAEb,MAKT,AAAgB,MAAX,MAAM,CAAQ,CACjB,GACF,IAEF,GAHc,GAIhB,CAEI,IAAI,CAAC,kBAAkB,CAAG,EAAK,MAAM,EAAI,IAAI,CAAC,QAAQ,CAAC,aAAa,EACtE,AADwE,IACpE,CAAC,kBAAkB,EAAI,EAAK,MAAM,CACtC,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAE,KAAM,EAAM,SAAU,CAAS,GAC/D,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,EAAM,EAAU,KAI3C,IAAI,CAAC,IAAI,CAAC,QAAS,IAAI,GACvB,IAAI,CAAC,KAAK,GAEd,EAGA,EAAoB,SAAS,CAAC,GAAG,CAAG,SAAU,CAAI,CAAE,CAAQ,CAAE,CAAQ,EAYpE,GAVI,CAUA,CAVW,IACb,EAAW,CADS,CAEpB,EAAO,EAAW,MAEX,EAAW,KAClB,EAAW,EACX,EAF6B,AAElB,MAIR,EAIA,CACH,GALS,CAKL,EAAO,IAAI,CACX,EAAiB,IAAI,CAAC,eAAe,CACzC,IAAI,CAAC,KAAK,CAAC,EAAM,EAAU,WACzB,EAAK,MAAM,EAAG,EACd,EAAe,GAAG,CAAC,KAAM,KAAM,EACjC,GACA,IAAI,CAAC,OAAO,EAAG,CACjB,MAXE,IAAI,CAAC,MAAM,CAAG,IAAI,CAAC,OAAO,EAAG,EAC7B,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,KAAM,KAAM,EAWzC,EAGA,EAAoB,SAAS,CAAC,SAAS,CAAG,SAAU,CAAI,CAAE,CAAK,EAC7D,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAK,CAAG,EAC9B,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,EAAM,EACvC,EAGA,EAAoB,SAAS,CAAC,YAAY,CAAG,SAAU,CAAI,EACzD,OAAO,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAK,CAClC,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,EACpC,EAGA,EAAoB,SAAS,CAAC,UAAU,CAAG,SAAU,CAAK,CAAE,CAAQ,EAClE,IAAI,EAAO,IAAI,CAGf,SAAS,EAAiB,CAAM,EAC9B,EAAO,UAAU,CAAC,GAClB,EAAO,cAAc,CAAC,UAAW,EAAO,OAAO,EAC/C,EAAO,WAAW,CAAC,UAAW,EAAO,OAAO,CAC9C,CAGA,SAAS,EAAW,CAAM,EACpB,EAAK,QAAQ,EACf,AADiB,aACJ,EAAK,QAAQ,EAE5B,EAAK,QAAQ,CAAG,WAAW,WACzB,EAAK,IAAI,CAAC,WACV,GACF,EAAG,GACH,EAAiB,EACnB,CAGA,SAAS,IAEH,EAAK,QAAQ,EAAE,CACjB,aAAa,EAAK,QAAQ,EAC1B,EAAK,QAAQ,CAAG,MAIlB,EAAK,cAAc,CAAC,QAAS,GAC7B,EAAK,cAAc,CAAC,QAAS,GAC7B,EAAK,cAAc,CAAC,WAAY,GAChC,EAAK,cAAc,CAAC,QAAS,GACzB,GACF,EAAK,KADO,SACO,CAAC,UAAW,GAE7B,AAAC,EAAK,MAAM,EAAE,AAChB,EAAK,eAAe,CAAC,cAAc,CAAC,SAAU,EAElD,CAsBA,OAnBI,GACF,IAAI,CAAC,EADO,AACL,CAAC,UAAW,GAIjB,IAAI,CAAC,MAAM,CACb,CADe,CACJ,IAAI,CAAC,MAAM,EAGtB,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,SAAU,GAItC,IAAI,CAAC,EAAE,CAAC,SAAU,GAClB,IAAI,CAAC,EAAE,CAAC,QAAS,GACjB,IAAI,CAAC,EAAE,CAAC,QAAS,GACjB,IAAI,CAAC,EAAE,CAAC,WAAY,GACpB,IAAI,CAAC,EAAE,CAAC,QAAS,GAEV,IAAI,AACb,EAGA,CACE,eAAgB,YAChB,aAAc,qBACf,CAAC,OAAO,CAAC,SAAU,CAAM,EACxB,EAAoB,SAAS,CAAC,EAAO,CAAG,SAAU,CAAC,CAAE,CAAC,EACpD,OAAO,IAAI,CAAC,eAAe,CAAC,EAAO,CAAC,EAAG,EACzC,CACF,GAGA,CAAC,UAAW,aAAc,SAAS,CAAC,OAAO,CAAC,SAAU,CAAQ,EAC5D,OAAO,cAAc,CAAC,EAAoB,SAAS,CAAE,EAAU,CAC7D,IAAK,WAAc,OAAO,IAAI,CAAC,eAAe,CAAC,EAAS,AAAE,CAC5D,EACF,GAEA,EAAoB,SAAS,CAAC,gBAAgB,CAAG,SAAU,CAAO,EAkBhE,GAhBI,AAAC,EAAQ,OAAO,EAAE,CACpB,EAAQ,OAAO,CAAG,EAAC,EAMjB,EAAQ,IAAI,EAAE,CAEZ,AAAC,EAAQ,QAAQ,EAAE,CACrB,EAAQ,QAAQ,CAAG,EAAQ,IAAA,AAAI,EAEjC,OAAO,EAAQ,IAAI,EAIjB,CAAC,EAAQ,QAAQ,EAAI,EAAQ,IAAI,CAAE,CACrC,IAAI,EAAY,EAAQ,IAAI,CAAC,OAAO,CAAC,KACjC,EAAY,EACd,CADiB,CACT,QAAQ,CAAG,EAAQ,IAAI,EAG/B,EAAQ,QAAQ,CAAG,EAAQ,IAAI,CAAC,SAAS,CAAC,EAAG,GAC7C,EAAQ,MAAM,CAAG,EAAQ,IAAI,CAAC,SAAS,CAAC,GAE5C,CACF,EAIA,EAAoB,SAAS,CAAC,eAAe,CAAG,WAE9C,IAAI,EAAW,IAAI,CAAC,QAAQ,CAAC,QAAQ,CACjC,EAAiB,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,EAAS,CAC5D,GAAI,CAAC,EACH,MAAM,AAAI,QADS,EACC,wBAA0B,GAKhD,GAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAE,CACxB,IAAI,EAAS,EAAS,KAAK,CAAC,EAAG,CAAC,GAChC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAO,AACpD,CAGA,IAAI,EAAU,IAAI,CAAC,eAAe,CAC5B,EAAe,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAE,IAAI,CAAC,iBAAiB,EAElE,IAAK,IAAI,KADT,EAAQ,aAAa,CAAG,IAAI,CACV,GAChB,EAAQ,EADgB,AACd,CAAC,EAAO,CAAa,CAAC,EAAM,EAaxC,GARA,IAAI,CAAC,WAAW,CAAG,MAAM,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,EAC9C,EAAI,MAAM,CAAC,IAAI,CAAC,QAAQ,EAGxB,EAFA,EAEI,CAAC,QAAQ,CAAC,IAAI,CAIhB,IAAI,CAAC,WAAW,CAAE,CAEpB,IAAI,CARoC,CAQhC,EACJ,EAAO,IAAI,CACX,EAAU,IAAI,CAAC,mBAAmB,EACrC,SAAS,EAAU,CAAK,EAGvB,GAAI,IAAY,EAAK,eAAe,CAGlC,CAHoC,EAGhC,EACF,EAAK,GADI,CACA,CAAC,QAAS,QAGhB,GAAI,EAAI,EAAQ,MAAM,CAAE,CAC3B,IAAI,EAAS,CAAO,CAAC,IAAI,AAErB,CAAC,EAAQ,QAAQ,EAAE,AACrB,EAAQ,KAAK,CAAC,EAAO,IAAI,CAAE,EAAO,QAAQ,CAAE,EAEhD,MAES,CAAJ,CAAS,MAAM,EAClB,AADoB,EACZ,GAAG,EAGjB,CAAA,EACF,CACF,EAGA,EAAoB,SAAS,CAAC,gBAAgB,CAAG,SAAU,CAAQ,EAEjE,cAyCI,EAzCA,EAAa,EAAS,UAAU,CAChC,IAAI,CAAC,QAAQ,CAAC,cAAc,EAAE,AAChC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CACnB,IAAK,IAAI,CAAC,WAAW,CACrB,QAAS,EAAS,OAAO,CACzB,WAAY,CACd,GAWF,IAAI,EAAW,EAAS,OAAO,CAAC,QAAQ,CACxC,GAAI,CAAC,IAA8C,IAAlC,IAAI,CAAC,QAAQ,CAAC,eAAe,EAC1C,EAAa,KAAO,GAAc,IAAK,CACzC,EAAS,WAAW,CAAG,IAAI,CAAC,WAAW,CACvC,EAAS,SAAS,CAAG,IAAI,CAAC,UAAU,CACpC,IAAI,CAAC,IAAI,CAAC,WAAY,GAGtB,IAAI,CAAC,mBAAmB,CAAG,EAAE,CAC7B,MACF,CASA,GANA,EAAe,IAAI,CAAC,eAAe,EAEnC,EAAS,OAAO,GAIZ,EAAE,IAAI,CAAC,cAAc,CAAG,IAAI,CAAC,QAAQ,CAAC,YAAY,CACpD,CADsD,KAChD,IAAI,EAKZ,IAAI,EAAiB,IAAI,CAAC,QAAQ,CAAC,cAAc,CAC7C,IACF,EAAiB,OAAO,GADN,GACY,CAAC,CAE7B,KAAM,EAAS,GAAG,CAAC,SAAS,CAAC,OAC/B,EAAG,IAAI,CAAC,QAAQ,CAAC,QAAO,EAO1B,IAAI,EAAS,IAAI,CAAC,QAAQ,CAAC,MAAM,EAC7B,AAAgB,MAAf,GAAqC,GAAG,GAAlB,GAAuB,AAAyB,aAArB,CAAC,QAAQ,CAAC,MAAM,AAAK,IAKvD,CAJhB,KAIC,CAAuB,EAAC,iBAAiB,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAM,GAAG,CACxE,IAAI,CAAC,IAL6D,IAKrD,CAAC,MAAM,CAAG,MAEvB,IAAI,CAAC,mBAAmB,CAAG,EAAE,CAC7B,EAAsB,aAAc,IAAI,CAAC,QAAQ,CAAC,OAAO,GAI3D,IAAI,EAAoB,EAAsB,UAAW,IAAI,CAAC,QAAQ,CAAC,OAAO,EAG1E,EAAkB,EAAS,IAAI,CAAC,WAAW,EAC3C,EAAc,GAAqB,EAAgB,IAAI,CACvD,EAAa,QAAQ,IAAI,CAAC,GAAY,IAAI,CAAC,WAAW,CACxD,EAAI,MAAM,CAAC,OAAO,MAAM,CAAC,EAAiB,CAAE,KAAM,CAAY,IAG5D,GAoHc,EApHW,EAoHD,EApHW,EAoHb,AAAM,AAEzB,EAAe,CAtHJ,GAsHQ,EAAI,EAAU,GAAQ,EAAS,EAAI,OAAO,CAAC,EAAM,KAvG3E,GAdA,EAAM,iBAAkB,EAAY,IAAI,EACxC,IAAI,CAAC,WAAW,EAAG,EACnB,EAAgB,EAAa,IAAI,CAAC,QAAQ,GAItC,EAAY,QAAQ,GAAK,EAAgB,QAAQ,EACzB,WAAzB,EAAY,QAAQ,AAAK,IACzB,EAAY,IAAI,GAAK,IA6LL,EA5LH,EAAY,IAAI,CA4LJ,AAAE,EA5L3B,AAA+B,CAA9B,CA6LJ,EADoC,AAC7B,EAAS,IAAc,EAAS,IAEhC,CADH,EAAM,EAAU,MAAM,CAAG,EAAO,MAAM,CAAG,GAChC,GAAwB,MAAnB,CAAS,CAAC,EAAI,EAAY,EAAU,QAAQ,CAAC,GA/L7B,GAAc,AAC9C,EAAsB,yCAA0C,IAAI,CAAC,QAAQ,CAAC,OAAO,EAInF,EAAW,GAAiB,CAC9B,IAAI,EAAkB,CACpB,QAAS,EAAS,OAAO,CACzB,WAAY,CACd,EACI,EAAiB,CACnB,IAAK,EACL,OAAQ,EACR,QAAS,CACX,EACA,EAAe,IAAI,CAAC,QAAQ,CAAE,EAAiB,GAC/C,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,QAAQ,CACrC,CAGA,IAAI,CAAC,eAAe,EACtB,EA8LA,EAAO,OAAO,CAAG,EAAK,CAAE,KAAM,EAAM,MAAO,CAAM,GACjD,EAAO,OAAO,CAAC,IAAI,CAAG,iCC3qBtB,IAAM,EAAW,IAAI,IAAI,CACxB,YACA,cAGA,4BACA,oBACA,mCACA,kCACA,qCACA,yBACA,wBACA,qBACA,mBACA,oBACA,kBACA,iCACA,gCACA,iCACA,iCACA,aACA,8BACA,4BACA,oCACA,kCACA,sBACA,eACA,aACA,uBACA,kBACA,iBACA,gBACA,oBACA,EAGD,EAAO,OAAO,CAAG,GAAS,CAAC,EAAS,GAAG,CAAC,GAAS,EAAM,IAAI,+BiGlCvD,IagYA,gBtClYsD,kdwMyBhD,u7CAkGgD,C1JiGd,kJ0JxF/B,iHAQC,w0BAmDV,gBAAA,8EAOuC,GAC/B,KAAA,yCACkB,KAAA,0JASZ,sDAIA,4BACA,yCAE0B,CmE2GK,2HnElGvB,KAAA,6GAOO,wCAEvB,sBAGK,KAAA,iHAOM,UAAW,KAAM,0CAEzB,EAAG,KAAA,kFAKgB,CoL/HH,IAAA,SpL+HmB,gKAWtC,2BACG,EAAG,KAAA,6FAMqB,gCACG,QAE9B,uLASW,YACX,iDAGmC,EAAG,MACtC,uBACG,eAAmB,4DAKlB,MACJ,qBACG,eAAmB,WAAY,2GAOA,CC0HD,6EDpHL,EAChC,CAAE,KAAA,QAAe,KAAA,OAAa,CtENA,AqRxDM,A/M8DJ,iCAGzB,EAAE,iBACM,aACjB,KAAM,mCAIa,KAAM,YACrB,KAAA,QAAe,KAAM,6GASnB,6BACG,UAAa,KAAM,8DAKjB,KAAA,uBAAgC,MACrC,yBACG,CAAC,CkNhORuB,AlNgOU,KAAM,C2DLK,E3DKD,KAAM,ChLuGD,CkYvUQ,0BlNiOlB,EkNhOV,AvJ2NgB,yD3DUQ,KAAA,YAC3B,KAAA,YAAoB,0CAGf,EAAE,iBACM,UACjB,KAAM,sDAMwB,C+D+BK,gB/D9BrB,aAAe,gDAEf,gBAAkB,UACxB,KAAA,eAAsB,KAAM,CoNqBa,AzJ1BH,Q3DKD,CAAE,CACzC,wEAME,C6N1RA,IAAA,iB7N4RM,+BACR,MACQ,ChLiHO,AkSvBQ,ClSuBP,AgZpaa,ArK8SP,0B3DMd,YAEN,KAAA,uCACM,C8NnRW,W9NmRE,KAAA,4CAMjB,C8NhRLnB,Y9NgRmB,KAAM,6FAIZ,iBAAkB,E2DNM,CAAA,C3DMF,CAAE,SAAS,CAAE,CAAC,gDAItD,gBAAiB,C+N3TW,S/N2TA,EzCsoDE,GyCtoDI,gDAKE,KAAA,SAAe,CAAE,iDAIrD,OAAA,EAAU,C3EoED,qB2EpE0B,EoN6CM,GpN7CA,OAAO,CAAE,E2DPI,CAAA,M3DS9C,CACN,CkNlOK,clNkOa,KAAA,SAAe,QACzB,QAAS,KAAA,SAAe,EACjC,8BAEQ,sBAGC,C6NzRkB,2B7N4RX,qCAKb,C2DPO,I3DOD,cAAgB,8BACD,6CAGP,GAAI,KAAA,uHAOkB,uFAOtB,QAAU,CoOhXRe,UpOgXoB,CC8JG,ApFzCR,4BmFnH7B,aAIG,EAA4B,EhLuIF,yHgL9HjC,MAAQ,kBAAoB,gCAAkC,CAAE,EsOhYsB,C5SuXvB,8BsEajE,C2DRG,AuDkIF,IAAA,0BlH1HiC,iCAG5B,iCAEI,SAAY,IAAI,CoO7VX,UpO6VwB,aAAA,SAAuB,CAAE,CAAC,+CAK3D,wBACI,WACE,KAAM,QAAU,UAAW,MoN0FY,OpN1FE,C2DRK,CAAA,O3DQI,CAAE,CAAC,iBAChD,GmJkKK,QiEzEgC,mBpNrFhD,iDAEI,MAAQ,ChL6ID,A6FvBA,uCmFtH6C,CAAE,kBAC/C,E2DRM,E3OqJJ,CAAC,CgL7IG,AuOhaX,qEvOsaH,EhLgJA,A2OxJM,wE3Def,gBAAiB,cAGX,WACN,KAAA,2CACU,mBACY,KAAM,C6NlRc,S7NkRH,aAAc,CtETL,2BsEU/B,SAGjB,KAAA,WACA,C2DRK,I3DQC,4BACN,OAAA,EAAA,SACS,CAAC,CAAE,C2DRK,AkEkNF,CAAC,CnMnND,CsESC,CAAE,EAAE,C6H0MG,A7H1MD,KAAM,UAAW,YAAY,CAAE,IoN6GU,KpN7GD,CAAE,CAAC,OzCqkES,UyCpkEzD,QAEnB,gCAGE,OAAA,sCAII,CE6HiB,AyDrIR,C3O8JH,WAAA,gDgLrJN,WAAY,gCAC0B,GzCilEW,UAAA,SyCjlEY,CAAE,AtETA,iBsEU1C,KAAM,UAAW,C4OjfyD,GlTwerD,SsESU,iBAC1C,QAAS,E0OjXK,GAAA,U1OiXY,aAAA,iBAE1B,EhLuJU,egLtJV,ChLuJS,A2Z1gBvB,S3OoXQ,aAAc,iBAER,SAAU,KAAM,SAAU,aAAc,QAAQ,CAAE,c0OrWhE,4B1OsWqD,QAAQ,CAAE,EACvD,KAAA,M2OlXsF,K3OkXnE,8BAAgC,CAAE,EACrD,KAAM,YAAc,UAAW,YAAY,CAAE,SAAS,CAAE,CAC1D,CAAE,KAAM,azCylE8E,IyCzlE3D,4BAA8B,CAAE,GAGhE,4CACiD,CtETL,OsESc,QtETE,6BsEavD,sFAKI,CtETK,AsTzeS,OhPmfpB,CE2Ic,YF3IA,qDACd,E2DRU,ApGsnEF,CvI97DF,QAAA,EgL/KF,KAAM,C2DRW,CmLtcC,oC9O8c8B,G2DRa,CAAA,CkL9eQ,CAAC,CAAA,E7Osfb,CAAE,EhLgLQ,AgL/KnE,ChL+KoE,CAAC,CAAC,EgL/KtE,SAAgB,KAAM,sBAAwB,QAAQ,CAAE,CAC1D,CAAE,KAAA,mCAA6C,GE0JS,KF1JD,CAAE,EACvD,CwO7VS,EnTqbA,CKjGH,AsESF,CAAA,WAAe,G2DRa,M3DQH,GhLuLS,UAAA,QgLvLa,CAAE,0BAG/C,GgPlfF,CrL0ekB,AjIDV,CqT5Pc,A1TgWT,A2T7kBb,AnHstBoB,A7S7CP,kBgLtLH,C+DgCC,mD/D/Bf,WAAA,EAEI,KAAM,C+DgCO,CxG6mES,QyC5oEtB,KAAM,UACN,aAAc,YAGd,C+DiCW,C8KlhBe,GAAA,Q7Okf1B,IAAI,CAAE,CzC+pEe,kCyC3pErB,KAAM,YACN,KAAA,UACA,aAAA,WAEF,kBAEQ,uBACQ,WAEhB,CACE,EtETQ,C0TjbW,EpP0bb,+CAIT,CCmMa,qBD/LC,IAAI,CAAE,ChL2LH,OgL3LY,aAAc,CE0KG,SFxKvD,QAAA,UAAsB,KAAA,OAAc,aAAc,MAAM,CAAE,CAAC,G2DLO,CAAA,a3DMjD,E2DLM,6B3DSvB,KAAM,oBACN,OAAQ,CACN,4BAEE,KAAM,QACN,aAAA,4DAEE,CAAE,ChL6LO,IAAA,egL7LgB,UAAW,aAAA,SAAuB,kBACxC,CoP3YoB,E7R0jGT,EAAA,UyC/qFM,MtETM,OAAA,yBsEUzB,CzC+qFS,IAAA,UyC/qFQ,CwP9gBsE,EvPysBjD,GvEpMf,OsESQ,SAAS,AtETA,GsEWvD,C2DLa,G3DKT,CoP1YoB,wCpP4YV,WAEhB,CAAE,KAAA,SAAgB,C+DkCD,G/DlCK,CAAE,AtETD,SsESW,QtETQ,KAAA,WsEUxC,KAAA,QAAe,KAAA,sBAA8B,QAAQ,CAAE,CACzD,CAAE,A+DkCD,AJvCU,CyLrYT,IpP0YM,MAAO,KAAM,SAAU,YAAY,CAAE,QAAQ,CAAE,EtETI,YsEU3C,KAAA,QwP3gBW,ExP2gBM,aAAc,EwPzgBkB,OxPygBT,CAAE,UwPzgByB,cxP0gBxD,qBAAuB,OAAO,EAC1D,uDAKa,2DACF,C+DmCG,C/DlCX,KAAM,GkP3aa,OlP2aF,KAAA,UAAiB,CoPzYiB,YpPyYH,CoPzYiB,CAAA,OpPyYR,CAAE,CAC7D,C2DLW,AuLtaX,AI5CM,oBtPudmB,CoPzYW,sBpPyYc,SAAS,CAAE,OACrD,QAAS,CnFmIK,IAAA,uBmFnI0B,SAAS,CAAE,CAC3D,E2DLY,AuLtaX,CAAA,AEkCgB,ArL4aR,G/DlCD,EoPzYwB,E1TgYlB,C4T9cL,OtPwdP,KAAA,uBACc,iBAER,SAAU,KAAM,SAAU,CmJyMW,AiGjlBd,YpPwYiB,IoPxYF,YpPyYtC,mDACA,MAAO,KAAM,GtETG,CyNqNG,KnJ5MI,aAAA,4BACT,oDACD,EtETE,GsESI,QAAS,G0PrhB9B,UAAA,gI1P6hBJ,C2DLW,GIwCP,A/DnCA,CAAA,QAAW,KAAA,SAAgB,aAAc,QAAQ,CAAE,2BAC1B,aAAc,QAAQ,qBAC9B,C+DmCC,AuLlfW,sBtP+ca,SAAS,CAAE,CAC5D,kBAGa,E+DmCN,A/DnCQ,0BAA8B,MAAM,CAAE,CAAC,CAC3D,gBAAA,cAEF,CACE,KAAA,WACA,KAAM,+BAEJ,6GAIc,ECiMM,eDhMG,KAAM,uBAAyB,uDACA,SAAS,CAAE,eAC5C,E6P7hBkB,E7P6hBd,CAAE,SAAS,CAAE,YAAY,CAAE,SAAS,CAAE,EAEzD,G2DHX,C3DGe,CAAA,wCAEU,K+PnmBqB,M/PqmBrC,MAAQ,E2DHY,E9IwIF,KmFrIA,KAAM,SAAU,aAAc,K2PxgBP,CAAA,E3PwgBe,CAAE,CAC1D,CAAE,C2DHW,CgMngBI,ChMmgBF,E3DGP,G2DHa,K3DGJ,C+PnmBc,I/PmmBR,SAAU,M+PnmBkB,CAAA,IpMgmBG,C3DGT,A2DHS,C3DGP,QAAQ,CAAE,OACjD,oBAAuB,C+PnmBI,Y/PmmBU,QAAQ,CAAE,EACrD,KAAM,OAAQ,KAAM,UAAW,K2DHe,CAAA,GoMhmBN,AF6GY,IE7GZ,S/PmmBc,CAAE,C+PnmBa,CAAA,A/PomBrE,CiQ7mBY,IjQ6mBN,C+PnmBc,ApMgmBH,wB3DGiB,E6Ptfc,CAAC,CAAK,AIvHN,CAAA,CAAA,OjQ6mBA,E2DHY,CAAA,I3DGL,CAAE,GAG/D,+BAAoC,GtETD,UAAA,UsEWrC,QAAS,UAAa,C2DHK,IAAA,O3DGS,CtETL,AwUjmBnB,YlQ0mBsC,MAAM,AtETN,EsESS,CAC3D,EtEVwD,csEUvC,cAEnB,CACE,C2DHK,I3DGC,WACN,C2DHK,IAAA,e3DIL,OAAA,EAAU,CACV,QAAS,CACP,CAAE,C2DHO,AuMjmBD,IlQomBA,cAAgB,SAAU,E2DHQ,CAAA,U3DGM,QAAQ,CAAE,CAC1D,MAAQ,C+DoCH,M/DpCW,CtETD,IAAA,SsESiB,M2P9fa,O3P8fC,I2DHU,CAAA,G3DGF,CAAE,CACxD,CiQjkBSO,AvUwjBR,KsESO,C6PzbHtB,AlMsbU,AwM/oBjB,uBnQkpBqC,aAAA,QAAsB,GACvD,CiQjkBSH,IAAAA,yBjQikByB,E+DoCJ,ErI7CQ,SsESU,OtETO,EsESE,CAAE,CAC7D,MACQ,I2DLsE,CAAA,8B3DO5E,aAAc,WAEhB,kBAAsB,UAAW,aAAc,C2DAjC,W3DEZ,KAAA,aACA,KAAA,YACA,aAAA,cAGJ,CnFuIC,eAAA,8BmFnIK,wBAGF,KAAA,iDAEc,gEACF,CtETC,CsEUT,C+DqCO,CoMvrBf,GnQkpBc,UAAW,KAAM,UAAW,aAAc,SAAS,CAAE,qBACrC,sBAAwB,CtETK,OsESG,CAAE,CoQ3iBhD,ApQ4iBV,MAAQ,QAAS,IAAI,CAAA,SAAY,aAAc,QAAQ,CAAE,CACzD,YAAe,KAAM,SAAU,aAAc,QAAQ,CAAE,EAErD,IAAI,CAAA,6BAEJ,aAAA,oDACA,WAAA,CACE,EqQ/lBGuB,6BrQkmBD,K+DqCiB,G8D0MQ,I7H/Ob,AnF2IU,CmF3IR,YAGd,CtETa,IsESP,KoQhf+B,EpQgfxB,AoQhfwB,CpQifrC,KAAM,UACN,aAAc,WAEhB,CACE,E+DoCO,G/DpCP,YACA,GqQ9lBMd,EAAAA,uBrQ+lBQ,SAAS,GAGvB,KAAA,OACA,EmQ3oBoB,CAAA,CnQ2oBhB,CAAE,UACN,GmQ3oBL,UnQ2oBmB,SAAS,EAEzB,GiQpekB,GjQqeV,iBACA,OAAO,CACb,CoQ9emC,CAAA,WpQ8erB,CoQ7eqB,GC7GA,EAAA,CrQ0lBd,IAI5B,EAEJ,CACD,QAAS,EAAG,EuQ/rBkB,CFyIhB,ErQsjBI,CuQ/rBY,CvQ+rBV,CsQrrBT,AtQqrBW,KAAM,ImQ3oBuC,MnQ2oB5B,EqQtjBE,WrQsjBY,SAAS,CAAE,CAAC,iBAChD,0DAOb,KAAM,uBACA,QACN,aAAA,gDACA,E+DsCI,ClJwGC,QAAA,EmF7ID,KAAM,UAAW,EnF8IM,CkJxGC,AlJwGA,EAAA,UmF9IU,YAAY,CAAE,SAAS,CAAE,OACrD,UAAW,EuQ7pB0D,EvQ6pBtD,CAAE,SAAS,CAAE,EqQhjBa,WrQgjBC,SAAS,CAAE,CAC7D,CAAE,AnF8IC,KmF9ID,QAAe,IAAI,CAAE,CnF8IG,A2V10BpB,SxQ4rB4B,aAAc,YAE9C,KAAM,YACN,KAAM,UACN,aAAA,WAEF,CuQzpBDN,AxM+rBQ,A/DtCL,KAAM,SAAU,KAAM,QAAQ,CAAE,YAAY,CAAE,QAAQ,CAAE,CAC1D,CAAE,KAAA,QAAe,KAAA,SAAgB,YAAY,CAAE,QAAQ,CAAE,CACzD,CAAE,KAAM,MAAO,IAAI,CAAE,SAAU,G+DsCW,U/DtCG,I+DsCY,I/DtCJ,CAAE,CACvD,MAAQ,OAAQ,KAAM,UAAW,YAAY,CAAE,SAAS,CAAE,OAClD,iBAAmB,G+DsCS,K/DtCA,YAAY,CAAE,OAAO,CAAE,CAC5D,GAGL,QAAS,EAEL,CuQxnBO,IvQwnBP,GACA,KAAM,qBACQ,4CACd,WAAY,CACV,CAAE,CyQruBR,IzQquBc,QAAS,KAAM,SAAU,aAAc,QAAQ,CAAE,OACjD,KAAK,CAAE,IAAI,CAAE,QAAQ,CAAE,YAAY,CAAE,QAAQ,CAAE,CACvD,CuQ/mBY,AvQ+mBV,IAAI,CAAE,QAAS,IAAI,CAAE,UAAW,YAAY,CAAE,SAAS,CAAE,CAC5D,EAEJ,AyQvuBD,CzQwuBA,gBAAA,8BAIM,iBACE,E0QhvBW,EHkIjB,+CvQknBgB,gDACd,WAAY,EACR,IAAI,CAAE,GyQruBd,OzQquByB,IAAI,CAAE,uBAAyB,SAAS,CAAE,EAC3D,C+DyCG,I/DzCG,UAAW,IAAI,CAAE,UAAW,aAAc,SAAS,gBAC1C,KAAA,UAAiB,aAAc,SAAS,CAAE,mBAGzD,IAAI,CAAA,mCAGJ,KAAA,SAAgB,IAAI,CAAE,QAAQ,CnFkJK,AmFlJH,K2Q5sBvB,O3Q4sBmC,CAAE,QAAQ,CAAE,CAC1D,MAAQ,E+D0CU,M/D1CD,G+D0CW,C/D1CP,CAAE,O0Q9uBT,C1Q8uBiB,cAAgB,O+D0Ce,G/DzC9D,MAAQ,MAAO,KAAA,SAAgB,aAAc,QAAQ,CAAE,CACvD,CAAE,KAAM,CyQpuBH,WzQouBiB,UAAW,aAAc,SAAS,CAAE,MyQpuBoB,CzQquBtE,YAAa,IAAI,AyQpuBpB,CzQouBsB,qBAAuB,OAAO,CAAE,CAC5D,GAGL,QAAS,OAAS,GAAI,CuQ5kBM,AxMunBT,I/D3CS,UAAW,aAAc,C0Q7uBS,Q1Q6uBA,CAAE,CAAC,iBAChD,EnFqJA,MmFnJnB,CACE,KAAM,gBACA,gCAGF,KAAA,kBACA,KAAA,QACA,aAAc,W4Q1wB6B,EFmCH,CEnCG,6C5Q2wB/B,CACV,CAAE,KAAM,UAAW,KAAM,UAAW,aAAc,SAAS,CAAE,CAC7D,CAAE,KAAA,UAAiB,KAAM,UAAW,YAAY,CAAE,SAAS,CAAE,CAC7D,CAAE,C2QvqBM,EC5DTkB,C5QmuBO,A0QvuBkB,CAAA,KDId,GzQmuBO,IAAI,CAAE,UAAW,YAAY,CAAE,SAAS,CAAE,OAEnD,wCAEQ,SAAS,iBAEP,KAAM,SAAU,I0QpuBY,S1QouBE,C4QnuBY,4B5QouBrC,SAAU,YAAY,CAAE,QAAQ,CAAE,a2Q/pB7D,CAAA,I3QgqByB,QAAQ,CAAE,YAAY,CAAE,QAAQ,CAAE,CACvD,CAAE,KAAM,C0QnuBgB,M1QmuBR,KAAM,G4QluBqE,GAAA,G5QkuB5D,C0QnuBA,A1QmuBE,C0QnuBe,Y1QmuBD,K0QnuBmB,CAAA,G1QmuBV,CAAE,EACxD,KAAM,YAAa,KAAM,qBAAuB,O2Q9pBtD,A3Q8pB6D,EAC1D,WAGI,CACP,Q2Q7pBA,2B3QgqBgB,uDACF,OACF,QAAS,KAAM,E0QluBsC,O1QkuB5B,aAAA,UACjC,MAAQ,KAAK,C+DgDO,A/DhDL,IAAI,CAAE,QAAQ,CAAE,YAAY,CAAE,QAAQ,CAAE,CACvD,CAAE,A+DgDK,A2MlxBS,C7V23BX,ImFzJG,QAAS,KAAM,I6QluB0E,M7QkuB/D,YAAY,CAAE,SAAS,CAAE,CAC5D,EAEJ,+BAIK,gBACA,oBACE,CACN,CACE,C0QjuBc,IAAA,kB1QkuBd,KAAM,C2QjoBH,AClDa,O5QorBhB,aAAc,gDACd,WAAY,EACR,KAAM,G2QjoBc,O3QioBH,KAAM,UAAW,YAAY,CAAE,SAAS,CAAE,CAC7D,C6QluBW,A7QkuBT,KAAM,UAAW,KAAM,C4QlrBY,S5QkrBD,K4QlrB4B,CAAA,CAAA,MAAA,Y5QmrB9D,KAAM,QAAS,IAAI,CAAE,UAAW,Q6QjuBvB,I7QiuBmC,CAAE,SAAS,CAAE,CAC3D,CACE,E+DgDG,G/DhDH,YACA,KAAA,UACA,aAAc,WAEhB,CAAE,KAAM,cAAgB,SAAU,aAAA,QAAsB,CAAE,OAClD,G6Q7tBqB,I9MgxBZ,A/DnDF,CAAE,IAAI,CAAE,QAAQ,CAAE,YAAY,CAAE,QAAQ,CAAE,CACzD,MAAQ,G+DmDK,E/DnDA,CAAE,IAAI,CAAE,O4QlrBkB,E5QkrBR,aAAc,QAAQ,CAAE,CACvD,CAAE,IAAI,C0Q1tBQ,O1Q0tBE,KAAM,UAAW,E0Q1tBW,W1Q0tBG,I0Q1tBmB,CAAE,O1Q2tBlE,KAAA,iBAAyB,OAAO,CAAE,YAAY,CAAE,OAAO,CAAE,CAC5D,GAGL,QAAS,CAAC,CAAE,KAAA,GAAU,IAAI,CAAE,OAAQ,aAAc,E0Q1sBxB,I1Q0sB8B,EAAG,CAC3D,gBAAiB,8BAIX,YACN,OAAA,CACE,CACE,C+DmDE,E2M5vBF,E1QysBM,C4QhpBH,gBFzDgC,A1QysBZ,C0QzsBY,A1Q0sBnC,IAAI,CAAE,A8QryBuF,C/My1BtF,E+Mz1BsF,6E9QuyBjF,CACV,C8QryBoB,A9QqyBlB,KAAM,UAAW,IAAI,CAAE,UAAW,aAAc,SAAS,CAAE,EAC3D,G0QvsBA,C1QusBI,CAAE,eAAiB,SAAS,CAAE,YAAY,CAAE,SAAS,CAAE,CAC7D,CAAE,C+DqDG,IAAA,Q/DrDY,IAAI,CAAE,G8QhyB/B,M9QgyBwC,CAAE,YAAY,CAAE,SAAS,CAAE,EAEzD,IAAI,CAAE,C+DsDK,S+Mt1BkB,C9QgyBZ,C8QhyBY,A9QiyB7B,IAAI,CAAE,SAAS,CACf,A8QjyB6B,EAAA,IFgJ/B,EAAuC,K5QipBvB,SAAS,EAEzB,C+DsDO,A/DtDL,GnF2JW,EmF3JL,G+Q31ByB,M/Q21Bf,KAAM,SAAU,YAAY,CAAE,QAAQ,CAAE,CAC1D,CAAE,KAAM,QAAS,IAAI,C+Q11BqB,A/Q01BnB,E+Q11BmB,EDgFD,K9Q0wBR,YAAY,CAAE,M8Q1wBN,CAAA,C9Q0wBc,CAAE,EACvD,C+Q11BY,I/Q01BN,MAAO,A0QxqBqE,CAAA,E7Vm0B9D,CmF3JH,CAAA,SAAY,O+Q11BiB,CAAA,CAAA,G/Q01BL,CAAE,QAAQ,CAAE,OAC/C,OAAQ,KAAM,UAAW,aAAc,SAAS,CAAE,CAC1D,MAAQ,YAAa,KAAA,QAAe,aAAA,OAAqB,CAAE,C0QpqB7D,A1QqqBC,EAEJ,C+Q9zBW,Q/Q+zBH,CAAC,CAAE,KAAM,GAAI,KAAM,MAAM,C0QjqBL,A1QiqBO,C0QjqBO,CIjGA,CAAyB,U9QkwBlB,MAAM,CAAE,A0QjqBM,kB1QkqB/C,QAEnB,CACE,KAAM,gBACA,UACN,OAAQ,E8QlwBR,GCvDKlB,E/Q2zBK,C+DwDC,M2MztBoB,gB1QkqBrB,OAAO,C+DyDC,a/DxDA,C+DyDC,8C/DzD8C,CAC7D,WAAA,CACE,CAAE,KAAM,UAAW,C0Q9pBc,I1Q8pBR,E+Q1xBgB,EL4HR,M1Q8pBG,YAAY,CAAE,E+Q1xBT,CAAA,M/Q0xBkB,CAAE,CAC7D,CAAE,C0Q7pBa,I1Q6pBP,UAAW,IAAI,CAAE,UAAW,YAAY,CAAE,SAAS,CAAE,oBACtC,UAAW,aAAc,WAChD,CACE,G+QzxBO,E/QyxBD,iBACA,SAAS,CACf,I0Q5pBM,S1Q4pBQ,SAAS,QAEjB,SAAU,IAAI,CAAE,SAAU,aAAc,QAAQ,CAAE,CAC1D,CAAE,C8QxuBD,G9QwuBK,CAAE,QAAS,IAAI,CAAE,QAAQ,CAAE,YAAY,CAAE,QAAQ,CAAE,CACzD,C+QjxBY,K/QixBJ,MAAO,IAAI,CAAE,SAAU,YAAY,CAAE,QAAQ,CAAE,CACvD,CAAE,C+QjxBY,I/QixBN,MAAM,CAAE,KAAM,SAAS,CAAE,YAAY,CAAE,SAAS,CAAE,CAC1D,CAAE,IAAI,CAAE,G8QxuBc,S9QwuBD,IAAI,CAAE,OAAO,CAAE,YAAY,CAAE,OAAO,CAAE,CAC5D,EAEJ,SACQ,CAAC,CAAE,KAAM,EAAE,CAAE,IAAI,CAAE,MAAM,CAAE,YAAY,CAAE,MAAM,CAAE,CAAC,CAC3D,CnF6JG,emF7Jc,EnF6JI,MmF3JvB,CACE,KAAM,WACN,KAAM,SACN,OAAQ,CACN,qCAGE,GnFgKK,CmWt/BQ,AD8EZ,S/QwwBa,gDACd,WAAA,CACE,CAAE,EnFgKM,GmFhKA,UAAW,IAAI,CAAE,UAAW,YAAY,CAAE,SAAS,CAAE,CAC7D,CAAE,C+D6DG,IAAA,e/D7DoB,uBAAyB,CgRt1BFoB,EAAe,CAAC,KhRs1BL,CAAE,OACrD,OAAO,gBAAmB,YAAY,CAAE,SAAS,CAAE,CAC3D,CACE,IAAI,CAAE,WAAW,CACjB,KAAM,C+Q/uBa,Q/Q+uBJ,CACf,aAAc,iBAER,G+D+DK,K/D/DG,CAAE,IAAI,CAAE,QAAQ,CAAE,YAAY,CAAE,QAAQ,CAAE,CAC1D,CAAE,IAAI,CAAE,OAAO,CAAE,IAAI,CAAE,QAAQ,CAAE,YAAY,CAAE,QAAQ,CAAE,CACzD,CAAE,KAAM,MAAO,IAAI,CAAE,SAAU,EgRr1BmE,GAAA,OhRq1BvD,CAAE,QAAQ,CAAE,EACrD,GgRr1Bc,EhRq1BR,G+Q/uBc,I/Q+uBN,IAAI,CAAE,UAAW,YAAY,CAAE,SAAS,CAAE,CAC1D,C+D+DO,K/D/DC,OgRr1BId,EAAe,GhRq1BN,IAAI,CAAE,OAAO,CAAE,YAAY,CAAE,OAAO,CAAE,CAC5D,EAEJ,CACD,QAAS,EAAA,gCAIT,IAAI,CAAE,WACN,KAAM,iBAAiB,CACvB,OAAQ,EiRt6BS,ODoF4B,EAAA,2BhRs1BzC,CnFiKK,YmFjKS,+CAA+C,CAC7D,EnFiKI,SmFjKQ,EACR,C+DiEG,AkNv+BS,IjRs6BN,E+DiEI,a/DjEa,UAAW,aAAA,SAAuB,CAAE,OACrD,eAAiB,UAAW,aAAA,SAAuB,CAAE,EAC3D,GnFoKS,EmFpKH,QAAS,IAAI,CAAE,SAAS,CAAE,YAAY,CAAE,SAAS,CAAE,CAC3D,CACE,KAAM,WAAW,CACjB,KAAM,EnFuKQ,QmFtKd,YAAY,CAAE,SAAS,EAEzB,CAAE,IAAI,CAAE,SAAU,IAAI,CAAE,OkRz6B2B,ClRy6BnB,cAAgB,QAAQ,CAAE,CAC1D,CAAE,CkRz6BY,IlRy6BN,QAAS,KAAM,QAAQ,CAAE,YAAY,CAAE,CkRz6BW,CAAA,CAAA,KlRy6BH,CAAE,CACzD,CAAE,IAAI,CAAE,MAAO,IAAI,CAAA,SAAY,YAAY,CAAE,QAAQ,CAAE,CACvD,CAAE,IAAI,CAAE,OAAQ,IAAI,CAAE,SAAS,CAAE,EkR93BkF,GAAA,OlR83BtE,CAAE,SAAS,CAAE,CAC1D,CAAE,C+DkEG,I/DlEG,C+DkEG,U/DlEQ,CAAE,IAAI,CAAE,OAAO,CAAE,YAAY,CAAE,OAAO,CAAE,CAC5D,WAGI,EAAA,+BAGX,MACQ,WACN,KAAM,QACN,MAAM,CAAA,CACJ,MACQ,kBACN,IAAI,CAAE,qBACQ,2DACF,CACV,C+DoEY,K/DpEJ,Q+DsEU,C/DtED,CAAE,IAAI,CAAE,SAAS,CAAE,YAAY,CAAE,SAAS,CAAE,CAC7D,MAAQ,eAAiB,uBAAyB,CkRt0B1D,QlRs0BmE,CAAE,CAC7D,MAAQ,QAAS,IAAI,CAAE,UAAW,YAAY,CAAE,SAAS,CAAE,CAC3D,CACE,EkRt0BkB,CAGH,AAHG,ElRs0BlB,iBACM,UACN,aAAc,CkRl0BS,UlRo0BzB,CAAE,E+DsEQ,EmNx4BC,AlRk0BL,CAAE,SAAU,IAAI,CAAE,SAAU,CkRl0BO,CFqDM,WhR6wBC,QAAQ,CAAE,CAC1D,CnF8KK,AmF9KH,KAAM,InF8KQ,ImF9KC,IAAI,CAAE,8BAAgC,CAAE,CACzD,MAAQ,MAAO,KAAM,SAAU,aAAc,QAAQ,CAAE,CACvD,CAAE,C+DsEG,I/DtEG,C+DsEG,K/DtEG,CkRl0BL,AlRk0BO,IAAI,CAAE,SAAS,CAAE,YAAY,CAAE,SAAS,CAAE,OAClD,YAAa,IAAI,CAAE,OAAO,CAAE,YAAY,CAAE,OAAO,CAAE,CAC5D,G+DuEG,A/DrEJ,CkR5zBQ,IAAA,QlR4zBO,KAAM,SAAS,CAAE,YAAY,CAAE,OmRp9Ba,CAAA,CAAA,AnRo9BJ,EAC1D,CACD,EkR7zBS,MlR6zBA,EAAE,C+DwEH,gB/DvES,M+DwEE,EmNp4BH,4BlRg0BV,oBACN,IkR5zBA,GAAA,ClR6zBE,C+DyEC,uB/DvEC,GkR1zBc,ClR0zBV,CAAA,QACJ,aAAc,2DACF,EACR,IAAI,CAAE,UAAW,IAAI,CAAE,MmR37BjC,GnR27B0C,AmR37B1C,CnR27B4C,YAAY,CAAE,SAAS,CAAE,CAC7D,CAAE,C+DyEO,I/DzED,UAAW,G+DyES,C/DzEL,CAAE,G+DyES,O/DzEE,E+DyEQ,W/DzEM,SAAS,CAAE,CAC7D,MAAQ,QAAS,KAAM,uBAAyB,SAAS,CAAE,CAC3D,CACE,KAAA,YACA,IAAI,CAAE,SAAS,CACf,aAAA,WAEF,CAAE,C+DyEO,CoNp/BQ,GnR26BT,M+DyEY,G/DzEF,E+DyEQ,G/DzEF,O+DyEa,E/DzEH,YAAY,CAAE,QAAQ,CAAE,EACxD,GmR36BQ,ApNo/BC,C/DzEL,CAAE,QAAS,IAAI,CAAE,SAAU,aAAA,QAAsB,CAAE,CACzD,CAAE,E+DyEQ,G/DzEF,WAAa,SAAU,YAAY,CAAE,QAAQ,CAAE,CACvD,CAAE,KAAA,OAAc,IAAI,CAAE,EkR1xBhB,QlR0xB2B,aAAc,SAAS,CAAE,EACxD,E+DyEQ,GAAA,Y/DzEW,KAAM,CmRv6BmC,CAAA,MnRu6B1B,YAAY,CAAE,OAAO,CAAE,CAC5D,EmRv6Ba,AnRy6BhB,CkRjwBwB,AlRiwBtB,CkRjwBsB,IlRiwBhB,QAAS,KAAA,UAAiB,aAAc,SAAS,CAAE,EAEzD,CkR5vBI,CnNq0BA,G/DzEE,kBACN,KAAM,IkR5vBO,IlR6vBb,aAAc,oCACd,WAAY,CACV,CAAE,KAAM,YAAa,IAAI,CAAE,OAAO,CAAE,YAAY,CAAE,OAAO,CAAE,EACzD,E+DyEQ,E/DzEJ,CAAA,QAAW,KAAM,UAAW,YAAY,CAAE,SAAS,CAAE,EACzD,KAAM,SAAU,IAAI,CAAE,SAAS,CAAE,YAAY,CAAE,SAAS,EAC1D,CAAE,CmRl5BS,GnRk5BL,CAAE,OAAO,CAAE,IAAI,CAAE,SAAS,CAAE,YAAY,CAAE,SAAS,CAAE,CAC3D,CAAE,C+DyEO,I/DzED,SAAU,E+DyEQ,G/DzEF,O+DyEa,e/DzEW,QAAQ,CAAE,CAC3D,EAEJ,EmRp5BK,OnRq5BG,EAAE,CACX,gBAAiB,YnF+KU,AmF/KE,EAE/B,CACE,I+DyEI,A/DzEA,CAAE,aACA,C+DyEC,yB/DxEP,OAAQ,EAEJ,A+DuEI,EAEA,G/DzEE,K+DyEO,ClJwGG,AmFjLJ,CACZ,EkRpvBJ,ArWq6BQ,AkJxGA,G/DzEE,UACN,CnFiLG,CkJxGC,MAAA,CAAA,E/DxEJ,OnFiLS,MmFjLK,YAGd,KAAM,CnFkLK,iBmFjLX,CkR7sBF,IlR6sBQ,mBAEN,IoRx9Ba,SpRw9BC,gDACd,WAAY,CACV,CAAE,CoRx9Bac,IpRw9BP,EoRz9BML,CF6QO,CE7QQ,KpRy9BZ,CoRx9BFK,ApRw9BI,CoRx9BW,IpRw9BL,SAAS,CAAE,YAAY,CAAE,SAAS,CAAE,CAC7D,CkR5sBA,AlR4sBE,KAAA,UAAiB,IAAI,CAAA,UAAa,CkR5sB8B,YlR4sBhB,SAAS,CAAE,2CACb,SAAS,CAAE,EAEzD,E+DyEI,G/DzEE,K+DyEO,O/DxEb,E+DyEI,G/DzEE,SAAS,CACf,E+DyEI,GADmB,Q/DxET,I+DyEM,O/DvEtB,CAAE,IAAI,CkR5sBY,AlR4sBV,CkR5sBU,OlR4sBF,CAAE,IAAI,CAAE,QAAQ,CAAE,GoRv9B2E,SpRu9B/D,CAAE,QAAQ,CAAE,OAClD,C+D0EG,O/D1EM,KAAM,QAAQ,CAAE,YAAY,CAAE,QAAQ,CAAE,CACzD,MAAQ,CkR5sBU,IlR4sBL,CAAE,EoRv9BY,GAAA,SpRu9BI,YAAY,CAAE,QAAQ,CAAE,CACvD,CoRv9BaE,ApRu9BX,KAAA,OAAc,EoRv9BY,GpRu9BN,UAAW,YAAY,CAAE,SAAS,CAAE,CAC1D,CAAE,C+D0EO,I/D1ED,YAAa,IAAI,CAAE,OAAO,CAAE,YAAY,CAAE,OAAO,CAAE,CAC5D,GAGL,WAAW,SAGL,6CAEE,OAEE,E+D0EM,CqNn/BA,IpR06BZ,KAAA,UACA,SAAS,IAAI,sBAGf,G+D0EK,G/DzEG,C+D0EK,iB/DzEX,KAAM,CoRz6BI,CrNm/BE,ClJ8GG,KmFvLf,CnFwLK,QmFxLI,eACK,gDACd,WAAY,CACV,CAAE,CnFyLO,ImFzLD,UAAW,KAAM,GnFyLS,OmFzLE,aAAc,KnF0L/C,ImF1LwD,CAAE,CAC7D,CAAE,CnF2LO,IAAA,UmF3LU,IAAI,CAAE,UAAW,aAAc,SAAS,CAAE,eAC5C,KAAM,uBAAyB,SAAS,CAAE,EAEzD,E+D0EI,G/D1EE,EnF8LQ,yBmF5Ld,aAAc,WAEhB,CAAE,KAAA,SAAgB,C+D0ED,I/D1EO,SAAU,YAAY,CAAE,QAAQ,CAAE,OAClD,QAAS,IAAI,CAAE,GoR/5Bc,CAAyB,CAAA,CAAA,EpR+5B/B,CAAE,YAAY,CAAE,QAAQ,CAAE,CACzD,CAAE,KAAM,MAAO,KAAM,SAAU,YAAY,CAAE,QAAQ,CAAE,EACrD,KAAA,OAAc,IAAI,CAAE,KqRx7BF,GtNkgCQ,E/D1EK,YAAY,CAAE,SAAS,CAAE,EACxD,GqRz7BkB,CAAA,CrRy7BlB,YAAmB,KAAM,OAAO,CAAE,YAAY,CAAE,OAAO,CAAE,CAC5D,CqRt7BI,CrRw7BR,CACD,UAAA,CAAA,SAGM,QACN,EoR/5BE,GpR+5BI,EqRt7BS,oBrRu7Bf,OAAA,EAEI,KAAM,YACA,C+D2EK,oB/DzEX,CoRh4BF,YpRg4BgB,WAEhB,CACE,C+D0EE,CqNz8BW,EpR+3BT,CAAA,eACE,mBACG,eACK,WAEhB,CACE,GqR96Bc,CrR86BV,CAAE,IqR/6BN,MrRg7BA,KAAM,UACN,SAAS,EACT,aAAA,YAGA,KAAM,uBAEN,SAAS,EACT,EqR96BJ,WrR86BkB,WAEhB,CACE,KAAM,cACN,KAAM,CnF+LO,gBmF9LJ,EACT,EnF+LI,WAAA,4CmF9LJ,WAAY,EACR,KAAA,aAAqB,QAAQ,cAAgB,QAAQ,CAAE,CnFiMtD,AmFhMH,CnFqMO,AmFrML,KAAM,MAAO,KAAM,CnFqMO,QmFrMG,EqRh3Ba,WrRg3BC,QAAQ,CAAE,EACrD,KAAM,QAAS,EqRh3BQ,GrRg3BF,SAAS,CAAE,IqRh3Be,SrRg3BD,SAAS,CAAE,GAGhE,CACD,WAAW,GAEb,MACQ,QACN,IAAI,CAAE,0BACN,OAAA,EAEI,IAAI,CAAE,kBAAkB,CACxB,IAAI,CAAA,SACJ,aAAc,sBAED,KAAM,SAAU,aAAc,QAAQ,CAAE,CACxD,EAEH,CACE,KAAM,InFwME,SmFvMF,oCACE,CACN,CACE,KAAM,EnF8MI,iBmF7MV,CnF8MG,IAAA,sBmF7MW,QAAQ,EAExB,CAAE,KAAM,QAAS,KAAM,I+D6EF,I/D7EU,CAAE,aAAc,QAAQ,EACxD,EAEH,CACE,KAAM,AqRp0BJ,arRq0BI,0BACN,OAAQ,CAAC,CAAE,KAAM,C+D6EL,O/D7Ec,CqRh0BO,IrRg0BD,G+D6EH,O/D7Ec,G+D6EH,U/D7EiB,SAAS,CAAE,CAAC,EAEvE,CAAE,KAAM,QAAS,KAAM,4BAA6B,MAAM,CAAE,EAAE,CAAE,CAChE,CACE,KAAM,QACN,KAAM,0BACN,OAAQ,eACW,IAAI,A+D8EA,CAAA,U/D9Ea,I+D8EI,S/D9EU,SAAS,CAAE,CAC3D,CAAE,IAAI,CAAA,YAAe,IAAI,CAAE,SAAS,CAAE,YAAY,CAAE,SAAS,CAAE,CAChE,EAEH,C+D4EM,a/D1EJ,KAAM,kCACE,CACN,CACE,C+D6EE,I/D7EI,Q+D8EY,iB/D9Ea,CAC/B,KAAM,QACN,MqRp0B6D,OrRo0B/C,O+D8EW,oC/D9EgC,CACzD,WAAY,CACV,CAAE,EsR7pCgC,GtR6pC1B,OAAO,CAAE,IAAI,CAAE,GsR3pCoB,KtR2pCZ,CAAE,YAAY,CAAE,QAAQ,CAAE,CACzD,CAAE,CsR3pCY,ItR2pCN,MAAO,KAAM,QAAQ,CAAE,QsR3pCkB,CAAA,CAAA,EtR2pCN,CAAE,QAAQ,CAAE,CACvD,CAAE,IAAI,CAAE,OAAO,CAAE,IAAI,CAAE,SAAS,CAAE,YAAY,CAAE,SAAS,CAAE,CAC5D,C+D8EG,C/D5EN,MACQ,4BACN,KAAM,QACN,aAAA,4CACA,CnFmNK,UAAA,CmFlNH,CAAE,KAAA,QAAe,IAAI,CAAE,SAAU,IsR9nCe,EAAC,OtR8nCF,QAAQ,CAAE,CACzD,CAAE,IAAI,CAAE,MAAO,C+D8EL,I/D9EW,QAAQ,CAAE,S+D8EG,G/D9ES,CAAE,QAAQ,CAAE,CACvD,CAAE,KAAM,QAAS,KAAM,EsR1nC/B,EvNwsC6B,CuNxsC7B,IzW80C8C,AmFpNN,cAAgB,SAAS,CAAE,CAC5D,EAEJ,EAEH,CACE,KAAM,OAAO,MACP,QsR3lCF,etR4lCI,CACN,CAAE,KAAA,SAAgB,IAAI,CAAE,UAAW,aAAc,SAAS,CAAE,CAC5D,CAAE,GsRzlCI,EtRylCE,WAAY,KAAM,UAAW,aAAc,SAAS,CAAE,GAGlE,CAAE,KAAA,QAAe,InFwNE,AmFxNE,CAAE,mBAAoB,MAAM,CAAE,EAAE,CAAE,CACvD,MACQ,+BAEN,OAAQ,CACN,CAAE,IAAI,CAAE,QAAS,KAAM,SAAU,E+D8EN,W/D9EoB,K+D8EH,G/D9EW,CAAE,EACvD,GnF4NK,EmF5NC,KAAK,CAAE,KAAM,QAAQ,CAAE,aAAc,GnF4NK,CAAC,CAAC,GmF5NC,CAAE,CACxD,GAGD,KAAM,QACN,KAAA,8BACA,OAAQ,EAEJ,KAAM,eACN,KAAM,UACN,aAAA,yCAIA,KAAA,kCAGH,EAEH,mBAEQ,KnFiOG,uBmFhOD,CACN,CACE,GsRljCE,CtRkjCE,CAAA,eACJ,KAAM,E+DgFM,O/DhFG,CACf,aAAc,SAAS,QAGjB,gBACN,E+DgFI,G/DhFE,UACN,WsRhjCoB,CtRgjCR,CsRhjCQ,AtRgjCN,SAAS,EAE1B,EAEH,MACQ,aACA,0BAA0B,QuRpuCsB,AvRquC9C,CAAC,CAAE,CuRruC2C,CACjDb,EvRouCU,AuRpuCK,AxNozCL,CAAA,Q/DhFW,KAAA,UAAiB,G+DgFG,U/DhFW,CuRpuCK,CAAA,CAAA,MvRouCI,CAAE,CAAC,EAEvE,MACQ,InF0OG,2CmFxOT,EuRhtCY,KAAA,OvRitCF,MnF4OM,OmF5OQ,IAAI,CAAE,SAAS,CAAE,YAAY,CAAE,SAAS,CAAE,CAChE,CACE,C+D+EE,AlJ8JG,ImF7OC,K+DgFS,W/D/Ef,KAAM,UACN,O+DgFW,M/DhFG,O+DgFW,E/DhFF,IAI7B,CACE,KAAM,OAAO,AuR3sCRT,MvR4sCC,qBACN,MAAM,CAAA,CAAG,CAAE,C+DgFH,I/DhFS,M+DgFE,C/DhFK,CAAE,IAAI,CAAE,OuR3sCY,EvR2sCH,AuR3sCG,CvR2sCD,YAAY,CAAE,SAAS,CAAE,CAAC,EAEvE,mBAEQ,C+DgFC,kC/D/EP,OAAQ,OACE,aAAc,KAAM,SAAS,cAAgB,SAAS,CAAE,CAChE,CACE,KAAM,auR5rCK,CAAA,EvR4rCW,gBAEtB,GuRxrCc,UvRwrCA,WAEjB,EAEH,CAAE,KAAA,QAAe,KAAA,8BAAqC,MAAM,CAAE,EAAE,CAAE,CAClE,CACE,KAAM,aACA,C+DgFC,gC/D/EC,CuRnqCN,MvRoqCQ,WAAY,KAAM,GuRlqCS,OvRkqCE,YAAY,CAAE,SAAS,CAAE,EAC5D,GnFkPG,CmFlPC,CAAE,MnFkPM,UmFlPY,SAAS,CAAE,YAAY,CAAE,SAAS,CAAE,IAGhE,KAAM,6BAAgC,OAAQ,EAAE,CAAE,CuRlqCsB,MvRmqClE,aAAe,M+DiFM,O/DjFQ,MAAM,A+DiFA,CAAA,E/DjFI,CAAE,A+DiFA,E/DhF/C,KAAM,QAAS,CuRlqCR,CAAA,EvRkqCY,CAAE,cAAe,MAAM,CAAE,EAAE,CAAE,EAChD,KAAM,E+DiFA,M/DjFS,IAAI,CAAE,YAAa,OAAQ,EAAE,CAAE,CAChD,CAAE,KAAA,QAAe,KAAM,YAAa,OAAQ,EAAE,EACtC,CAAC,I/Q7nBa,EAAuB,IAKN,wB2dlqB7BQ,M5avBD,A6a0Bc,E7amCd,EC7DA,E6D4gHA,0GzG1xGX,SAAS,EAAkB,CAAU,CAAE,CAAO,EAC5C,IAAI,EACJ,GAAI,CACF,EAAU,GACZ,CAAE,MAAO,EAAG,CACV,MACF,CAsBA,MArBuB,CACrB,AAoBK,QApBI,AAAC,IACR,IAAI,EACJ,IAAM,EAAQ,AAAC,GACb,AAAI,AAAS,MAAM,GACV,KAEF,KAAK,KAAK,CAAC,EAAiB,MAAX,OAAkB,EAAY,EAAQ,OAAO,EAEjE,EAAM,AAAgC,OAA/B,EAAK,EAAQ,OAAO,CAAC,EAAA,CAAK,CAAY,EAAK,YACxD,AAAI,aAAe,QACV,CADmB,CACf,IAAI,CAAC,GAEX,EAAM,EACf,EACA,QAAS,CAAC,EAAM,IAAa,EAAQ,OAAO,CAC1C,EACA,KAAK,SAAS,CAAC,EAAqB,MAAX,OAAkB,EAAY,EAAQ,QAAQ,GAEzE,WAAY,AAAC,GAAS,EAAQ,UAAU,CAAC,EAC3C,CAEF,CACA,IAAM,EAAa,AAAC,GAAO,AAAC,IAC1B,GAAI,CACF,IAAM,EAAS,EAAG,GAClB,GAAI,aAAkB,QACpB,CAD6B,MACtB,EAET,MAAO,MACL,AAAK,GACI,EAAW,GAAa,GAEjC,AAHgB,MAGV,CAAW,EACf,OAAO,IAAI,AACb,CACF,CACF,CAAE,MAAO,EAAG,CACV,MAAO,CACL,KAAK,CAAY,EACf,OAAO,IAAI,AACb,QACA,AAAM,GACG,EAAW,GAAY,EADhB,AAGlB,CACF,CACF,EHxSM,EAAmB,AAAD,IAEtB,IADI,EACE,EAA4B,IAAI,IAChC,EADY,AACD,CAAC,EAAS,KACzB,IAAM,CAFuB,CAEQ,YAAnB,OAAO,EAAyB,EAAQ,GAAS,EACnE,GAAI,CAAC,OAAO,EAAE,CAAC,EAAW,GAAQ,CAChC,IAAM,EAAgB,EACtB,EAAQ,CAAY,MAAX,EAAkB,EAAU,AAAqB,iBAAd,GAAwC,OAAd,CAAc,CAAI,CAAI,EAAY,OAAO,MAAM,CAAC,CAAC,EAAG,EAAO,GACjI,EAAU,OAAO,CAAC,AAAC,GAAa,EAAS,EAAO,GAClD,CACF,EACM,EAAW,IAAM,EAMjB,EAAM,UAAE,WAAU,EAAU,gBALV,IAAM,EAKqB,UAJjC,AAAC,IACjB,EAAU,GAAG,CAAC,GACP,IAAM,EAAU,MAAM,CAAC,GAE6B,EACvD,EAAe,EAAQ,EAAY,EAAU,EAAU,GAC7D,OAAO,CACT,EACM,EAAc,AAAC,GAAgB,EAAc,EAAgB,GAAe,QGoR7D,6PAAQ,sMAAgB,CAAC,EAAK,EAAK,KACtD,IA+CI,EA/CA,EAAU,CACZ,QAAS,EAAkB,IAAM,cACjC,WAAY,AAAC,GAAU,EACvB,QAAS,EACT,MAAO,CAAC,EAAgB,KAAkB,CACxC,GAAG,CAAY,CACf,GAAG,CAAc,AAFsB,CAGzC,CAAC,CACD,GAAG,CAAW,AAChB,EACI,GAAc,EACZ,EAAqC,IAAI,IACzC,EAA2C,IAAI,IACjD,CAFuB,CAEb,EAAQ,OAAO,CAC7B,EAHwC,CAGpC,CAAC,CAF4B,CAG/B,OADY,AACL,EACL,CAAC,EAJyC,CAItC,KACF,QAAQ,IAAI,CACV,CAAC,oDAAoD,EAAE,EAAQ,IAAI,CAAC,8CAA8C,CAAC,EAErH,KAAO,EACT,EACA,EACA,GAGJ,IAAM,EAAU,KACd,IAAM,EAAQ,EAAQ,UAAU,CAAC,CAAE,GAAG,GAAK,AAAC,GAC5C,OAAO,EAAQ,OAAO,CAAC,EAAQ,IAAI,CAAE,OACnC,EACA,QAAS,EAAQ,OAAO,AAC1B,EACF,EACM,EAAgB,EAAI,QAAQ,CAClC,EAAI,QAAQ,CAAG,CAAC,EAAO,KACrB,EAAc,EAAO,GAChB,GACP,EACA,IAAM,EAAe,EACnB,CAAC,GAAG,KACF,KAAO,GACF,GACP,EACA,EACA,GAEF,EAAI,eAAe,CAAG,IAAM,EAE5B,IAAM,EAAU,KACd,IAAI,EAAI,EACR,GAAI,CAAC,EAAS,OACd,GAAc,EACd,EAAmB,OAAO,CAAC,AAAC,IAC1B,IAAI,EACJ,OAAO,EAAG,AAAiB,OAAhB,EAAM,GAAA,CAAK,CAAY,EAAM,EAC1C,GACA,IAAM,EAA0B,AAAC,CAAqC,OAApC,EAAK,EAAQ,kBAAA,AAAkB,OAAY,EAAY,EAAG,IAAI,CAAC,EAAS,AAAgB,OAAf,EAAK,GAAA,CAAK,CAAY,EAAK,EAAA,CAAa,OAAK,EACxJ,OAAO,EAAW,EAAQ,OAAO,CAAC,IAAI,CAAC,IAAU,EAAQ,IAAI,EAAE,IAAI,CAAE,AAAD,IAClE,GAAI,EACF,GAAgD,UAA5C,OAAO,EAAyB,EADR,KACe,EAAiB,EAAyB,OAAO,GAAK,EAAQ,OAAO,CAe9G,MAAO,EAAC,EAAO,EAAyB,KAAK,CAAC,KAfkE,CAChH,GAAI,EAAQ,OAAO,CAAE,CACnB,IAAM,EAAY,EAAQ,OAAO,CAC/B,EAAyB,KAAK,CAC9B,EAAyB,OAAO,SAElC,AAAI,aAAqB,QAChB,CADyB,CACf,IAAI,CAAC,AAAC,GAAW,EAAC,EAAM,EAAO,EAE3C,EAAC,EAAM,EAAU,AAC1B,CACA,QAAQ,KAAK,CACX,CAAC,qFAAqF,CAAC,CAE3F,CAIF,MAJS,AAIF,CAAC,QAAO,EAAU,AAC3B,GAAG,IAAI,CAAC,AAAC,IACP,IAAI,EACJ,GAAM,CAAC,EAAU,EAAc,CAAG,EAMlC,GADA,EAJA,EAAmB,AAIf,EAJuB,KAAK,CAC9B,EACA,AAAiB,OAAhB,EAAM,GAAA,CAAK,CAAY,EAAM,IAEV,GAClB,EACF,OAAO,CADK,EAGhB,GAAG,IAAI,CAAC,KACqB,MAA3B,CAAkC,EAAY,EAAwB,OAAkB,GACxF,EAAmB,IACnB,GAAc,EACd,EAAyB,OAAO,CAAC,AAAC,GAAO,EAAG,GAC9C,GAAG,KAAK,CAAE,AAAD,IACoB,AAA3B,OAAkC,EAAY,OAAwB,EAAW,EACnF,EACF,EAiCA,OAhCA,EAAI,OAAO,CAAG,CACZ,WAAY,AAAC,IACX,EAAU,CACR,GAAG,CAAO,CACV,GAAG,CACL,AADe,EAEX,EAAW,OAAO,EAAE,AACtB,GAAU,EAAW,OAAA,AAAO,CAEhC,EACA,aAAc,KACD,MAAX,CAAkB,EAAY,EAAQ,UAAU,CAAC,EAAQ,IAAI,CAC/D,EACA,WAAY,IAAM,EAClB,UAAW,IAAM,IACjB,YAAa,IAAM,EACnB,UAAW,AAAC,IACV,EAAmB,GAAG,CAAC,GAChB,KACL,EAAmB,MAAM,CAAC,EAC5B,GAEF,kBAAmB,AAAC,IAClB,EAAyB,GAAG,CAAC,GACtB,KACL,EAAyB,MAAM,CAAC,EAClC,EAEJ,EACK,AAAD,EAAS,aAAa,EAAE,AAC1B,IAEK,GAAoB,CAC7B,+MqXpLiD,EAAA,MAAA,QAA2B,CAAC,4IA/DxD,EAAA,OAAA,KAA4C,kLAhBT,CAAA,gLA6C/C,6CAQF,IAAA,GAAA,QAAA,GAAA,MAAA,kFAYA,GAAA,GAAA,QAAA,GAAA,IAAA,CAAA,EAA8C,KAC9C,CAAA,EAAA,qCACkD,QAAgB,CAAE,SAElE,8pDlGtGuB,oBAAA,CAAA,MAAmB,OAAO,CAAC,qJAYJ,GAAmC,UAA5B,OAAQ,CAAA,CAAA,EAAe,iBxKzItB,eAML,eA0BQ,eAQc,IAxCnB,CciBzD,Ud2BwD,EAZhB,aAgBoC,GAAG,CAAC,KAhBlB,MAoBS,WARf,KAJoB,UAQpB,eAIA,GAJkB,UAIL,kEAmCK,gFAQ1C,MAAA,OAAA,CAAc,GAAA,oBAC3B,CAAA,CAAA,CAAA,4TAsCP,uiBatIF,qzByNYT,IAAA,CAAA,GAAA,CAAA,CAAA;;;;;;;;;wBnVxBL,sBAAI,GAAE,GAAE,GAAE,AAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,AAAE,GAAE,CAAC,EAAE,GAAE,EAAE,CAAC,GAAE,oEAAoE,GAAE,MAAM,OAAO,CAAC,SAAS,GAAE,CAAC,CAAC,CAAC,EAAE,IAAI,IAAI,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC,SAAS,GAAE,CAAC,EAAE,GAAG,EAAE,UAAU,EAAE,EAAE,UAAU,CAAC,WAAW,CAAC,EAAE,CAAC,SAAS,GAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,IAAI,KAAK,EAAE,OAAO,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,UAAU,MAAM,CAAC,IAAI,CAAD,CAAG,QAAQ,CAAC,UAAU,MAAM,CAAC,EAAE,GAAE,IAAI,CAAC,UAAU,IAAG,CAAC,CAAE,YAAY,OAAO,GAAG,MAAM,EAAE,YAAY,CAAC,IAAI,KAAK,EAAE,YAAY,CAAC,KAAK,IAAI,CAAC,CAAC,EAAE,GAAG,CAAC,AAAF,CAAG,EAAE,CAAC,EAAE,YAAY,CAAC,EAAA,AAAE,EAAE,OAAO,GAAE,EAAE,EAAE,EAAE,EAAE,KAAK,CAAC,SAAS,GAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,KAAK,GAAG,KAAK,IAAI,EAAE,IAAI,KAAK,IAAI,KAAK,EAAE,IAAI,KAAK,YAAY,KAAK,EAAE,IAAI,MAAM,EAAE,EAAE,GAAE,EAAE,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,OAAO,MAAM,GAAG,MAAM,GAAE,KAAK,EAAE,GAAE,KAAK,CAAC,GAAG,CAAC,CAAmC,SAAS,GAAE,CAAC,EAAE,OAAO,EAAE,QAAQ,CAAC,SAAS,GAAE,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,SAAS,GAAE,CAAC,CAAC,CAAC,EAAE,GAAG,MAAM,EAAE,OAAO,EAAE,EAAE,CAAC,GAAE,EAAE,EAAE,CAAC,EAAE,GAAG,CAAC,GAAG,KAAK,IAAI,IAAI,EAAE,EAAE,EAAE,GAAG,CAAC,MAAM,CAAC,IAAI,GAAG,OAAO,CAAD,CAAG,EAAE,GAAG,CAAC,EAAE,AAAF,GAAK,MAAM,EAAE,GAAG,CAAC,OAAO,EAAE,GAAG,CAAC,MAAM,YAAY,OAAO,EAAE,IAAI,CAAC,GAAE,GAAG,IAAI,CAAsL,SAAS,GAAE,CAAC,EAAE,CAAC,CAAC,EAAE,GAAG,GAAG,CAAD,CAAG,GAAG,CAAC,EAAC,CAAC,EAAG,GAAE,IAAI,CAAC,IAAI,CAAC,GAAE,GAAG,IAAI,KAAI,GAAE,iBAAA,AAAiB,GAAG,CAAC,CAAC,GAAE,GAAE,iBAAA,AAAiB,KAAG,CAAC,CAAE,GAAE,CAAC,SAAS,KAAI,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,GAAE,IAAI,CAAC,IAAG,EAAE,GAAE,KAAK,IAAI,EAAE,GAAG,GAAG,CAAD,CAAG,GAAE,MAAM,CAAC,EAAE,KAAK,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAA,CAAC,CAAE,GAAA,AAAG,EAAE,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,GAAG,GAAG,CAAD,AAAE,EAAE,GAAE,CAAC,EAAE,EAAA,CAAE,CAAE,GAAG,CAAC,EAAE,GAAG,CAAC,EAAE,GAAE,KAAK,EAAE,GAAE,KAAK,CAAC,GAAG,GAAE,EAAE,GAAG,CAAC,EAAE,EAAE,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,EAAE,CAAC,KAAK,EAAE,MAAM,EAAE,GAAE,GAAG,EAAE,CAAC,CAAC,CAAC,GAAG,EAAE,GAAA,AAAG,EAAE,GAAG,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE,GAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,AAA1lB,SAAS,EAAE,CAAC,EAAE,IAAI,EAAE,EAAE,GAAG,OAAO,CAAD,CAAG,EAAE,EAAE,AAAF,GAAK,MAAM,EAAE,GAAG,CAAC,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,EAAE,EAAE,GAAG,CAAC,MAAM,CAAC,IAAI,GAAG,OAAO,CAAD,CAAG,EAAE,GAAG,CAAC,EAAA,AAAE,GAAG,MAAM,EAAE,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC,OAAO,EAAE,EAAE,CAAC,EAAwa,EAAA,CAAE,CAAE,GAAE,MAAM,CAAC,GAAG,GAAE,IAAI,CAAC,GAAA,CAAE,CAAE,GAAE,GAAG,CAAC,CAAC,CAAC,SAAS,GAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAE,EAAE,EAAE,MAAM,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE,AAA6W,SAAS,AAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,MAAM,CAAC,EAAE,EAAE,MAAM,CAAC,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,IAAI,OAAO,CAAD,CAAG,CAAC,CAAC,EAAA,AAAE,GAAG,WAAW,OAAO,GAAG,YAAY,OAAO,GAAG,CAAD,CAAG,EAAE,EAAE,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,CAAC,UAAU,OAAO,GAAG,UAAU,OAAO,GAAG,UAAU,OAAO,GAAG,EAAE,WAAW,EAAE,OAAO,GAAE,KAAK,EAAE,KAAK,KAAK,MAAM,GAAE,GAAG,GAAE,GAAE,CAAC,SAAS,CAAC,EAAE,KAAK,KAAK,MAAM,KAAK,IAAI,EAAE,WAAW,EAAE,EAAE,GAAG,CAAC,EAAE,GAAE,EAAE,IAAI,CAAC,EAAE,KAAK,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,KAAK,EAAE,GAAG,GAAE,CAAC,CAAE,EAAE,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,KAAK,CAAC,KAAK,CAAD,CAAG,EAAE,GAAG,CAAC,AAAoqB,SAAS,AAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,GAAG,OAAO,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAD,MAAQ,EAAE,GAAA,AAAG,EAAE,OAAO,EAAE,GAAG,IAAE,AAAC,MAAM,GAAG,GAAI,EAAD,MAAQ,EAAE,GAAA,CAAG,EAAO,EAAL,GAAU,CAAR,CAAC,CAAU,GAAG,EAAE,EAAE,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,EAAA,AAAE,GAAG,IAAI,CAAD,MAAQ,EAAE,GAAA,AAAG,GAAG,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,CAAC,OAAO,EAAE,GAAG,CAAC,GAAG,EAAE,EAAE,MAAM,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,EAAA,AAAE,GAAG,IAAI,CAAD,MAAQ,EAAE,GAAA,AAAG,GAAG,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,OAAM,CAAC,CAAC,EAAlgC,EAAE,EAAE,EAAE,EAAA,CAAE,GAAI,EAAD,EAAK,CAAC,EAAE,CAAC,CAAC,EAAA,AAAE,IAAI,CAAD,CAAG,GAAG,EAAE,MAAA,CAAM,CAAC,CAAE,MAAM,GAAG,OAAO,EAAE,GAAG,CAAE,CAAC,CAAF,GAAK,GAAG,IAAI,YAAY,OAAO,EAAE,IAAI,EAAG,EAAD,CAAG,GAAG,EAAE,KAAA,CAAK,CAAC,CAAE,IAAI,IAAI,CAAD,EAAI,EAAE,EAAE,IAAI,GAAG,EAAE,EAAE,KAAK,CAAD,CAAG,EAAE,IAAI,IAAI,EAAE,GAAG,EAAE,KAAA,CAAK,CAAC,CAAC,CAAE,EAAE,EAAE,GAAG,CAAC,EAAE,CAAC,KAAK,GAAG,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,IAAI,OAAO,CAAD,CAAG,CAAC,CAAC,EAAA,AAAE,GAAG,IAAI,CAAD,MAAQ,EAAE,GAAA,AAAG,IAAI,CAAD,CAAG,GAAG,EAAE,EAAE,GAAG,GAAG,CAAD,CAAG,GAAG,CAAC,GAAE,EAAA,CAAE,CAAm3L,AAAj3L,SAA03L,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,GAAG,GAAE,OAAO,EAAE,GAAE,OAAO,CAAC,GAAG,CAAC,EAAE,EAAE,GAAA,AAAG,IAAI,CAAD,CAAG,OAAO,EAAE,EAAE,OAAO,GAAG,EAAE,GAAG,EAAE,GAAE,EAAE,KAAK,EAAA,CAAE,CAAE,OAAO,CAAD,CAAG,EAAE,GAAA,AAAG,EAAE,CAAC,GAAG,EAAE,oBAAoB,CAAC,GAAG,CAAC,EAAE,oBAAoB,EAAE,CAAC,MAAM,EAAE,CAAC,GAAE,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE,IAAI,CAAC,EAAE,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,EAAE,GAAG,CAAC,IAAI,EAAE,EAAE,EAAE,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,GAAG,YAAY,OAAO,EAAE,IAAI,CAAE,IAAG,GAAE,EAAE,GAAG,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC,EAAjsM,EAAE,EAAA,CAAE,AAAC,EAA1jC,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,IAAI,OAAO,CAAD,CAAG,EAAE,GAAG,CAAC,EAAA,AAAE,IAAI,CAAD,CAAG,CAAC,IAAI,EAAE,GAAG,CAAC,GAAE,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE,GAAE,EAAE,GAAG,CAAC,EAAE,GAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,CAAC,EAAE,GAAG,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,CAAD,CAAG,GAAG,EAAE,GAAE,EAAE,GAAG,CAAC,KAAK,GAAG,EAAE,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,EAAE,EAAE,EAAA,CAAE,CAAE,MAAM,GAAG,MAAM,IAAI,CAAD,EAAG,CAAC,CAAE,MAAM,EAAE,GAAG,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,CAAC,EAAE,AAA60B,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,GAAG,YAAY,OAAO,EAAE,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,EAAE,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,GAAG,CAAD,AAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,EAAA,CAAE,CAAE,OAAO,CAAC,CAAC,EAAE,GAAG,EAAE,IAAI,CAAD,EAAI,EAAE,IAAI,EAAE,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAD,CAAG,GAAE,EAAA,CAAE,CAAE,EAAE,YAAY,CAAC,EAAE,GAAG,CAAC,GAAG,MAAM,EAAE,EAAE,GAAA,AAAG,EAAE,GAAE,AAAC,EAAE,GAAG,EAAE,WAAW,OAAO,MAAM,GAAG,IAAI,EAAE,QAAQ,CAAE,OAAO,CAAC,EAAjmC,EAAE,EAAE,GAAG,YAAY,OAAO,EAAE,IAAI,EAAE,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,IAAI,CAAD,CAAG,EAAE,WAAA,AAAW,EAAE,EAAE,GAAG,CAAC,KAAK,EAAE,EAAE,GAAG,EAAE,CAAC,MAAA,CAAM,CAAE,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,CAAq7C,SAAS,GAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,WAAW,CAAC,EAAE,MAAM,EAAE,GAAG,GAAG,CAAC,CAAC,EAAE,CAAC,MAAM,EAAE,GAAG,UAAU,OAAO,GAAG,GAAE,IAAI,CAAC,GAAG,EAAE,EAAE,IAAI,CAAC,SAAS,GAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,GAAG,UAAU,EAAE,GAAG,UAAU,OAAO,EAAE,EAAE,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,UAAU,OAAO,IAAI,CAAD,CAAG,KAAK,CAAC,OAAO,CAAC,EAAE,EAAA,CAAE,CAAE,EAAE,IAAI,KAAK,EAAE,GAAG,KAAK,GAAG,GAAE,EAAE,KAAK,CAAC,EAAE,IAAI,GAAG,EAAE,IAAI,KAAK,EAAE,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE,EAAE,GAAE,EAAE,KAAK,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC,EAAE,EAAE,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,CAAD,CAAG,EAAE,OAAO,CAAC,8BAA8B,KAAA,CAAK,CAAE,EAAE,EAAE,WAAW,KAAK,GAAG,eAAe,GAAG,cAAc,EAAE,EAAE,WAAW,GAAG,KAAK,CAAC,GAAG,EAAE,KAAK,CAAC,GAAG,EAAE,CAAC,GAAG,CAAD,CAAG,CAAC,CAAC,EAAC,CAAC,CAAE,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAD,CAAG,CAAC,CAAC,GAAE,EAAE,gBAAgB,CAAC,EAAE,EAAE,GAAE,GAAE,EAAA,CAAE,CAAE,EAAE,mBAAmB,CAAC,EAAE,EAAE,GAAE,GAAE,OAAO,CAAC,GAAG,8BAA8B,EAAE,EAAE,EAAE,OAAO,CAAC,cAAc,KAAK,OAAO,CAAC,SAAS,UAAU,GAAG,SAAS,GAAG,UAAU,GAAG,QAAQ,GAAG,QAAQ,GAAG,QAAQ,GAAG,YAAY,GAAG,YAAY,GAAG,WAAW,GAAG,WAAW,GAAG,QAAQ,GAAG,WAAW,GAAG,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,EAAE,GAAG,EAAE,MAAM,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,YAAY,OAAO,IAAI,CAAD,KAAO,GAAG,CAAC,IAAI,GAAG,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,eAAe,CAAC,GAAG,EAAE,YAAY,CAAC,EAAE,WAAW,GAAG,GAAG,EAAE,GAAG,EAAA,CAAE,AAAC,CAAC,CAAC,SAAS,GAAE,CAAC,EAAE,OAAO,SAAS,CAAC,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,UAAS,GAAG,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,OAAO,OAAO,EAAE,GAAE,KAAK,CAAC,GAAE,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,SAAS,GAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,CAAC,GAAG,KAAK,IAAI,EAAE,WAAW,CAAC,OAAO,KAAK,IAAI,EAAE,GAAG,GAAG,CAAD,CAAG,CAAC,CAAC,CAAC,GAAG,EAAE,GAAA,AAAG,EAAE,EAAE,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,EAAE,CAAC,EAAE,GAAE,GAAA,AAAG,GAAG,EAAE,GAAG,EAAE,GAAG,YAAY,OAAO,EAAE,GAAG,CAAC,GAAG,EAAE,EAAE,KAAK,CAAC,EAAE,cAAc,GAAG,EAAE,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE,EAAE,WAAA,AAAW,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,KAAK,CAAC,KAAK,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,AAAC,GAAE,EAAE,GAAG,CAAC,EAAE,GAAA,AAAG,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,CAAD,CAAG,EAAE,GAAG,CAAC,EAAE,IAAI,EAAE,EAAE,IAAI,CAAD,CAAG,GAAG,CAAC,EAAE,IAAI,GAAE,EAAE,GAAG,EAAE,WAAW,CAAC,EAAE,EAAE,MAAM,GAAC,CAAC,CAAE,GAAG,EAAE,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,EAAE,KAAK,GAAG,CAAD,CAAG,KAAK,CAAC,EAAC,CAAC,CAAE,EAAE,OAAO,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,EAAE,GAAG,CAAC,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,CAAC,EAAE,GAAG,CAAC,EAAA,AAAE,EAAE,GAAG,MAAM,EAAE,GAAG,GAAG,CAAD,CAAG,GAAG,CAAC,EAAE,KAAA,AAAK,EAAE,GAAG,MAAM,EAAE,wBAAwB,GAAG,CAAD,CAAG,GAAG,EAAE,EAAE,KAAK,GAAG,CAAD,CAAG,GAAG,CAAC,GAAE,CAAC,EAAE,EAAE,IAAG,CAAC,CAAE,GAAE,EAAE,GAAG,CAAC,EAAE,wBAAwB,CAAC,EAAE,EAAE,GAAG,EAAA,CAAE,CAAE,EAAE,EAAE,KAAK,CAAC,EAAE,EAAE,KAAK,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,MAAM,EAAE,wBAAwB,EAAE,MAAM,EAAE,kBAAkB,EAAE,EAAE,kBAAkB,GAAG,GAAG,MAAM,EAAE,iBAAiB,EAAE,EAAE,GAAG,CAAC,IAAI,CAAC,EAAE,iBAAiB,MAAM,CAAC,GAAG,GAAG,MAAM,EAAE,wBAAwB,EAAE,IAAI,GAAG,MAAM,EAAE,yBAAyB,EAAE,EAAE,yBAAyB,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,GAAG,CAAD,KAAO,EAAE,qBAAqB,EAAE,CAAC,IAAI,EAAE,qBAAqB,CAAC,EAAE,EAAE,GAAG,CAAC,IAAI,EAAE,GAAG,GAAG,EAAE,GAAA,AAAG,EAAE,CAAC,IAAI,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,CAAD,CAAG,KAAK,CAAC,EAAE,EAAE,KAAK,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,EAAC,CAAC,CAAE,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,IAAI,EAAD,AAAG,EAAE,EAAC,CAAC,AAAC,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,CAAC,MAAM,CAAC,IAAI,EAAE,GAAG,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,EAAE,GAAG,CAAC,EAAE,CAAC,EAAE,GAAG,CAAC,MAAM,EAAE,EAAE,IAAI,CAAC,GAAG,MAAM,CAAC,CAAC,MAAM,EAAE,mBAAmB,EAAE,EAAE,mBAAmB,CAAC,EAAE,EAAE,GAAG,CAAC,GAAG,GAAG,MAAM,EAAE,kBAAkB,EAAE,EAAE,GAAG,CAAC,IAAI,CAAC,WAAW,EAAE,kBAAkB,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,GAAG,EAAE,OAAO,CAAC,EAAE,EAAE,KAAK,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,EAAE,EAAE,GAAE,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,MAAM,CAAC,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,OAAO,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,CAAC,MAAM,CAAC,IAAI,EAAE,GAAG,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,EAAE,GAAG,CAAC,EAAE,MAAM,GAAE,AAAC,EAAE,GAAG,CAAC,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,MAAM,CAAC,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,OAAO,EAAE,EAAE,KAAK,CAAC,EAAE,GAAG,OAAO,EAAE,GAAG,EAAE,EAAE,EAAE,GAAI,EAAE,KAAK,CAAC,EAAE,GAAG,CAAC,MAAM,EAAE,eAAe,GAAG,CAAD,CAAG,GAAE,GAAE,CAAC,EAAE,GAAG,EAAE,eAAe,GAAA,CAAG,CAAE,GAAG,CAAC,GAAG,MAAM,EAAE,uBAAuB,GAAG,CAAD,CAAG,EAAE,uBAAuB,CAAC,EAAE,EAAA,CAAE,CAAE,GAAE,EAAE,GAAE,EAAE,MAAM,GAAG,EAAE,IAAI,GAAG,IAAG,MAAM,EAAE,GAAG,CAAC,EAAE,KAAK,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE,GAAG,CAAC,MAAM,EAAE,EAAE,IAAI,CAAC,GAAG,IAAI,CAAD,CAAG,GAAG,CAAC,EAAE,EAAE,CAAC,IAAA,CAAI,AAAC,CAAC,MAAM,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,KAAK,GAAG,MAAM,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,EAAE,IAAI,GAAG,GAAG,IAAI,EAAE,QAAQ,EAAE,EAAE,WAAW,EAAE,EAAE,EAAE,WAAW,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,MAAM,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,GAAE,GAAG,CAAC,EAAE,EAAE,EAAE,MAAM,MAAM,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,CAAD,CAAG,GAAG,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,EAAE,GAAA,AAAG,EAAE,EAAE,GAAG,CAAiP,AAAhP,SAAyP,AAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,KAAK,CAAC,EAAE,EAAE,KAAK,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG,QAAQ,EAAE,EAAE,6BAA6B,SAAS,EAAE,EAAE,qCAAqC,GAAI,EAAD,CAAG,8BAAA,CAA8B,CAAE,MAAM,GAAE,IAAI,EAAE,EAAE,EAAE,EAAE,MAAM,CAAC,IAAI,GAAG,AAAC,GAAE,CAAC,CAAC,EAAA,AAAE,GAAG,iBAAiB,GAAG,CAAC,CAAC,IAAI,CAAD,CAAG,EAAE,SAAS,GAAG,EAAE,IAAI,EAAE,QAAA,AAAQ,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,KAAK,MAAK,CAAC,GAAG,MAAM,EAAE,CAAC,GAAG,OAAO,EAAE,OAAO,SAAS,cAAc,CAAC,GAAG,EAAE,SAAS,eAAe,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,IAAI,CAAD,EAAG,GAAG,EAAE,GAAE,GAAG,CAAC,EAAE,GAAG,EAAE,EAAC,CAAC,CAAE,EAAE,IAAI,CAAC,GAAG,OAAO,EAAE,IAAI,GAAG,GAAG,EAAE,IAAI,GAAG,IAAI,CAAD,CAAG,IAAI,EAAC,CAAC,KAAM,CAAC,GAAG,EAAE,GAAG,GAAE,IAAI,CAAC,EAAE,UAAU,EAAE,EAAE,EAAE,KAAK,EAAE,GAAE,CAAC,GAAG,MAAM,EAAE,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,UAAU,CAAC,EAAE,AAAF,EAAI,IAAI,CAAC,CAAC,EAAE,KAAK,CAAC,IAAI,KAAK,EAAE,GAAG,EAAE,CAAC,CAAC,EAAE,CAAC,YAAY,QAAQ,GAAG,2BAA2B,EAAE,EAAE,OAAO,GAAG,CAAC,CAAC,MAAK,CAAC,CAAE,CAAC,GAAG,SAAS,GAAG,iBAAiB,GAAG,WAAW,GAAG,mBAAmB,EAAE,SAAS,GAAE,EAAE,EAAE,KAAK,EAAE,EAAE,CAAC,IAAI,KAAK,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,YAAY,EAAE,EAAE,EAAE,2BAA2B,EAAE,EAAE,EAAE,SAAS,EAAE,EAAE,EAAE,WAAW,EAAE,EAAE,EAAE,GAAG,YAAY,OAAO,GAAG,CAAC,CAAC,EAAE,GAAG,GAAG,GAAE,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,GAAG,GAAI,EAAD,CAAG,MAAM,GAAG,EAAE,MAAM,EAAE,EAAE,MAAM,GAAG,EAAE,SAAA,AAAS,IAAI,CAAD,CAAG,SAAS,CAAC,EAAE,MAAA,AAAM,EAAE,EAAE,GAAG,CAAC,EAAE,MAAM,GAAG,IAAI,CAAD,CAAG,SAAS,CAAC,EAAA,CAAE,CAAE,GAAE,EAAE,GAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,kBAAkB,EAAE,+BAA+B,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,GAAE,EAAE,GAAG,EAAE,GAAG,MAAM,EAAE,IAAI,EAAE,EAAE,MAAM,CAAC,KAAK,GAAE,CAAC,CAAC,EAAE,EAAE,IAAI,CAAD,CAAG,QAAQ,aAAa,GAAG,MAAM,EAAE,EAAE,eAAe,CAAC,SAAS,KAAK,IAAI,GAAI,EAAD,EAAK,CAAC,CAAC,EAAE,GAAE,aAAa,IAAI,CAAD,GAAI,WAAW,GAAG,IAAI,CAAC,CAAC,EAAA,AAAE,GAAG,GAAE,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,GAAG,EAAE,UAAU,KAAK,IAAI,GAAG,IAAI,CAAC,CAAC,EAAE,EAAE,GAAE,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,EAAA,CAAE,AAAC,CAAC,OAAO,CAAC,EAA7pD,EAAE,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAG,EAAC,EAAE,GAAE,MAAA,AAAM,GAAG,EAAE,EAAE,CAAC,SAAS,GAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,GAAG,CAAC,KAAK,EAAE,IAAI,IAAI,EAAE,EAAE,EAAE,EAAE,MAAM,CAAC,IAAI,GAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,GAAE,GAAG,EAAE,GAAE,GAAG,CAAC,EAAE,GAAG,EAAE,IAAI,CAAC,SAAS,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,SAAS,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,CAAC,MAAM,EAAE,CAAC,GAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,EAAE,CAAi7C,SAAS,GAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,GAAG,YAAY,OAAO,EAAE,CAAC,IAAI,EAAE,YAAY,OAAO,EAAE,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,GAAG,MAAM,IAAI,CAAD,CAAG,GAAG,CAAC,EAAE,EAAA,CAAE,AAAC,MAAM,EAAE,OAAO,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,GAAE,GAAG,CAAC,EAAE,EAAE,CAAC,CAAoV,SAAS,GAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,OAAO,IAAI,CAAC,WAAW,CAAC,EAAE,EAAE,CAAC,SAAS,GAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,GAAE,EAAE,EAAE,GAAE,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,YAAY,QAAO,CAAC,CAAE,KAAK,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,GAAE,EAAE,EAAE,CAAC,CAAC,GAAG,IAAG,CAAC,CAAE,GAAG,CAAC,GAAE,GAAE,KAAK,CAAC,EAAE,EAAE,GAAG,GAAE,GAAE,EAAE,YAAY,CAAC,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,UAAU,CAAC,GAAE,IAAI,CAAC,EAAE,UAAU,EAAE,KAAK,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,CAAC,EAAE,UAAU,CAAC,EAAE,GAAG,GAAE,EAAE,EAAE,EAAE,CAAi3B,GAAE,GAAE,KAAK,CAAC,GAAE,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,GAAA,AAAG,GAAG,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,EAAE,WAAA,AAAW,GAAG,MAAM,EAAE,wBAAwB,GAAG,CAAD,CAAG,QAAQ,CAAC,EAAE,wBAAwB,CAAC,IAAI,EAAE,EAAE,GAAA,AAAG,EAAE,MAAM,EAAE,iBAAiB,GAAG,CAAD,CAAG,iBAAiB,CAAC,EAAE,GAAG,CAAC,GAAG,EAAE,EAAE,GAAA,AAAG,EAAE,EAAE,OAAO,EAAE,GAAG,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE,GAAE,EAAqD,CAAnD,EAAqD,EAAnD,OAA4D,CAAC,CAApD,EAAC,KAA2D,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,IAAI,CAAE,GAAE,MAAM,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,GAAE,CAAC,EAAE,IAAI,CAAC,KAAK,EAAE,YAAY,OAAO,IAAI,EAAD,AAAG,EAAE,GAAE,CAAC,EAAE,GAAG,IAAI,CAAC,MAAK,CAAC,CAAE,GAAG,GAAE,EAAE,GAAG,MAAM,GAAG,IAAI,CAAC,GAAG,EAAG,EAAD,EAAI,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,GAAE,KAAI,CAAC,AAAC,EAAE,GAAE,SAAS,CAAC,WAAW,CAAC,SAAS,CAAC,EAAE,IAAI,CAAC,GAAG,GAAG,CAAD,GAAK,CAAC,GAAG,CAAC,CAAC,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,GAAE,IAAI,CAAC,CAAC,EAAE,GAAE,SAAS,CAAC,MAAM,CAAC,GAAE,GAAE,EAAE,CAAC,GAAE,YAAY,OAAO,QAAQ,QAAQ,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,OAAO,IAAI,WAAW,GAAE,SAAS,CAAC,CAAC,CAAC,EAAE,OAAO,EAAE,GAAG,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,GAAG,EAAE,GAAE,GAAG,CAAC,EAAE,GAAE,EAAE,GAAE,GAAE,CAAC,GAAG,GAAE,GAAE,CAAC,GkDAvkV,ClDA0kV,GkDAtkV,AAAsE,ClDAkgV,EkDAhgV,EAAkB,AAAxF,CAAwE,KAAE,GAAuB,GAAjB,AAAmB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAlB,AAAmB,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAD,CAAG,EAAC,CAAC,CAAE,IAAI,EAAE,EAAE,EAAE,EAAE,QAAQ,IAAI,CAAD,CAAG,EAAE,GAAG,CAAC,OAAO,EAAE,GAAG,AAAH,EAAK,IAAI,EAAE,CAAC,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,KAAK,GAAG,KAAK,IAAI,EAAE,IAAI,KAAK,IAAI,KAAK,EAAE,IAAI,KAAK,YAAY,KAAK,EAAE,IAAI,EAAE,GAAE,IAAI,CAAC,EAAE,IAAI,EAAE,SAAS,EAAE,OAAO,CAAC,EAAE,GAAG,YAAY,OAAO,IAAI,CAAD,CAAG,EAAE,YAAA,AAAY,EAAE,IAAI,KAAK,EAAE,KAAK,IAAI,CAAC,CAAC,EAAE,GAAG,CAAD,AAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAAA,AAAE,EAAE,OAAO,GAAE,KAAK,EAAE,GAAE,KAAK,CAAC,GAAG,CAAC,CjDAljB,SAAS,KAAO,IAAI,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,UAAU,MAAM,EAAE,CAAC,EAAE,SAAS,CAAC,IAAA,AAAI,IAAI,CAAD,CAA5T,AAA+T,SAAtT,EAAE,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,GAAG,GAAG,UAAU,OAAO,GAAG,UAAU,OAAO,EAAE,GAAG,OAAO,GAAG,UAAU,OAAO,EAAE,GAAG,MAAM,OAAO,CAAC,GAAG,IAAI,EAAE,EAAE,EAAE,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,GAAG,CAAD,CAAG,EAAE,CAAC,CAAC,GAAE,CAAC,GAAI,EAAD,EAAK,EAAD,CAAI,GAAA,CAAG,CAAE,IAAG,CAAC,MAAO,IAAI,KAAK,EAAE,CAAC,CAAC,EAAE,GAAG,CAAD,EAAK,GAAD,CAAI,GAAA,CAAG,CAAE,IAAG,CAAC,CAAE,OAAO,CAAC,EAA0F,EAAA,CAAE,GAAI,EAAD,EAAK,EAAD,CAAI,GAAA,CAAG,CAAE,IAAG,CAAC,CAAE,OAAO,CAAC,yOyGQvV,CboBgC,AYlBtB,uhBCDZ,IAAI,EAAE,SAAS,iBAAA,EACf,EACE,CACP,A1DZ8B,C0DY7B,G1DZiC,GAAE,GAAE,GAAE,GAAE,GAAE,EAAE,GAAE,EAAE,CAAC,GAAE,GAAE,GAAE,GAAE,GAAG,CAAC,GAAE,GAAE,GAAG,CAAC,GAAE,GAAE,MAAM,CAAC,GAAE,GAAE,GAAG,CAAC,GAAE,GAAE,OAAO,CAAC,GAAE,GAAE,EAAE,CAAC,SAAS,GAAE,CAAC,CAAC,CAAC,EAAE,GAAE,GAAG,EAAE,GAAE,GAAG,CAAC,GAAE,EAAE,IAAG,GAAG,GAAE,EAAE,IAAI,EAAE,GAAE,GAAG,GAAG,CAAD,EAAG,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,IAAI,EAAE,CAAA,CAAC,CAAE,OAAO,GAAG,EAAE,EAAE,CAAC,MAAM,EAAE,EAAE,EAAE,CAAC,IAAI,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,CAAC,SAAS,GAAE,CAAC,EAAE,OAAO,GAAE,EAAE,AAAO,SAAS,AAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,GAAE,KAAI,GAAG,GAAG,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,GAAG,GAAG,CAAD,CAAG,EAAE,CAAC,CAAQ,GAAE,KAAK,EAAE,GAAG,SAAS,CAAC,EAAE,IAAI,EAAE,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,GAAG,IAAI,GAAI,EAAD,CAAG,GAAG,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC,QAAQ,CAAC,CAAC,EAAA,CAAE,AAAC,EAAE,CAAC,EAAE,GAAG,CAAC,GAAE,CAAC,IAAE,AAAC,EAAE,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,IAAI,EAAE,EAAE,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE,MAAM,CAAC,CAAC,EAAE,GAAG,GAAG,GAAG,EAAE,KAAK,CAAC,SAAS,CAAC,EAAE,MAAM,CAAC,EAAE,GAAG,GAAG,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,EAAE,GAAG,IAAI,EAAE,CAAC,EAAE,OAAO,EAAE,OAAO,CAAC,SAAS,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,KAAK,EAAE,IAAI,EAAE,EAAE,CAAC,EAAE,GAAG,CAAD,CAAG,EAAC,CAAC,AAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,KAAK,GAAG,CAAA,CAAC,EAAI,EAAC,CAAF,EAAK,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,EAAE,EAAA,CAAE,AAAC,EAAE,GAAE,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,GAAE,qBAAqB,CAAC,EAAE,GAAE,mBAAmB,CAAC,GAAE,mBAAmB,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE,GAAE,qBAAqB,CAAC,CAAC,CAAC,OAAO,EAAE,GAAG,EAAE,EAAE,EAAE,EAA1tB,GAAE,EAAE,CAAutB,SAAS,GAAE,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,GAAE,KAAI,EAAG,EAAC,GAAE,GAAG,EAAE,GAAE,EAAE,GAAG,CAAC,KAAK,CAAD,CAAG,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,GAAE,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,EAAA,CAAE,AAAC,CAAy7B,SAAS,KAAI,IAAI,IAAI,EAAE,EAAE,GAAE,KAAK,IAAI,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC,IAAG,EAAE,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC,IAAG,EAAE,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC,GAAE,GAAG,CAAC,SAAS,CAAC,EAAE,GAAE,KAAK,IAAG,GAAE,EAAE,EAAE,GAAE,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,GAAG,CAAC,GAAG,GAAG,CAAD,CAAG,GAAG,CAAC,EAAE,GAAG,CAAC,GAAA,AAAG,EAAE,IAAG,GAAE,EAAE,EAAE,EAAE,GAAE,GAAG,CAAC,SAAS,CAAC,EAAE,IAAG,GAAE,GAAG,GAAE,EAAE,IAAI,EAAE,CAAC,GAAE,EAAE,GAAG,AAAH,EAAK,GAAG,CAAC,IAAI,CAAD,IAAK,IAAG,CAAD,CAAG,GAAG,CAAC,EAAE,CAAC,GAAE,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE,EAAE,GAAG,GAAG,CAAD,CAAG,EAAE,CAAC,EAAE,GAAA,AAAG,EAAE,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC,KAAK,CAAC,EAAA,CAAE,EAAG,EAAD,AAAG,GAAG,CAAC,OAAO,CAAC,IAAG,EAAE,GAAG,CAAC,OAAO,CAAC,IAAG,EAAE,GAAG,CAAC,EAAE,CAAC,IAAE,CAAC,CAAC,CAAE,GAAE,EAAC,EAAE,GAAE,MAAM,CAAC,SAAS,CAAC,EAAE,IAAG,GAAE,GAAG,IAAI,EAAE,EAAE,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,CAAD,CAAG,GAAG,CAAC,GAAG,CAAC,MAAM,GAAG,CAAD,GAAK,GAAE,IAAI,CAAC,IAAI,KAAI,GAAE,qBAAqB,EAAE,CAAC,CAAC,GAAE,GAAE,qBAAA,AAAqB,GAA8c,EAA3c,OAAod,AAAE,CAAC,EAAE,IAAI,EAAE,EAAE,WAAW,aAAa,GAAG,IAAG,qBAAqB,GAAG,WAAW,EAAE,EAAE,EAAE,WAAW,EAAE,KAAK,IAAI,EAAD,CAAG,sBAAsB,EAAA,CAAE,AAAC,CAAzlB,CAAC,CAAE,GAAA,CAAE,CAAE,EAAE,GAAG,CAAC,EAAE,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE,EAAE,CAAC,GAAG,CAAD,CAAG,GAAG,CAAC,GAAG,AAAD,EAAG,EAAE,CAAC,CAAC,KAAK,CAAC,EAAA,CAAE,CAAE,GAAE,GAAE,IAAI,EAAE,GAAE,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,IAAI,CAAC,SAAS,CAAC,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,OAAO,CAAC,IAAG,EAAE,GAAG,CAAC,EAAE,GAAG,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE,MAAM,CAAC,EAAE,EAAE,EAAE,GAAE,EAAE,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,IAAI,CAAC,SAAS,CAAC,EAAE,EAAE,GAAG,GAAG,CAAD,CAAG,GAAG,CAAC,EAAA,AAAE,CAAC,GAAG,EAAE,EAAE,CAAC,GAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,GAAG,IAAG,GAAE,EAAE,EAAE,EAAE,GAAE,OAAO,CAAC,SAAS,CAAC,EAAE,IAAG,GAAE,GAAG,IAAI,EAAE,EAAE,EAAE,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,CAAD,CAAG,GAAG,CAAC,EAAE,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE,GAAG,CAAC,GAAE,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,KAAK,EAAE,GAAG,GAAE,GAAG,CAAC,EAAE,EAAE,IAAG,CAAC,AAAC,EAAE,IAAI,GAAE,YAAY,OAAO,sBAAqK,SAAS,GAAE,CAAC,EAAE,IAAI,EAAE,GAAE,EAAE,EAAE,GAAG,CAAC,YAAY,OAAO,IAAI,CAAD,CAAG,GAAG,CAAC,KAAK,EAAE,GAAA,CAAG,CAAE,GAAE,CAAC,CAAC,SAAS,GAAE,CAAC,EAAE,IAAI,EAAE,GAAE,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,GAAE,CAAC,CAAC,SAAS,GAAE,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,GAAG,EAAE,MAAM,GAAG,EAAE,MAAM,EAAE,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,OAAO,IAAI,CAAC,CAAC,EAAE,EAAE,CAAC,SAAS,GAAE,CAAC,CAAC,CAAC,EAAE,MAAM,YAAY,OAAO,EAAE,EAAE,GAAG,CAAC,kFsHe10G,CeOC,AF8BP,AC0OK,Ad/QE,AgBAxC,CDOyC,CE8C1B,AF9C2B,AG2CM,CAAG,ADGpC,AF9C2B,ysBf8EvD,CAAC,IAAA,CAAA,KAAA,CAAW,OAAO,IAAA,GAAO,CAAA,CAAE,CAAC,EAAK,CgIiChD,ChIjC0D,C1BpBtD,CAAC,A0BoBuD,CACvD,CADyD,EAAC,CAAN,EACrC,CAAA,GACT,CAAS,CACb,GAAG,CAAE,CAFQ,CAGb,CADQ,UACG,CAAE,GAAG,EAAE,wKAgE5B,GAAA,QAAA,WAAQ,CwIwC8E,wrLxIvCtF,GAAA,CwIwCK,KAAA,CxIvCH,KAAK,CAAC,+BAA+B,CACrC,YAAY,EAAE,gBAAgB,0BAC9B,WAAW,EAAE,eAAe,4BAnCD,kCAoC3B,UAAU,EAAE,cAAc,+GAAA,SAE1B,GAAA,MAAA,CACE,KAAK,CAAC,sBAAsB,CAC5B,KAAK,CAAE,+BAC8B,sEAK9B,EgBlD8C,CAAC,CAAC,IhBkDxC,MAEb,EACF,CACP,CAAC,kDAOS,CAAA,QtHlMs3C,EAAC,iBsHoM71C,yBAEmB,mFAQjC,CAAA,4CAMU,CAAA,GAAI,GAAA,QAAA,EAAA,CAAA,EAAA,8BAUlC,EAAE,oDtH9N83C,CAAC,KAAwB,GAAE,CAApB,EAAE,GAAE,KAAI,IAAc,GAAG,CAAC,KAAK,CAAD,CAAG,EAAE,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,CAAA,CAAC,CAAE,EAAE,EAAE,uGsH2Ol8C,SAAA,CAED,GAAA,MAAA,CAAK,KAAK,CAAC,sCAAsC,CAAA,SAAA,CAC/C,GAAA,MAAA,CAAK,KAAK,CAAC,qDAAqD,CAAA,SAAA,CAC9D,GAAC,GAAQ,CAAC,IAAD,AAAK,CAAC,MAAM,EAAG,CACvB,IAAyB,GACxB,MAAA,CAAK,KAAK,CAAC,CADS,0DACkD,CAAA,SACnE,CAAW,EACR,CACP,EACG,CACN,GAAA,CAJkB,KAIlB,CAAK,KAAK,CAAC,4CAA4C,CAAC,OAAO,CAAE,EAAW,SAAA,AAC1E,GAAA,MAAA,CAAK,GAAG,EAAE,SAAS,sRA5OqR,CAAC,AA4OpR,KAAK,CAAC,iDAAiD,EAAG,EAC3E,CAAA,EACF,CACN,GAAA,MAAA,CAAK,KAAK,CAAC,uCAAuC,CAAA,SAAA,CAChD,GAAA,MAAA,CAAK,KAAK,CAAC,6CAA6C,CAAA,SAAE,CAAK,EAAO,CACtE,CAD+D,EAC/D,MAAA,CAAK,KAAK,CAAC,+CAA+C,CAAA,SAAE,CAAO,EAAO,CAAA,EACtE,CAD+D,AAEpE,GAAe,EAAY,MAAM,AAAtB,CAAyB,CAAC,CAAX,CACzB,GAAA,MAAA,CAAK,KAAK,CAAC,uCAAuC,CAAA,SAC/C,EAAY,GAAG,CAAC,CAAC,EAAQ,CAAC,CAAf,CAAiB,CAC3B,AADsB,CAAO,CAAC,CAC9B,SAAA,CACE,KAAK,CAAE,GACL,CADS,qCAC6B,CACnB,SAAS,GAA5B,EAAO,IAAD,GAAQ,EAAkB,8CAA8C,CAC9E,AAAmB,MAAb,KAAwB,KAAvB,OAAO,EAAoB,gDAAgD,CACnF,CACD,OAAO,CAAE,EAAO,IAAD,GAAQ,CAAA,SAGtB,EAAO,IAAD,AAAK,EAFP,CAAC,CAGC,CACV,AAAC,CAAA,CACE,CACP,EACG,CACP,CAAC,0O9E3QgF,CEmBrD,ADpBwD,ADCF,AGDE,sf8NmDA,EAAE,CAAC,CAAC,ICqDpE,CACX,CAAA,+3BlKtFsC,KAAc,KAAS,GAAA,CAAvB,i4BAoFb,YAAH,GAAG,0DiKEH,CAAA,CAAA,MAAA,CAAA,CAAA,GAAe,gBAAA,GAAA,IAAA,CAAA,44BxHnCV,CAAA,EAAA,EAAA,EAAA,CAAA,CAAA,uDAGgD,69B8E3BtD,EAAA,CAAA,CAAW,wBACtC,CAAA,CAAG,CACH,whCA6DA,mlBAgC8C,uPAwBjD,CAAA,MACM,CAAA,yEAEH,EtE5CkF,6LsEkDvD,EAAA,CAAA,uBACqB,4LAaH,GAAA,SAAA,6JAiB7C,sBAEgB,wJAKA,CAAA,UAAA,EAAA,EAAA,CAAA,gKAvBH,0TAkDV,CAAA,MAAA,CAAA,cACK,wJASsC,wPAiBR,GAAA,SAAA,sBAMzC,CAAA,qFAGG,0LAeF,OAAA,CAAA,CAAA,MAKK,CAAA,uDAAA,sBAEW,iBAA2B,CAAC,CAAC,MAAM,CAAA,SACjD,KAAA,mOAekD,CzFzEY,8HyFmEjD,sCAgB8B,uNAkBC,GAAA,SAAA,qHAY1C,iHAEyC,EAAA,CAAA,EACzC,MAAM,CAAA,oIAdK,sCAwBuC,CrFcH,EoSvRtC,iB/M8Qb,CAAA,CAAA,CAAA,8DAI8D,iJAKnD,uRAaX,CAAA,CAAA,CAAA,MAIK,CAAA,oEAAA,SAEH,KAAM,uIAQC,WAAA,GAAA,SAA2C,EgNhUtD,2BhNuUO,CAAA,gDAAA,cAEG,CyN7VE,4IzNsW+B,GAAA,SAAA,CAG3C,E3C62CI,U2C72CQ,OAAE,CAAK,CAAqC,CAAA,CACtD,KAAK,CAAA,0FAEH,OACE,OACM,2BAGZ,6GAO6C,GAAA,SAAS,C2NhYQ,Y3NmYlD,CAAA,MAAA,CAAO,CAAA,CAAA,MACZ,CACH,0FACA,8HALU,0BAiB0C,CF1GT,EAAA,SE0GkB,+EAS7D,KAAA,8HARa,C3LoDX,AsZ7aW,qC3N0YyC,oBAGxD,CAAA,CAAA,QAAA,CAAA,CAAA,YAAA,CAAA,CAAA,SAAA,CAGQ,CFnHkC,CAAA,0HE8HtC,GAAA,YACA,GAAe,gCAEhB,CAAA,MAAA,CAAQ,SACT,KAAA,iCAEJ,qGAOW,WAAkC,GAAA,SAAS,QyD7HQ,CAAA,WzDgIhD,CgN1VVW,AhN0Ve,AlLFN,CkLEM,CAAA,8IAGf,SAEE,KAAM,CgN5VRA,AWxD8B,+G3N6YpB,0BAiBuC,GAAA,SAAS,oBAG5D,CyDnIe,AzDmIV,CAGN,CyDtIwB,CzDuIvB,KAAK,CAAA,+DAAiE,SAEpE,KAAM,2HARO,CkNvEX,clNyFK,WAA4C,E3C6qDE,A7BpzDd,CAAA,SwEuIqB,ExEvIZ,mBwE0IjC,CAAqC,CAAA,4FAGpD,uJAWO,WAAkC,GAAA,SAAA,CAE7C,YAAY,OACV,CAAA,CAAA,CAAA,MAIK,CAAC,CxE/IC,yBwE+I0B,C6DzGL,CsKhbiB,A3S0YV,A0SvWoD,8ClO0fnF,kHACD,CAAA,MAAO,CAAC,2JAUyC,EyD7IE,CAAA,AyJ8FG,A7Pq4DF,S2Ct1DM,CAE/D,ExEhJwD,UwEgJ5C,CAAA,MAAA,CACL,CAAA,CAAA,CAIL,CyDlJK,ApGm+DF,I2Cj1DE,CAAC,wCAAyC,OAC7C,eACc,wJAGN,CAAC,cACH,4HAZO,eAoBN,WAAA,GAAA,SAA6C,IyDhJI,CAAA,kBzDsJ3D,CACC,CyDrJK,IAAA,CzDqJC,wDAAyD,IkN7CU,mBlNgDrE,GlLGK,yIkLDN,CAAA,MAAA,CAAA,SACD,KAAM,C3Cg7DK,oH2C57DE,eAqBN,WAA6C,GyDpJI,CAAA,CAAA,OzDoJK,MkNnCQ,kBlN0CvE,KAAK,CAAC,CyDzJK,uDzDyJoD,SAE7D,aAAA,yIAGC,CAAA,MAAA,CAAA,SACD,KAAA,8HAZa,eAsBN,WAA+C,GAAA,SAAS,aAGvD,CAAA,MAAA,CAAO,CAAA,CAAA,MACZ,CACH,sGACA,OACE,kFkNtBA,4ElNkCmD,G3Cs8DC,S2Ct8DQ,aAGtD,OAAE,CAAK,CAAqC,CAAA,iC3Co8DM,0C2Cn8De,cAEnE,mB3Cq8DgD,yG2C18D5C,CAAC,cAeJ,WAAA,GAAA,SAAA,oBAGG,CAAK,A3Co9DJ,C2Cp9DyC,CAAA,MACjD,CAAC,yDAA0D,CyDlKK,CAAA,C3DQR,oIEuJjD,CAAC,yBAeqC,GAAA,SAAS,GyDlKG,CAAA,UjIDG,MwEsKrD,CAAA,CAAA,CAAA,OAEV,sIACA,cAEQ,sIASD,WAA4B,C4O3jBA,EAAA,S5O2jBS,aACpC,OAAE,CAAA,CAAA,CAAA,MACP,CAAA,CAAA,kDAAA,EACkD,GAAO,GxEvKC,UAAA,CwEuKa,CAC1E,SAEE,KAAM,+BAUD,WAA0C,GlLsBJ,CAAA,QAAA,akLpBrC,OACV,CAAA,CAGD,CAAA,CACC,CyD/KK,EkL5eW,E3O2pBX,CAAA,kDAAA,sBAEW,CACZ,C2O3pBY,EAAA,AlL4eD,EuLjeVnB,AvLieY,oBzDgLb,E2O3pBG,AtRi7FK,oE2CrxET,CAAC,MAAA,CAAO,SACT,KAAA,qCAEJ,CAAC,qFAdgB,eAqBN,WAAA,GAAA,SAAiD,CyD9KA,C2LzfG,WpPyqBnD,CAAA,MAAA,CACL,CAAA,CAAA,CAIL,CyDnLK,IAAA,CAAA,oDzDmLsD,uHAKxD,CAAC,MAAA,CAAO,cACH,6SxKjvBM,CAAA,qBAAA,CACQ,OACpB,CCVC,ADUI,WACL,CAAA,kBACA,CAAgB,eAChB,CAAa,yBACb,CVEsC,oBAAA,WUDtC,CVEyB,oBUDzB,CAAkB,KVCO,GUAzB,CAAM,EVCe,EACzB,OUDI,CAAS,sBACT,CAAoB,CAGrB,CAAA,UVHwB,GAC5B,2BAAiD,CAAC,mDUgCI,QAAW,mSGzD+d,6bH2E3hB,CAAE,IAAI,CAAE,mCAAmC,CAAE,CAC9C,CAAA,wKAmBwD,CuPxBF,EAAA,SAAA,2GvP2B4B,CACjF,MAAQ,C0LP6F,8kC0GyGzD,GAAA,OAAA,IAAA,GAAA,qKAgBP,CAAA,IAAA,CAAA,GAAA,OAAA,IAAA,GAAA,wFAOJ,CAAA,IAAA,CAAA,GAAA,OAAA,IAAA,GAAA,wBAIS,CAAA,IAAA,CAAA,GAAA,OAAA,IAAA,GAAA,OAEnC,uBAE2C,GAAA,OAAA,IAAA,GAAA,4HAYL,GAAA,OAAA,IAAA,GAAA,qDAM0B,CAAC,CAChC,CAAA,ElMtH0C,EiBqEtD,yMiLmEO,CtKpEmB,AiMzKR,qC3BiPvC,IAAA,GAAA,uEAO8C,E5PzBF,AqSrOkBD,EAAAA,CAAAA,OAAAA,IAAAA,GAAAA,8BzCkQf,ChD7DC,OAAA,IAAA,GAAA,0BgDiEC,IAAA,CAAA,OAAA,IAAA,GAAA,0BAID,IAAA,CAAA,OAAA,IAAA,GAAA,8BAIC,CAAA,OAAA,IAAA,GAAA,ogBxNvMR,4EAWlD,iEAMmB,CAAA,EAAA,EAAA,CAAA,EAAY,CSWhC,CiLtEoE,CAAA,A1L2DjC,ASWjC,EiLtEkE,CAAA,CAAA,GAAA,EAAA,EAAA,Y1L2DH,CAAA,CAAE,CAAA,2BAMpE,yLAgB8D,s7BsGrG3B,CAChC,CAAA,6NAMqE,4LAKI,yvByFgEvC,eAAA,CAAA,EAAA,OAAA,CAAA,EAAA,KAAA,EAAA,IAAA,MAAA,CAAA,EAAA,GAAA,SAAA,EAAA,EAAA,GAAA,UAAA,CAAA,cAAA,CAAA,EAAA,EAKP,KAAA,WAAA,0DAGP,CAAA,uBAAA,uFAQkB,EAAA,OAAA,CAAA,EAAA,OAAA,CAAA,GAAA,CAAA,EAAA,KAAA,EAAA,CAAA,gHpFGyB,OACvB,mFAErB,CAAA,weavBd,EAAA,OAAA,CAAA,+KAOkD,oUpNoM3C,CACd,E+MnNoC,6C/M0N/B,EAAA,CAAA,EAAA,GAAA,YAAA,EAAA,qBAYmD,oJAQ/C,EAAA,GAEA,CsC5N+E,AgPhClB,ChPgCmB,sBAAA,6CtCkOhF,KoMrOiF,epMsOjF,EsRhQgG,CzPkCb,AyPjCrF,CzPkCL,CAAA,mE7BkO+C,CAAA,CAAA,gIAe5B,6EAYjB,wCASmD,CwCzNV,KxCyNgB,E4HjDY,M5HiDJ,C2ThViB,A/R4IlB,EAAA,C5BoMK,6CAI7C,yPAmBc,uCAIQ,cAAc,gDAKvD,GAAW,EAAA,CAAA,EAAc,CqEvNS,A8BII,E9BJJ,MAAA,EAAA,GrEuNQ,EAAY,CAAC,MAAG,EkHhSkB,OlHgST,6DAYzC,+BAAA,EACa,AADb,IqMxMgB,AlGPG,MnG+MnB,OAAA,EAAA,oBAAA,CqMxMgB,OAAA,0CrM8MM,CM9NL,AgVvLgB,AtVqZV,sGAOhD,CAAA,yBAO+B,EAAI,kDAGpB,CoQ5OyC,sBAAA,cpQ+OvC,sCAKiB,gCAAA,EAAA,YAAA,CAAA,4GAGwE,CAKxE,CAAA,8EAWjB,CAAA,eACG,cAVsF,UAUtF,CAAA,EAAA,KAAA,2CAIF,0GAGoB,UAAA,IAAe,CAAC,KAI1D,CAAA,aqChIuB,ArC8Hd,CiP9SwD,A5MiLnE,C4MjLmE,IAAA,CAAA,EjP+SxD,aAAa,iLAmDd,WACT,MACO,KAAA,CAAA,EAAqB,KAAA,CAAM,EAAE,YACjB,GAAA,SAAA,EAAA,EAAkB,GAAA,UAAW,CAAE,CyPpMC,azPoMa,CAAA,C2GrPN,A3GqPQ,C2GrPP,A3GqPQ,CAAA,A2GrPP,+C3GkNjD,CAAA,yDAEiC,CAAA,OACrB,OAAA,CAAA,EAAA,aACN,CAAA,CAAA,4BAOU,AAA/B,KAA+B,IAA/B,EAAA,SAA+B,CAAA,EAAA,SAAA,CAAA,EACE,SAAA,YAEd,CAAG,MAAM,EAAQ,gBAAgB,CAChD,K8IzOwE,E9IyOhD,gFA6BR,cAAA,GAAA,CAAA,GAAA,CAAA,EAAA,gBAAA,CAAA,CAKpB,GAAA,CAAA,QAAA,EAAA,CAAA,CAAA,CAAA,QAEW,CAAA,CAAA,GACN,EACJ,CkH9SuD,A4GVJ,M9NwT1C,C8NxTmD,CAAC,e9NyT7C,mCACuB,OAAO,wBAKrC,SAEL,CAAA,CAEP,aAO4C,qBAAA,EAAA,gBAAyB,GACnE,EAAA,gBAAA,CAAA,IAAA,yCAS2B,EgHjUE,UhHiUW,CAAC,MAC3B,MAAA,EAAA,aAA2B,CAAC,C8NrTc,U9NqTH,CAAA,cAK9C,CAAA,KAOU,KAAA,MAAA,YAAA,EAAA,AACkB,KAAA,IADlB,EAAA,kBACkB,EAAA,AACO,E8YhmBU,AN+DtD,OxYgiBqC,EAAA,oBAAA,EAEhC,EAAA,SAAA,EAAA,KAAA,IAAA,EAAA,uBAAA,EAAA,EAEQ,SAAA,EAAA,KAC0C,CwYjiBvD,GxYgiBa,EAAA,6BACqC,CAC9C,mCAIE,EgY/gB2DE,ChRsMG,yBhH0U9D,0BAIgB,qB0Y7UhB,A1Y8UoB,CAAA,oFAMd,CqYlYJ,6BAAA,CAAA,CrYkYqC,CwYtiB7C,AOlD8C,kD/Y+lBE,YAAY,CACtD,CiZ9jBA,AzN6VG,CqNhUwC,CAAA,ULNjD,CAAA,KhNsUS,EAAA,kBAAA,EAAA,ExLkOiC,kBAAkB,gB0Y5TtD,M1Y8TE,EAAA,C0Y7TwD,mB1Y6T5B,C6YhiB8B,C7YgiB1B,EAAG,CAAA,mBAAqB,mB0Y5TE,+B1Y8T3B,EAAI,EAAI,CAAD,WwShQwC,WxSgQhB,iCAEtD,I0Y9TV,GACwD,sB1Y6TjB,EAAA,EACjC,6BAAA,yDAekB,C6Y3gBO,CAAA,C7Y4gBlC,EACD,CAAC,CiPjV4B,C3DKH,UtL8UF,CkH7TY,A1DqPf,C0DrPe,uClH+TP,UAAU,CAAC,OAAA,gDAc3B,KAAK,QACb,EAAQ,UAAA,UACA,gBAAgB,CAC3B,iBAAA,EAAA,SAAA,EAAA,OAA8C,EAAA,SAAA,CAI3C,oFqOrhBQ,CAAA,CAAA,mZAiC2D,wlC3QhLpC,CACnC,0GAGyC,2BAG5B,kBAAA,CAAA,OAAA,EAAA,mBAAyD,qQwPmCb,o/BrHoOhC,EAAQ,oLkHpNxB,IAAA,CACX,CAAG,yIAUyD,AAAC,wFAYF,uEAShD,MAAE,CAAI,CAAE,C/MkNN,A+MlNO,C/MkNP,A+MlNO,+KAqBqC,MAAE,E1JlDjD,ewCsNqB,EAAA,otDkL3OE,00CrOjDgC,u0FoNmEY,CtIrCQ,AyFe5E,C6CsBsE,oQ/P4DrE,CC9HoE,iBAAA,CD+H7D,CN5HuE,UM6HvF,CAAA,CAAA,cAAA,CACa,CAAA,CAAA,gO+PKG,mCAGD,oCAmBiB,oGAWqB,uLzQzKxD,0CAI2E,CgDgC1B,gQ2BhCoC,CAAC,CCDG,uHDID,CAAC,E1DgCnF,mH0D7BuE,EAAA,WAAA,GAAmB,CAAC,AyCHF,6SGoBlE,CAAA,CAAA,CAAA,sMAgBZ,CAAA,maF/BsE,CC2BvF,CD3ByF,8jFsNuEhC,EAAA,KAAS,CAAA,EAAA,EAAA,KAAA,CAAA,8PzFXxD,iCANN,6SIFwD,EkBKF,ChHqEC,AoCqBoD,Ae7E1D,AnEXJ,CAAC,A7ByjCQ,A2IhkCE,CAAA,IAAA,CAAA,iBkBoBnC,CAAA,CAAA,+EAQsC,mCAAR,QAAQ,GAAA,4DAO7C,EAAA,EAAA,MAAA,CAAA,EAAA,kX4E4B2C,gBA4ExB,CnRgGR,A6HzER,EAAA,CAAA,CAAA,KsJtBd,CAAA,KAAA,CAAA,CAAA,CAAA,yBAKsB,iBAGH,CAAC,+BAGpB,EAAA,EAAA,MAAA,CAAA,mBACuB,iBACL,EAAA,EAAA,EAAA,IAAA,OACH,GAA0B,C9B4DC,CAAA,UAAA,C8B5DoB,C3L0BiB,A2L1BhB,EAAE,QACvB,EAAU,UAAU,CAAC,wEAGpC,CAAS,CAAC,EAAI,CAAC,CAAC,CAAA,EAAA,CAAY,CAAC,CAAC,CAAG,CAAC,CAAC,CAAA,MAAA,EAAS,EAAS,GAAA,CAAK,CACtF,CAAA,CADiF,CAG9E,EAAA,CAAS,GAAA,EAAA,kCAoFX,CAAA,KAAA,CAAA,CAAA,CAAA,gVA2IO,MAAA,aA6Bb,CAAA,CACA,CAA0B,AnJ7GN,AzLoJQ,C4UvCF,CACF,C+D/Ua,EAAA,CAAA,CAAA,K/DkV/B,CAAA,OAAA,CAAQ,CAAA,CAAA,yBACoB,+DAAP,SACrB,ClJ6BC,CAAA,EkJ7Bc,KAAK,CAAC,EAAA,0IACkB,EAAO,GAC7C,WA8BO,GAAA,CAAA,CAAuB,CnJ3HZ,CAAA,CAAA,CAAA,amJ4HX,C5L0jDE,CoG5rDE,AkE0KmB,AtKkhDrB,Q4LzjDL,KAAA,IAAA,GAAA,GAAA,EAAiD,C4Epb9B,E5EsbvB,MADmB,EAAA,GACD,C4EpbS,C/N0Tb,kBmJqYoB,CiGnlBP,A1TiYF,sByNsNzB,CAAA,CAAA,QAAA,EACyB,AADzB,CsGzuBuC,StGyuBvC,OACe,EzNrNA,A+TrhBwB,CLoJb,EjGslByB,GAAS,CtBsCK,CsBtCA,GlJTY,UAAA,EkJSI,OAAO,EAAK,GAAA,0BAAA,CAA+B,CAC/H,eACiB,8HANI,uCAuBd,WAAA,0BAGG,CAAS,SAAE,CAAA,CAAiD,CAAA,CACxE,KAAK,CAAA,CACH,qBAAA,EAAwB,CnJ5MD,CAAA,wBAAA,EmJ4MmC,CnJ5MD,AtETA,CAAA,SAAA,CyNqNqB,CAC/E,CAAA,mFALsB,mCAoBd,WAAoC,CpFrKX,A9DuJoB,CvEnMjB,CyNoNvC,YAAA,QACE,CAAA,UACA,CxFjNuB,AIwCX,CAAA,KAAA,CAAA,CAAA,CAAA,MoF4KP,CAAA,CAAA,MAAA,EAAA,UAAA,EAAA,WAEmC,SAAA,aAAA,EAAA,EAChB,6BAAA,EAAgC,EAAI,EAAA,EAAA,CAAM,CACjE,CAAA,mFAXsB,wDA0BsB,EzNtNR,AuUzjBsE,a9GkxBjG,CAAA,KAAA,CACN,CAAA,WAAA,CACM,CAAA,KAAA,CACN,CAKL,CAAA,CACC,KAAK,CAAA,CAAA,EACA,EAAA,MAAW,CAAC,CAAC,CAAC,CAAC,EzNjOA,SyNiOW,EAAE,AzNjOF,CAAA,EyNiOK,EAAI,CzNjOH,CyNiOG,GAAA,CAC7B,GACN,WAAW,GAAA,SAAA,EAAA,EAAkB,4BAAA,EAA+B,EAAU,CzNjOb,GyNiOa,CAAM,CAChF,CAAA,AAfe,CxF5MX,GuMjmBS,GAAA,cAAA,CAAA,IAAA,CAAA,OAAA,qmBrIkIa,CAAA,CAAA,qBAGhB,EAAA,EAAA,EAAA,MAAA,CAAA,IAAA,GAAA,EAAA,CAAA,CAAA,CAAA,EAAmD,CAAC,0EAO1D,eAkCe,CAAA,EACQ,CAAA,CAAA,yBAER,CAAA,yBAMW,CAAA,CAAiB,CAAjB,OAAA,GAAiB,CAAA,CAAA,EAAA,CAAA,CAAY,CAAA,OACpB,YAAA,CAAA,CAAA,uDAEC,+EAME,IAAM,oDAG5B,EAAA,CAAA,gDAQF,EAAI,EAAC,CAAE,EAAI,OAAA,AAAc,EAAd,EAAc,CAAE,CAAI,OAAO,GAAU,CAAA,CAAM,CACzE,AAAD,QAAS,CAAC,EAAE,CAAC,CAAA,UAEuB,+CA8C9B,GAAA,GAAA,MAAA,CAAA,GAAiC,iBA8BP,CAAA,WAC1B,GAAA,UAAA,EAAA,GAAA,GAAA,GAA8C,mBAwB5B,qJAmDK,AsBqBe,CkE5V3CD,ANuFuC,AxYiPV,AqHnHS,gBiM2IxC,CAAA,CAAA,CAC0B,CAC1B,CAAA,CACA,C7HnIkC,C6HmIT,CAAA,CAAA,KAEnB,CAAE,QAAM,CAAA,CAAA,wGAEM,EAAA,OAAA,CAAA,KAAA,IAAA,KAAA,CAAA,CAAA,GAAA,CAAA,EAEI,ClEzIK,AkEyIJ,CAAA,CAAG,CkFjMkF,AOyH7D,EAAA,EAAA,MAAA,AzFwEF,CAAC,CAAG,GAAA,CAAa,CAAA,OAC5D,GAAA,2HAAiC,EAAQ,EAAA,GACtC,cA6BY,CAAA,mBACF,CAAA,EAAA,MAAA,CAAA,CAAA,CAAiB,CAAA,4BAsBb,EAAA,CAAS,E7S5CF,CAAC,A6S4CI,C7S5CH,AkYzUO,+BrF6Y9B,GAAc,CXlEK,ClSuBL,A6S2CO,CAAE,IAAK,IkGjeF,CnSyVS,ciMmK5B,GAAA,CAAA,CAAA,EAA+C,CAAA,CAAA,eAC7C,ClExKG,AqK9LV,AnGsWU,I9DpIA,AJpCM,SkE0Ka,EAAK,C9DpIjB,A/D7BE,C2DPK,AkEwKkB,IAAI,CAAC,AiGjZX,A9YqWL,K6S8ClC,EAAA,OAAA,0BAKgB,CAAA,EAAA,CAAA,CAAA,CAAA,kBAFK,CAAC,CAAC,AAAG,CAAC,CuFpHK,AvFoHL,AxM9FH,AwMgGR,GAA6B,CAAA,gBACd,CAExB,EACN,EAAA,EAAA,CAAA,CAAyB,kCAiCW,CtTnBb,AStBJ,CAAA,IAAA,iB6S2Cb,SAAA,MAAA,CAAA,sBACc,eACM,C7SvCP,CAAC,A6SwC7B,CADsC,A7SvCR,A6SwC7B,YA8BuB,CgGhdY,AhGgdJ,CtKmrDN,EsKnrDmC,CAAA,CAAA,EAC3D,OAAO,GAAA,EAAA,mBA8BsD,CAAA,CAAE,G7StD9B,U6SuDzB,CAAA,CAAA,KAAA,CAAY,CAAA,CAAK,YACT,ClE3MG,CkE4MZ,OAAO,GAAA,EAAc,IlE5MT,OAAA,iBkEyOc,EAAA,CAAA,CAAA,KAC3B,CAAE,MAAA,CAAA,CAAS,E2GrmBMW,qB3GwmBb,CACkB,EAAO,GAAF,AAC/B,EsBmBK,6LtBnBL,EsBmB0B,KAAO,CnU9BH,U6SazB,C7H1MD,G6H0MK,ClElNG,aAAA,MkEkNiB,CAAC,YAkClB,GAAA,CAAA,CAEd,EAA4B,CAAA,CAAA,KAEtB,C+GvsBU,OAAA,EAAA,CAAA,C/GusBM,CAAA,CAAK,gBAElB,EAAO,gDA2B0B,CiH9qBE,ApTicX,CqT5Pe,kBlH6e9C,CAAG,CAAA,IAAA,CACA,QACH,CAAA,CAAA,KAAA,CACI,OACJ,CnMpP+B,CmM2PhC,CnM3PgC,AAAM,8CmM8Pf,EAAP,C7S7DoC,C6S6D5B,IAAA,CAAM,CAAG,EAC9B,CAAA,EAAG,EAAS,IAAH,CAAC,CAAC,IAAC,YAAuB,eAAA,EAAkB,EAAM,CAAA,GAAA,EAAM,EAAG,CAAA,OAAA,EAAW,EAAG,CAAA,EAAA,CAAK,CAAC,AAAE,CAAD,AAAC,SAAA,EAAY,EAAG,CAAA,EAAA,CAAK,CAAA,CAAE,CACjH,CAAA,mFAnBsB,C9D7Lf,gD8DgOgC,wCAIlB,EAAA,2BAAA,CAAgC,CAAA,cACtC,4DAEb,4HAgBM,CuHxnBD,UvHwnB6B,InMvPN,oBmM4P7B,CAAA,QAAA,EAAW,UAAA,OAAA,EAA4B,GAAe,CAAX,CAAC,CnM1PD,AAAgB,EmM0PA,AAAS,CAAR,CAAC,AnM1PF,WmM0PS,EAAgB,OAAO,EAAK,GAAA,uBAAA,CAA4B,CAC5H,mEACqE,GsBtCD,oKtB4DrD,EAAK,2BAAA,CAAA,CAA+B,+GAHrC,OAAA,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,oCAsBd,E8HhxBIW,S9HgxBuB,gBAGhB,CAAA,MACf,CACH,CAAA,aAAA,EAAA,EAAA,sBAAA,EAA8C,EnMvPA,AmMuPM,EnMvPA,ImMuPM,CAAG,CAAC,CAAA,UAAA,CAAY,CAC1E,CACE,aAAc,CAAC,6BAA6B,sFANzB,GlEtOL,C9IuIP,8BgNsHF,WAA0B,eAGzB,CAAA,UAAA,CAAW,SAAE,CAAO,CAA0C,CAAA,EnMtPpD,6BmMwPM,ClEjPS,CjINN,EqI6CD,CrI7CC,qBAAA,EmMuP+B,EnMvPG,GAAA,MAAA,CmMuPiB,CAC/E,CAAA,8GAeC,MAAO,WAAoC,EnMnPR,amMsP3B,QACV,CAAA,CAAA,SAAA,CAAA,CAAA,KAAA,CAEI,CAAA,CAAA,+DAKc,EAAM,IAAA,yBAAA,EAAgC,EAAI,EAAA,EAAA,CAAM,CACjE,CAAA,mFAXsB,C7HpOf,qD6H8PqC,EoIvvBG,apI0vBtC,MACV,CAAA,YACA,CAAU,MACV,CAAI,CAKL,CAAA,UAEM,EAAK,MAAA,CAAO,GAAG,GhN9GO,QgN8GI,EAAE,CAAA,EAAG,EAC/B,EADmC,AhN9GI,GgN+GlC,CAAA,GACL,WAAA,GAAa,SAAA,EAAA,EAAgB,4BAAA,EAA+B,EAAU,IAAA,CAAM,CAChF,CAAA,CAD0E,kFAdpD,gaRp0BK,oE8BsnBP,CAAc,sKAGnC,C8F7sBW,AtL6fN,MwFgNE,OACD,CAAC,OACA,c9BrkB2B,GAAA,qDAGE,iBAAA,EAAA,qCAGrC,gEAoGuC,+IAUrB,GAAA,EAAA,GAAyB,2CASC,CAAC,A3LjGF,C2LiGE,oCACH,sBACC,C7E7FK,CxLqFT,AqQQM,oDASL,yCAmCH,GACxC,CAAC,A9J6gCS,0F8J99BiC,MAAQ,CAAC,CAAE,CAAC,AsFhSoC,CAAA,AtFgSnC,AAAE,CAAD,GAAK,CAC1D,GAAG,AAAY,CAAX,AAAY,CAAF,AAAI,CAAE,IAAI,CAAE,EAAE,CAAE,CAAC,CAExB,iBAAA,EAAA,GAAA,EAAmC,MAAQ,CsFhSS,CtFgSP,AsFhSO,0BtFoUjC,CAAA,sFAoCd,CAAA,CAAA,CAAA,uDAC+D,GzL1IK,WyL2IhE,C9S1BH,sE8S6BT,CQrBe,AlExIN,A/HqCJ,C0R4BA,A1R5BC,4MyLsIQ,CAAA,MAAA,CAAA,CAAA,CAAA,kCACoB,CAAA,8FAHf,wCAUd,WAAA,iNASA,WAAuC,sBAI3C,CAAA,qIAHkB,oDAQd,WAAA,0BAGG,CAAS,AzL5HN,CyL4H8C,CAAA,MACxD,CAAC,CAAA,QAAA,EAAA,EAAA,iCAAA,CAAuD,CAAE,G0GrdU,qH1GwdrE,CAAA,SAAA,EAAY,EyGnaPD,CzGmaU,A1DrJQ,A0DqJF,CAAL,AyGnaQ,EzGmaA,AAAM,CAAL,CAAI,E+FrHsB,K/FqHZ,CAAC,CAAC,A+FrHU,C/FqHD,igBpHlctB,CAAA,EAAA,CAAA,CAAA,8IAWW,CAAA,+RAmEP,GAAA,0ZAyJ/B,eAuC0C,YAC/B,GAAA,gBAwBO,CAAkB,YAChC,CAAA,CAAA,CAAA,GAAA,SAAA,CAAA,SAAA,CAA0B,OAAA,CAAQ,GrElGD,AqEkGI,GAAiB,KAAK,CAAC,CAAC,GACxE,CvEjHC,AmR5NK,K5M6UC,GAAE,+BAuBJ,EAAA,CAAA,kBAEiB,EAAA,CAAW,CAAC,qBA+B5B,EAAA,CAAA,KACJ,IAAM,EAAI,EAAU,CAAC,CAAA,OAAU,EAAU,CAAA,EAAA,KAAA,EACzC,EAAc,EAAU,OAAA,CAAA,OAAA,EAAA,OAAkC,EAAA,KAAA,yBACV,C1LGqB,gB0LHjC,CyMtUK,AN+MG,E7X0HyB,CAAA,EAAA,GAAA,EAAA,2B0LA7D,IAAI,GAAoB,CAAE,CyM5TpC,A1MkMuC,KAAA,EAAA,OC0HqB,aAE3D,sBAGsB,C1LGH,A0LHI,GACnB,OAAO,EAAA,CAAA,+DA8BM,CAAA,CAAA,CAAA,OAAA,KACb,OAAA,EAAA,CAAA,CAAA,CAAkB,OAAA,8CA2BD,CAA6B,C5EjEzB,A6RpSjB,AxR0Na,iCuEyKtB,GAAO,aAGD,EAAA,EAAA,CAAA,QAEA,AASC,GATD,GACW,CAAC,CvEtJqB,AyNsHgB,ClJgCjC,KAAM,EAAE,CAAE,CvEtJqB,AuEsJpB,CAAA,GAChB,CAAC,CAAE,CAAE,IAAI,CAAE,EAAE,CAAE,CAAC,CAEF,E1LSA,wB0LTL,C1LSK,GAAA,G0LRC,EAAA,OAAA,EAAoB,CAAE,E0DtJI,CAAA,C1DsJA,CAAE,CAAC,MmNtHvD,YnNuJQ,GAAW,CAAA,aACT,C0DhKG,EAAA,SAAA,C1DgKO,E/HiJE,E8H1SA,KCyJO,CAAA,EAAW,CAAC,CAAE,EAAU,CAAC,A0DhKN,C1DgKO,A0DhKP,C1DgKO,IAAH,ImNxGgB,qBnNmItB,wBAC3B,CAAC,CoOtjBe,A1KiZZ,Q1DqKM,CAAC,EAAU,CAAC,CAAE,A/HuKX,C8HrUC,CC8JoB,CAAA,QACpD,CAAA,EAAA,EAAA,EAAA,QAAA,GAAA,CAAA,cAqBoC,QACpC,GACF,EAAU,CAAA,GACV,EAAU,CAAA,GACV,GAAA,EAAqB,OAAA,eAyBN,CAAA,KACd,CAAA,EAAA,CAAA,GAAK,CAAA,CAAA,QAAA,CAAA,CAAA,CAAA,WAEN,GAAA,EAAA,MAA0B,EAAE,KAC5B,GAAA,EAAkB,CAAE,C4N5bsC,IAAA,a5N6bxC,CAAC,CmOzeM,AnOyeL,IAAE,MAAQ,mBA0Bb,CAAoB,aAC9B,C0DpLG,A+K7WmC,QAAA,CAAA,CzOiiB3B,CAAG,C0OzkBxB,uB1O6kBM,AyOjiBO,CCvCH,ADuCG,KzOiiBF,KAAA,GAAoB,GAAe,CAAE,CAAC,CAAC,gBACnB,GAAA,uBA8BH,E6OtoBmF,ApTsc3E,cuEmM7B,EAAW,mCA8Bc,EAClC,CjLXiB,AmUkBhB,EAAA,AlJPS,IkJOT,GlJPS,KAAA,EAAA,OAAsB,KAC5B,AAAM,OAAW,CgPjrBqC,AtLyelC,C1DwMD,GAAR,CAAC,AkJOF,CAAA,AlJPS,EgPjrBmC,KhPirB1B,KAC5B,GAAK,GAAA,QAAW,CAAC,CChCV,A+O/oBE,A/O+oBF,IDgCmB,CAAC,A0DtMP,C1DsMQ,CAAC,A0DtMP,C1DsMQ,IAAI,AAChC,CADiC,A1Ci+DT,AoGvqEE,C1DsMO,EACjC,GAAkB,CD9LX,A3E8FoB,AyTlhBL,AnL4aD,sB1D2NF,CmP7nBO,AnP6nBQ,CmP7nBR,CnP8nBhC,A0DzM4B,A3OgMN,GiLStB,AAAgB,CDnMP,ACmMQ,GAAjB,EAAiB,OAAA,4BAEX,IAAI,GAAA,QAAoC,oBAQA,EiP5qBG,EAAA,EjP4qBG,CAAC,QAGzC,C0D7MG,A1D0M+C,M0D3MM,CAAA,G1D8MtD,CAAS,CAAA,CAAA,MAChB,CAAA,CAAA,AChCoE,QDgCpE,EAAA,EAAqB,C8DvKV,+BAAA,CAAA,C9DuK8C,cAC9C,mCAEZ,CAAA,SAAA,EAAY,GAAS,GAAS,CiPrpBa,CvLwcH,CAAA,CAAA,OAAA,C1D6MU,IANtC,GiP/oB+B,CAAA,GjP+oB/B,cAAA,CAAA,IAAA,CAAA,OAAA,iDAAO,gDAad,C0DxMC,UAAA,0B1D2ME,CAAA,CAAA,CAAA,sBAEK,GAAA,GAAA,8DAAA,CAAyF,CACzG,CAAA,mFALsB,sEAab,CAAA,MAAA,CAAA,CAAA,CAAA,kBAEG,CDrMD,ChL+LK,A2OpMM,uEAAA,C1D0MoE,CAC1F,CAAA,mFALsB,oEAaX,CAAK,CAAsB,CAAA,OAErC,CAAA,QAAA,EAAA,EAAA,uEAAA,CAAyF,CAC1F,CAAA,mFALsB,CqP1oBrB,kCrPopBO,WAA4B,G8D7JP,a9DgKlB,OAAA,CAA2B,C8D/J3B,M9DgKP,CAAA,CAAA,QAAA,EAAA,EAAA,yDAAA,CACwE,CAC5E,CAAA,uIAK8B,0BAI/B,C0DtMK,I1DsMA,CAAC,CAAA,QAAA,EAAW,EAAK,mDAAA,CAAqD,CAAC,CAAA,8nCrK9zBzE,CAAA,CAAE,EAAG,CAAC,GAAK,KAAM,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CACtC,0GAMK,GAAG,CAAA,CAAA,EAAK,CAAC,AfkBb,CmCZkB,CAAC,ApBNJ,CAAG,CAAD,AAAE,CAAC,CAAC,SfkBJ,CelBc,CAAA,GAAK,CAAC,CAAC,CAAC,CACtC,cfkBqB,CoC3B0G,CpC4BhI,AoC5BgI,gBpC4BhH,EAChB,gBAAgB,EAChB,mBAAmB,EACnB,mBAAmB,EACnB,ae4MmB,EAAA,Gf5MD,GACnB,Ae2MoB,Mf3Md,iBAAiB,CAAA,4Be+MS,CAAA,EAAA,CAAM,EAAA,EAAA,CAAM,CAAA,CAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,EAAA,EAAA,EAAA,CAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAEJ,CAAA,EAAA,CAAA,EAAA,EAAA,CAAA,CAAA,CAAA,EAAA,EAAA,CAAA,mBAGnB,GAAA,EAAA,4BAKT,WAAA,EAAA,MAAA,CAAA,iBADwC,EAAA,EAAA,CAAA,gMoFlPsB,4BAAA,CAAA,IAAA,2IAYU,MAAM,uRAsBZ,wHA4BzB,UAAA,uGAeQ,qCAA5B,E+F2D4B,W/F3Df,MAAA,CAAO,CAAC,CAAC,CAAC,wCAoBzB,CAAA,6BAfZ,WAAA,GAAA,EAAA,SAAA,IAAA,EAAA,MAAA,IAAA,GAAA,oEAoHmB,CqMgEX,A8B1DY,6BnOLH,MAAA,2DACK,MAAA,CAAO,CqQlJY,kCrQkJuB,CAqHpE,GAAA,CACS,WAOmB,C2IhGhB,G3IgG2B,MAAM,CAAC,GAAQ,EHMnB,C6RzTO,A1RmTe,AHMrB,CGNsB,AHMrB,A6RzTK,A1RmTkB,CAAD,KAAC,KAC9D,aACN,SAAA,CAAY,CYlFH,A+QvND,AjY8fE,CAAA,SsGrNe,GACzB,QAAQ,CAAG,EAAA,QAAY,SACjB,CAAG,IAAA,8K8I1RJ,CAAA,6jBA6CF,OAAA,CAAA,EAAA,6PAQ0B,OAAA,AAAW,EAAX,IAAW,CAAA,MAAA,EAAA,qIAOzB,GAAA,ydAiC2C,IAAA,CAAA,6CAChB,WAAY,WAAY,sBACzE,iHAQM,GAAA,YAAA,IAA+D,CAAA,wDACR,WAAY,mGACY,C+E9DD,U/E+DpF,8EAI6D,sBAAwB,kEACxB,WAAY,+ItBhF7D,YAAM,CuFwBoE,IAAA,GAAA,CvFxB3D,ExLiEmD,AoRrH7E,CAAA,EAAA,G5FoDkC,CAAC,EAAA,+BAuFhC,oBAA4B,WAAgB,KAChD,oBACmD,CAAA,MAAA,IAAe,G9GLP,C8GKW,CAAA,GAAA,GAAO,CAAA,CAAA,EAAA,IAAW,CAAC,mBAC/B,CqF+DJ,ArF/DK,A9GLV,C8GKa,CAAC,CAAC,CAAG,E3N4EN,A2N5EQ,iBAE9D,CAAA,eAGD,IAAA,EAAA,EAAA,EAAA,EAAA,IAAA,IAAA,IAAA,KAAA,EAAA,EAAA,IAAA,CAAA,CAAA,CAAA,EAAA,CAAA,GAAA,CAA2D,AAAD,GAAC,EAAA,CAAA,EAAA,YAEjE,YAC2C,C2GiCD,A3GjCE,YAIX,cACf,EAAG,YAAiB,GAAI,OAAU,6BAClB,SAAY,IAAM,CAAC,QAC/C,C6E4FO,Q7E5FK,iBAAwB,SAAa,CAAC,CAAC,KqBgCG,WrB/BvC,sBAA+B,CAAC,CAAE,EAAE,kBACjC,gBAAsB,EAAG,EAAG,CAAC,QACjD,CAAA,GAAA,WAAA,IAAA,CAAA,IACC,GAA6B,GAAK,CxN6EP,ATsBA,AmHvGE,A1D6IA,ApC3DG,A2Hg7BG,ArFj1BjC,CFpC4B,AgIxIJ,CwCDW,CAAA,CAAA,EAAA,IAAA,EAAA,GAAoB,CAAA,AAAE,CAAC,EAAA,EAAc,CAAC,CAAC,CAAC,CAAC,CAAC,CAAA,GAC/E,GAAA,GAAA,GAAA,CAAA,CAAuC,EAAA,IAAW,CxKyIL,CAAC,GAAA,CwKzIY,AAAC,CAAC,E9GJJ,A8GIM,AAAG,EAAA,CAAU,CAAC,AxN6EV,CwN7EW,CAAC,CAAC,A9GJN,C8GIO,C9GJL,A8GIM,CAAC,gBAC9C,IAAA,CAAA,oCACQ,WACjD,EACK,GAAwB,KAAhB,CxH4BD,MwH5B6B,IAAA,CAAA,kCACJ,WAAY,8PlJjM+B,CCLJ,ADKM,6cmBqCM,GAAA,SAAA,2CAkEzE,CAAA,CAAA,EACK,EAAA,CAAA,qWOtD+C,CnGoCD,SmGpCW,CAAA,+LPLP,CAAA,CAAA,EAAA,GAAA,CAAA,CAAA,CAAA,EAAA,GAAA,oEAMtD,GAAA,EAAA,EAAA,GAAA,CAAA,CAAA,EAAA,6FAUA,EAAA,EAAA,GAAA,IAAA,iLAakD,CAAA,CAAA,EAAA,CAAA,EAAA,GAAA,eAI7D,CAAC,CAAA,EAAA,EAAA,CAAA,EAAA,AACL,0EAkDa,oHASgC,CAAA,EAAA,4KASP,CAAA,CAAA,IAAA,yHAWlB,IAAA,CAAA,KAAU,0CAEQ,C/F2RH,AgWvbnC,AnWqOyC,CAAA,GAAA,6CkGvEhB,CAAA,EAAA,IAAA,CAAA,MAAA,CAAA,EAAA,GACrB,EAAA,GAAA,CAAA,EAAA,QAAA,CAA2B,IAAA,CAAA,MAAW,CAAE,IAAA,CAAA,MAAA,CAAA,GAAA,0EAQL,oDAC1B,CAAA,SAAA,CAAA,wCAIa,WAAA,0BAGX,IAAA,qIAOU,IAAA,WAAA,IAAA,CAAA,SAA6B,CAAC,AwL4DiB,CxL5DhB,A0OwBA,gB1OrBjD,SAAA,CAAA,CAAA,sFAIwC,CAAA,CAAA,CAAc,IAAI,CAAC,AkJXI,AjIDN,A1D6IA,C2L5IM,8BlJYH,8CAG9D,MAAA,CAAA,IAAA,CAAA,MAAA,iBACgB,QAAA,iFA0BhB,IAAA,cAdkB,E6Q7F6B,C7Q2GU,IAAJ,CkJfN,CAAA,AjPiTH,A+FlSoB,EAAP,IAAa,CAA3B,CAA6B,AAdrC,CAcsC,EAAE,CAAC,EAdnC,EAAE,GkR5GkD,CAAA,KlR4GzC,CAAC,CAAC,CAAC,2EmBjNwB,+KAEA,6EACZ,UAAY,wFACA,wFACA,CHAwB,CAAA,A4BgBlG,sFzBf0E,C6BMpD,EhBGmC,CAChE,AxCWmF,CwCXnF,KbV2F,mEACtB,WAAY,6PAqBlD,CAAA,IAAA,iMAkB+C,+HAMrB,C+HFM,E/HEH,CAAA,uCAG5B,IAAA,kEAEmB,GAAA,6BACmB,CrDwCG,AqDxCF,CAAC,ArDwCC,CRpB3B,AfoCqB,yE4ElDzD,EAAA,+XA+CqD,oFACA,C+HLE,AE0BT,A2C6EzB,ma5K7FgC,0sBAS5C,0CAA4C,oFACA,mJAEtB,C4IwDC,A1DCR,mElFvDO,EAAA,CACxC,GAA4B,EAAA,CAAA,EAAA,IAGC,CsOnJG,GAAA,MtOmJnB,MsOnJmB,AtOgJJ,2BA0OrB,CmIYH,EnIZmC,GAAA,GAAhB,CAAgB,IAAuB,0D2K1OjB,OAAA,CAAA,CAAA,+mBzGvHvC,GAAA,MAAA,2EAY+C,CAAA,EAAA,GAAA,YAAA,EAAA,GAAA,eAAA,CAAA,AAChB,GAAsB,GAAY,CAAO,CAAC,CAAC,CAAC,CAAC,CAAE,EAAd,6wBAkChE,GAAA,MAAA,KAKV,GAAA,mBAAA,EAAA,GAAA,8fkC6GI,IAAA,WAAA,GACA,I3K5HK,CACR,CAAC,G8JlBgE,CAC/D,CTwB4C,ASxB3C,0FaqJoB,SAAS,CAAA,MAAA,oKAewC,CAAC,A1IjJ/B,C0IiJ+B,ACxGxE,mNnCOC,8fAasC,EAC/B,GAAA,MAAA,EAIyB,CAAA,EAAA,GAAA,mBAAA,EACf,GAAO,SANkE,ImHPZ,4G/OhGlF,sFA8BY,CmKFwD,AfX5D,AS4D6D,AKpEN,CLoEM,O7J/ChD,CAAA,WAAY,CAAA,CAE9B,GAAG,EACJ,CAAG,CADK,AfGiE,CAAA,KeF/D,CAAA,wCFmE4H,CACpI,CAAC,mHEIsC,4DAEsB,CAAA,CAAK,CyJlCH,yCzJqChB,2EAgDhD,CAAA,CAAA,OAAA,EACS,EsPlE2D,CAAC,IAAA,QtPkE7C,CAAC,E+JgCzB,I/JhC+B,C2CGsD,C3CFnF,oEtChD6D,CAAA,CAAA,yKAzEO,CAAC,iEAInC,GAAA,EAAA,oDAImB,8IAkExC,GAAA,GAAA,csCmDmC,IAAA,CAAA,mGA2CzB,gKAUjB,OAAA,QAAA,CAAA,KAAA,CACP,CAAA,KAAA,CAAA,CAAA,WAAA,CAAA,CAAA,CAAA,6GAY2B,GAAA,IAAA,GAAA,CAAA,6BAGnB,wBAIL,4JAOuD,CAAE,C0DxFK,C1DwFH,CAAE,C0DxFK,AqPxJU,M/SgPR,sCAElC,mHAsGnB,ExD+H0D,AwLlOE,QhImGlD,CAC9B,CAAG,OAAO,CAAA,AACJ,WACM,gCAKoB,4JAqF3B,CkU5OkC,UAAA,ClU6O7B,kBACT,EAAmB,CkU7OP,KAAY,IlU6OK,CAC9B,CAAA,yCAOwC,yCrDjM8W,CAAA,gBqDuM5X,GAAA,GAA2B,ayU9TkB,4KzU2UlE,GAAA,EAAwC,4BA4ExC,CAAA,MAAA,EACI,OAAA,SAAA,CAAiB,WAAW,CAAC,EwDhQA,CxDgQG,CAAA,IAAK,CAAC,OAAO,CwDhQD,QxDgQU,CAAA,WAAA,CAAa,CAC3E,GAAG,EACJ,CAAG,CADK,GkV9OoD,AlVgPtC,GADZ,AACY,CADZ,oCAIP,GAEF,GAAA,CAAA,EAAA,MAAA,IAA2B,6BAGG,YAAY,CACxC,GAAA,IAAA,WAAkB,EAAS,IkVhPc,ElVgPf,QAAe,CAAC,CAC3C,CAAA,GwUza2D,CxU0atB,CwU1a4D,CAAA,ExM8QP,GhI4J9C,CAAC,mBACb,OAAO,CAAC,C8HhQC,6B9HmQzB,CkVlPmD,ClVkP1C,CsVniBmD,QtVmiB1C,CAAC,CACnC,CAAA,wBkVnPsE,iJlVuPhD,CsVriBW,EAAA,ItVsiBxB,WAAW,EAAS,MAAD,WAAkB,CAAC,CAC3C,gBkVrPmD,wDlV0PH,UAAU,iDAGxD,SAEA,EAAA,eAEL,MAAA,iBA4DiB,CAAuB,EAC5C,GAAA,CAAQ,C+HjJC,CAAC,SAAA,CAAA,KAAA,EAAA,CAAA,C/HiJoB,C+HjJC,SAAA,C/HiJS,CAAA,UAAA,CAAA,WAAa,CAAS,C+HjJC,C/HiJI,EAC7D,CAAA,GwDzS6D,CxDwSO,CAAA,aACpE,CAAA,gBAEJ,CAAc,C6LrQwB,AJpCI,AyJoCE,eAAA,ClVsQ9B,WACd,CAAS,C4V5hBsC,A5V6hB/C,WkVzQI,elVyQoB,CACzB,CAAG,EAEE,EAAA,GAAuC,CAFjC,CAAA,O2V/jB+D,S3VokBnC,OAAO,QAElC,CAAsB,CAAC,GAAI,CgPnME,AhPmMF,A6L3QJ,IqJJ9B,YlVuR0B,CAAA,AAAQ,CgI/KD,A2HyCE,C3PsIT,CgI/KO,GAAA,IhImLlC,EAAA,CAAA,CAAW,EAAM,GAJyC,AAIzC,CAAA,AAAgB,GAAhB,CAAgB,GAAU,gBAG1C,EAAA,2BACF,IAAA,EAAwB,KAAK,CAAC,CwDjTH,MAAA,GxDiTsB,EwDjTF,AxDiTO,GwDjTD,GxDiTO,CAAA,GAAA,MAAA,CAAA,UAK7D,KAAA,CAAA,OAAA,IAAA,KACK,CAAA,oCACW,MAGb,CAAC,EAAA,EAAA,CAAA,eAC0B,MAA2B,kBACnD,8BuF/eyB,WAAA,CAAA,CAAA,kDAGwB,GACxD,GAAgB,EAAP,CAAkB,AAAjB,KAAK,CAAU,CAAC,EAAU,CAAC,CAAC,CAAC,EACvC,EAAI,EAAO,CAAC,CAAJ,AAAM,CAAL,CAAC,KAAW,EAAE,EAAM,EAAF,EAAM,CAAE,EAAI,CAAE,CAAC,AAAH,CAAI,AAAE,CAAD,CAAG,CAAC,CACjD,CAAA,AvFgfkB,gBAFH,ElDvKA,CkZtfT,AvK2Wc,ApPiKF,A2DiJU,EAHF,GAAY,CwDnTP,AyS3Sa,CnOmTN,C9H2SiB,CgWvqBjD,CAAA,CxSoX4C,CxDoTjD,GAAA,SAEmD,EwDnTV,A0R+DgB,gClVqRhD,WAAA,kCAIJ,CAAA,+BAAA,oJAOI,WAAA,sBAGG,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,MACP,CAAA,gCAAA,OACH,uFAJqB,oKoJztBiC,CAAA,0HAUxD,EAAQ,CcT+D,QdStD,4GAyDyB,8CARS,CACnD,mDAQoD,EAAA,qJA0Cb,CAAA,MAAO,CAAA,SAAA,CAAA,MAAA,GAE5B,CjGD+D,CAAC,AuK/CG,CvK+CF,EuK/CE,MtEgDlD,CAAC,CACpC,CAAE,IAAI,CAAE,OAAO,CAAE,UAAU,CAAE,OAAO,CAAE,EACtC,EACA,CAAC,CADG,OACK,CAAC,CACX,CAAA,4GAQyE,M6HkH1E,ChF2DyB,I7C7KiD,GAAA,muBnH5GhB,grBA+DU,EAAA,qqB8J1DtD,iBAAA,qSAcO,CAAA,MAAA,IAAA,CAAA,OAAA,CAAA,GAAA,kNAYuB,YAAA,aAAA,gDACuB,CAAA,IAAA,CAAA,cAAoB,CAAC,CAAC,u4BlLgBlE,CACrB,0BAA0B,GAAG,EAAE,aAC/B,GAAc,CAAK,CACnB,IAAE,EADS,OAEX,EAAU,KAAH,EAAU,CAClB,CAAG,UAAU,CAAA,qMAgBoD,EAAA,sVAkClD,qCAAA,EAAA,oBAAA,EAAA,IAAA,EAAA,EAAA,OAAA,CAAA,WAAA,GAAA,QAAA,CAAA,sCAAA,EAAA,OAAA,CAAA,WAAA,GAAA,QAAA,CAAA,kCAAA,EAAA,OAAA,CAAA,WAAA,GAAA,QAAA,CAAA,+CAAA,EAAA,OAAA,CAAA,WAAA,GAAA,QAAA,CAAA,6CAAA,EAAA,OAAA,CAAA,WAAA,GAAA,QAAA,CAAA,2BAAA,EAAA,OAAA,CAAA,WAAA,GAAA,QAAA,CAa2B,6LAUlC,CAAC,AACN,CAAC,2BAEkE,CAC/D,AAAC,GAAA,CAAgB,C+GrCmC,C/GqCxB,C+GrC0B,GAAY,I/GqC9B,CACrC,CAAA,oJAKO,G4KzE4D,CAAA,AuFtCR,CvFsCQ,O5KyEnD,CAAC,EAAS,KAAF,gKAUV,CAAA,EAAA,+MAqBA,EAAA,kCAIuB,CAAC,+JAUlB,EAAA,CAAA,sJ2HvKkC,KAAA,CAAM,CAAC,wIASpB,KAAK,CAAC,CAAC,CAAC,GAAK,EAAI,EAAA,OAAA,CAAA,sZAuC7C,EpKsBiB,EAAA,kNoKHhB,GAAA,WAAA,EAAA,GAAA,KAAA,2RqBlCK,GAAA,AAAoB,GAAG,GAAvB,GAA2B,GAAc,GAAG,IAAP,QAC7D,EAAa,CAAC,OAAJ,KACV,EAAa,CAAC,OAAE,AAAN,CAAW,CAAE,EAAE,CAAoB,IAAjB,CAAD,CAAG,CAAC,CAAC,EAAI,CAAA,CAAK,AAAO,CAAN,QAAQ,EAAA,GAAA,CAAA,eAAA,EAAsB,CAAA,CAAA,CAAA,CAAA,mJAWf,sKAiB7C,ChBxBL,oHgBmCuB,gSAiC5B,CAAE,KAAM,GuF3HuF,6BvF2HvD,CAAE,CAC3C,CAAA,+WxNjGuE,UAAU,CAAC,E2HkF3BzB,I3HlFN,CAAA,CAAA,EAAA,CAAU,OAAA,yBA8BpD,CACV,CAAA,+QAwCe,GAAA,iBAAA,CAAA,GAA2B,IAAA,CAAA,oEAMQ,CAAA,MAAA,EAAA,cAAA,GAAA,MAAA,oBAKJ,iCAAA,+CAQxB,OAAA,CAAA,UAAA,oHA4MF,GAA4B,QAChD,CAAA,CAAA,GAAA,CAAA,CAEqC,C8X/N2B,A1I8GA,6BpPsHrD,cAAA,MAAA,QACF,EAAA,QAAA,EAAA,CAAA,EAAA,CAAA,yBAGwB,wBAAA,yBAIjC,CAAK,MACL,CAAI,SACJ,CAAO,CmHxH2C,C1GmGG,YTsBrD,CAAY,CAMb,CS5B4E,CgGeS,SzGcvD,GAAA,GAAA,aAAmB,CAAC,8CAMlC,qFAOZ,CgJwpCG,chJrpCsB,QACU,EAAA,mBACd,IAAA,GAAA,CAAA,EAA6B,OAOhD,eAAA,yCAEkD,CAAA,EAAA,0QAM1C,oMAWc,C6YxHiB,qE7Y2HlC,EAAA,KAAA,GACA,EAAA,oEAOA,GAAA,CACE,cAAe,gDACD,EmHpIM,C6R9MY,oBhZqV3B,MAAU,+CAyGyB,CAAE,C0LAT,A1LAgB,MACvD,EAAA,EAAiB,MAAA,CAAO,AAAC,CAAC,A2DiJF,C+VxoBgB,A/VwoBf,CAAC,A3DjJE,AAAG,CAAD,AAAE,GAAK,IAAI,CAAC,CAAC,GAC1C,EoPjKiD,CAAA,IyJwDO,C7YyGrC,CAAC,AuZ/WE,AGxID,Y1ZggBa,CAAA,CAAA,CAAmB,C6YrGR,O7YuG7C,CAAC,GADS,CgJgmDC,AoGjwDE,CpGiwDF,MAAA,CAAA,GAAA,IAAA,2JjJ3pEqD,CCYlE,AH2FmE,AIpG1B,4xB0QgHgB,CAAA,EAAA,MAAA,IAAA,GAAA,sBAAA,CAAA,qEAKrD,CAAA,EAAA,GAAA,GAAA,EAAA,EAAA,mgCnBpF2B,KAAA,scAwClB,wRAeV,ykBAmDJ,qKAsBQ,8IAWG,kPA6BF,gLAsBL,yCAMO,OAEH,CJnBS,+IIsCf,KAAA,uFAUS,gBAGT,KAAA,uFAYM,aACN,KAAA,mHAiBM,wBAGR,CAAE,SAAS,C7LyLK,mE6LpLR,6DASV,KAAA,iHAaa,qBAGH,qBAGG,CJ/BS,0CIuClB,KAAA,kGASI,C6JzIoB,AjKwGf,SImCA,kBAGT,C7DsDiB,IAAA,8C6DhDjB,KAAM,qBAGG,sCAMP,0EAMG,UAAa,KAAA,WAAkB,CrIrCL,uDqI2CzB,C1IqCK,e0IrCa,UACxB,KAAA,SAAgB,KAAA,SAAe,2BACL,KAAA,gGAOhC,2GAKQ,qDAGwC,2BAEpC,SAAY,E/OmFE,CTkCK,AuZvapB,E/JkTmB,EmJ/PO,sCnJiQ7B,sBAGK,KAAM,0BAA6B,CAC9C,KrItC8C,AqIsC9C,oBACS,EAAA,iBACQ,C9DgHG,CAAC,kC8D5GZ,CAAE,KAAA,yBACL,WACN,QAAS,iBACY,KAAA,qDAEF,C8DoIK,CAAA,C7S7CF,E+OvFG,CrIrCG,AoS9Ob,W/JoRX,KAAA,sDACsB,CrIrCG,CmSlRuB,GAAA,Q9JuTZ,CAAE,EAE1C,gBAAA,gCAIQ,wDAER,QAAS,4CAG+B,CAAE,CACpC,CAAE,CxG8pD+C,AoGlsDpC,AwFiIF,CxFlIuC,GIqC1C,SAAU,KAAM,QACxB,8BACA,C7L4QM,AyLhTK,AIoCT,KAAM,kBAAmB,IAAI,CAAE,CqJoBa,OrJpBL,CAAE,sBACnB,KAAM,UAC/B,SqJkBkD,kBrJbtD,iEAMmB,C/D9BG,C8NtNM,A9YuVP,GAAA,S+OnGa,GAC/B,KAAA,+CAGK,OAAS,QAAS,KAAM,CrItCT,QqIsCkB,EAAG,iBAC5B,CxP6HG,CsTmBe,8B9D5I3B,EAAG,KAAM,gBAAkB,GJrCO,CAAA,GIqCA,EAAG,MACvC,8CAEW,uCAKf,mBAEY,CkKzTmB,CjZmaX,O+O1GE,C7DyGO,A3L0BA,IwPnID,SAAS,EACjC,MAAQ,sBAAwB,CAAE,EqJuCc,ArJtC9C,KAAA,WAAkB,KAAM,E/O0GI,AoYlEU,KrJxCP,CAAE,CACnC,CJrCW,AyKxWEyB,ArK6YX,KAAM,EsK7awB,ctK6aN,OAAO,CAAE,OqJyCmB,ArJxC9C,eAAgB,E/D7BI,G+D6BE,wCAG5B,KAAA,YAGA,KAAA,2CAGM,gCAEN,KAAA,uCAGF,CJrCW,AIqCT,KAAA,mBAA0B,IAAI,CAAE,A7D6GK,e6D5G/B,EsKhZY,sBtKgZc,CAAE,CACrC,CAED,CoKvSU,AC/EI,ApZ+dP,I+OzGP,SACA,KAAM,C/O2Ge,AsZ3YD,cvKmSlB,wBACG,OAAS,CoKpSS,EpKoSL,C/O+GC,I+O/GK,EsKjZM,OtKiZG,CAAE,CAAC,ClJuFD,MuS3Bc,uDrJrDrC,CJtCS,AjIDR,aqI0CP,MAAQ,SAAU,IAAI,CAAE,SAAS,CAAE,CACnC,K7D8GmD,S6D9GlC,KAAM,SAAS,CAAE,GqJmEmB,erJlEjC,IJtCkB,AIsCd,CAAE,AJtCY,OIsCL,CAAE,AqJoEgB,ErJnEjD,KAAA,WAAkB,G8JnTwD,C9JmTpD,CAAE,C/OkHS,Q+OjHnC,MACQ,+BAGR,CwKpVE,AxKqVA,ErIvCQ,GAAA,uBqIwCR,KAAM,ClJsFK,WkJnFX,KAAA,qBACA,EoFmJc,AzN1LN,GqIuCF,EoFmJc,AnUhCN,S+OjHhB,EJtCgB,C3DQH,G+D+BL,G8JjTW,Y9JkTjB,KAAM,CrIvCS,A8SnZQ,gBzK6bjB,uBACN,C8D4Ke,C7H1MD,A6H0ME,CAAA,E9D5KV,MJtCsB,CAAA,A3DQH,kC+DkCnB,SAER,CAAE,KAAM,CyKzbe,WzKybF,GJtCiB,CIsCb,AJtCa,CgLnZE,A5Kybb,OAAO,CAAE,CACrC,CAED,CqJkFyD,AsBre3C,AzOiiBL,IAAA,e8D7IH,E1IiDM,ArGsEI,S+OrHlB,mBAEE,KAAA,iBAEM,YAAa,KAAM,OAAO,gCAI9B,WAER,C4KjZc,A5KiZZ,KAAA,cAAqB,KAAM,SAAS,wCAG7B,CACX,gBAAA,kBACM,sBAKF,WAAY,C4K5ThB,AhLoRyB,AIyCnB,CJxCW,AgLlRVrB,K5K0TO,CJxCW,EiLlegC,W7K0gB3B,yBACP,IAAI,CAAA,4BACD,C/O8IO,AgL9KA,A+O1bjC,I/O0biC,O+DgCM,CAAE,OAC3B,gBAAkB,CmDkGS,MnDlGF,EACjC,MAAQ,eAAgB,KAAM,SAAS,CAAE,EAEvC,KAAA,wCAIA,KAAM,qBACN,KAAA,gCAEsB,CrIzCC,IqIyCK,CrIzCC,4CqI4CvB,G/OuJS,iC+OrJW,KAAA,OAAa,CAAE,ErIzCE,KqI0CrC,EJxCY,C6KrVE,qBzK6XY,CAAE,CrIzCC,AqI0CtC,CJxCS,AsL7fM,AlLuiBhB,CoFsKO,A0FxrBH,ACuDA,A5OukBU,I6D5GR,WACA,WAER,CmDmGK,yCnDjGD,oBACG,EAAE,+CAIb,C+KrdE,Q/KsdS,CAAE,KAAM,C/OwJC,mB+OxJqB,CAAE,CAAC,CAC1C,KAAA,oBxGwqEsE,OwGvqE3D,8EAMiB,uBAIpB,CmL3gBc,UAAA,CnL4gBZ,oBAAwB,WACxB,CAAE,AJtCa,CmLzZG,I/K+bV,aAAe,WACvB,CqL3doB,ArL4dlB,C9DgKe,I8DhKT,CrI1CS,EuE0MQ,Y8D/JvB,KAAM,I/DjCgB,AzCg8EI,QwG55E1B,IAAI,CAAE,YmLvgB6B,EAAA,AvLieC,CAAA,wBIyCtC,MACQ,E9DuKU,wB8DtKV,kCAEmB,iBAEnB,oBACA,iBAGA,uBACN,KAAM,YAIV,KAAM,UACN,EJvCc,A3DKV,GAAA,4B+DoCgB,KAAM,EqL5ac,ApawkBR,8B+O3JT,SAAS,QAC1B,QuL3hBmB,EAAA,GEhBf,GzL2iBa,GoF+JqB,CpF/JjB,CAAE,OJvCiB,CAAA,C6LpgBO,AzL2iBf,QAChC,CqL5agB,EzLqYH,QIuCD,IAAI,CAAA,SAAW,CAAE,CACtC,GyL5iBwD,CAAA,E7LogBD,CAAA,2CI6CjC,I9D+JU,CAAC,CyPnxBG,iC3LunBhC,CAAC,MAAQ,qBAAuB,WAAY,K/DnCD,Y+DoCnC,CrI5CH,8BqIg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AS,EEyBa,CAAC,CAAC,IkSvSF,4DpSqRxD,8BACuB,CsEMC,StENU,IAAI,CAAE,SAAS,CAAE,I0RiCR,qB1RhC1B,IAAI,CiICW,AjIDT,C0RiCa,AxRNK,SF3BP,KAAM,SAAS,CAAE,E1G0HtC,CAAC,sB0GzHG,KAAA,QAAe,IAAI,C0RiCa,S1RjCF,CAAE,yBAChC,KAAM,CsSvRgB,WtSuRH,IAAI,C1G0HsB,S0G1HX,CAAE,EAC7D,aAAA,I0RgCmD,U1RhCrB,CqS1TU,AhK+VH,QrIrCG,EwE+HI,ExE/HA,C1G0HK,Q0G1HK,CAAE,EACxD,CuEoJS,ACrBN,YxE/HW,SAAU,KAAM,QAAS,IAAI,CAAA,QAAU,CAAE,EACvD,CuEoJS,ArEzHE,YAAA,SF3Ba,CoSzQU,A9NgRL,ItEPC,MAAO,CE2BkB,AoEpBb,ItEPC,CnH+JS,C6Y5HK,M1RnCN,CAAE,AE2BiB,CF1BxE,CE0B0E,CAAC,CAAC,WF1B5D,CuEsJnB,A1Cg/C8B,C0Ch/C7B,UmNvHA,G1R/BmC,I0RkC6B,G1RlCrB,CuEsJnB,IAAA,SvEtJkC,CAAE,EACxD,CuEsJM,YvEtJQ,QAAS,KAAA,YAAmB,KAAM,CmSlRwB,MnSkRjB,CAAE,EAE7D,aAAc,E0R8Bd,OAIoD,8D1RhCpD,KAAM,CmSlRsB,QnSoR9B,cAAgB,QAAS,KAAM,GqIqCG,SrIrCU,KAAM,6DAG1B,OAAQ,CqIqCD,IrIrCO,GAAI,KAAM,CsEQC,KtERK,EAAG,mCAErD,oBAGE,EAAE,CuSnXA,KvSoXJ,sCAEY,SAAU,KAAA,yBACxB,aAAc,SAAU,KAAM,MAAM,CAAE,KAAM,QAAQ,CAAE,E0RuDU,OAdhE,oB1RxC8B,UAAW,CxDiTK,IwDjTC,UACjD,CAAE,aAAA,yBAA0C,KAAM,SAAS,C0RwDU,Aa3aE,AvSmXV,CAC7D,CAAE,CqSlTM,YAAA,erSkTyB,CyNkII,QpF7FC,WrIrCgB,IAAI,A0RwDQ,C1RxDN,SAAS,CAAE,CACvE,CAAE,CiICO,AoKnTI,A5EobN,KiE3E8D,OjE2E9D,UzNlIoB,CxDiTK,CAAA,C6L5QN,CrIrCK,CAAE,C6BosDO,EoGnsDE,IjIDD,IAAI,CAAE,SAAS,4BAC3B,KAAM,C6BosDK,IwG/pDJ,AJpCU,ajIDS,WAAW,CAAE,kBAErD,gB0RuDoD,iB1RlDnE,CuStVU,AvSuVR,Cb8HK,UAAA,Ea7HD,aAAA,UAAyB,GiICa,CAAA,AjIDT,CwL2HW,UxL3HE,KAAM,SAAS,CAAE,C0R2Da,qC1R1DhC,KAAM,QAAQ,CAAE,CAC1D,CxDkTM,YkVvP4D,C1R3DlD,sBAAyB,IAAI,CAAE,QAAQ,CAAE,6BACzB,E0R4Dc,CADA,G1R3DP,KAAM,QAAQ,cAEvC,EACR,aAAc,C1G4IwB,AmZvbN,wBzS2SU,EyS3SW,CjW8lBI,CAAC,AwDnTZ,CxDmTY,AlDvKY,W0G3IxE,CAAE,aAAA,UAAyB,KAAA,QAAe,KAAM,SAAS,CAAE,CAC3D,CAAE,C0R+D2B,Me3W2D,MzS4StF,UAAyB,KAAM,KyS3SsC,OzS2SzB,IAAI,CAAE,I0RgErB,K1RhE8B,CAAE,EAC7D,CmMsL2B,A9DhJhB,Y8DgJgB,2BnMtLkB,WAC/C,sBAAyB,CiICe,CAAA,E3O4IS,A0G7IpB,C1G6IqB,Y0G7IN,G1G6IuB,E0G7IjB,E1G6IsB,IoY7EzC,C1RhE0B,CAAE,CAC5D,cACa,4EAER,EqIsCU,UrInCpB,aAAA,0DACM,CnHsKK,AyL9JA,AoOhXMY,0C1S4Wf,uBACG,eAAiB,EqIsCJ,CsKhbuB,O3S0YR,KAAM,EAAE,AqIsCN,erItCuB,CAAE,CAAC,CACjE,gBAAA,sEAOiC,KAAM,G4SvX4B,O5SuXjB,KAAA,SAAe,CAAE,EAC3D,aAAc,eAAiB,E0RsFc,Q1RtFH,IAAI,CAAE,SAAS,CAAE,CAC7D,wBAA2B,KAAA,gB0RmF7B,M1RnF2D,CAAE,ELgFxD,AK/ED,aAAc,S0RqFlB,C1RrF6B,IAAI,C0RuFa,A1RvFX,YAAa,KAAM,SAAS,CAAE,CAC/D,CAAE,Y0RsF6C,C1RtF/B,SAAU,CyS/PgB,IzS+PV,O6Bm7DiB,C7Bn7DT,CAAE,KAAM,QAAQ,CAAE,wBAChC,C0StVe,CrK4Xb,GrItCI,QAAS,E0RyFc,G1RzFR,M0StVN,CAAA,C1SsVc,CAAE,CACzD,cAAgB,QAAQ,CAAE,CiICU,IAAA,MjIDG,CLqFO,C+RSO,A/RTN,GKrFF,QAAQ,CAAE,CACvD,CuE2KO,avE3KS,UAAW,KAAA,YAAoB,G0RqFjD,EASA,I1R9F0D,CAAE,CAC1D,C1GiJG,qB0GjJsB,KAAA,YAAmB,KAAM,OAAO,CAAE,eAE/C,CsESK,UoNoFqC,qC1R5FxD,CwEmJG,IAAA,gCxEhJN,mCAIG,WAAA,CACE,CAAE,CqIuCO,AlJuFF,Ya9HS,GyN0KwC,CkFphB1B,AlFohB2B,KzN1K/B,IAAI,CAAE,CiICW,EyJkGI,KAvBjD,A1R5E2C,IAAI,CAAE,QAAQ,CAAE,eACzC,cAAgB,WAAa,UAC7C,CAAE,CyN0KS,YAAA,ezN1KsB,GiICa,CAAA,IjIDJ,KAAM,I1GsJI,K0GtJK,CAAE,CAC5D,0DAED,CwE+HiB,IxE/HX,CsESK,CtETH,AmM4MM,CnM3Md,E0SzTa,A7Qo0EL,GAAA,kD7BrgEd,E6BskEI,oB7BlkEI,CAAE,EiICY,ApGqkEF,W7BtkEI,yBAA4B,EiICY,CAAA,CjIDR,CAAE,M0R+GkB,G1R/GT,gBAC3C,eAAiB,I0RgHgB,M1RhHL,KAAM,SAAS,CAAE,CAC7D,A0R+GoD,wB1R/GzB,KAAM,QAAS,CiICU,IjIDJ,SAAS,CAAE,CAC3D,Gb4H6D,CAAC,CAAC,M0TvaqB,kB7S2SnD,YAAa,IAAI,CAAE,SAAS,CAAE,CAC/D,c6BqkEsF,A7BrkEtE,O0R+GgC,E1R/GtB,KAAM,SAAU,IAAI,CAAE,QAAQ,CAAE,eAC1C,M0R+GqC,G1R/G3B,C8SrbkB,AxZ8kBjB,EAAE,E0GzJG,G6BskEe,CACH,I7BvkEH,IAAI,CAAE,QAAQ,CAAE,EACvD,aAAA,cAA8B,KAAK,C6BukEW,AwGhiEhB,AJtCgB,KjIDH,QAAQ,CAAE,E0RgHzD,A1R/GI,C+SnasB,A9KoaX,YAAA,QyJ+GyB,mB1RhHS,O6BwkEO,E7BxkEE,CAAE,gB0RiHR,wB1RhHN,E6BykEQ,E7BzkEJ,CAAE,I1G0JgB,CACjE,CAAC,C0G3JuD,CAAE,CAC5D,CACD,EmS1QyB,A7YsarB,W0G5JU,CgTtba,ADwDnB,qBlRu8E4C,sB6Pz9DpD,I1R/GA,K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CtVqiBR,A2V9hBd,qDLLuB,iBAAgB,skBhErBnD,iWAgBA,CpBmDF,A0BxFE,ApN2ND,6L8MnK+E,E9N2FjC,MAAA,CAAA,E8N3FkD,E9N2FjC,I8N3FuC,CAAA,wZtIrClC,EAAQ,CAAA,CAAA,CCaE,ADbI,CCchF,EDbc,IAAA,CAD2E,AACtE,CAAL,EAAQ,CACb,CAAA,KAAA,CAAA,2K8DZqE,yJoEhB/B,CAAA,yLlM4CH,mBAAA,EAAA,MAAA,ohBkM3CW,C5EmLH,C4EnLW,ApOkJR,AwLkFrB,C9K3GsB,Cb6EC,AevEI,IwN/HU,CAAA,EAAQ,MAAA,GAAW,E5CoOrB,GAAA,mCpG3L9C,EAAA,cAAA,2Z9J0B8C,OAAA,yC6WpCtE,MzCNiB,mC9O+LO,kBiQ9KM,CF4DG,C5T0JX,A2DvDF,AEeI,+CwOrM0D,CFTP,AC8F6B,AzO6CrC,uEoOpJE,EHgBvE,AGhB+E,CHgB/E,AGhB+E,OAAQ,gBAAA,AAAmB,CAAA,EAAA,OAI7F,uB+ByCmF,GAAA,GACtF,gB/FpC0E,EAAA,CAAI,CAAA,C+FoC9E,KtViE6D,CACpE,CAAA,iBuJ7C2G,CAAC,qCmJ/CtF,uCAEY,CAAA,wCAQqC,EAAU,gN7BjBA,OAAA,CAAQ,+CAUhF,IpB+K0F,CAAA,wDoBxKtD,CACnB,EAAA,CAAA,qK6BO4C,CrN2FT,qBqN3FiC,GzUuJb,SyUvJa,qE4CQvF,wOvPkNqF,ChIvOb,A2HXE,EAAE,E1CCN,U+CiP6B,GLlPR,0IK4PS,ClCzKpC,oHkCmLY,aAAY,oHASR,aAAc,CyFhKnF,AzFgKoF,4JAOvB,SAAW,CAAA,YAAY,CAAA,E+IhLL,AxD/BM,C2DxB/F,6HlJ0OuD,CAAC,QAAS,MAAqB,CAAC,CAAC,CAAA,+BACnC,GAAA,0MASK,CyBnOP,AnIHI,CmIGH,A7BWQ,CIwNF,CAAS,AAAL,CAAK,CiKjNV,CAAA,AjKiNU,CkKrLL,CAAC,CAAC,2RlK0MA,+CACG,qHAEW,6EAER,CnC5NP,A4MNF,C5MMG,A4MNF,qDzKoO/D,oMAQgE,CIrKP,CAAC,CAAC,AhIsNA,G4HjD0B,EAAE,CAAA,uBACpC,0BAA0C,CAAC,AgFzLhG,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","ignoreList":[0,1,2,3,4,5,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633]}